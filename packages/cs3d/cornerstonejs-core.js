var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var toStr = Object.prototype.toString;
  module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
});

// ../../node_modules/object-keys/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var keysShim;
  if (!Object.keys) {
    has = Object.prototype.hasOwnProperty;
    toStr = Object.prototype.toString;
    isArgs = require_isArguments();
    isEnumerable = Object.prototype.propertyIsEnumerable;
    hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object) {
      var isObject = object !== null && typeof object === "object";
      var isFunction = toStr.call(object) === "[object Function]";
      var isArguments = isArgs(object);
      var isString = isObject && toStr.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject && !isFunction && !isArguments) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object.length > 0 && !has.call(object, 0)) {
        for (var i = 0;i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments && object.length > 0) {
        for (var j = 0;j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0;k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  var has;
  var toStr;
  var isArgs;
  var isEnumerable;
  var hasDontEnumBug;
  var hasProtoEnumBug;
  var dontEnums;
  var equalsConstructorPrototype;
  var excludedKeys;
  var hasAutomationEqualityBug;
  var equalsConstructorPrototypeIfNotBuggy;
  module.exports = keysShim;
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS((exports, module) => {
  var slice = Array.prototype.slice;
  var isArgs = require_isArguments();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : require_implementation();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object) {
          if (isArgs(object)) {
            return originalKeys(slice.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  module.exports = keysShim;
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// ../../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS((exports, module) => {
  var $defineProperty = require_es_define_property();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var gopd = require_gopd();
  module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS((exports, module) => {
  var $defineProperty = require_es_define_property();
  var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  module.exports = hasPropertyDescriptors;
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS((exports, module) => {
  var keys = require_object_keys();
  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty = require_define_data_property();
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var supportsDescriptors = require_has_property_descriptors()();
  var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
      if (predicate === true) {
        if (object[name] === value) {
          return;
        }
      } else if (!isFunction(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty(object, name, value, true);
    } else {
      defineDataProperty(object, name, value);
    }
  };
  var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) {
      props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0;i < props.length; i += 1) {
      defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  module.exports = defineProperties;
});

// ../../node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS((exports, module) => {
  if (typeof self !== "undefined") {
    module.exports = self;
  } else if (typeof window !== "undefined") {
    module.exports = window;
  } else {
    module.exports = Function("return this")();
  }
});

// ../../node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS((exports, module) => {
  var implementation = require_implementation_browser();
  module.exports = function getPolyfill() {
    if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
      return implementation;
    }
    return global;
  };
});

// ../../node_modules/globalthis/shim.js
var require_shim = __commonJS((exports, module) => {
  var define2 = require_define_properties();
  var getPolyfill = require_polyfill();
  module.exports = function shimGlobal() {
    var polyfill = getPolyfill();
    if (define2.supportsDescriptors) {
      var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
      if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
        Object.defineProperty(polyfill, "globalThis", {
          configurable: true,
          enumerable: false,
          value: polyfill,
          writable: true
        });
      }
    } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
      polyfill.globalThis = polyfill;
    }
    return polyfill;
  };
});

// ../../node_modules/globalthis/index.js
var require_globalthis = __commonJS((exports, module) => {
  var defineProperties = require_define_properties();
  var implementation = require_implementation_browser();
  var getPolyfill = require_polyfill();
  var shim = require_shim();
  var polyfill = getPolyfill();
  var getGlobal = function() {
    return polyfill;
  };
  defineProperties(getGlobal, {
    getPolyfill,
    implementation,
    shim
  });
  module.exports = getGlobal;
});

// ../../node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 0.00000000023283064365386963;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 0.00000000000000011102230246251565;
      };
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i = 0;i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 4294967296;
        }
        return (n >>> 0) * 0.00000000023283064365386963;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { x: X, i } = me, t, v, w;
        t = X[i];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i] = v;
        me.i = i + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, w, X = [];
        if (seed2 === (seed2 | 0)) {
          w = X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0;j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0;j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          w = X[7] = -1;
        else
          w = X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256;j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { w, X, i } = me, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i + 34 & 127];
        t = X[i = i + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i] = v ^ t;
        me.i = i;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\x00";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i = 0, j = -32;j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i = t == 0 ? i + 1 : 0;
          }
        }
        if (i >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i = 127;
        for (j = 4 * 128;j > 0; --j) {
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i;
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// ../../node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var { b, c, d, a } = me;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e) => () => (t && (e = t(t = 0)), e), T = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
}, Ya = (t, e, r, o) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f of bw(e))
      !gw.call(t, f) && f !== r && Xa(t, f, { get: () => e[f], enumerable: !(o = vw(e, f)) || o.enumerable });
  return t;
}, ot = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default")), rn = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t), Nd, Dd, Ut, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn, _p, Ep, gh, qp, yh, Op, ko, Tt, Gr, No, Jt, pa, Rh, pr, Y_, Oi, Fi, Ui, k1, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr, fu, ou, os, eb, cu, lb, bu, vf, S7, db, yi, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl, pg, dl, kn, cl, bl, Ln, Ds, Lg, Dg, yl, Il, Yg, t2, i2, Ws, Ks, s2, ri, Nl, or, Oa, b2, y2, _2, Pl, Cr, Tf, Cl, N2, Fl, F2, Wl, Z2, V2, Q2, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m3, Ha, bd, _3, A3, k3, N3, P3, _d, xd, w0, Ed, j3, Y3, X3, ow, qd, Xt, zq, Ga = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id, Td, cw, Wq;
var init_crypto = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr[45] = 62;
    lr[95] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o = r === e ? 0 : 4 - r % 4;
      return [r, o];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o = e[1];
      return (r + o) * 3 / 4 - o;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o = r[0], f = r[1], p = new yw(Mw(t, o, f)), m = 0, y = f > 0 ? o - 4 : o, M;
      for (M = 0;M < y; M += 4)
        e = lr[t.charCodeAt(M)] << 18 | lr[t.charCodeAt(M + 1)] << 12 | lr[t.charCodeAt(M + 2)] << 6 | lr[t.charCodeAt(M + 3)], p[m++] = e >> 16 & 255, p[m++] = e >> 8 & 255, p[m++] = e & 255;
      return f === 2 && (e = lr[t.charCodeAt(M)] << 2 | lr[t.charCodeAt(M + 1)] >> 4, p[m++] = e & 255), f === 1 && (e = lr[t.charCodeAt(M)] << 10 | lr[t.charCodeAt(M + 1)] << 4 | lr[t.charCodeAt(M + 2)] >> 2, p[m++] = e >> 8 & 255, p[m++] = e & 255), p;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o, f = [], p = e;p < r; p += 3)
        o = (t[p] << 16 & 16711680) + (t[p + 1] << 8 & 65280) + (t[p + 2] & 255), f.push(xw(o));
      return f.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o = r % 3, f = [], p = 16383, m = 0, y = r - o;m < y; m += p)
        f.push(Sw(t, m, m + p > y ? y : m + p));
      return o === 1 ? (e = t[r - 1], f.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], f.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f.join("");
    }
  });
  Dd = T((q0) => {
    q0.read = function(t, e, r, o, f) {
      var p, m, y = f * 8 - o - 1, M = (1 << y) - 1, x = M >> 1, S = -7, E = r ? f - 1 : 0, B = r ? -1 : 1, q = t[e + E];
      for (E += B, p = q & (1 << -S) - 1, q >>= -S, S += y;S > 0; p = p * 256 + t[e + E], E += B, S -= 8)
        ;
      for (m = p & (1 << -S) - 1, p >>= -S, S += o;S > 0; m = m * 256 + t[e + E], E += B, S -= 8)
        ;
      if (p === 0)
        p = 1 - x;
      else {
        if (p === M)
          return m ? NaN : (q ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, o), p = p - x;
      }
      return (q ? -1 : 1) * m * Math.pow(2, p - o);
    };
    q0.write = function(t, e, r, o, f, p) {
      var m, y, M, x = p * 8 - f - 1, S = (1 << x) - 1, E = S >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o ? 0 : p - 1, L = o ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, m = S) : (m = Math.floor(Math.log(e) / Math.LN2), e * (M = Math.pow(2, -m)) < 1 && (m--, M *= 2), m + E >= 1 ? e += B / M : e += B * Math.pow(2, 1 - E), e * M >= 2 && (m++, M /= 2), m + E >= S ? (y = 0, m = S) : m + E >= 1 ? (y = (e * M - 1) * Math.pow(2, f), m = m + E) : (y = e * Math.pow(2, E - 1) * Math.pow(2, f), m = 0));f >= 8; t[r + q] = y & 255, q += L, y /= 256, f -= 8)
        ;
      for (m = m << f | y, x += f;x > 0; t[r + q] = m & 255, q += L, m /= 256, x -= 8)
        ;
      t[r + q - L] |= ge * 128;
    };
  });
  Ut = T((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo = 2147483647;
    Xn.kMaxLength = eo;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li(t) {
      if (t > eo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
        return k0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return me.from(o, e, r);
      let f = Iw(t);
      if (f)
        return f;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li(t) : e !== undefined ? typeof r == "string" ? li(t).fill(e, r) : li(t).fill(e) : li(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o = li(r), f = o.write(t, e);
      return f !== r && (o = o.slice(0, f)), o;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e);
      for (let o = 0;o < e; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function qw(t) {
      if (Zr(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k0(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e) : o = new Uint8Array(t, e, r), Object.setPrototypeOf(o, me.prototype), o;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o = e.length, f = r.length;
      for (let p = 0, m = Math.min(o, f);p < m; ++p)
        if (e[p] !== r[p]) {
          o = e[p], f = r[p];
          break;
        }
      return o < f ? -1 : f < o ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e.length; ++o)
          r += e[o].length;
      let f = me.allocUnsafe(r), p = 0;
      for (o = 0;o < e.length; ++o) {
        let m = e[o];
        if (Zr(m, Uint8Array))
          p + m.length > f.length ? (me.isBuffer(m) || (m = me.from(m)), m.copy(f, p)) : Uint8Array.prototype.set.call(f, m, p);
        else if (me.isBuffer(m))
          m.copy(f, p);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p += m.length;
      }
      return f;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f)
              return o ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o = t[e];
      t[e] = t[r], t[r] = o;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o, f, p) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o === undefined && (o = e ? e.length : 0), f === undefined && (f = 0), p === undefined && (p = this.length), r < 0 || o > e.length || f < 0 || p > this.length)
        throw new RangeError("out of range index");
      if (f >= p && r >= o)
        return 0;
      if (f >= p)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f >>>= 0, p >>>= 0, this === e)
        return 0;
      let m = p - f, y = o - r, M = Math.min(m, y), x = this.slice(f, p), S = e.slice(r, o);
      for (let E = 0;E < M; ++E)
        if (x[E] !== S[E]) {
          m = x[E], y = S[E];
          break;
        }
      return m < y ? -1 : y < m ? 1 : 0;
    };
    function Wd(t, e, r, o, f) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o, f);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o, f);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o, f) {
      let p = 1, m = t.length, y = e.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p = 2, m /= 2, y /= 2, r /= 2;
      }
      function M(S, E) {
        return p === 1 ? S[E] : S.readUInt16BE(E * p);
      }
      let x;
      if (f) {
        let S = -1;
        for (x = r;x < m; x++)
          if (M(t, x) === M(e, S === -1 ? 0 : x - S)) {
            if (S === -1 && (S = x), x - S + 1 === y)
              return S * p;
          } else
            S !== -1 && (x -= x - S), S = -1;
      } else
        for (r + y > m && (r = m - y), x = r;x >= 0; x--) {
          let S = true;
          for (let E = 0;E < y; E++)
            if (M(t, x + E) !== M(e, E)) {
              S = false;
              break;
            }
          if (S)
            return x;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o) {
      return this.indexOf(e, r, o) !== -1;
    };
    me.prototype.indexOf = function(e, r, o) {
      return Wd(this, e, r, o, true);
    };
    me.prototype.lastIndexOf = function(e, r, o) {
      return Wd(this, e, r, o, false);
    };
    function Lw(t, e, r, o) {
      r = Number(r) || 0;
      let f = t.length - r;
      o ? (o = Number(o), o > f && (o = f)) : o = f;
      let p = e.length;
      o > p / 2 && (o = p / 2);
      let m;
      for (m = 0;m < o; ++m) {
        let y = parseInt(e.substr(m * 2, 2), 16);
        if (C0(y))
          return m;
        t[r + m] = y;
      }
      return m;
    }
    function Nw(t, e, r, o) {
      return to(L0(e, t.length - r), t, r, o);
    }
    function Dw(t, e, r, o) {
      return to(Vw(e), t, r, o);
    }
    function Pw(t, e, r, o) {
      return to(Xd(e), t, r, o);
    }
    function Cw(t, e, r, o) {
      return to($w(e, t.length - r), t, r, o);
    }
    me.prototype.write = function(e, r, o, f) {
      if (r === undefined)
        f = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f === undefined && (f = "utf8")) : (f = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p = this.length - r;
      if ((o === undefined || o > p) && (o = p), e.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f || (f = "utf8");
      let m = false;
      for (;; )
        switch (f) {
          case "hex":
            return Lw(this, e, r, o);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o);
          case "base64":
            return Pw(this, e, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o);
          default:
            if (m)
              throw new TypeError("Unknown encoding: " + f);
            f = ("" + f).toLowerCase(), m = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o = [], f = e;
      for (;f < r; ) {
        let p = t[f], m = null, y = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
        if (f + y <= r) {
          let M, x, S, E;
          switch (y) {
            case 1:
              p < 128 && (m = p);
              break;
            case 2:
              M = t[f + 1], (M & 192) === 128 && (E = (p & 31) << 6 | M & 63, E > 127 && (m = E));
              break;
            case 3:
              M = t[f + 1], x = t[f + 2], (M & 192) === 128 && (x & 192) === 128 && (E = (p & 15) << 12 | (M & 63) << 6 | x & 63, E > 2047 && (E < 55296 || E > 57343) && (m = E));
              break;
            case 4:
              M = t[f + 1], x = t[f + 2], S = t[f + 3], (M & 192) === 128 && (x & 192) === 128 && (S & 192) === 128 && (E = (p & 15) << 18 | (M & 63) << 12 | (x & 63) << 6 | S & 63, E > 65535 && E < 1114112 && (m = E));
          }
        }
        m === null ? (m = 65533, y = 1) : m > 65535 && (m -= 65536, o.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), o.push(m), f += y;
      }
      return Fw(o);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e; )
        r += String.fromCharCode.apply(String, t.slice(o, o += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f] & 127);
      return o;
    }
    function zw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f]);
      return o;
    }
    function Hw(t, e, r) {
      let o = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o) && (r = o);
      let f = "";
      for (let p = e;p < r; ++p)
        f += Gw[t[p]];
      return f;
    }
    function Ww(t, e, r) {
      let o = t.slice(e, r), f = "";
      for (let p = 0;p < o.length - 1; p += 2)
        f += String.fromCharCode(o[p] + o[p + 1] * 256);
      return f;
    }
    me.prototype.slice = function(e, r) {
      let o = this.length;
      e = ~~e, r = r === undefined ? o : ~~r, e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e && (r = e);
      let f = this.subarray(e, r);
      return Object.setPrototypeOf(f, me.prototype), f;
    };
    function Dt(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e + m] * p;
      return f;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e + --r], p = 1;
      for (;r > 0 && (p *= 256); )
        f += this[e + --r] * p;
      return f;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f) + (BigInt(p) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o;
      return (BigInt(f) << BigInt(32)) + BigInt(p);
    });
    me.prototype.readIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e + m] * p;
      return p *= 128, f >= p && (f -= Math.pow(2, 8 * r)), f;
    };
    me.prototype.readIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = r, p = 1, m = this[e + --f];
      for (;f > 0 && (p *= 256); )
        m += this[e + --f] * p;
      return p *= 128, m >= p && (m -= Math.pow(2, 8 * r)), m;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e] | this[e + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e + 1] | this[e] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er(t, e, r, o, f, p) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f || e < p)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p = 1, m = 0;
      for (this[r] = e & 255;++m < o && (p *= 256); )
        this[r + m] = e / p & 255;
      return r + o;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p = o - 1, m = 1;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        this[r + p] = e / m & 255;
      return r + o;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, r;
    }
    function Zd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r + 7] = p, p = p >> 8, t[r + 6] = p, p = p >> 8, t[r + 5] = p, p = p >> 8, t[r + 4] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m, m = m >> 8, t[r + 2] = m, m = m >> 8, t[r + 1] = m, m = m >> 8, t[r] = m, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p = 0, m = 1, y = 0;
      for (this[r] = e & 255;++p < o && (m *= 256); )
        e < 0 && y === 0 && this[r + p - 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p = o - 1, m = 1, y = 0;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        e < 0 && y === 0 && this[r + p + 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o, f, p) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o) {
      return $d(this, e, r, true, o);
    };
    me.prototype.writeFloatBE = function(e, r, o) {
      return $d(this, e, r, false, o);
    };
    function Gd(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o) {
      return Gd(this, e, r, true, o);
    };
    me.prototype.writeDoubleBE = function(e, r, o) {
      return Gd(this, e, r, false, o);
    };
    me.prototype.copy = function(e, r, o, f) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f && f !== 0 && (f = this.length), r >= e.length && (r = e.length), r || (r = 0), f > 0 && f < o && (f = o), f === o || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f < 0)
        throw new RangeError("sourceEnd out of bounds");
      f > this.length && (f = this.length), e.length - r < f - o && (f = e.length - r + o);
      let p = f - o;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f) : Uint8Array.prototype.set.call(e, this.subarray(o, f), r), p;
    };
    me.prototype.fill = function(e, r, o, f) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f = r, r = 0, o = this.length) : typeof o == "string" && (f = o, o = this.length), f !== undefined && typeof f != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f == "string" && !me.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f);
        if (e.length === 1) {
          let m = e.charCodeAt(0);
          (f === "utf8" && m < 128 || f === "latin1") && (e = m);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e || (e = 0);
      let p;
      if (typeof e == "number")
        for (p = r;p < o; ++p)
          this[p] = e;
      else {
        let m = me.isBuffer(e) ? e : me.from(e, f), y = m.length;
        if (y === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p = 0;p < o - r; ++p)
          this[p + r] = m[p % y];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o = `The value of "${t}" is out of range.`, f = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f = Fd(String(r)) : typeof r == "bigint" && (f = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f = Fd(f)), f += "n"), o += ` It must be ${e}. Received ${f}`, o;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o, f, p) {
      if (t > r || t < e) {
        let m = typeof e == "bigint" ? "n" : "", y;
        throw p > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${m} and < 2${m} ** ${(p + 1) * 8}${m}` : y = `>= -(2${m} ** ${(p + 1) * 8 - 1}${m}) and < 2 ** ${(p + 1) * 8 - 1}${m}` : y = `>= ${e}${m} and <= ${r}${m}`, new $n.ERR_OUT_OF_RANGE("value", y, t);
      }
      Kw(o, f, p);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o = t.length, f = null, p = [];
      for (let m = 0;m < o; ++m) {
        if (r = t.charCodeAt(m), r > 55295 && r < 57344) {
          if (!f) {
            if (r > 56319) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            } else if (m + 1 === o) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            }
            f = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p.push(239, 191, 189), f = r;
            continue;
          }
          r = (f - 55296 << 10 | r - 56320) + 65536;
        } else
          f && (e -= 3) > -1 && p.push(239, 191, 189);
        if (f = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o, f, p = [];
      for (let m = 0;m < t.length && !((e -= 2) < 0); ++m)
        r = t.charCodeAt(m), o = r >> 8, f = r % 256, p.push(f), p.push(o);
      return p;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to(t, e, r, o) {
      let f;
      for (f = 0;f < o && !(f + r >= e.length || f >= t.length); ++f)
        e[f + r] = t[f];
      return f;
    }
    function Zr(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f = 0;f < 16; ++f)
          e[o + f] = t[r] + t[f];
      }
      return e;
    }();
    function Ti(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T((O0, Qd) => {
    var ro = Ut(), Vr = ro.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
    function an(t, e, r) {
      return Vr(t, e, r);
    }
    an.prototype = Object.create(Vr.prototype);
    Jd(Vr, an);
    an.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e !== undefined ? typeof r == "string" ? o.fill(e, r) : o.fill(e) : o.fill(0), o;
    };
    an.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro.SlowBuffer(t);
    };
  });
  on = T((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o = 0;o < t; o += F0)
            io.getRandomValues(r.slice(o, o + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e.prototype = new o, e.prototype.constructor = e;
      }
    };
  });
  ki = T((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o) {
      return Function.prototype.apply.call(e, r, o);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f = e === "error", p = this._events;
      if (p !== undefined)
        f = f && p.error === undefined;
      else if (!f)
        return false;
      if (f) {
        var m;
        if (r.length > 0 && (m = r[0]), m instanceof Error)
          throw m;
        var y = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
        throw y.context = m, y;
      }
      var M = p[e];
      if (M === undefined)
        return false;
      if (typeof M == "function")
        ec(M, this, r);
      else
        for (var x = M.length, S = sc(M, x), o = 0;o < x; ++o)
          ec(S[o], this, r);
      return true;
    };
    function nc(t, e, r, o) {
      var f, p, m;
      if (fo(r), p = t._events, p === undefined ? (p = t._events = Object.create(null), t._eventsCount = 0) : (p.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p = t._events), m = p[e]), m === undefined)
        m = p[e] = r, ++t._eventsCount;
      else if (typeof m == "function" ? m = p[e] = o ? [r, m] : [m, r] : o ? m.unshift(r) : m.push(r), f = ic(t), f > 0 && m.length > f && !m.warned) {
        m.warned = true;
        var y = new Error("Possible EventEmitter memory leak detected. " + m.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y.name = "MaxListenersExceededWarning", y.emitter = t, y.type = e, y.count = m.length, t6(y);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f = r6.bind(o);
      return f.listener = r, o.wrapFn = f, f;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o, f, p, m, y;
      if (fo(r), f = this._events, f === undefined)
        return this;
      if (o = f[e], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f[e], f.removeListener && this.emit("removeListener", e, o.listener || r));
      else if (typeof o != "function") {
        for (p = -1, m = o.length - 1;m >= 0; m--)
          if (o[m] === r || o[m].listener === r) {
            y = o[m].listener, p = m;
            break;
          }
        if (p < 0)
          return this;
        p === 0 ? o.shift() : i6(o, p), o.length === 1 && (f[e] = o[0]), f.removeListener !== undefined && this.emit("removeListener", e, y || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o, f;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e]), this;
      if (arguments.length === 0) {
        var p = Object.keys(o), m;
        for (f = 0;f < p.length; ++f)
          m = p[f], m !== "removeListener" && this.removeAllListeners(m);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f = r.length - 1;f >= 0; f--)
          this.removeListener(e, r[f]);
      return this;
    };
    function ac(t, e, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f = o[e];
      return f === undefined ? [] : typeof f == "function" ? r ? [f.listener || f] : [f] : r ? n6(f) : sc(f, f.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o = 0;o < e; ++o)
        r[o] = t[o];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o) {
        function f(m) {
          t.removeListener(e, p), o(m);
        }
        function p() {
          typeof t.removeListener == "function" && t.removeListener("error", f), r([].slice.call(arguments));
        }
        hc(t, e, p, { once: true }), e !== "error" && a6(t, f, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p) {
          o.once && t.removeEventListener(e, f), r(p);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T(() => {
  });
  pc = T((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o) {
          s6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o = ao.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          p6(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = ao.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: c6, value: function(r, o) {
        return K0(this, o6({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T((rI, bc) => {
    function v6(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p)) : process.nextTick(vc, r, p) : e ? (process.nextTick(oo, r), e(p)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T((iI, yc) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f = function(p) {
        g6(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gc[t] = f;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && y6(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (w6(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mc(e, "type"));
      else {
        var p = M6(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mc(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    dr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o) {
      var f = x6(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new _6(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T((aI, Rc) => {
    Rc.exports = ht;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn;
    ht.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
    Ie()(ht, Sc);
    function U6() {
    }
    function Yf(t, e, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        V6(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e) {
      return so.call(this, e) ? true : this !== ht ? false : e && e._writableState instanceof Yf;
    } })) : so = function(e) {
      return e instanceof this;
    };
    function ht(t) {
      Qn = Qn || hn();
      var e = this instanceof Qn;
      if (!e && !so.call(ht, this))
        return new ht(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht.prototype.pipe = function() {
      ef(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o) {
      var f;
      return r === null ? f = new C6 : typeof r != "string" && !e.objectMode && (f = new k6("chunk", ["string", "Buffer"], r)), f ? (ef(t, f), process.nextTick(o, f), false) : true;
    }
    ht.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p = !o.objectMode && q6(t);
      return p && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = U6), o.ending ? z6(this, r) : (p || H6(this, o, t, r)) && (o.pendingcb++, f = K6(this, o, p, t, e, r)), f;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o, f, p) {
      if (!r) {
        var m = W6(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y, o, f, p);
      return M;
    }
    function Y0(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef(t, o)) : (f(o), t._writableState.errorEmitted = true, ef(t, o), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o, e, f);
      else {
        var p = Ac(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o ? process.nextTick(_c, t, r, p, f) : _c(t, r, p, f);
      }
    }
    function _c(t, e, r, o) {
      r || $6(t, e), e.pendingcb--, o(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, Y0(t, e, true, e.length, f, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E = e.objectMode ? 1 : M.length;
          if (Y0(t, e, false, E, M, x, S), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || X6(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht.prototype.destroy = X0.destroy;
    ht.prototype._undestroy = X0.undestroy;
    ht.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r;
    var Bc = th(), eh = J0();
    Ie()($r, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o = e.length - 1;
      if (o < r)
        return 0;
      var f = rh(e[o]);
      return f >= 0 ? (f > 0 && (t.lastNeed = f - 1), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (t.lastNeed = f - 2), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (f === 2 ? f = 0 : t.lastNeed = f - 3), f) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e, o);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn(co());
  });
  vo = T((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new kc), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new kc), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return mM(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T((uI, Dc) => {
    var bo;
    function Ni(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di] = null, t[un] = null, e(Pi(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[mo]) {
            r(Pi(undefined, true));
            return;
          }
          e[nh](r, o);
        }, o);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[ea] ? y(e[ea]) : m(Pi(undefined, true));
          });
        });
      var o = this[ln], f;
      if (o)
        f = new Promise(MM(o, this));
      else {
        var p = this[dn].read();
        if (p !== null)
          return Promise.resolve(Pi(p, false));
        f = new Promise(this[nh]);
      }
      return this[ln] = f, f;
    } }, Ni(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[dn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Pi(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o = Object.create(xM, (r = {}, Ni(r, dn, { value: e, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p, m) {
        var y = o[dn].read();
        y ? (o[ln] = null, o[Di] = null, o[un] = null, p(Pi(y, false))) : (o[Di] = p, o[un] = m);
      }, writable: true }), r));
      return o[ln] = null, gM(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[un];
          p !== null && (o[ln] = null, o[Di] = null, o[un] = null, p(f)), o[ea] = f;
          return;
        }
        var m = o[Di];
        m !== null && (o[ln] = null, o[Di] = null, o[un] = null, m(Pi(undefined, true))), o[mo] = true;
      }), e.on("readable", wM.bind(null, o)), o;
    };
    Dc.exports = SM;
  });
  Oc = T((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T((cI, $c) => {
    $c.exports = Ce;
    var tf;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf = tf || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof tf;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o = true), Wc(this, t, e, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o, f) {
      Ne("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, OM(t, p);
      else {
        var m;
        if (f || (m = PM(p, e)), m)
          ta(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o)
            p.endEmitted ? ta(t, new NM) : hh(t, p, e, true);
          else if (p.ended)
            ta(t, new kM);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? hh(t, p, e, false) : lh(t, p)) : hh(t, p, e, false);
          }
        else
          o || (p.reading = false, lh(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
      if (t = Uc(t, e), t === 0 && e.ended)
        return e.length === 0 && uh(this), null;
      var o = e.needReadable;
      Ne("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Ne("length less than watermark", o)), e.ended || e.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc(r, e)));
      var f;
      return t > 0 ? f = Zc(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f !== null && this.emit("data", f), f;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        Ne("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S());
      }
      function y() {
        Ne("onend"), t.end();
      }
      var M = UM(r);
      t.on("drain", M);
      var x = false;
      function S() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        Ne("ondata");
        var N = t.write(_e);
        Ne("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Vc(o.pipes, t) !== -1) && !x && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        Ne("onerror", _e), ge(), t.removeListener("error", B), zc(t, "error") === 0 && ta(t, _e);
      }
      DM(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        Ne("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Vc(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? wo(this) : o.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (Ne("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < sh.length; p++)
        t.on(sh[p], this.emit.bind(this, sh[p]));
      return this._read = function(m) {
        Ne("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T((pI, Yc) => {
    Yc.exports = di;
    var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function di(t) {
      if (!(this instanceof di))
        return new di(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    di.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o) {
      o = XM(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return t4(m, M, x, function(S) {
          f || (f = S), S && p.forEach(tp), !M && (p.forEach(tp), o(f));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T((cr, fp) => {
    cr = fp.exports = th();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = J0();
    cr.Duplex = hn();
    cr.Transform = ph();
    cr.PassThrough = Qc();
    cr.finished = vo();
    cr.pipeline = np();
  });
  bh = T((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e, r) {
      var o = null;
      try {
        this.update(t, e);
      } catch (f) {
        o = f;
      }
      r(o);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f = this._blockOffset;f < this._blockSize; )
          r[f++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p = 0, m = t.length * 8;m > 0; ++p)
        this._length[p] += m, m = this._length[p] / 4294967296 | 0, m > 0 && (this._length[p] -= 4294967296 * m);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o = this._b, f = this._c, p = this._d;
      r = jt(r, o, f, p, t[0], 3614090360, 7), p = jt(p, r, o, f, t[1], 3905402710, 12), f = jt(f, p, r, o, t[2], 606105819, 17), o = jt(o, f, p, r, t[3], 3250441966, 22), r = jt(r, o, f, p, t[4], 4118548399, 7), p = jt(p, r, o, f, t[5], 1200080426, 12), f = jt(f, p, r, o, t[6], 2821735955, 17), o = jt(o, f, p, r, t[7], 4249261313, 22), r = jt(r, o, f, p, t[8], 1770035416, 7), p = jt(p, r, o, f, t[9], 2336552879, 12), f = jt(f, p, r, o, t[10], 4294925233, 17), o = jt(o, f, p, r, t[11], 2304563134, 22), r = jt(r, o, f, p, t[12], 1804603682, 7), p = jt(p, r, o, f, t[13], 4254626195, 12), f = jt(f, p, r, o, t[14], 2792965006, 17), o = jt(o, f, p, r, t[15], 1236535329, 22), r = Zt(r, o, f, p, t[1], 4129170786, 5), p = Zt(p, r, o, f, t[6], 3225465664, 9), f = Zt(f, p, r, o, t[11], 643717713, 14), o = Zt(o, f, p, r, t[0], 3921069994, 20), r = Zt(r, o, f, p, t[5], 3593408605, 5), p = Zt(p, r, o, f, t[10], 38016083, 9), f = Zt(f, p, r, o, t[15], 3634488961, 14), o = Zt(o, f, p, r, t[4], 3889429448, 20), r = Zt(r, o, f, p, t[9], 568446438, 5), p = Zt(p, r, o, f, t[14], 3275163606, 9), f = Zt(f, p, r, o, t[3], 4107603335, 14), o = Zt(o, f, p, r, t[8], 1163531501, 20), r = Zt(r, o, f, p, t[13], 2850285829, 5), p = Zt(p, r, o, f, t[2], 4243563512, 9), f = Zt(f, p, r, o, t[7], 1735328473, 14), o = Zt(o, f, p, r, t[12], 2368359562, 20), r = Vt(r, o, f, p, t[5], 4294588738, 4), p = Vt(p, r, o, f, t[8], 2272392833, 11), f = Vt(f, p, r, o, t[11], 1839030562, 16), o = Vt(o, f, p, r, t[14], 4259657740, 23), r = Vt(r, o, f, p, t[1], 2763975236, 4), p = Vt(p, r, o, f, t[4], 1272893353, 11), f = Vt(f, p, r, o, t[7], 4139469664, 16), o = Vt(o, f, p, r, t[10], 3200236656, 23), r = Vt(r, o, f, p, t[13], 681279174, 4), p = Vt(p, r, o, f, t[0], 3936430074, 11), f = Vt(f, p, r, o, t[3], 3572445317, 16), o = Vt(o, f, p, r, t[6], 76029189, 23), r = Vt(r, o, f, p, t[9], 3654602809, 4), p = Vt(p, r, o, f, t[12], 3873151461, 11), f = Vt(f, p, r, o, t[15], 530742520, 16), o = Vt(o, f, p, r, t[2], 3299628645, 23), r = $t(r, o, f, p, t[0], 4096336452, 6), p = $t(p, r, o, f, t[7], 1126891415, 10), f = $t(f, p, r, o, t[14], 2878612391, 15), o = $t(o, f, p, r, t[5], 4237533241, 21), r = $t(r, o, f, p, t[12], 1700485571, 6), p = $t(p, r, o, f, t[3], 2399980690, 10), f = $t(f, p, r, o, t[10], 4293915773, 15), o = $t(o, f, p, r, t[1], 2240044497, 21), r = $t(r, o, f, p, t[8], 1873313359, 6), p = $t(p, r, o, f, t[15], 4264355552, 10), f = $t(f, p, r, o, t[6], 2734768916, 15), o = $t(o, f, p, r, t[13], 1309151649, 21), r = $t(r, o, f, p, t[4], 4149444226, 6), p = $t(p, r, o, f, t[11], 3174756917, 10), f = $t(f, p, r, o, t[2], 718787259, 15), o = $t(o, f, p, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f | 0, this._d = this._d + p | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt(t, e, r, o, f, p, m) {
      return Eo(t + (e & r | ~e & o) + f + p | 0, m) + e | 0;
    }
    function Zt(t, e, r, o, f, p, m) {
      return Eo(t + (e & o | r & ~o) + f + p | 0, m) + e | 0;
    }
    function Vt(t, e, r, o, f, p, m) {
      return Eo(t + (e ^ r ^ o) + f + p | 0, m) + e | 0;
    }
    function $t(t, e, r, o, f, p, m) {
      return Eo(t + (r ^ (e | ~o)) + f + p | 0, m) + e | 0;
    }
    up.exports = So;
  });
  Bo = T((yI, mp) => {
    var mh = Ut().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._a | 0, M = this._b | 0, x = this._c | 0, S = this._d | 0, E = this._e | 0, B = 0;B < 80; B += 1) {
        var q, L;
        B < 16 ? (q = lp(r, o, f, p, m, t[na[B]], sa[0], aa[B]), L = vp(y, M, x, S, E, t[fa[B]], ha[0], oa[B])) : B < 32 ? (q = dp(r, o, f, p, m, t[na[B]], sa[1], aa[B]), L = pp(y, M, x, S, E, t[fa[B]], ha[1], oa[B])) : B < 48 ? (q = cp(r, o, f, p, m, t[na[B]], sa[2], aa[B]), L = cp(y, M, x, S, E, t[fa[B]], ha[2], oa[B])) : B < 64 ? (q = pp(r, o, f, p, m, t[na[B]], sa[3], aa[B]), L = dp(y, M, x, S, E, t[fa[B]], ha[3], oa[B])) : (q = vp(r, o, f, p, m, t[na[B]], sa[4], aa[B]), L = lp(y, M, x, S, E, t[fa[B]], ha[4], oa[B])), r = m, m = p, p = cn(f, 10), f = o, o = q, y = E, E = S, S = cn(x, 10), x = M, M = L;
      }
      var ge = this._b + f + S | 0;
      this._b = this._c + p + E | 0, this._c = this._d + m + y | 0, this._d = this._e + r + M | 0, this._e = this._a + o + x | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o, f, p, m, y) {
      return cn(t + (e ^ r ^ o) + p + m | 0, y) + f | 0;
    }
    function dp(t, e, r, o, f, p, m, y) {
      return cn(t + (e & r | ~e & o) + p + m | 0, y) + f | 0;
    }
    function cp(t, e, r, o, f, p, m, y) {
      return cn(t + ((e | ~r) ^ o) + p + m | 0, y) + f | 0;
    }
    function pp(t, e, r, o, f, p, m, y) {
      return cn(t + (e & o | r & ~o) + p + m | 0, y) + f | 0;
    }
    function vp(t, e, r, o, f, p, m, y) {
      return cn(t + (e ^ (r | ~o)) + p + m | 0, y) + f | 0;
    }
    mp.exports = Ro;
  });
  pn = T((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o = this._blockSize, f = t.length, p = this._len, m = 0;m < f; ) {
        for (var y = p % o, M = Math.min(f - m, o - y), x = 0;x < M; x++)
          r[y + x] = t[m + x];
        p += M, m += M, p % o === 0 && this._update(r);
      }
      return this._len += f, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f = (r - o) / 4294967296;
        this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p = this._hash();
      return t ? p.toString(t) : p;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T((MI, Mp) => {
    var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b4(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16];
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = b4(r) + g4(x, o, f, p) + m + e[M] + p4[x] | 0;
        m = p, p = f, f = m4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T((_I, Sp) => {
    var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E4(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = x4(e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16]);
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = S4(r) + A4(x, o, f, p) + m + e[M] + M4[x] | 0;
        m = p, p = f, f = E4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T((xI, Rp) => {
    var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N4(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._f | 0, M = this._g | 0, x = this._h | 0, S = 0;S < 16; ++S)
        e[S] = t.readInt32BE(S * 4);
      for (;S < 64; ++S)
        e[S] = P4(e[S - 2]) + e[S - 7] + D4(e[S - 15]) + e[S - 16] | 0;
      for (var E = 0;E < 64; ++E) {
        var B = x + N4(m) + T4(m, y, M) + q4[E] + e[E] | 0, q = L4(r) + k4(r, o, f) | 0;
        x = M, M = y, y = m, m = p + B | 0, p = f, f = o, o = r, r = B + q | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0, this._f = y + this._f | 0, this._g = M + this._g | 0, this._h = x + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T((EI, Pp) => {
    var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o = this._bh | 0, f = this._ch | 0, p = this._dh | 0, m = this._eh | 0, y = this._fh | 0, M = this._gh | 0, x = this._hh | 0, S = this._al | 0, E = this._bl | 0, B = this._cl | 0, q = this._dl | 0, L = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
        var Ae = V4(ye, xe), P = $4(xe, ye), Se = e[we - 7 * 2], v = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a = e[we - 16 * 2 + 1], h = Ee + v | 0, s = Re + Se + Pt(h, Ee) | 0;
        h = h + P | 0, s = s + Ae + Pt(h, P) | 0, h = h + a | 0, s = s + i + Pt(h, a) | 0, e[we] = s, e[we + 1] = h;
      }
      for (var u = 0;u < 160; u += 2) {
        s = e[u], h = e[u + 1];
        var c = kp(r, o, f), b = kp(S, E, B), l = Lp(r, S), n = Lp(S, r), d = Np(m, L), w = Np(L, m), g = Ip[u], _ = Ip[u + 1], A = Tp(m, y, M), R = Tp(L, ge, _e), I = N + w | 0, Me = x + d + Pt(I, N) | 0;
        I = I + R | 0, Me = Me + A + Pt(I, R) | 0, I = I + _ | 0, Me = Me + g + Pt(I, _) | 0, I = I + h | 0, Me = Me + s + Pt(I, h) | 0;
        var k = n + b | 0, D = l + c + Pt(k, n) | 0;
        x = M, N = _e, M = y, _e = ge, y = m, ge = L, L = q + I | 0, m = p + Me + Pt(L, q) | 0, p = f, q = B, f = o, B = E, o = r, E = S, S = I + k | 0, r = Me + D + Pt(S, I) | 0;
      }
      this._al = this._al + S | 0, this._bl = this._bl + E | 0, this._cl = this._cl + B | 0, this._dl = this._dl + q | 0, this._el = this._el + L | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N | 0, this._ah = this._ah + r + Pt(this._al, S) | 0, this._bh = this._bh + o + Pt(this._bl, E) | 0, this._ch = this._ch + f + Pt(this._cl, B) | 0, this._dh = this._dh + p + Pt(this._dl, q) | 0, this._eh = this._eh + m + Pt(this._el, L) | 0, this._fh = this._fh + y + Pt(this._fl, ge) | 0, this._gh = this._gh + M + Pt(this._gl, _e) | 0, this._hh = this._hh + x + Pt(this._hl, N) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T((ci, Fp) => {
    var ci = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci.sha = _p();
    ci.sha1 = Ep();
    ci.sha224 = qp();
    ci.sha256 = gh();
    ci.sha384 = Op();
    ci.sha512 = yh();
  });
  Tt = T((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr = T((BI, Mh) => {
    var e_ = Ut(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o = 0;o < e.length; o++)
          r += `    ${e[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o, f) => {
        t = o, e = f;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o, ...f) => o ? r(o) : e(...f));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f = e.shift();
        return o === "f" ? f.toFixed(6) : o === "j" ? JSON.stringify(f) : o === "s" && typeof f == "object" ? `${f.constructor !== Object ? f.constructor.name : ""} {}`.trim() : f.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p) {
          super(l_(t, e, p));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[o_] = true, Po[t] = o;
    }
    function Kp(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f = [], p = [], m = [];
      for (let M of e)
        vn(typeof M == "string", "All expected entries have to be of type string"), s_.includes(M) ? f.push(M.toLowerCase()) : h_.test(M) ? p.push(M) : (vn(M !== "object", 'The value "object" should be written as "Object"'), m.push(M));
      if (p.length > 0) {
        let M = f.indexOf("object");
        M !== -1 && (f.splice(f, M, 1), p.push("Object"));
      }
      if (f.length > 0) {
        switch (f.length) {
          case 1:
            o += `of type ${f[0]}`;
            break;
          case 2:
            o += `one of type ${f[0]} or ${f[1]}`;
            break;
          default: {
            let M = f.pop();
            o += `one of type ${f.join(", ")}, or ${M}`;
          }
        }
        (p.length > 0 || m.length > 0) && (o += " or ");
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            o += `an instance of ${p[0]}`;
            break;
          case 2:
            o += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let M = p.pop();
            o += `an instance of ${p.join(", ")}, or ${M}`;
          }
        }
        m.length > 0 && (o += " or ");
      }
      switch (m.length) {
        case 0:
          break;
        case 1:
          m[0].toLowerCase() !== m[0] && (o += "an "), o += `${m[0]}`;
          break;
        case 2:
          o += `one of ${m[0]} or ${m[1]}`;
          break;
        default: {
          let M = m.pop();
          o += `one of ${m.join(", ")}, or ${M}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y;
        (y = r.constructor) !== null && y !== undefined && y.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M = Do(r, { colors: false });
        M.length > 25 && (M = `${M.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o = Do(e);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o;
      let f = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Wp(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = Wp(o)), o += "n") : o = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt(), { hideStackFrames: Ir, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir((t, e, r = b_, o = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), L_ = Ir((t, e, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), Xp = Ir((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o = r ? 1 : 0, f = 4294967295;
      if (t < o || t > f)
        throw new bn(e, `>= ${o} && <= ${f}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var D_ = Ir((t, e, r) => {
      if (!Gp(r, t)) {
        let o = Yp(c_(r, (p) => typeof p == "string" ? `'${p}'` : w_(p)), ", "), f = "must be one of: " + o;
        throw new Co(e, t, f);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir((t, e, r = null) => {
      let o = xh(r, "allowArray", false), f = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o && $p(t) || typeof t != "object" && (!f || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new Co(e, t, o);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T((kI, i1) => {
    var dt = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi = mn.concat(pi) : Oo = -1, pi.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi.length;e; ) {
          for (mn = pi, pi = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi.push(new r1(t, e)), pi.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt.title = "browser";
    dt.browser = true;
    dt.env = {};
    dt.argv = [];
    dt.version = "";
    dt.versions = {};
    function vi() {
    }
    dt.on = vi;
    dt.addListener = vi;
    dt.once = vi;
    dt.off = vi;
    dt.removeListener = vi;
    dt.removeAllListeners = vi;
    dt.emit = vi;
    dt.prependListener = vi;
    dt.prependOnceListener = vi;
    dt.listeners = function(t) {
      return [];
    };
    dt.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt.cwd = function() {
      return "/";
    };
    dt.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt.umask = function() {
      return 0;
    };
  });
  pr = {};
  Ja(pr, { default: () => Y_ });
  Oi = R0(() => {
    ot(pr, rn(Rh()));
    Y_ = rn(Rh());
  });
  Fi = T((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !!(t.destroyed || t[a1] || o != null && o.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !o && p1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o, f, p, m, y, M, x, S;
      return !!(t && ((e = (r = (o = (f = (p = (m = t[o1]) !== null && m !== undefined ? m : t.readableErrored) !== null && p !== undefined ? p : t.writableErrored) !== null && f !== undefined ? f : (y = t._readableState) === null || y === undefined ? undefined : y.errorEmitted) !== null && o !== undefined ? o : (M = t._writableState) === null || M === undefined ? undefined : M.errorEmitted) !== null && r !== undefined ? r : (x = t._readableState) === null || x === undefined ? undefined : x.errored) !== null && e !== undefined ? e : (S = t._writableState) === null || S === undefined ? undefined : S.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T((DI, Ih) => {
    var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e, r) {
      var o, f;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p = (o = e.readable) !== null && o !== undefined ? o : qh(t), m = (f = e.writable) !== null && f !== undefined ? f : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y, _readableState: M } = t, x = () => {
        t.writable || B();
      }, S = w8(t) && qh(t) === p && _1(t) === m, E = x1(t, false), B = () => {
        E = true, t.destroyed && (S = false), !(S && (!t.readable || p)) && (!p || q) && r.call(t);
      }, q = w1(t, false), L = () => {
        q = true, t.destroyed && (S = false), !(S && (!t.writable || m)) && (!m || E) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e = b8(t), N = () => {
        _e = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p && !q && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m && !E && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B);
      };
      M8(t) ? (t.on("complete", B), S || t.on("abort", N), t.req ? we() : t.on("request", we)) : m && !y && (t.on("end", x), t.on("close", x)), !S && typeof t.aborted == "boolean" && t.on("aborted", N), t.on("end", L), t.on("finish", B), e.error !== false && t.on("error", ge), t.on("close", N), _e ? ff.nextTick(N) : y != null && y.errorEmitted || M != null && M.errorEmitted ? S || ff.nextTick(N) : (!p && (!S || y1(t)) && (E || M1(t) === false) || !m && (!S || M1(t)) && (q || y1(t) === false) || M && t.req && t.aborted) && ff.nextTick(N);
      let ye = () => {
        r = _8, t.removeListener("aborted", N), t.removeListener("complete", B), t.removeListener("abort", N), t.removeListener("request", we), t.req && t.req.removeListener("finish", B), t.removeListener("end", x), t.removeListener("close", x), t.removeListener("finish", B), t.removeListener("end", L), t.removeListener("error", ge), t.removeListener("close", N);
      };
      if (e.signal && !_e) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e) {
      return new v8((r, o) => {
        S1(t, e, (f) => {
          f ? o(f) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f, p;
        let m = new B1, y = this, M = [], x = m.signal, S = { signal: x }, E = () => m.abort();
        e != null && (f = e.signal) !== null && f !== undefined && f.aborted && E(), e == null || (p = e.signal) === null || p === undefined || p.addEventListener("abort", E);
        let B, q, L = false;
        function ge() {
          L = true;
        }
        async function _e() {
          try {
            for await (let ye of y) {
              var N;
              if (L)
                return;
              if (x.aborted)
                throw new Jr;
              try {
                ye = t(ye, S);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N = ye) === null || N === undefined ? undefined : N.catch) == "function" && ye.catch(ge), M.push(ye), B && (B(), B = null), !L && M.length && M.length >= r && await new E1((xe) => {
                q = xe;
              }));
            }
            M.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M.push(xe);
          } finally {
            var we;
            L = true, B && (B(), B = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M.length > 0; ) {
              let N = await M[0];
              if (N === R1)
                return;
              if (x.aborted)
                throw new Jr;
              N !== Wo && (yield N), M.shift(), q && (q(), q = null);
            }
            await new E1((N) => {
              B = N;
            });
          }
        } finally {
          m.abort(), L = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new Jr({ cause: t.signal.reason });
          yield [r++, f];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f), Wo;
      }
      for await (let o of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f) ? o : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x = new Jr(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x)), x;
      }
      let p = new B1, m = p.signal;
      if (r != null && r.signal) {
        let x = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p.abort(), x);
      }
      let y = false;
      try {
        for await (let x of this) {
          var M;
          if (y = true, r != null && (M = r.signal) !== null && M !== undefined && M.aborted)
            throw new Jr;
          f ? e = await t(e, x, { signal: m }) : (e = x, f = true);
        }
        if (!y && !f)
          throw new Th;
      } finally {
        p.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr(undefined, { cause: t.signal.reason });
        q8(e, o);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f of r)
          yield* f;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          t-- <= 0 && (yield p);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          if (t-- > 0)
            yield p;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T((CI, U1) => {
    var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o = this._writableState, f = o || r;
      return o && o.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f.constructed ? L1(this, t, e) : this.once(P1, function(p) {
        L1(this, W8(p, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o = false;
      function f(p) {
        if (o)
          return;
        o = true;
        let { _readableState: m, _writableState: y } = t;
        C1(p, y, m), y && (y.closed = true), m && (m.closed = true), typeof r == "function" && r(p), p ? zi.nextTick(X8, t, p) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f);
      } catch (p) {
        f(p);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o } = t;
      o && o.errorEmitted || r && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o, _writableState: f } = t;
      if (f && f.destroyed || o && o.destroyed)
        return this;
      o && o.autoDestroy || f && f.autoDestroy ? t.destroy(e) : e && (e.stack, f && !f.errored && (f.errored = e), o && !o.errored && (o.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o) {
        if (e) {
          Ph(t, o ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f, _writableState: p } = t, m = p || f;
        f && (f.constructed = true), p && (p.constructed = true), m.destroyed ? t.emit(P1, o) : o ? Ph(t, o, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o) {
        r(o);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o(S) {
        t.writable && t.write(S) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f), !t._isStdio && (!e || e.end !== false) && (r.on("end", m), r.on("close", y));
      let p = false;
      function m() {
        p || (p = true, t.end());
      }
      function y() {
        p || (p = true, typeof t.destroy == "function" && t.destroy());
      }
      function M(S) {
        x(), jo.listenerCount(this, "error") === 0 && this.emit("error", S);
      }
      Ch(r, "error", M), Ch(t, "error", M);
      function x() {
        r.removeListener("data", o), t.removeListener("drain", f), r.removeListener("end", m), r.removeListener("close", y), r.removeListener("error", M), t.removeListener("error", M), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x);
      }
      return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt(), { Buffer: Oh } = Ut(), { inspect: d5 } = Gr();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e + r.data;
        return o;
      }
      concat(e) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e >>> 0), o = this.head, f = 0;
        for (;o; )
          Yo(r, o.data, f), f += o.data.length, o = o.next;
        return r;
      }
      consume(e, r) {
        let o = this.head.data;
        if (e < o.length) {
          let f = o.slice(0, e);
          return this.head.data = o.slice(e), f;
        }
        return e === o.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o = this.head, f = 0;
        do {
          let p = o.data;
          if (e > p.length)
            r += p, e -= p.length;
          else {
            e === p.length ? (r += p, ++f, o.next ? this.head = o.next : this.head = this.tail = null) : (r += K1(p, 0, e), this.head = o, o.data = K1(p, e));
            break;
          }
          ++f;
        } while ((o = o.next) !== null);
        return this.length -= f, r;
      }
      _getBuffer(e) {
        let r = Oh.allocUnsafe(e), o = e, f = this.head, p = 0;
        do {
          let m = f.data;
          if (e > m.length)
            Yo(r, m, o - e), e -= m.length;
          else {
            e === m.length ? (Yo(r, m, o - e), ++p, f.next ? this.head = f.next : this.head = this.tail = null) : (Yo(r, new l5(m.buffer, m.byteOffset, e), o - e), this.head = f, f.data = m.slice(e));
            break;
          }
          ++p;
        } while ((f = f.next) !== null);
        return this.length -= p, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o) {
      let f = b5(e, o, r);
      if (f != null) {
        if (!p5(f) || f < 0) {
          let p = o ? `options.${r}` : "options.highWaterMark";
          throw new v5(p, f);
        }
        return c5(f);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T((WI, J1) => {
    var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt(), { Buffer: y5 } = Ut(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f;
      if (e && e[Y1])
        f = true, o = e[Y1]();
      else if (e && e[X1])
        f = false, o = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p = new t({ objectMode: true, highWaterMark: 1, ...r }), m = false;
      p._read = function() {
        m || (m = true, M());
      }, p._destroy = function(x, S) {
        g5(y(x), () => G1.nextTick(S, x), (E) => G1.nextTick(S, E || x));
      };
      async function y(x) {
        let S = x != null, E = typeof o.throw == "function";
        if (S && E) {
          let { value: B, done: q } = await o.throw(x);
          if (await B, q)
            return;
        }
        if (typeof o.return == "function") {
          let { value: B } = await o.return();
          await B;
        }
      }
      async function M() {
        for (;; ) {
          try {
            let { value: x, done: S } = f ? await o.next() : o.next();
            if (S)
              p.push(null);
            else {
              let E = x && typeof x.then == "function" ? await x : x;
              if (E === null)
                throw m = false, new M5;
              if (p.push(E))
                continue;
              m = false;
            }
          } catch (x) {
            p.destroy(x);
          }
          break;
        }
      }
      return p;
    }
    J1.exports = _5;
  });
  ba = T((KI, lv) => {
    var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe = Gr().debuglog("stream", (t) => {
      Pe = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi.prototype);
    rv(Le, Hi);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o) {
      Pe("readableAddChunk", e);
      let f = t._readableState, p;
      if (f.objectMode || (typeof e == "string" ? (r = r || f.defaultEncoding, f.encoding !== r && (o && f.encoding ? e = Uh.from(e, r).toString(f.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi._isUint8Array(e) ? (e = Hi._uint8ArrayToBuffer(e), r = "") : e != null && (p = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p)
        sf(t, p);
      else if (e === null)
        f.reading = false, $5(t, f);
      else if (f.objectMode || e && e.length > 0)
        if (o)
          if (f.endEmitted)
            sf(t, new W5);
          else {
            if (f.destroyed || f.errored)
              return false;
            Hh(t, f, e, true);
          }
        else if (f.ended)
          sf(t, new H5);
        else {
          if (f.destroyed || f.errored)
            return false;
          f.reading = false, f.decoder && !r ? (e = f.decoder.write(e), f.objectMode || e.length !== 0 ? Hh(t, f, e, false) : Jo(t, f)) : Hh(t, f, e, false);
        }
      else
        o || (f.reading = false, Jo(t, f));
      return !f.ended && (f.length < f.highWaterMark || f.length === 0);
    }
    function Hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f of r)
        o += e.write(f);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o = e.needReadable;
      if (Pe("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Pe("length less than watermark", o)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o = false, Pe("reading, ended or constructing", o);
      else if (o) {
        Pe("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p) {
          sf(this, p);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f;
      return t > 0 ? f = hv(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f)), f;
    };
    function $5(t, e) {
      if (Pe("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e = t._readableState;
      Pe("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new q5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), Pe("pipe count=%d opts=%j", o.pipes.length, e);
      let p = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y : _e;
      o.endEmitted ? Tr.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(N, we) {
        Pe("onunpipe"), N === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S());
      }
      function y() {
        Pe("onend"), t.end();
      }
      let M, x = false;
      function S() {
        Pe("cleanup"), t.removeListener("close", L), t.removeListener("finish", ge), M && t.removeListener("drain", M), t.removeListener("error", q), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", _e), r.removeListener("data", B), x = true, M && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M();
      }
      function E() {
        x || (o.pipes.length === 1 && o.pipes[0] === t ? (Pe("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (Pe("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M || (M = Y5(r, t), t.on("drain", M));
      }
      r.on("data", B);
      function B(N) {
        Pe("ondata");
        let we = t.write(N);
        Pe("dest.write", we), we === false && E();
      }
      function q(N) {
        if (Pe("onerror", N), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N) : t.emit("error", N);
        }
      }
      L5(t, "error", q);
      function L() {
        t.removeListener("finish", ge), _e();
      }
      t.once("close", L);
      function ge() {
        Pe("onfinish"), t.removeListener("close", L), _e();
      }
      t.once("finish", ge);
      function _e() {
        Pe("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E() : o.flowing || (Pe("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e ? (Pe("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (Pe("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f = e.pipes;
        e.pipes = [], this.pause();
        for (let p = 0;p < f.length; p++)
          f[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = x5(e.pipes, t);
      return o === -1 ? this : (e.pipes.splice(o, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe("on readable", o.length, o.reading), o.length ? Qo(this) : o.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        sf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o = 1;o < r.length; o++) {
        let f = r[o];
        this[f] === undefined && typeof t[f] == "function" && (this[f] = t[f].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o(m) {
        this === t ? (r(), r = zh) : r = m;
      }
      t.on("readable", o);
      let f, p = D5(t, { writable: false }, (m) => {
        f = m ? Q1(f, m) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m = t.destroyed ? null : t.read();
          if (m !== null)
            yield m;
          else {
            if (f)
              throw f;
            if (f === null)
              return;
            await new B5(o);
          }
        }
      } catch (m) {
        throw f = Q1(f, m), f;
      } finally {
        (f || e?.destroyOnReturn !== false) && (f === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o), p());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f, p) {
        hf.destroyer(t, f), p(f);
      } }).wrap(t);
    };
  });
  Jh = T((jI, xv) => {
    var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt();
    xv.exports = st;
    st.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st.prototype, ma.prototype);
    mv(st, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st(t) {
      let e = this instanceof Qr();
      if (!e && !vv(st, this))
        return new st(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st ? false : t && t._writableState instanceof ya;
    } });
    st.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o) {
      let f = t._writableState;
      if (typeof r == "function")
        o = r, r = f.defaultEncoding;
      else {
        if (!r)
          r = f.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o != "function" && (o = $h);
      }
      if (e === null)
        throw new bx;
      if (!f.objectMode)
        if (typeof e == "string")
          f.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p;
      return f.ending ? p = new mx : f.destroyed && (p = new ga("write")), p ? (Mn.nextTick(o, p), uf(t, p, true), p) : (f.pendingcb++, gx(t, f, e, r, o));
    }
    st.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st.prototype.cork = function() {
      this._writableState.corked++;
    };
    st.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o, f) {
      let p = e.objectMode ? 1 : r.length;
      e.length += p;
      let m = e.length < e.highWaterMark;
      return m || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o, callback: f }), e.allBuffers && o !== "buffer" && (e.allBuffers = false), e.allNoop && f !== $h && (e.allNoop = false)) : (e.writelen = p, e.writecb = f, e.writing = true, e.sync = true, t._write(r, o, e.onwrite), e.sync = false), m && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o) {
      --e.pendingcb, o(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o ? Mn.nextTick(cv, t, r, e, f) : cv(t, r, e, f)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f));
    }
    function wx({ stream: t, state: e, count: r, cb: o }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o);
    }
    function Mv(t, e, r, o) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f = t.bufferedIndex;f < t.buffered.length; ++f) {
        var e;
        let { chunk: p, callback: m } = t.buffered[f], y = t.objectMode ? 1 : p.length;
        t.length -= y, m((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f = 0;f < r.length; f++) {
        var o;
        r[f]((o = t.errored) !== null && o !== undefined ? o : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f } = e, p = r.length - o;
      if (!p)
        return;
      let m = o;
      if (e.bufferProcessing = true, p > 1 && t._writev) {
        e.pendingcb -= p - 1;
        let y = e.allNoop ? $h : (x) => {
          for (let S = m;S < r.length; ++S)
            r[S].callback(x);
        }, M = e.allNoop && m === 0 ? r : pv(r, m);
        M.allBuffers = e.allBuffers, dv(t, e, true, e.length, M, "", y), rs(e);
      } else {
        do {
          let { chunk: y, encoding: M, callback: x } = r[m];
          r[m++] = null;
          let S = f ? 1 : y.length;
          dv(t, e, false, S, y, M, x);
        } while (m < r.length && !e.writing);
        m === r.length ? rs(e) : m > 256 ? (r.splice(0, m), e.bufferedIndex = 0) : e.bufferedIndex = m;
      }
      e.bufferProcessing = false;
    }
    st.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st.prototype._writev = null;
    st.prototype.end = function(t, e, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f;
      if (t != null) {
        let p = wv(this, t, e);
        p instanceof ix && (f = p);
      }
      return o.corked && (o.corked = 1, this.uncork()), f || (!o.errored && !o.ending ? (o.ending = true, Xh(this, o, true), o.ended = true) : o.finished ? f = new vx("end") : o.destroyed && (f = new ga("end"))), typeof r == "function" && (f || o.finished ? Mn.nextTick(r, f) : o[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o(f) {
        if (r) {
          uf(t, f ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f) {
          let p = e[lf].splice(0);
          for (let m = 0;m < p.length; m++)
            p[m](f);
          uf(t, f, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o);
      } catch (f) {
        o(f);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o, f) => {
        ts(f) ? Vh(o, f) : f.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
    }
    function Vh(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    nx(st.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st.prototype._undestroy = is.undestroy;
    st.prototype._destroy = function(t, e) {
      e(t);
    };
    st.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T((ZI, Nv) => {
    var Qh = (Oi(), ur(pr)), Sx = Ut(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt(), _n = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f, write: p, final: m, destroy: y } = Nx(e);
        if (Sv(f))
          return Iv(_n, f, { objectMode: true, write: p, final: m, destroy: y });
        let M = f?.then;
        if (typeof M == "function") {
          let x, S = kv(M, f, (E) => {
            if (E != null)
              throw new Bv("nully", "body", E);
          }, (E) => {
            df(x, E);
          });
          return x = new _n({ objectMode: true, readable: false, write: p, final(E) {
            m(async () => {
              try {
                await S, Qh.nextTick(E, null);
              } catch (B) {
                Qh.nextTick(E, B);
              }
            });
          }, destroy: y });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f, writable: p });
      }
      let o = e?.then;
      if (typeof o == "function") {
        let f;
        return kv(o, e, (p) => {
          p != null && f.push(p), f.push(null);
        }, (p) => {
          df(f, p);
        }), f = new _n({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o = new Lx, f = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m = e;
          e = null;
          let { chunk: y, done: M, cb: x } = await m;
          if (Qh.nextTick(x), M)
            return;
          if (f.aborted)
            throw new Lv(undefined, { cause: f.reason });
          ({ promise: e, resolve: r } = qv()), yield y;
        }
      }(), { signal: f }), write(m, y, M) {
        let x = r;
        r = null, x({ chunk: m, done: false, cb: M });
      }, final(m) {
        let y = r;
        r = null, y({ done: true, cb: m });
      }, destroy(m, y) {
        o.abort(), y(m);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o = !!Ex(e), f = !!Ax(r), p, m, y, M, x;
      function S(E) {
        let B = M;
        M = null, B ? B(E) : E ? x.destroy(E) : !o && !f && x.destroy();
      }
      return x = new _n({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f }), f && (Rv(r, (E) => {
        f = false, E && df(e, E), S(E);
      }), x._write = function(E, B, q) {
        r.write(E, B) ? q() : p = q;
      }, x._final = function(E) {
        r.end(), m = E;
      }, r.on("drain", function() {
        if (p) {
          let E = p;
          p = null, E();
        }
      }), r.on("finish", function() {
        if (m) {
          let E = m;
          m = null, E();
        }
      })), o && (Rv(e, (E) => {
        o = false, E && df(e, E), S(E);
      }), e.on("readable", function() {
        if (y) {
          let E = y;
          y = null, E();
        }
      }), e.on("end", function() {
        x.push(null);
      }), x._read = function() {
        for (;; ) {
          let E = e.read();
          if (E === null) {
            y = x._read;
            return;
          }
          if (!x.push(E))
            return;
        }
      }), x._destroy = function(E, B) {
        !E && M !== null && (E = new Lv), y = null, p = null, m = null, M === null ? B(E) : (M = B, df(r, E), df(e, E));
      }, x;
    }
  });
  Qr = T((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt();
    Ov.exports = kr;
    var ru = ba(), vr = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu = T(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt();
    Uv.exports = mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
    Fv(mi.prototype, nu.prototype);
    Fv(mi, nu);
    var wa = Cx("kCallback");
    function mi(t) {
      if (!(this instanceof mi))
        return new mi(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu && iu.call(this);
    }
    mi.prototype._final = iu;
    mi.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi.prototype._write = function(t, e, r) {
      let o = this._readableState, f = this._writableState, p = o.length;
      this._transform(t, e, (m, y) => {
        if (m) {
          r(m);
          return;
        }
        y != null && this.push(y), f.ended || p === o.length || o.length < o.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou = T((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt();
    Hv.exports = cf;
    var au = fu();
    zv(cf.prototype, au.prototype);
    zv(cf, au);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au.call(this, t);
    }
    cf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T((YI, Gv) => {
    var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
    function jv(t, e, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f = as(t, { readable: e, writable: r }, (p) => {
        o = !p;
      });
      return { destroy: (p) => {
        o || (o = true, jx.destroyer(t, p || new $x("pipe")));
      }, cleanup: f };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o }) {
      let f, p = null, m = (x) => {
        if (x && (f = x), p) {
          let S = p;
          p = null, S();
        }
      }, y = () => new Hx((x, S) => {
        f ? S(f) : p = () => {
          f ? S(f) : x();
        };
      });
      e.on("drain", m);
      let M = as(e, { readable: false }, m);
      try {
        e.writableNeedDrain && await y();
        for await (let x of t)
          e.write(x) || await y();
        o && e.end(), await y(), r();
      } catch (x) {
        r(f !== x ? Zx(f, x) : x);
      } finally {
        M(), e.off("drain", m);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o = new Qx, f = o.signal, p = r?.signal, m = [];
      Jx(p, "options.signal");
      function y() {
        q(new Yx);
      }
      p?.addEventListener("abort", y);
      let M, x, S = [], E = 0;
      function B(N) {
        q(N, --E === 0);
      }
      function q(N, we) {
        if (N && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = N), !(!M && !we)) {
          for (;S.length; )
            S.shift()(M);
          p?.removeEventListener("abort", y), o.abort(), we && (M || m.forEach((ye) => ye()), fs.nextTick(e, M, x));
        }
      }
      let L;
      for (let N = 0;N < t.length; N++) {
        let we = t[N], ye = N < t.length - 1, xe = N > 0, Re = ye || r?.end !== false, Ee = N === t.length - 1;
        if (Kv(we)) {
          let Ae = function(P) {
            P && P.name !== "AbortError" && P.code !== "ERR_STREAM_PREMATURE_CLOSE" && B(P);
          };
          var _e = Ae;
          if (Re) {
            let { destroy: P, cleanup: Se } = jv(we, ye, xe);
            S.push(P), hu(we) && Ee && m.push(Se);
          }
          we.on("error", Ae), hu(we) && Ee && m.push(() => {
            we.removeListener("error", Ae);
          });
        }
        if (N === 0)
          if (typeof we == "function") {
            if (L = we({ signal: f }), !pf(L))
              throw new su("Iterable, AsyncIterable or Stream", "source", L);
          } else
            pf(we) || du(we) ? L = we : L = Wv.from(we);
        else if (typeof we == "function")
          if (L = t7(L), L = we(L, { signal: f }), ye) {
            if (!pf(L, true))
              throw new su("AsyncIterable", `transform[${N - 1}]`, L);
          } else {
            var ge;
            uu || (uu = ou());
            let Ae = new uu({ objectMode: true }), P = (ge = L) === null || ge === undefined ? undefined : ge.then;
            if (typeof P == "function")
              E++, P.call(L, (i) => {
                x = i, i != null && Ae.write(i), Re && Ae.end(), fs.nextTick(B);
              }, (i) => {
                Ae.destroy(i), fs.nextTick(B, i);
              });
            else if (pf(L, true))
              E++, Zv(L, Ae, B, { end: Re });
            else
              throw new su("AsyncIterable or Promise", "destination", L);
            L = Ae;
            let { destroy: Se, cleanup: v } = jv(L, false, true);
            S.push(Se), Ee && m.push(v);
          }
        else if (Kv(we)) {
          if (du(L)) {
            E += 2;
            let Ae = n7(L, we, B, { end: Re });
            hu(we) && Ee && m.push(Ae);
          } else if (pf(L))
            E++, Zv(L, we, B, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L);
          L = we;
        } else
          L = Wv.from(we);
      }
      return (f != null && f.aborted || p != null && p.aborted) && fs.nextTick(y), L;
    }
    function n7(t, e, r, { end: o }) {
      let f = false;
      return e.on("close", () => {
        f || r(new Gx);
      }), t.pipe(e, { end: o }), o ? t.once("end", () => {
        f = true, e.end();
      }) : r(), as(t, { readable: true, writable: false }, (p) => {
        let m = t._readableState;
        p && p.code === "ERR_STREAM_PREMATURE_CLOSE" && m && m.ended && !m.errored && !m.errorEmitted ? t.once("end", r).once("error", r) : r(p);
      }), as(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q = e.length - 1;
        e[q] = ss.from(e[q]);
      }
      for (let q = 0;q < e.length; ++q)
        if (!!o7(e[q])) {
          if (q < e.length - 1 && !Yv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !Xv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be writable");
        }
      let o, f, p, m, y;
      function M(q) {
        let L = m;
        m = null, L ? L(q) : q ? y.destroy(q) : !B && !E && y.destroy();
      }
      let x = e[0], S = f7(e, M), E = !!Xv(x), B = !!Yv(S);
      return y = new ss({ writableObjectMode: !!(x != null && x.writableObjectMode), readableObjectMode: !!(S != null && S.writableObjectMode), writable: E, readable: B }), E && (y._write = function(q, L, ge) {
        x.write(q, L) ? ge() : o = ge;
      }, y._final = function(q) {
        x.end(), f = q;
      }, x.on("drain", function() {
        if (o) {
          let q = o;
          o = null, q();
        }
      }), S.on("finish", function() {
        if (f) {
          let q = f;
          f = null, q();
        }
      })), B && (S.on("readable", function() {
        if (p) {
          let q = p;
          p = null, q();
        }
      }), S.on("end", function() {
        y.push(null);
      }), y._read = function() {
        for (;; ) {
          let q = S.read();
          if (q === null) {
            p = y._read;
            return;
          }
          if (!y.push(q))
            return;
        }
      }), y._destroy = function(q, L) {
        !q && m !== null && (q = new s7), p = null, o = null, f = null, m === null ? L(q) : (m = L, a7(S, q));
      }, y;
    };
  });
  cu = T((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o, f, p = t[t.length - 1];
        if (p && typeof p == "object" && !c7(p) && !d7(p)) {
          let m = u7(t);
          o = m.signal, f = m.end;
        }
        p7(t, (m, y) => {
          m ? r(m) : e(y);
        }, { signal: o, end: f });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T((QI, ub) => {
    var { Buffer: m7 } = Ut(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct = ub.exports = Vo().Stream;
    ct.isDisturbed = vu.isDisturbed;
    ct.isErrored = vu.isErrored;
    ct.isReadable = vu.isReadable;
    ct.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o) {
        if (new.target)
          throw ob();
        return ct.Readable.from(fb(e, this, o));
      };
      M7 = r;
      let e = rb[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f) {
        if (new.target)
          throw ob();
        return fb(e, this, f);
      };
      M7 = r;
      let e = ib[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct.Writable = Jh();
    ct.Duplex = Qr();
    ct.Transform = fu();
    ct.PassThrough = ou();
    ct.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct.addAbortSignal = w7;
    ct.finished = hb;
    ct.destroy = y7;
    ct.compose = g7;
    gi(ct, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct.Stream = ct;
    ct._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T((eT, pt) => {
    var Lt = lb(), _7 = cu(), x7 = Lt.Readable.destroy;
    pt.exports = Lt.Readable;
    pt.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt.exports._isUint8Array = Lt._isUint8Array;
    pt.exports.isDisturbed = Lt.isDisturbed;
    pt.exports.isErrored = Lt.isErrored;
    pt.exports.isReadable = Lt.isReadable;
    pt.exports.Readable = Lt.Readable;
    pt.exports.Writable = Lt.Writable;
    pt.exports.Duplex = Lt.Duplex;
    pt.exports.Transform = Lt.Transform;
    pt.exports.PassThrough = Lt.PassThrough;
    pt.exports.addAbortSignal = Lt.addAbortSignal;
    pt.exports.finished = Lt.finished;
    pt.exports.destroy = Lt.destroy;
    pt.exports.destroy = x7;
    pt.exports.pipeline = Lt.pipeline;
    pt.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt.exports.Stream = Lt.Stream;
    pt.exports.default = pt.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot(vf, rn(bu()));
    S7 = rn(bu());
  });
  yi = T((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f) {
        o = f;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    vb.exports = Lr;
  });
  bf = T((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o = this._opad = xn.allocUnsafe(mf), f = 0;f < mf; f++)
        r[f] = e[f] ^ 54, o[f] = e[f] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o = t === "rmd160" ? new gu : yu(t);
        e = o.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f = this._ipad = Ma.allocUnsafe(r), p = this._opad = Ma.allocUnsafe(r), m = 0;m < r; m++)
        f[m] = e[m] ^ 54, p[m] = e[m] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o = j7(t), f = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f ? e = o(e) : e.length < f && (e = Sn.concat([e, K7], f));
      for (var p = Sn.allocUnsafe(f + ds[t]), m = Sn.allocUnsafe(f + ds[t]), y = 0;y < f; y++)
        p[y] = e[y] ^ 54, m[y] = e[y] ^ 92;
      var M = Sn.allocUnsafe(f + r + 4);
      p.copy(M, 0, 0, f), this.ipad1 = M, this.ipad2 = p, this.opad = m, this.alg = t, this.blocksize = f, this.hash = o, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o) {
        return H7(t).update(o).digest();
      }
      function r(o) {
        return new z7().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o, f) {
      W7(r, o), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f = f || "sha1";
      var p = new kb(f, t, e.length), m = Sn.allocUnsafe(o), y = Sn.allocUnsafe(e.length + 4);
      e.copy(y, 0, 0, e.length);
      for (var M = 0, x = ds[f], S = Math.ceil(o / x), E = 1;E <= S; E++) {
        y.writeUInt32BE(E, e.length);
        for (var B = p.run(y, p.ipad1), q = B, L = 1;L < r; L++) {
          q = p.run(q, p.ipad2);
          for (var ge = 0;ge < x; ge++)
            B[ge] ^= q[ge];
        }
        B.copy(m, M), M += x;
      }
      return m;
    }
    Lb.exports = Z7;
  });
  Ub = T((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o, f) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f } }, p, o << 3);
      }).then(function(p) {
        return Cb.from(p);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o, f, p) {
      typeof f == "function" && (p = f, f = undefined), f = f || "sha1";
      var m = $7[f.toLowerCase()];
      if (!m || typeof global.Promise != "function") {
        Bu()(function() {
          var y;
          try {
            y = Db(t, e, r, o, f);
          } catch (M) {
            return p(M);
          }
          p(null, y);
        });
        return;
      }
      if (V7(r, o), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m).then(function(y) {
        return y ? Ob(t, e, r, o, m) : Db(t, e, r, o, f);
      }), p);
    };
  });
  Iu = T((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T((br) => {
    br.readUInt32BE = function(e, r) {
      var o = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o >>> 0;
    };
    br.writeUInt32BE = function(e, r, o) {
      e[0 + o] = r >>> 24, e[1 + o] = r >>> 16 & 255, e[2 + o] = r >>> 8 & 255, e[3 + o] = r & 255;
    };
    br.ip = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 6;y >= 0; y -= 2) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >>> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >>> M + y & 1;
      }
      for (var y = 6;y >= 0; y -= 2) {
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= r >>> M + y & 1;
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= e >>> M + y & 1;
      }
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.rip = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 0;y < 4; y++)
        for (var M = 24;M >= 0; M -= 8)
          p <<= 1, p |= r >>> M + y & 1, p <<= 1, p |= e >>> M + y & 1;
      for (var y = 4;y < 8; y++)
        for (var M = 24;M >= 0; M -= 8)
          m <<= 1, m |= r >>> M + y & 1, m <<= 1, m |= e >>> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.pc1 = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 7;y >= 5; y--) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        p <<= 1, p |= r >> M + y & 1;
      for (var y = 1;y <= 3; y++) {
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        m <<= 1, m |= e >> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br.pc2 = function(e, r, o, f) {
      for (var p = 0, m = 0, y = ps.length >>> 1, M = 0;M < y; M++)
        p <<= 1, p |= e >>> ps[M] & 1;
      for (var M = y;M < ps.length; M++)
        m <<= 1, m |= r >>> ps[M] & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.expand = function(e, r, o) {
      var f = 0, p = 0;
      f = (e & 1) << 5 | e >>> 27;
      for (var m = 23;m >= 15; m -= 4)
        f <<= 6, f |= e >>> m & 63;
      for (var m = 11;m >= 3; m -= 4)
        p |= e >>> m & 63, p <<= 6;
      p |= (e & 31) << 1 | e >>> 31, r[o + 0] = f >>> 0, r[o + 1] = p >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br.substitute = function(e, r) {
      for (var o = 0, f = 0;f < 4; f++) {
        var p = e >>> 18 - f * 6 & 63, m = zb[f * 64 + p];
        o <<= 4, o |= m;
      }
      for (var f = 0;f < 4; f++) {
        var p = r >>> 18 - f * 6 & 63, m = zb[4 * 64 + f * 64 + p];
        o <<= 4, o |= m;
      }
      return o >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br.permute = function(e) {
      for (var r = 0, o = 0;o < Hb.length; o++)
        r <<= 1, r |= e >>> Hb[o] & 1;
      return r >>> 0;
    };
    br.padSplit = function(e, r, o) {
      for (var f = e.toString(2);f.length < r; )
        f = "0" + f;
      for (var p = [], m = 0;m < r; m += o)
        p.push(f.slice(m, m + o));
      return p.join(" ");
    };
  });
  ar = T((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o) {
      if (e != r)
        throw new Error(o || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T((mT, jb) => {
    var X7 = ar();
    function mr(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr;
    mr.prototype._init = function() {
    };
    mr.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr.prototype._buffer = function(e, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - r), f = 0;f < o; f++)
        this.buffer[this.bufferOff + f] = e[r + f];
      return this.bufferOff += o, o;
    };
    mr.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr.prototype._updateEncrypt = function(e) {
      var r = 0, o = 0, f = (this.bufferOff + e.length) / this.blockSize | 0, p = new Array(f * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p, o)));
      for (var m = e.length - (e.length - r) % this.blockSize;r < m; r += this.blockSize)
        this._update(e, r, p, o), o += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p;
    };
    mr.prototype._updateDecrypt = function(e) {
      for (var r = 0, o = 0, f = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p = new Array(f * this.blockSize);f > 0; f--)
        r += this._buffer(e, r), o += this._flushBuffer(p, o);
      return r += this._buffer(e, r), p;
    };
    mr.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    mr.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr.prototype._unpad = function(e) {
      return e;
    };
    mr.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T((gT, $b) => {
    var Zb = ar(), J7 = Ie(), Nt = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f, e.tmp, 0), o = e.tmp[0], f = e.tmp[1];
      for (var p = 0;p < e.keys.length; p += 2) {
        var m = e9[p >>> 1];
        o = Nt.r28shl(o, m), f = Nt.r28shl(f, m), Nt.pc2(o, f, e.keys, p);
      }
    };
    ei.prototype._update = function(e, r, o, f) {
      var p = this._desState, m = Nt.readUInt32BE(e, r), y = Nt.readUInt32BE(e, r + 4);
      Nt.ip(m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, m, y, p.tmp, 0) : this._decrypt(p, m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], Nt.writeUInt32BE(o, m, f), Nt.writeUInt32BE(o, y, f + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o = e.length - r, f = r;f < e.length; f++)
        e[f] = o;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o = e.length - r;o < e.length; o++)
        Zb.equal(e[o], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o, f, p) {
      for (var m = r, y = o, M = 0;M < e.keys.length; M += 2) {
        var x = e.keys[M], S = e.keys[M + 1];
        Nt.expand(y, e.tmp, 0), x ^= e.tmp[0], S ^= e.tmp[1];
        var E = Nt.substitute(x, S), B = Nt.permute(E), q = y;
        y = (m ^ B) >>> 0, m = q;
      }
      Nt.rip(y, m, f, p);
    };
    ei.prototype._decrypt = function(e, r, o, f, p) {
      for (var m = o, y = r, M = e.keys.length - 2;M >= 0; M -= 2) {
        var x = e.keys[M], S = e.keys[M + 1];
        Nt.expand(m, e.tmp, 0), x ^= e.tmp[0], S ^= e.tmp[1];
        var E = Nt.substitute(x, S), B = Nt.permute(E), q = m;
        m = (y ^ B) >>> 0, y = q;
      }
      Nt.rip(m, y, f, p);
    };
  });
  Yb = T((Gb) => {
    var t9 = ar(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p) {
        t.call(this, p), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o = 0;o < r.length; o++) {
        var f = r[o];
        e.prototype[f] = bs[f];
      }
      return e.create = function(m) {
        return new e(m);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o, f) {
      var p = this._cbcState, m = this.constructor.super_.prototype, y = p.iv;
      if (this.type === "encrypt") {
        for (var M = 0;M < this.blockSize; M++)
          y[M] ^= e[r + M];
        m._update.call(this, y, 0, o, f);
        for (var M = 0;M < this.blockSize; M++)
          y[M] = o[f + M];
      } else {
        m._update.call(this, e, r, o, f);
        for (var M = 0;M < this.blockSize; M++)
          o[f + M] ^= y[M];
        for (var M = 0;M < this.blockSize; M++)
          y[M] = e[r + M];
      }
    };
  });
  Qb = T((wT, Jb) => {
    var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o = e.slice(8, 16), f = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o }), Wi.create({ type: "encrypt", key: f })] : this.ciphers = [Wi.create({ type: "decrypt", key: f }), Wi.create({ type: "encrypt", key: o }), Wi.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o, f) {
      var p = this._edeState;
      p.ciphers[0]._update(e, r, o, f), p.ciphers[1]._update(o, f, o, f), p.ciphers[2]._update(o, f, o, f);
    };
    An.prototype._pad = Wi.prototype._pad;
    An.prototype._unpad = Wi.prototype._unpad;
  });
  em = T((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T((_T, rm) => {
    var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f = t.key;
      Rn.isBuffer(f) || (f = Rn.from(f)), (e === "des-ede" || e === "des-ede-cbc") && (f = Rn.concat([f, f.slice(0, 8)]));
      var p = t.iv;
      Rn.isBuffer(p) || (p = Rn.from(p)), this._des = r.create({ key: f, iv: p, type: o });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf = T((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o = Math.min(e.length, r.length), f = new Buffer(o), p = 0;p < o; ++p)
        f[p] = e[p] ^ r[p];
      return f;
    };
  });
  om = T((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o = t._cipher.decryptBlock(e);
      return am(o, r);
    };
  });
  um = T((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e, r) {
      var o = e.length, f = h9(e, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ea.concat([t._prev, r ? e : f]), f;
    }
    hm.encrypt = function(t, e, r) {
      for (var o = Ea.allocUnsafe(0), f;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f = t._cache.length, o = Ea.concat([o, sm(t, e.slice(0, f), r)]), e = e.slice(f);
        else {
          o = Ea.concat([o, sm(t, e, r)]);
          break;
        }
      return o;
    };
  });
  dm = T((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o = t._cipher.encryptBlock(t._prev), f = o[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f])]), f;
    }
    lm.encrypt = function(t, e, r) {
      for (var o = e.length, f = Du.allocUnsafe(o), p = -1;++p < o; )
        f[p] = u9(t, e[p], r);
      return f;
    };
  });
  pm = T((cm) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o, f = -1, p = 8, m = 0, y, M;++f < p; )
        o = t._cipher.encryptBlock(t._prev), y = e & 1 << 7 - f ? 128 : 0, M = o[0] ^ y, m += (M & 128) >> f % 8, t._prev = d9(t._prev, r ? y : M);
      return m;
    }
    function d9(t, e) {
      var r = t.length, o = -1, f = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o < r; )
        f[o] = t[o] << 1 | t[o + 1] >> 7;
      return f;
    }
    cm.encrypt = function(t, e, r) {
      for (var o = e.length, f = gs.allocUnsafe(o), p = -1;++p < o; )
        f[p] = l9(t, e[p], r);
      return f;
    };
  });
  bm = T((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f = 0;f < r; f++) {
        var p = g9(t), m = o + f * Cu;
        t._cache.writeUInt32BE(p[0], m + 0), t._cache.writeUInt32BE(p[1], m + 4), t._cache.writeUInt32BE(p[2], m + 8), t._cache.writeUInt32BE(p[3], m + 12);
      }
      var y = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y);
    };
  });
  Fu = T((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o = 0;o < e; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o, f) {
      for (var p = r[0], m = r[1], y = r[2], M = r[3], x = t[0] ^ e[0], S = t[1] ^ e[1], E = t[2] ^ e[2], B = t[3] ^ e[3], q, L, ge, _e, N = 4, we = 1;we < f; we++)
        q = p[x >>> 24] ^ m[S >>> 16 & 255] ^ y[E >>> 8 & 255] ^ M[B & 255] ^ e[N++], L = p[S >>> 24] ^ m[E >>> 16 & 255] ^ y[B >>> 8 & 255] ^ M[x & 255] ^ e[N++], ge = p[E >>> 24] ^ m[B >>> 16 & 255] ^ y[x >>> 8 & 255] ^ M[S & 255] ^ e[N++], _e = p[B >>> 24] ^ m[x >>> 16 & 255] ^ y[S >>> 8 & 255] ^ M[E & 255] ^ e[N++], x = q, S = L, E = ge, B = _e;
      return q = (o[x >>> 24] << 24 | o[S >>> 16 & 255] << 16 | o[E >>> 8 & 255] << 8 | o[B & 255]) ^ e[N++], L = (o[S >>> 24] << 24 | o[E >>> 16 & 255] << 16 | o[B >>> 8 & 255] << 8 | o[x & 255]) ^ e[N++], ge = (o[E >>> 24] << 24 | o[B >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[S & 255]) ^ e[N++], _e = (o[B >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[S >>> 8 & 255] << 8 | o[E & 255]) ^ e[N++], q = q >>> 0, L = L >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q, L, ge, _e];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o = [], f = [[], [], [], []], p = [[], [], [], []], m = 0, y = 0, M = 0;M < 256; ++M) {
        var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
        x = x >>> 8 ^ x & 255 ^ 99, r[m] = x, o[x] = m;
        var S = t[m], E = t[S], B = t[E], q = t[x] * 257 ^ x * 16843008;
        f[0][m] = q << 24 | q >>> 8, f[1][m] = q << 16 | q >>> 16, f[2][m] = q << 8 | q >>> 24, f[3][m] = q, q = B * 16843009 ^ E * 65537 ^ S * 257 ^ m * 16843008, p[0][x] = q << 24 | q >>> 8, p[1][x] = q << 16 | q >>> 16, p[2][x] = q << 8 | q >>> 24, p[3][x] = q, m === 0 ? m = y = 1 : (m = S ^ t[t[t[B ^ S]]], y ^= t[t[y]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f, INV_SUB_MIX: p };
    }();
    function gr(t) {
      this._key = Hu(t), this._reset();
    }
    gr.blockSize = 4 * 4;
    gr.keySize = 256 / 8;
    gr.prototype.blockSize = gr.blockSize;
    gr.prototype.keySize = gr.keySize;
    gr.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o = (r + 1) * 4, f = [], p = 0;p < e; p++)
        f[p] = t[p];
      for (p = e;p < o; p++) {
        var m = f[p - 1];
        p % e === 0 ? (m = m << 8 | m >>> 24, m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255], m ^= M9[p / e | 0] << 24) : e > 6 && p % e === 4 && (m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255]), f[p] = f[p - e] ^ m;
      }
      for (var y = [], M = 0;M < o; M++) {
        var x = o - M, S = f[x - (M % 4 ? 0 : 4)];
        M < 4 || x <= 4 ? y[M] = S : y[M] = kt.INV_SUB_MIX[0][kt.SBOX[S >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S & 255]];
      }
      this._nRounds = r, this._keySchedule = f, this._invKeySchedule = y;
    };
    gr.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    gr.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr;
  });
  Em = T((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o, f, p = -1;++p < 128; ) {
        for (o = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, o && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o = Math.min(t.length, e.length), f = 0;f < o; ++f)
        r += t[f] ^ e[f];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o = new Rm(r), f = e.length, p = f % 16;
      o.update(e), p && (p = 16 - p, o.update(rr.alloc(p, 0))), o.update(rr.alloc(8, 0));
      var m = f * 8, y = rr.alloc(8);
      y.writeUIntBE(m, 0, 8), o.update(y), t._finID = o.state;
      var M = rr.from(t._finID);
      return R9(M), M;
    }
    function Bn(t, e, r, o) {
      Am.call(this);
      var f = rr.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p = this._cipher.encryptBlock(f);
      this._ghash = new Rm(p), r = q9(this, r, p), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn, Am);
    Bn.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn;
  });
  ju = T((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
    function _s(t, e, r, o) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f = r / 8, p = qn.alloc(f), m = qn.alloc(o || 0), y = qn.alloc(0);f > 0 || o > 0; ) {
        var M = new k9;
        M.update(y), M.update(t), e && M.update(e), y = M.digest();
        var x = 0;
        if (f > 0) {
          var S = p.length - f;
          x = Math.min(f, y.length), y.copy(p, S, 0, x), f -= x;
        }
        if (x < y.length && o > 0) {
          var E = m.length - o, B = Math.min(o, y.length - x);
          y.copy(m, E, x, x + B), o -= B;
        }
      }
      return y.fill(0), { key: p, iv: m };
    }
    Tm.exports = L9;
  });
  Dm = T((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o.push(r);
      return Mi.concat(o);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o = km[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new D9(o.module, e, r) : o.type === "auth" ? new N9(o.module, e, r) : new qa(o.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = C9(e, false, r.key, r.iv);
      return Nm(t, o.key, o.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o.push(r);
      return Mf.concat(o);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o = Pm[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o.type === "stream" ? new H9(o.module, e, r, true) : o.type === "auth" ? new z9(o.module, e, r, true) : new Ia(o.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = K9(e, false, r.key, r.iv);
      return Om(t, o.key, o.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T((_i) => {
    _i["des-ecb"] = { key: 8, iv: 0 };
    _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
    _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
    _i["des-ede3"] = { key: 24, iv: 0 };
    _i["des-ede-cbc"] = { key: 16, iv: 8 };
    _i["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T((Dr) => {
    var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return jm(t, f.key, f.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return Zm(t, f.key, f.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createCipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createDecipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi).concat($u.getCiphers());
    }
    Dr.createCipher = Dr.Cipher = Y9;
    Dr.createCipheriv = Dr.Cipheriv = jm;
    Dr.createDecipher = Dr.Decipher = X9;
    Dr.createDecipheriv = Dr.Decipheriv = Zm;
    Dr.listCiphers = Dr.getCiphers = J9;
  });
  ji = T(() => {
  });
  Yu = T(($m, Gu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Gu > "u" || Gu, $m);
  });
  Ym = T((Gm, Xu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T(() => {
  });
  As = T(($T, el) => {
    var Ju;
    el.exports = function(e) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {
      }
    var Qu;
  });
  tl = T((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o = Math.ceil(r / 8);
      do
        var f = new In(this.rand.generate(o));
      while (f.cmp(e) >= 0);
      return f;
    };
    Tn.prototype._randrange = function(e, r) {
      var o = r.sub(e);
      return e.add(this._randbelow(o));
    };
    Tn.prototype.test = function(e, r, o) {
      var f = e.bitLength(), p = In.mont(e), m = new In(1).toRed(p);
      r || (r = Math.max(1, f / 48 | 0));
      for (var y = e.subn(1), M = 0;!y.testn(M); M++)
        ;
      for (var x = e.shrn(M), S = y.toRed(p), E = true;r > 0; r--) {
        var B = this._randrange(new In(2), y);
        o && o(B);
        var q = B.toRed(p).redPow(x);
        if (!(q.cmp(m) === 0 || q.cmp(S) === 0)) {
          for (var L = 1;L < M; L++) {
            if (q = q.redSqr(), q.cmp(m) === 0)
              return false;
            if (q.cmp(S) === 0)
              break;
          }
          if (L === M)
            return false;
        }
      }
      return E;
    };
    Tn.prototype.getDivisor = function(e, r) {
      var o = e.bitLength(), f = In.mont(e), p = new In(1).toRed(f);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m = e.subn(1), y = 0;!m.testn(y); y++)
        ;
      for (var M = e.shrn(y), x = m.toRed(f);r > 0; r--) {
        var S = this._randrange(new In(2), m), E = e.gcd(S);
        if (E.cmpn(1) !== 0)
          return E;
        var B = S.toRed(f).redPow(M);
        if (!(B.cmp(p) === 0 || B.cmp(x) === 0)) {
          for (var q = 1;q < y; q++) {
            if (B = B.redSqr(), B.cmp(p) === 0)
              return B.fromRed().subn(1).gcd(e);
            if (B.cmp(x) === 0)
              break;
          }
          if (q === y)
            return B = B.redSqr(), B.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol = T((ek, tg) => {
    var eS = on();
    tg.exports = al;
    al.simpleSieve = nl;
    al.fermatTest = fl;
    var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f = Math.ceil(Math.sqrt(o)), p = 0;p < r && e[p] <= f && o % e[p] !== 0; p++)
          ;
        r !== p && e[p] <= f || (e[r++] = o);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl(t) {
      var e = Ht.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e = new Ht(e);
      for (var r, o;; ) {
        for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o = r.shrn(1), nl(o) && nl(r) && fl(o) && fl(r) && Qm.test(o) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T((rk, fg) => {
    var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
    fg.exports = Si;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in Rs)
        return Rs[o];
      var f = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f += 1, r === "02" || r === "05" ? f += 8 : f += 4, Rs[o] = f, f;
      ig.test(t.shrn(1)) || (f += 2);
      var p;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f += 8);
          break;
        case "05":
          p = t.mod(cS), p.cmp(pS) && p.cmp(vS) && (f += 8);
          break;
        default:
          f += 4;
      }
      return Rs[o] = f, f;
    }
    function Si(t, e, r) {
      this.setGenerator(e), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si.prototype.computeSecret = function(t) {
      t = new yr(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f = new Buffer(o.length - r.length);
        f.fill(0), r = Buffer.concat([f, r]);
      }
      return r;
    };
    Si.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl = T((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o) {
          SS(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o = qs.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          IS(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = qs.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: qS, value: function(r, o) {
        return ul(this, xS({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl = T((ak, bg) => {
    function TS(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p)) : process.nextTick(vg, r, p) : e ? (process.nextTick(Is, r), e(p)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f = function(p) {
        NS(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gg[t] = f;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && DS(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (PS(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mg(e, "type"));
      else {
        var p = CS(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mg(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl = T((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o) {
      var f = FS(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new OS(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T((hk, Ag) => {
    Ag.exports = ut;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl(), ks = Ut().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut, xg);
    function tE() {
    }
    function ka(t, e, r) {
      xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        sE(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut ? false : e && e._writableState instanceof ka;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut(t) {
      xf = xf || Ln();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut, this))
        return new ut(t);
      this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o) {
      var f;
      return r === null ? f = new JS : typeof r != "string" && !e.objectMode && (f = new VS("chunk", ["string", "Buffer"], r)), f ? (Sf(t, f), process.nextTick(o, f), false) : true;
    }
    ut.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p = !o.objectMode && KS(t);
      return p && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = tE), o.ending ? rE(this, r) : (p || iE(this, o, t, r)) && (o.pendingcb++, f = fE(this, o, p, t, e, r)), f;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o, f, p) {
      if (!r) {
        var m = nE(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl(t, e, false, y, o, f, p);
      return M;
    }
    function pl(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o)) : (f(o), t._writableState.errorEmitted = true, Sf(t, o), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o, e, f);
      else {
        var p = Eg(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o ? process.nextTick(Mg, t, r, p, f) : Mg(t, r, p, f);
      }
    }
    function Mg(t, e, r, o) {
      r || hE(t, e), e.pendingcb--, o(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, pl(t, e, true, e.length, f, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E = e.objectMode ? 1 : M.length;
          if (pl(t, e, false, E, M, x, S), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || dE(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut.prototype.destroy = vl.destroy;
    ut.prototype._undestroy = vl.undestroy;
    ut.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln = T((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti;
    var Rg = yl(), gl = bl();
    Ie()(ti, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti(t) {
      if (!(this instanceof ti))
        return new ti(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new qg), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new qg), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return yE(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e(Yi(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi(undefined, true));
            return;
          }
          e[wl](r, o);
        }, o);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[La] ? y(e[La]) : m(Yi(undefined, true));
          });
        });
      var o = this[Dn], f;
      if (o)
        f = new Promise(xE(o, this));
      else {
        var p = this[Pn].read();
        if (p !== null)
          return Promise.resolve(Yi(p, false));
        f = new Promise(this[wl]);
      }
      return this[Dn] = f, f;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[Pn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Yi(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p, m) {
        var y = o[Pn].read();
        y ? (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(Yi(y, false))) : (o[Gi] = p, o[Nn] = m);
      }, writable: true }), r));
      return o[Dn] = null, wE(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[Nn];
          p !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(f)), o[La] = f;
          return;
        }
        var m = o[Gi];
        m !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, m(Yi(undefined, true))), o[Cs] = true;
      }), e.on("readable", _E.bind(null, o)), o;
    };
    kg.exports = AE;
  });
  Dg = T((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl = T((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl(), Os = Ut().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o = true), Ug(this, t, e, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o, f) {
      De("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, UE(t, p);
      else {
        var m;
        if (f || (m = OE(p, e)), m)
          Na(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o)
            p.endEmitted ? Na(t, new PE) : El(t, p, e, true);
          else if (p.ended)
            Na(t, new NE);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? El(t, p, e, false) : Rl(t, p)) : El(t, p, e, false);
          }
        else
          o || (p.reading = false, Rl(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function El(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur(Jf)).StringDecoder);
      var e = new Af(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o = e.needReadable;
      De("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, De("length less than watermark", o)), e.ended || e.reading ? (o = false, De("reading or ended", o)) : o && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f;
      return t > 0 ? f = Wg(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f !== null && this.emit("data", f), f;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, De("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        De("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S());
      }
      function y() {
        De("onend"), t.end();
      }
      var M = HE(r);
      t.on("drain", M);
      var x = false;
      function S() {
        De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        De("ondata");
        var N = t.write(_e);
        De("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Kg(o.pipes, t) !== -1) && !x && (De("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        De("onerror", _e), ge(), t.removeListener("error", B), Og(t, "error") === 0 && Na(t, _e);
      }
      CE(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        De("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Kg(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? Us(this) : o.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (De("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < Sl.length; p++)
        t.on(Sl[p], this.emit.bind(this, Sl[p]));
      return this._read = function(m) {
        De("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T((bk, Vg) => {
    Vg.exports = Ei;
    var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
    Ie()(Ei, Hs);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function Ei(t) {
      if (!(this instanceof Ei))
        return new Ei(t);
      Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e);
    };
    Ei.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    Ei.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei.prototype._destroy = function(t, e) {
      Hs.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o) {
      o = QE(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return iA(m, M, x, function(S) {
          f || (f = S), S && p.forEach(Jg), !M && (p.forEach(Jg), o(f));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T((Mr, r2) => {
    Mr = r2.exports = yl();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws = T((n2, kl) => {
    (function(t, e) {
      function r(h, s) {
        if (!h)
          throw new Error(s || "Assertion failed");
      }
      function o(h, s) {
        h.super_ = s;
        var u = function() {
        };
        u.prototype = s.prototype, h.prototype = new u, h.prototype.constructor = h;
      }
      function f(h, s, u) {
        if (f.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h || 0, s || 10, u || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(s) {
        return s instanceof f ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f.wordSize && Array.isArray(s.words);
      }, f.max = function(s, u) {
        return s.cmp(u) > 0 ? s : u;
      }, f.min = function(s, u) {
        return s.cmp(u) < 0 ? s : u;
      }, f.prototype._init = function(s, u, c) {
        if (typeof s == "number")
          return this._initNumber(s, u, c);
        if (typeof s == "object")
          return this._initArray(s, u, c);
        u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
        var b = 0;
        s[0] === "-" && (b++, this.negative = 1), b < s.length && (u === 16 ? this._parseHex(s, b, c) : (this._parseBase(s, u, b), c === "le" && this._initArray(this.toArray(), u, c)));
      }, f.prototype._initNumber = function(s, u, c) {
        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
      }, f.prototype._initArray = function(s, u, c) {
        if (r(typeof s.length == "number"), s.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l, n, d = 0;
        if (c === "be")
          for (b = s.length - 1, l = 0;b >= 0; b -= 3)
            n = s[b] | s[b - 1] << 8 | s[b - 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        else if (c === "le")
          for (b = 0, l = 0;b < s.length; b += 3)
            n = s[b] | s[b + 1] << 8 | s[b + 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        return this._strip();
      };
      function m(h, s) {
        var u = h.charCodeAt(s);
        if (u >= 48 && u <= 57)
          return u - 48;
        if (u >= 65 && u <= 70)
          return u - 55;
        if (u >= 97 && u <= 102)
          return u - 87;
        r(false, "Invalid character in " + h);
      }
      function y(h, s, u) {
        var c = m(h, u);
        return u - 1 >= s && (c |= m(h, u - 1) << 4), c;
      }
      f.prototype._parseHex = function(s, u, c) {
        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l = 0, n = 0, d;
        if (c === "be")
          for (b = s.length - 1;b >= u; b -= 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        else {
          var w = s.length - u;
          for (b = w % 2 === 0 ? u + 1 : u;b < s.length; b += 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        }
        this._strip();
      };
      function M(h, s, u, c) {
        for (var b = 0, l = 0, n = Math.min(h.length, u), d = s;d < n; d++) {
          var w = h.charCodeAt(d) - 48;
          b *= c, w >= 49 ? l = w - 49 + 10 : w >= 17 ? l = w - 17 + 10 : l = w, r(w >= 0 && l < c, "Invalid character"), b += l;
        }
        return b;
      }
      f.prototype._parseBase = function(s, u, c) {
        this.words = [0], this.length = 1;
        for (var b = 0, l = 1;l <= 67108863; l *= u)
          b++;
        b--, l = l / u | 0;
        for (var n = s.length - c, d = n % b, w = Math.min(n, n - d) + c, g = 0, _ = c;_ < w; _ += b)
          g = M(s, _, _ + b, u), this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (d !== 0) {
          var A = 1;
          for (g = M(s, _, s.length, u), _ = 0;_ < d; _++)
            A *= u;
          this.imuln(A), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, f.prototype.copy = function(s) {
        s.words = new Array(this.length);
        for (var u = 0;u < this.length; u++)
          s.words[u] = this.words[u];
        s.length = this.length, s.negative = this.negative, s.red = this.red;
      };
      function x(h, s) {
        h.words = s.words, h.length = s.length, h.negative = s.negative, h.red = s.red;
      }
      if (f.prototype._move = function(s) {
        x(s, this);
      }, f.prototype.clone = function() {
        var s = new f(null);
        return this.copy(s), s;
      }, f.prototype._expand = function(s) {
        for (;this.length < s; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f.prototype[Symbol.for("nodejs.util.inspect.custom")] = S;
        } catch {
          f.prototype.inspect = S;
        }
      else
        f.prototype.inspect = S;
      function S() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(s, u) {
        s = s || 10, u = u | 0 || 1;
        var c;
        if (s === 16 || s === "hex") {
          c = "";
          for (var b = 0, l = 0, n = 0;n < this.length; n++) {
            var d = this.words[n], w = ((d << b | l) & 16777215).toString(16);
            l = d >>> 24 - b & 16777215, b += 2, b >= 26 && (b -= 26, n--), l !== 0 || n !== this.length - 1 ? c = E[6 - w.length] + w + c : c = w + c;
          }
          for (l !== 0 && (c = l.toString(16) + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        if (s === (s | 0) && s >= 2 && s <= 36) {
          var g = B[s], _ = q[s];
          c = "";
          var A = this.clone();
          for (A.negative = 0;!A.isZero(); ) {
            var R = A.modrn(_).toString(s);
            A = A.idivn(_), A.isZero() ? c = R + c : c = E[g - R.length] + R + c;
          }
          for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var s = this.words[0];
        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
      }, f.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (f.prototype.toBuffer = function(s, u) {
        return this.toArrayLike(p, s, u);
      }), f.prototype.toArray = function(s, u) {
        return this.toArrayLike(Array, s, u);
      };
      var L = function(s, u) {
        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
      };
      f.prototype.toArrayLike = function(s, u, c) {
        this._strip();
        var b = this.byteLength(), l = c || Math.max(1, b);
        r(b <= l, "byte array longer than desired length"), r(l > 0, "Requested array length <= 0");
        var n = L(s, l), d = u === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d](n, b), n;
      }, f.prototype._toArrayLikeLE = function(s, u) {
        for (var c = 0, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c++] = d & 255, c < s.length && (s[c++] = d >> 8 & 255), c < s.length && (s[c++] = d >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c < s.length)
          for (s[c++] = b;c < s.length; )
            s[c++] = 0;
      }, f.prototype._toArrayLikeBE = function(s, u) {
        for (var c = s.length - 1, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c--] = d & 255, c >= 0 && (s[c--] = d >> 8 & 255), c >= 0 && (s[c--] = d >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c >= 0)
          for (s[c--] = b;c >= 0; )
            s[c--] = 0;
      }, Math.clz32 ? f.prototype._countBits = function(s) {
        return 32 - Math.clz32(s);
      } : f.prototype._countBits = function(s) {
        var u = s, c = 0;
        return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
      }, f.prototype._zeroBits = function(s) {
        if (s === 0)
          return 26;
        var u = s, c = 0;
        return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
      }, f.prototype.bitLength = function() {
        var s = this.words[this.length - 1], u = this._countBits(s);
        return (this.length - 1) * 26 + u;
      };
      function ge(h) {
        for (var s = new Array(h.bitLength()), u = 0;u < s.length; u++) {
          var c = u / 26 | 0, b = u % 26;
          s[u] = h.words[c] >>> b & 1;
        }
        return s;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s = 0, u = 0;u < this.length; u++) {
          var c = this._zeroBits(this.words[u]);
          if (s += c, c !== 26)
            break;
        }
        return s;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(s) {
        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(s) {
        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(s) {
        for (;this.length < s.length; )
          this.words[this.length++] = 0;
        for (var u = 0;u < s.length; u++)
          this.words[u] = this.words[u] | s.words[u];
        return this._strip();
      }, f.prototype.ior = function(s) {
        return r((this.negative | s.negative) === 0), this.iuor(s);
      }, f.prototype.or = function(s) {
        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
      }, f.prototype.uor = function(s) {
        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
      }, f.prototype.iuand = function(s) {
        var u;
        this.length > s.length ? u = s : u = this;
        for (var c = 0;c < u.length; c++)
          this.words[c] = this.words[c] & s.words[c];
        return this.length = u.length, this._strip();
      }, f.prototype.iand = function(s) {
        return r((this.negative | s.negative) === 0), this.iuand(s);
      }, f.prototype.and = function(s) {
        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
      }, f.prototype.uand = function(s) {
        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
      }, f.prototype.iuxor = function(s) {
        var u, c;
        this.length > s.length ? (u = this, c = s) : (u = s, c = this);
        for (var b = 0;b < c.length; b++)
          this.words[b] = u.words[b] ^ c.words[b];
        if (this !== u)
          for (;b < u.length; b++)
            this.words[b] = u.words[b];
        return this.length = u.length, this._strip();
      }, f.prototype.ixor = function(s) {
        return r((this.negative | s.negative) === 0), this.iuxor(s);
      }, f.prototype.xor = function(s) {
        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
      }, f.prototype.uxor = function(s) {
        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
      }, f.prototype.inotn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = Math.ceil(s / 26) | 0, c = s % 26;
        this._expand(u), c > 0 && u--;
        for (var b = 0;b < u; b++)
          this.words[b] = ~this.words[b] & 67108863;
        return c > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - c), this._strip();
      }, f.prototype.notn = function(s) {
        return this.clone().inotn(s);
      }, f.prototype.setn = function(s, u) {
        r(typeof s == "number" && s >= 0);
        var c = s / 26 | 0, b = s % 26;
        return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b : this.words[c] = this.words[c] & ~(1 << b), this._strip();
      }, f.prototype.iadd = function(s) {
        var u;
        if (this.negative !== 0 && s.negative === 0)
          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s.negative !== 0)
          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
        var c, b;
        this.length > s.length ? (c = this, b = s) : (c = s, b = this);
        for (var l = 0, n = 0;n < b.length; n++)
          u = (c.words[n] | 0) + (b.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        for (;l !== 0 && n < c.length; n++)
          u = (c.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        if (this.length = c.length, l !== 0)
          this.words[this.length] = l, this.length++;
        else if (c !== this)
          for (;n < c.length; n++)
            this.words[n] = c.words[n];
        return this;
      }, f.prototype.add = function(s) {
        var u;
        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
      }, f.prototype.isub = function(s) {
        if (s.negative !== 0) {
          s.negative = 0;
          var u = this.iadd(s);
          return s.negative = 1, u._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
        var c = this.cmp(s);
        if (c === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b, l;
        c > 0 ? (b = this, l = s) : (b = s, l = this);
        for (var n = 0, d = 0;d < l.length; d++)
          u = (b.words[d] | 0) - (l.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        for (;n !== 0 && d < b.length; d++)
          u = (b.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        if (n === 0 && d < b.length && b !== this)
          for (;d < b.length; d++)
            this.words[d] = b.words[d];
        return this.length = Math.max(this.length, d), b !== this && (this.negative = 1), this._strip();
      }, f.prototype.sub = function(s) {
        return this.clone().isub(s);
      };
      function _e(h, s, u) {
        u.negative = s.negative ^ h.negative;
        var c = h.length + s.length | 0;
        u.length = c, c = c - 1 | 0;
        var b = h.words[0] | 0, l = s.words[0] | 0, n = b * l, d = n & 67108863, w = n / 67108864 | 0;
        u.words[0] = d;
        for (var g = 1;g < c; g++) {
          for (var _ = w >>> 26, A = w & 67108863, R = Math.min(g, s.length - 1), I = Math.max(0, g - h.length + 1);I <= R; I++) {
            var Me = g - I | 0;
            b = h.words[Me] | 0, l = s.words[I] | 0, n = b * l + A, _ += n / 67108864 | 0, A = n & 67108863;
          }
          u.words[g] = A | 0, w = _ | 0;
        }
        return w !== 0 ? u.words[g] = w | 0 : u.length--, u._strip();
      }
      var N = function(s, u, c) {
        var b = s.words, l = u.words, n = c.words, d = 0, w, g, _, A = b[0] | 0, R = A & 8191, I = A >>> 13, Me = b[1] | 0, k = Me & 8191, D = Me >>> 13, nt = b[2] | 0, C = nt & 8191, O = nt >>> 13, vt = b[3] | 0, F = vt & 8191, U = vt >>> 13, bt = b[4] | 0, z = bt & 8191, H = bt >>> 13, mt = b[5] | 0, W = mt & 8191, K = mt >>> 13, gt = b[6] | 0, j = gt & 8191, Z = gt >>> 13, yt = b[7] | 0, V = yt & 8191, $ = yt >>> 13, wt = b[8] | 0, G = wt & 8191, Y = wt >>> 13, Mt = b[9] | 0, X = Mt & 8191, J = Mt >>> 13, _t = l[0] | 0, Q = _t & 8191, ee = _t >>> 13, xt = l[1] | 0, te = xt & 8191, re = xt >>> 13, St = l[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l[3] | 0, fe = Et & 8191, ae = Et >>> 13, At = l[4] | 0, oe = At & 8191, se = At >>> 13, Rt = l[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l[7] | 0, ce = qt & 8191, pe = qt >>> 13, It = l[8] | 0, ve = It & 8191, be = It >>> 13, ft = l[9] | 0, Be = ft & 8191, qe = ft >>> 13;
        c.negative = s.negative ^ u.negative, c.length = 19, w = Math.imul(R, Q), g = Math.imul(R, ee), g = g + Math.imul(I, Q) | 0, _ = Math.imul(I, ee);
        var ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(k, Q), g = Math.imul(k, ee), g = g + Math.imul(D, Q) | 0, _ = Math.imul(D, ee), w = w + Math.imul(R, te) | 0, g = g + Math.imul(R, re) | 0, g = g + Math.imul(I, te) | 0, _ = _ + Math.imul(I, re) | 0;
        var He = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q), g = Math.imul(C, ee), g = g + Math.imul(O, Q) | 0, _ = Math.imul(O, ee), w = w + Math.imul(k, te) | 0, g = g + Math.imul(k, re) | 0, g = g + Math.imul(D, te) | 0, _ = _ + Math.imul(D, re) | 0, w = w + Math.imul(R, ie) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(I, ie) | 0, _ = _ + Math.imul(I, ne) | 0;
        var We = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F, Q), g = Math.imul(F, ee), g = g + Math.imul(U, Q) | 0, _ = Math.imul(U, ee), w = w + Math.imul(C, te) | 0, g = g + Math.imul(C, re) | 0, g = g + Math.imul(O, te) | 0, _ = _ + Math.imul(O, re) | 0, w = w + Math.imul(k, ie) | 0, g = g + Math.imul(k, ne) | 0, g = g + Math.imul(D, ie) | 0, _ = _ + Math.imul(D, ne) | 0, w = w + Math.imul(R, fe) | 0, g = g + Math.imul(R, ae) | 0, g = g + Math.imul(I, fe) | 0, _ = _ + Math.imul(I, ae) | 0;
        var Ke = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z, Q), g = Math.imul(z, ee), g = g + Math.imul(H, Q) | 0, _ = Math.imul(H, ee), w = w + Math.imul(F, te) | 0, g = g + Math.imul(F, re) | 0, g = g + Math.imul(U, te) | 0, _ = _ + Math.imul(U, re) | 0, w = w + Math.imul(C, ie) | 0, g = g + Math.imul(C, ne) | 0, g = g + Math.imul(O, ie) | 0, _ = _ + Math.imul(O, ne) | 0, w = w + Math.imul(k, fe) | 0, g = g + Math.imul(k, ae) | 0, g = g + Math.imul(D, fe) | 0, _ = _ + Math.imul(D, ae) | 0, w = w + Math.imul(R, oe) | 0, g = g + Math.imul(R, se) | 0, g = g + Math.imul(I, oe) | 0, _ = _ + Math.imul(I, se) | 0;
        var je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q), g = Math.imul(W, ee), g = g + Math.imul(K, Q) | 0, _ = Math.imul(K, ee), w = w + Math.imul(z, te) | 0, g = g + Math.imul(z, re) | 0, g = g + Math.imul(H, te) | 0, _ = _ + Math.imul(H, re) | 0, w = w + Math.imul(F, ie) | 0, g = g + Math.imul(F, ne) | 0, g = g + Math.imul(U, ie) | 0, _ = _ + Math.imul(U, ne) | 0, w = w + Math.imul(C, fe) | 0, g = g + Math.imul(C, ae) | 0, g = g + Math.imul(O, fe) | 0, _ = _ + Math.imul(O, ae) | 0, w = w + Math.imul(k, oe) | 0, g = g + Math.imul(k, se) | 0, g = g + Math.imul(D, oe) | 0, _ = _ + Math.imul(D, se) | 0, w = w + Math.imul(R, he) | 0, g = g + Math.imul(R, ue) | 0, g = g + Math.imul(I, he) | 0, _ = _ + Math.imul(I, ue) | 0;
        var Ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j, Q), g = Math.imul(j, ee), g = g + Math.imul(Z, Q) | 0, _ = Math.imul(Z, ee), w = w + Math.imul(W, te) | 0, g = g + Math.imul(W, re) | 0, g = g + Math.imul(K, te) | 0, _ = _ + Math.imul(K, re) | 0, w = w + Math.imul(z, ie) | 0, g = g + Math.imul(z, ne) | 0, g = g + Math.imul(H, ie) | 0, _ = _ + Math.imul(H, ne) | 0, w = w + Math.imul(F, fe) | 0, g = g + Math.imul(F, ae) | 0, g = g + Math.imul(U, fe) | 0, _ = _ + Math.imul(U, ae) | 0, w = w + Math.imul(C, oe) | 0, g = g + Math.imul(C, se) | 0, g = g + Math.imul(O, oe) | 0, _ = _ + Math.imul(O, se) | 0, w = w + Math.imul(k, he) | 0, g = g + Math.imul(k, ue) | 0, g = g + Math.imul(D, he) | 0, _ = _ + Math.imul(D, ue) | 0, w = w + Math.imul(R, le) | 0, g = g + Math.imul(R, de) | 0, g = g + Math.imul(I, le) | 0, _ = _ + Math.imul(I, de) | 0;
        var Ve = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V, Q), g = Math.imul(V, ee), g = g + Math.imul($, Q) | 0, _ = Math.imul($, ee), w = w + Math.imul(j, te) | 0, g = g + Math.imul(j, re) | 0, g = g + Math.imul(Z, te) | 0, _ = _ + Math.imul(Z, re) | 0, w = w + Math.imul(W, ie) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(K, ie) | 0, _ = _ + Math.imul(K, ne) | 0, w = w + Math.imul(z, fe) | 0, g = g + Math.imul(z, ae) | 0, g = g + Math.imul(H, fe) | 0, _ = _ + Math.imul(H, ae) | 0, w = w + Math.imul(F, oe) | 0, g = g + Math.imul(F, se) | 0, g = g + Math.imul(U, oe) | 0, _ = _ + Math.imul(U, se) | 0, w = w + Math.imul(C, he) | 0, g = g + Math.imul(C, ue) | 0, g = g + Math.imul(O, he) | 0, _ = _ + Math.imul(O, ue) | 0, w = w + Math.imul(k, le) | 0, g = g + Math.imul(k, de) | 0, g = g + Math.imul(D, le) | 0, _ = _ + Math.imul(D, de) | 0, w = w + Math.imul(R, ce) | 0, g = g + Math.imul(R, pe) | 0, g = g + Math.imul(I, ce) | 0, _ = _ + Math.imul(I, pe) | 0;
        var $e = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G, Q), g = Math.imul(G, ee), g = g + Math.imul(Y, Q) | 0, _ = Math.imul(Y, ee), w = w + Math.imul(V, te) | 0, g = g + Math.imul(V, re) | 0, g = g + Math.imul($, te) | 0, _ = _ + Math.imul($, re) | 0, w = w + Math.imul(j, ie) | 0, g = g + Math.imul(j, ne) | 0, g = g + Math.imul(Z, ie) | 0, _ = _ + Math.imul(Z, ne) | 0, w = w + Math.imul(W, fe) | 0, g = g + Math.imul(W, ae) | 0, g = g + Math.imul(K, fe) | 0, _ = _ + Math.imul(K, ae) | 0, w = w + Math.imul(z, oe) | 0, g = g + Math.imul(z, se) | 0, g = g + Math.imul(H, oe) | 0, _ = _ + Math.imul(H, se) | 0, w = w + Math.imul(F, he) | 0, g = g + Math.imul(F, ue) | 0, g = g + Math.imul(U, he) | 0, _ = _ + Math.imul(U, ue) | 0, w = w + Math.imul(C, le) | 0, g = g + Math.imul(C, de) | 0, g = g + Math.imul(O, le) | 0, _ = _ + Math.imul(O, de) | 0, w = w + Math.imul(k, ce) | 0, g = g + Math.imul(k, pe) | 0, g = g + Math.imul(D, ce) | 0, _ = _ + Math.imul(D, pe) | 0, w = w + Math.imul(R, ve) | 0, g = g + Math.imul(R, be) | 0, g = g + Math.imul(I, ve) | 0, _ = _ + Math.imul(I, be) | 0;
        var Ge = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X, Q), g = Math.imul(X, ee), g = g + Math.imul(J, Q) | 0, _ = Math.imul(J, ee), w = w + Math.imul(G, te) | 0, g = g + Math.imul(G, re) | 0, g = g + Math.imul(Y, te) | 0, _ = _ + Math.imul(Y, re) | 0, w = w + Math.imul(V, ie) | 0, g = g + Math.imul(V, ne) | 0, g = g + Math.imul($, ie) | 0, _ = _ + Math.imul($, ne) | 0, w = w + Math.imul(j, fe) | 0, g = g + Math.imul(j, ae) | 0, g = g + Math.imul(Z, fe) | 0, _ = _ + Math.imul(Z, ae) | 0, w = w + Math.imul(W, oe) | 0, g = g + Math.imul(W, se) | 0, g = g + Math.imul(K, oe) | 0, _ = _ + Math.imul(K, se) | 0, w = w + Math.imul(z, he) | 0, g = g + Math.imul(z, ue) | 0, g = g + Math.imul(H, he) | 0, _ = _ + Math.imul(H, ue) | 0, w = w + Math.imul(F, le) | 0, g = g + Math.imul(F, de) | 0, g = g + Math.imul(U, le) | 0, _ = _ + Math.imul(U, de) | 0, w = w + Math.imul(C, ce) | 0, g = g + Math.imul(C, pe) | 0, g = g + Math.imul(O, ce) | 0, _ = _ + Math.imul(O, pe) | 0, w = w + Math.imul(k, ve) | 0, g = g + Math.imul(k, be) | 0, g = g + Math.imul(D, ve) | 0, _ = _ + Math.imul(D, be) | 0, w = w + Math.imul(R, Be) | 0, g = g + Math.imul(R, qe) | 0, g = g + Math.imul(I, Be) | 0, _ = _ + Math.imul(I, qe) | 0;
        var Ye = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X, te), g = Math.imul(X, re), g = g + Math.imul(J, te) | 0, _ = Math.imul(J, re), w = w + Math.imul(G, ie) | 0, g = g + Math.imul(G, ne) | 0, g = g + Math.imul(Y, ie) | 0, _ = _ + Math.imul(Y, ne) | 0, w = w + Math.imul(V, fe) | 0, g = g + Math.imul(V, ae) | 0, g = g + Math.imul($, fe) | 0, _ = _ + Math.imul($, ae) | 0, w = w + Math.imul(j, oe) | 0, g = g + Math.imul(j, se) | 0, g = g + Math.imul(Z, oe) | 0, _ = _ + Math.imul(Z, se) | 0, w = w + Math.imul(W, he) | 0, g = g + Math.imul(W, ue) | 0, g = g + Math.imul(K, he) | 0, _ = _ + Math.imul(K, ue) | 0, w = w + Math.imul(z, le) | 0, g = g + Math.imul(z, de) | 0, g = g + Math.imul(H, le) | 0, _ = _ + Math.imul(H, de) | 0, w = w + Math.imul(F, ce) | 0, g = g + Math.imul(F, pe) | 0, g = g + Math.imul(U, ce) | 0, _ = _ + Math.imul(U, pe) | 0, w = w + Math.imul(C, ve) | 0, g = g + Math.imul(C, be) | 0, g = g + Math.imul(O, ve) | 0, _ = _ + Math.imul(O, be) | 0, w = w + Math.imul(k, Be) | 0, g = g + Math.imul(k, qe) | 0, g = g + Math.imul(D, Be) | 0, _ = _ + Math.imul(D, qe) | 0;
        var Xe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X, ie), g = Math.imul(X, ne), g = g + Math.imul(J, ie) | 0, _ = Math.imul(J, ne), w = w + Math.imul(G, fe) | 0, g = g + Math.imul(G, ae) | 0, g = g + Math.imul(Y, fe) | 0, _ = _ + Math.imul(Y, ae) | 0, w = w + Math.imul(V, oe) | 0, g = g + Math.imul(V, se) | 0, g = g + Math.imul($, oe) | 0, _ = _ + Math.imul($, se) | 0, w = w + Math.imul(j, he) | 0, g = g + Math.imul(j, ue) | 0, g = g + Math.imul(Z, he) | 0, _ = _ + Math.imul(Z, ue) | 0, w = w + Math.imul(W, le) | 0, g = g + Math.imul(W, de) | 0, g = g + Math.imul(K, le) | 0, _ = _ + Math.imul(K, de) | 0, w = w + Math.imul(z, ce) | 0, g = g + Math.imul(z, pe) | 0, g = g + Math.imul(H, ce) | 0, _ = _ + Math.imul(H, pe) | 0, w = w + Math.imul(F, ve) | 0, g = g + Math.imul(F, be) | 0, g = g + Math.imul(U, ve) | 0, _ = _ + Math.imul(U, be) | 0, w = w + Math.imul(C, Be) | 0, g = g + Math.imul(C, qe) | 0, g = g + Math.imul(O, Be) | 0, _ = _ + Math.imul(O, qe) | 0;
        var Je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X, fe), g = Math.imul(X, ae), g = g + Math.imul(J, fe) | 0, _ = Math.imul(J, ae), w = w + Math.imul(G, oe) | 0, g = g + Math.imul(G, se) | 0, g = g + Math.imul(Y, oe) | 0, _ = _ + Math.imul(Y, se) | 0, w = w + Math.imul(V, he) | 0, g = g + Math.imul(V, ue) | 0, g = g + Math.imul($, he) | 0, _ = _ + Math.imul($, ue) | 0, w = w + Math.imul(j, le) | 0, g = g + Math.imul(j, de) | 0, g = g + Math.imul(Z, le) | 0, _ = _ + Math.imul(Z, de) | 0, w = w + Math.imul(W, ce) | 0, g = g + Math.imul(W, pe) | 0, g = g + Math.imul(K, ce) | 0, _ = _ + Math.imul(K, pe) | 0, w = w + Math.imul(z, ve) | 0, g = g + Math.imul(z, be) | 0, g = g + Math.imul(H, ve) | 0, _ = _ + Math.imul(H, be) | 0, w = w + Math.imul(F, Be) | 0, g = g + Math.imul(F, qe) | 0, g = g + Math.imul(U, Be) | 0, _ = _ + Math.imul(U, qe) | 0;
        var Qe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X, oe), g = Math.imul(X, se), g = g + Math.imul(J, oe) | 0, _ = Math.imul(J, se), w = w + Math.imul(G, he) | 0, g = g + Math.imul(G, ue) | 0, g = g + Math.imul(Y, he) | 0, _ = _ + Math.imul(Y, ue) | 0, w = w + Math.imul(V, le) | 0, g = g + Math.imul(V, de) | 0, g = g + Math.imul($, le) | 0, _ = _ + Math.imul($, de) | 0, w = w + Math.imul(j, ce) | 0, g = g + Math.imul(j, pe) | 0, g = g + Math.imul(Z, ce) | 0, _ = _ + Math.imul(Z, pe) | 0, w = w + Math.imul(W, ve) | 0, g = g + Math.imul(W, be) | 0, g = g + Math.imul(K, ve) | 0, _ = _ + Math.imul(K, be) | 0, w = w + Math.imul(z, Be) | 0, g = g + Math.imul(z, qe) | 0, g = g + Math.imul(H, Be) | 0, _ = _ + Math.imul(H, qe) | 0;
        var et = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X, he), g = Math.imul(X, ue), g = g + Math.imul(J, he) | 0, _ = Math.imul(J, ue), w = w + Math.imul(G, le) | 0, g = g + Math.imul(G, de) | 0, g = g + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, de) | 0, w = w + Math.imul(V, ce) | 0, g = g + Math.imul(V, pe) | 0, g = g + Math.imul($, ce) | 0, _ = _ + Math.imul($, pe) | 0, w = w + Math.imul(j, ve) | 0, g = g + Math.imul(j, be) | 0, g = g + Math.imul(Z, ve) | 0, _ = _ + Math.imul(Z, be) | 0, w = w + Math.imul(W, Be) | 0, g = g + Math.imul(W, qe) | 0, g = g + Math.imul(K, Be) | 0, _ = _ + Math.imul(K, qe) | 0;
        var tt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(X, le), g = Math.imul(X, de), g = g + Math.imul(J, le) | 0, _ = Math.imul(J, de), w = w + Math.imul(G, ce) | 0, g = g + Math.imul(G, pe) | 0, g = g + Math.imul(Y, ce) | 0, _ = _ + Math.imul(Y, pe) | 0, w = w + Math.imul(V, ve) | 0, g = g + Math.imul(V, be) | 0, g = g + Math.imul($, ve) | 0, _ = _ + Math.imul($, be) | 0, w = w + Math.imul(j, Be) | 0, g = g + Math.imul(j, qe) | 0, g = g + Math.imul(Z, Be) | 0, _ = _ + Math.imul(Z, qe) | 0;
        var rt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, w = Math.imul(X, ce), g = Math.imul(X, pe), g = g + Math.imul(J, ce) | 0, _ = Math.imul(J, pe), w = w + Math.imul(G, ve) | 0, g = g + Math.imul(G, be) | 0, g = g + Math.imul(Y, ve) | 0, _ = _ + Math.imul(Y, be) | 0, w = w + Math.imul(V, Be) | 0, g = g + Math.imul(V, qe) | 0, g = g + Math.imul($, Be) | 0, _ = _ + Math.imul($, qe) | 0;
        var S0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w = Math.imul(X, ve), g = Math.imul(X, be), g = g + Math.imul(J, ve) | 0, _ = Math.imul(J, be), w = w + Math.imul(G, Be) | 0, g = g + Math.imul(G, qe) | 0, g = g + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, qe) | 0;
        var E0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w = Math.imul(X, Be), g = Math.imul(X, qe), g = g + Math.imul(J, Be) | 0, _ = Math.imul(J, qe);
        var A0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        return d = (_ + (g >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt, n[15] = rt, n[16] = S0, n[17] = E0, n[18] = A0, d !== 0 && (n[19] = d, c.length++), c;
      };
      Math.imul || (N = _e);
      function we(h, s, u) {
        u.negative = s.negative ^ h.negative, u.length = h.length + s.length;
        for (var c = 0, b = 0, l = 0;l < u.length - 1; l++) {
          var n = b;
          b = 0;
          for (var d = c & 67108863, w = Math.min(l, s.length - 1), g = Math.max(0, l - h.length + 1);g <= w; g++) {
            var _ = l - g, A = h.words[_] | 0, R = s.words[g] | 0, I = A * R, Me = I & 67108863;
            n = n + (I / 67108864 | 0) | 0, Me = Me + d | 0, d = Me & 67108863, n = n + (Me >>> 26) | 0, b += n >>> 26, n &= 67108863;
          }
          u.words[l] = d, c = n, n = b;
        }
        return c !== 0 ? u.words[l] = c : u.length--, u._strip();
      }
      function ye(h, s, u) {
        return we(h, s, u);
      }
      f.prototype.mulTo = function(s, u) {
        var c, b = this.length + s.length;
        return this.length === 10 && s.length === 10 ? c = N(this, s, u) : b < 63 ? c = _e(this, s, u) : b < 1024 ? c = we(this, s, u) : c = ye(this, s, u), c;
      };
      function xe(h, s) {
        this.x = h, this.y = s;
      }
      xe.prototype.makeRBT = function(s) {
        for (var u = new Array(s), c = f.prototype._countBits(s) - 1, b = 0;b < s; b++)
          u[b] = this.revBin(b, c, s);
        return u;
      }, xe.prototype.revBin = function(s, u, c) {
        if (s === 0 || s === c - 1)
          return s;
        for (var b = 0, l = 0;l < u; l++)
          b |= (s & 1) << u - l - 1, s >>= 1;
        return b;
      }, xe.prototype.permute = function(s, u, c, b, l, n) {
        for (var d = 0;d < n; d++)
          b[d] = u[s[d]], l[d] = c[s[d]];
      }, xe.prototype.transform = function(s, u, c, b, l, n) {
        this.permute(n, s, u, c, b, l);
        for (var d = 1;d < l; d <<= 1)
          for (var w = d << 1, g = Math.cos(2 * Math.PI / w), _ = Math.sin(2 * Math.PI / w), A = 0;A < l; A += w)
            for (var R = g, I = _, Me = 0;Me < d; Me++) {
              var k = c[A + Me], D = b[A + Me], nt = c[A + Me + d], C = b[A + Me + d], O = R * nt - I * C;
              C = R * C + I * nt, nt = O, c[A + Me] = k + nt, b[A + Me] = D + C, c[A + Me + d] = k - nt, b[A + Me + d] = D - C, Me !== w && (O = g * R - _ * I, I = g * I + _ * R, R = O);
            }
      }, xe.prototype.guessLen13b = function(s, u) {
        var c = Math.max(u, s) | 1, b = c & 1, l = 0;
        for (c = c / 2 | 0;c; c = c >>> 1)
          l++;
        return 1 << l + 1 + b;
      }, xe.prototype.conjugate = function(s, u, c) {
        if (!(c <= 1))
          for (var b = 0;b < c / 2; b++) {
            var l = s[b];
            s[b] = s[c - b - 1], s[c - b - 1] = l, l = u[b], u[b] = -u[c - b - 1], u[c - b - 1] = -l;
          }
      }, xe.prototype.normalize13b = function(s, u) {
        for (var c = 0, b = 0;b < u / 2; b++) {
          var l = Math.round(s[2 * b + 1] / u) * 8192 + Math.round(s[2 * b] / u) + c;
          s[b] = l & 67108863, l < 67108864 ? c = 0 : c = l / 67108864 | 0;
        }
        return s;
      }, xe.prototype.convert13b = function(s, u, c, b) {
        for (var l = 0, n = 0;n < u; n++)
          l = l + (s[n] | 0), c[2 * n] = l & 8191, l = l >>> 13, c[2 * n + 1] = l & 8191, l = l >>> 13;
        for (n = 2 * u;n < b; ++n)
          c[n] = 0;
        r(l === 0), r((l & -8192) === 0);
      }, xe.prototype.stub = function(s) {
        for (var u = new Array(s), c = 0;c < s; c++)
          u[c] = 0;
        return u;
      }, xe.prototype.mulp = function(s, u, c) {
        var b = 2 * this.guessLen13b(s.length, u.length), l = this.makeRBT(b), n = this.stub(b), d = new Array(b), w = new Array(b), g = new Array(b), _ = new Array(b), A = new Array(b), R = new Array(b), I = c.words;
        I.length = b, this.convert13b(s.words, s.length, d, b), this.convert13b(u.words, u.length, _, b), this.transform(d, n, w, g, b, l), this.transform(_, n, A, R, b, l);
        for (var Me = 0;Me < b; Me++) {
          var k = w[Me] * A[Me] - g[Me] * R[Me];
          g[Me] = w[Me] * R[Me] + g[Me] * A[Me], w[Me] = k;
        }
        return this.conjugate(w, g, b), this.transform(w, g, I, n, b, l), this.conjugate(I, n, b), this.normalize13b(I, b), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
      }, f.prototype.mul = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), this.mulTo(s, u);
      }, f.prototype.mulf = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), ye(this, s, u);
      }, f.prototype.imul = function(s) {
        return this.clone().mulTo(s, this);
      }, f.prototype.imuln = function(s) {
        var u = s < 0;
        u && (s = -s), r(typeof s == "number"), r(s < 67108864);
        for (var c = 0, b = 0;b < this.length; b++) {
          var l = (this.words[b] | 0) * s, n = (l & 67108863) + (c & 67108863);
          c >>= 26, c += l / 67108864 | 0, c += n >>> 26, this.words[b] = n & 67108863;
        }
        return c !== 0 && (this.words[b] = c, this.length++), u ? this.ineg() : this;
      }, f.prototype.muln = function(s) {
        return this.clone().imuln(s);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(s) {
        var u = ge(s);
        if (u.length === 0)
          return new f(1);
        for (var c = this, b = 0;b < u.length && u[b] === 0; b++, c = c.sqr())
          ;
        if (++b < u.length)
          for (var l = c.sqr();b < u.length; b++, l = l.sqr())
            u[b] !== 0 && (c = c.mul(l));
        return c;
      }, f.prototype.iushln = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 67108863 >>> 26 - u << 26 - u, l;
        if (u !== 0) {
          var n = 0;
          for (l = 0;l < this.length; l++) {
            var d = this.words[l] & b, w = (this.words[l] | 0) - d << u;
            this.words[l] = w | n, n = d >>> 26 - u;
          }
          n && (this.words[l] = n, this.length++);
        }
        if (c !== 0) {
          for (l = this.length - 1;l >= 0; l--)
            this.words[l + c] = this.words[l];
          for (l = 0;l < c; l++)
            this.words[l] = 0;
          this.length += c;
        }
        return this._strip();
      }, f.prototype.ishln = function(s) {
        return r(this.negative === 0), this.iushln(s);
      }, f.prototype.iushrn = function(s, u, c) {
        r(typeof s == "number" && s >= 0);
        var b;
        u ? b = (u - u % 26) / 26 : b = 0;
        var l = s % 26, n = Math.min((s - l) / 26, this.length), d = 67108863 ^ 67108863 >>> l << l, w = c;
        if (b -= n, b = Math.max(0, b), w) {
          for (var g = 0;g < n; g++)
            w.words[g] = this.words[g];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g = 0;g < this.length; g++)
              this.words[g] = this.words[g + n];
          else
            this.words[0] = 0, this.length = 1;
        var _ = 0;
        for (g = this.length - 1;g >= 0 && (_ !== 0 || g >= b); g--) {
          var A = this.words[g] | 0;
          this.words[g] = _ << 26 - l | A >>> l, _ = A & d;
        }
        return w && _ !== 0 && (w.words[w.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f.prototype.ishrn = function(s, u, c) {
        return r(this.negative === 0), this.iushrn(s, u, c);
      }, f.prototype.shln = function(s) {
        return this.clone().ishln(s);
      }, f.prototype.ushln = function(s) {
        return this.clone().iushln(s);
      }, f.prototype.shrn = function(s) {
        return this.clone().ishrn(s);
      }, f.prototype.ushrn = function(s) {
        return this.clone().iushrn(s);
      }, f.prototype.testn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return false;
        var l = this.words[c];
        return !!(l & b);
      }, f.prototype.imaskn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
          return this;
        if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
          var b = 67108863 ^ 67108863 >>> u << u;
          this.words[this.length - 1] &= b;
        }
        return this._strip();
      }, f.prototype.maskn = function(s) {
        return this.clone().imaskn(s);
      }, f.prototype.iaddn = function(s) {
        return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
      }, f.prototype._iaddn = function(s) {
        this.words[0] += s;
        for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
        return this.length = Math.max(this.length, u + 1), this;
      }, f.prototype.isubn = function(s) {
        if (r(typeof s == "number"), r(s < 67108864), s < 0)
          return this.iaddn(-s);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s), this.negative = 1, this;
        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u = 0;u < this.length && this.words[u] < 0; u++)
            this.words[u] += 67108864, this.words[u + 1] -= 1;
        return this._strip();
      }, f.prototype.addn = function(s) {
        return this.clone().iaddn(s);
      }, f.prototype.subn = function(s) {
        return this.clone().isubn(s);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(s, u, c) {
        var b = s.length + c, l;
        this._expand(b);
        var n, d = 0;
        for (l = 0;l < s.length; l++) {
          n = (this.words[l + c] | 0) + d;
          var w = (s.words[l] | 0) * u;
          n -= w & 67108863, d = (n >> 26) - (w / 67108864 | 0), this.words[l + c] = n & 67108863;
        }
        for (;l < this.length - c; l++)
          n = (this.words[l + c] | 0) + d, d = n >> 26, this.words[l + c] = n & 67108863;
        if (d === 0)
          return this._strip();
        for (r(d === -1), d = 0, l = 0;l < this.length; l++)
          n = -(this.words[l] | 0) + d, d = n >> 26, this.words[l] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f.prototype._wordDiv = function(s, u) {
        var c = this.length - s.length, b = this.clone(), l = s, n = l.words[l.length - 1] | 0, d = this._countBits(n);
        c = 26 - d, c !== 0 && (l = l.ushln(c), b.iushln(c), n = l.words[l.length - 1] | 0);
        var w = b.length - l.length, g;
        if (u !== "mod") {
          g = new f(null), g.length = w + 1, g.words = new Array(g.length);
          for (var _ = 0;_ < g.length; _++)
            g.words[_] = 0;
        }
        var A = b.clone()._ishlnsubmul(l, 1, w);
        A.negative === 0 && (b = A, g && (g.words[w] = 1));
        for (var R = w - 1;R >= 0; R--) {
          var I = (b.words[l.length + R] | 0) * 67108864 + (b.words[l.length + R - 1] | 0);
          for (I = Math.min(I / n | 0, 67108863), b._ishlnsubmul(l, I, R);b.negative !== 0; )
            I--, b.negative = 0, b._ishlnsubmul(l, 1, R), b.isZero() || (b.negative ^= 1);
          g && (g.words[R] = I);
        }
        return g && g._strip(), b._strip(), u !== "div" && c !== 0 && b.iushrn(c), { div: g || null, mod: b };
      }, f.prototype.divmod = function(s, u, c) {
        if (r(!s.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var b, l, n;
        return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b = n.div.neg()), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.iadd(s)), { div: b, mod: l }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b = n.div.neg()), { div: b, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.isub(s)), { div: n.div, mod: l }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f(this.modrn(s.words[0])) } : this._wordDiv(s, u);
      }, f.prototype.div = function(s) {
        return this.divmod(s, "div", false).div;
      }, f.prototype.mod = function(s) {
        return this.divmod(s, "mod", false).mod;
      }, f.prototype.umod = function(s) {
        return this.divmod(s, "mod", true).mod;
      }, f.prototype.divRound = function(s) {
        var u = this.divmod(s);
        if (u.mod.isZero())
          return u.div;
        var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b = s.ushrn(1), l = s.andln(1), n = c.cmp(b);
        return n < 0 || l === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
      }, f.prototype.modrn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = (1 << 26) % s, b = 0, l = this.length - 1;l >= 0; l--)
          b = (c * b + (this.words[l] | 0)) % s;
        return u ? -b : b;
      }, f.prototype.modn = function(s) {
        return this.modrn(s);
      }, f.prototype.idivn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = 0, b = this.length - 1;b >= 0; b--) {
          var l = (this.words[b] | 0) + c * 67108864;
          this.words[b] = l / s | 0, c = l % s;
        }
        return this._strip(), u ? this.ineg() : this;
      }, f.prototype.divn = function(s) {
        return this.clone().idivn(s);
      }, f.prototype.egcd = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = new f(0), d = new f(1), w = 0;u.isEven() && c.isEven(); )
          u.iushrn(1), c.iushrn(1), ++w;
        for (var g = c.clone(), _ = u.clone();!u.isZero(); ) {
          for (var A = 0, R = 1;(u.words[0] & R) === 0 && A < 26; ++A, R <<= 1)
            ;
          if (A > 0)
            for (u.iushrn(A);A-- > 0; )
              (b.isOdd() || l.isOdd()) && (b.iadd(g), l.isub(_)), b.iushrn(1), l.iushrn(1);
          for (var I = 0, Me = 1;(c.words[0] & Me) === 0 && I < 26; ++I, Me <<= 1)
            ;
          if (I > 0)
            for (c.iushrn(I);I-- > 0; )
              (n.isOdd() || d.isOdd()) && (n.iadd(g), d.isub(_)), n.iushrn(1), d.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(n), l.isub(d)) : (c.isub(u), n.isub(b), d.isub(l));
        }
        return { a: n, b: d, gcd: c.iushln(w) };
      }, f.prototype._invmp = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
          for (var d = 0, w = 1;(u.words[0] & w) === 0 && d < 26; ++d, w <<= 1)
            ;
          if (d > 0)
            for (u.iushrn(d);d-- > 0; )
              b.isOdd() && b.iadd(n), b.iushrn(1);
          for (var g = 0, _ = 1;(c.words[0] & _) === 0 && g < 26; ++g, _ <<= 1)
            ;
          if (g > 0)
            for (c.iushrn(g);g-- > 0; )
              l.isOdd() && l.iadd(n), l.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(l)) : (c.isub(u), l.isub(b));
        }
        var A;
        return u.cmpn(1) === 0 ? A = b : A = l, A.cmpn(0) < 0 && A.iadd(s), A;
      }, f.prototype.gcd = function(s) {
        if (this.isZero())
          return s.abs();
        if (s.isZero())
          return this.abs();
        var u = this.clone(), c = s.clone();
        u.negative = 0, c.negative = 0;
        for (var b = 0;u.isEven() && c.isEven(); b++)
          u.iushrn(1), c.iushrn(1);
        do {
          for (;u.isEven(); )
            u.iushrn(1);
          for (;c.isEven(); )
            c.iushrn(1);
          var l = u.cmp(c);
          if (l < 0) {
            var n = u;
            u = c, c = n;
          } else if (l === 0 || c.cmpn(1) === 0)
            break;
          u.isub(c);
        } while (true);
        return c.iushln(b);
      }, f.prototype.invm = function(s) {
        return this.egcd(s).a.umod(s);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(s) {
        return this.words[0] & s;
      }, f.prototype.bincn = function(s) {
        r(typeof s == "number");
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return this._expand(c + 1), this.words[c] |= b, this;
        for (var l = b, n = c;l !== 0 && n < this.length; n++) {
          var d = this.words[n] | 0;
          d += l, l = d >>> 26, d &= 67108863, this.words[n] = d;
        }
        return l !== 0 && (this.words[n] = l, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(s) {
        var u = s < 0;
        if (this.negative !== 0 && !u)
          return -1;
        if (this.negative === 0 && u)
          return 1;
        this._strip();
        var c;
        if (this.length > 1)
          c = 1;
        else {
          u && (s = -s), r(s <= 67108863, "Number is too big");
          var b = this.words[0] | 0;
          c = b === s ? 0 : b < s ? -1 : 1;
        }
        return this.negative !== 0 ? -c | 0 : c;
      }, f.prototype.cmp = function(s) {
        if (this.negative !== 0 && s.negative === 0)
          return -1;
        if (this.negative === 0 && s.negative !== 0)
          return 1;
        var u = this.ucmp(s);
        return this.negative !== 0 ? -u | 0 : u;
      }, f.prototype.ucmp = function(s) {
        if (this.length > s.length)
          return 1;
        if (this.length < s.length)
          return -1;
        for (var u = 0, c = this.length - 1;c >= 0; c--) {
          var b = this.words[c] | 0, l = s.words[c] | 0;
          if (b !== l) {
            b < l ? u = -1 : b > l && (u = 1);
            break;
          }
        }
        return u;
      }, f.prototype.gtn = function(s) {
        return this.cmpn(s) === 1;
      }, f.prototype.gt = function(s) {
        return this.cmp(s) === 1;
      }, f.prototype.gten = function(s) {
        return this.cmpn(s) >= 0;
      }, f.prototype.gte = function(s) {
        return this.cmp(s) >= 0;
      }, f.prototype.ltn = function(s) {
        return this.cmpn(s) === -1;
      }, f.prototype.lt = function(s) {
        return this.cmp(s) === -1;
      }, f.prototype.lten = function(s) {
        return this.cmpn(s) <= 0;
      }, f.prototype.lte = function(s) {
        return this.cmp(s) <= 0;
      }, f.prototype.eqn = function(s) {
        return this.cmpn(s) === 0;
      }, f.prototype.eq = function(s) {
        return this.cmp(s) === 0;
      }, f.red = function(s) {
        return new i(s);
      }, f.prototype.toRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(s) {
        return this.red = s, this;
      }, f.prototype.forceRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
      }, f.prototype.redAdd = function(s) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
      }, f.prototype.redIAdd = function(s) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
      }, f.prototype.redSub = function(s) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
      }, f.prototype.redISub = function(s) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
      }, f.prototype.redShl = function(s) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
      }, f.prototype.redMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
      }, f.prototype.redIMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(s) {
        return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h, s) {
        this.name = h, this.p = new f(s, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s = new f(null);
        return s.words = new Array(Math.ceil(this.n / 13)), s;
      }, Ee.prototype.ireduce = function(s) {
        var u = s, c;
        do
          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
        while (c > this.n);
        var b = c < this.n ? -1 : u.ucmp(this.p);
        return b === 0 ? (u.words[0] = 0, u.length = 1) : b > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
      }, Ee.prototype.split = function(s, u) {
        s.iushrn(this.n, 0, u);
      }, Ee.prototype.imulK = function(s) {
        return s.imul(this.k);
      };
      function Ae() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Ae, Ee), Ae.prototype.split = function(s, u) {
        for (var c = 4194303, b = Math.min(s.length, 9), l = 0;l < b; l++)
          u.words[l] = s.words[l];
        if (u.length = b, s.length <= 9) {
          s.words[0] = 0, s.length = 1;
          return;
        }
        var n = s.words[9];
        for (u.words[u.length++] = n & c, l = 10;l < s.length; l++) {
          var d = s.words[l] | 0;
          s.words[l - 10] = (d & c) << 4 | n >>> 22, n = d;
        }
        n >>>= 22, s.words[l - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
      }, Ae.prototype.imulK = function(s) {
        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = s.words[c] | 0;
          u += b * 977, s.words[c] = u & 67108863, u = b * 64 + (u / 67108864 | 0);
        }
        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
      };
      function P() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(P, Ee);
      function Se() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se, Ee);
      function v() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v, Ee), v.prototype.imulK = function(s) {
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = (s.words[c] | 0) * 19 + u, l = b & 67108863;
          b >>>= 26, s.words[c] = l, u = b;
        }
        return u !== 0 && (s.words[s.length++] = u), s;
      }, f._prime = function(s) {
        if (Re[s])
          return Re[s];
        var u;
        if (s === "k256")
          u = new Ae;
        else if (s === "p224")
          u = new P;
        else if (s === "p192")
          u = new Se;
        else if (s === "p25519")
          u = new v;
        else
          throw new Error("Unknown prime " + s);
        return Re[s] = u, u;
      };
      function i(h) {
        if (typeof h == "string") {
          var s = f._prime(h);
          this.m = s.p, this.prime = s;
        } else
          r(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      i.prototype._verify1 = function(s) {
        r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s, u) {
        r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
      }, i.prototype.imod = function(s) {
        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x(s, s.umod(this.m)._forceRed(this)), s);
      }, i.prototype.neg = function(s) {
        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
      }, i.prototype.add = function(s, u) {
        this._verify2(s, u);
        var c = s.add(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
      }, i.prototype.iadd = function(s, u) {
        this._verify2(s, u);
        var c = s.iadd(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c;
      }, i.prototype.sub = function(s, u) {
        this._verify2(s, u);
        var c = s.sub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
      }, i.prototype.isub = function(s, u) {
        this._verify2(s, u);
        var c = s.isub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c;
      }, i.prototype.shl = function(s, u) {
        return this._verify1(s), this.imod(s.ushln(u));
      }, i.prototype.imul = function(s, u) {
        return this._verify2(s, u), this.imod(s.imul(u));
      }, i.prototype.mul = function(s, u) {
        return this._verify2(s, u), this.imod(s.mul(u));
      }, i.prototype.isqr = function(s) {
        return this.imul(s, s.clone());
      }, i.prototype.sqr = function(s) {
        return this.mul(s, s);
      }, i.prototype.sqrt = function(s) {
        if (s.isZero())
          return s.clone();
        var u = this.m.andln(3);
        if (r(u % 2 === 1), u === 3) {
          var c = this.m.add(new f(1)).iushrn(2);
          return this.pow(s, c);
        }
        for (var b = this.m.subn(1), l = 0;!b.isZero() && b.andln(1) === 0; )
          l++, b.iushrn(1);
        r(!b.isZero());
        var n = new f(1).toRed(this), d = n.redNeg(), w = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new f(2 * g * g).toRed(this);this.pow(g, w).cmp(d) !== 0; )
          g.redIAdd(d);
        for (var _ = this.pow(g, b), A = this.pow(s, b.addn(1).iushrn(1)), R = this.pow(s, b), I = l;R.cmp(n) !== 0; ) {
          for (var Me = R, k = 0;Me.cmp(n) !== 0; k++)
            Me = Me.redSqr();
          r(k < I);
          var D = this.pow(_, new f(1).iushln(I - k - 1));
          A = A.redMul(D), _ = D.redSqr(), R = R.redMul(_), I = k;
        }
        return A;
      }, i.prototype.invm = function(s) {
        var u = s._invmp(this.m);
        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
      }, i.prototype.pow = function(s, u) {
        if (u.isZero())
          return new f(1).toRed(this);
        if (u.cmpn(1) === 0)
          return s.clone();
        var c = 4, b = new Array(1 << c);
        b[0] = new f(1).toRed(this), b[1] = s;
        for (var l = 2;l < b.length; l++)
          b[l] = this.mul(b[l - 1], s);
        var n = b[0], d = 0, w = 0, g = u.bitLength() % 26;
        for (g === 0 && (g = 26), l = u.length - 1;l >= 0; l--) {
          for (var _ = u.words[l], A = g - 1;A >= 0; A--) {
            var R = _ >> A & 1;
            if (n !== b[0] && (n = this.sqr(n)), R === 0 && d === 0) {
              w = 0;
              continue;
            }
            d <<= 1, d |= R, w++, !(w !== c && (l !== 0 || A !== 0)) && (n = this.mul(n, b[d]), w = 0, d = 0);
          }
          g = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s) {
        var u = s.umod(this.m);
        return u === s ? u.clone() : u;
      }, i.prototype.convertFrom = function(s) {
        var u = s.clone();
        return u.red = null, u;
      }, f.mont = function(s) {
        return new a(s);
      };
      function a(h) {
        i.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a, i), a.prototype.convertTo = function(s) {
        return this.imod(s.ushln(this.shift));
      }, a.prototype.convertFrom = function(s) {
        var u = this.imod(s.mul(this.rinv));
        return u.red = null, u;
      }, a.prototype.imul = function(s, u) {
        if (s.isZero() || u.isZero())
          return s.words[0] = 0, s.length = 1, s;
        var c = s.imul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.mul = function(s, u) {
        if (s.isZero() || u.isZero())
          return new f(0)._forceRed(this);
        var c = s.mul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.invm = function(s) {
        var u = this.imod(s._invmp(this.m).mul(this.r2));
        return u._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks = T((yk, o2) => {
    var Rf = Ws(), oA = on();
    function sA(t) {
      var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a2(t, e) {
      var r = sA(e), o = e.modulus.byteLength(), f = new Rf(t).mul(r.blinder).umod(e.modulus), p = f.toRed(Rf.mont(e.prime1)), m = f.toRed(Rf.mont(e.prime2)), y = e.coefficient, M = e.prime1, x = e.prime2, S = p.redPow(e.exponent1).fromRed(), E = m.redPow(e.exponent2).fromRed(), B = S.isub(E).imul(y).umod(M).imul(x);
      return E.iadd(B).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o);
    }
    a2.getr = f2;
    o2.exports = a2;
  });
  s2 = T((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri = T((h2, Ll) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h2);
  });
  Nl = T((d2) => {
    var js = d2;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f = t.charCodeAt(o), p = f >> 8, m = f & 255;
          p ? r.push(p, m) : r.push(m);
        }
      return r;
    }
    js.toArray = uA;
    function u2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js.zero2 = u2;
    function l2(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u2(t[r].toString(16));
      return e;
    }
    js.toHex = l2;
    js.encode = function(e, r) {
      return r === "hex" ? l2(e) : e;
    };
  });
  or = T((c2) => {
    var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs.toArray;
    Pr.zero2 = Zs.zero2;
    Pr.toHex = Zs.toHex;
    Pr.encode = Zs.encode;
    function cA(t, e, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f = 1 << e + 1, p = t.clone(), m = 0;m < o.length; m++) {
        var y, M = p.andln(f - 1);
        p.isOdd() ? (M > (f >> 1) - 1 ? y = (f >> 1) - M : y = M, p.isubn(y)) : y = 0, o[m] = y, p.iushrn(1);
      }
      return o;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o = 0, f = 0, p;t.cmpn(-o) > 0 || e.cmpn(-f) > 0; ) {
        var m = t.andln(3) + o & 3, y = e.andln(3) + f & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var M;
        (m & 1) === 0 ? M = 0 : (p = t.andln(7) + o & 7, (p === 3 || p === 5) && y === 2 ? M = -m : M = m), r[0].push(M);
        var x;
        (y & 1) === 0 ? x = 0 : (p = e.andln(7) + f & 7, (p === 3 || p === 5) && m === 2 ? x = -y : x = y), r[1].push(x), 2 * o === M + 1 && (o = 1 - o), 2 * f === x + 1 && (f = 1 - f), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o = "_" + e;
      t.prototype[e] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T((xk, p2) => {
    var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
    function Xi(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p2.exports = Xi;
    Xi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype._fixedNafMul = function(e, r) {
      $s(e.precomputed);
      var o = e._getDoubles(), f = Vs(r, 1, this._bitLength), p = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p /= 3;
      var m = [], y, M;
      for (y = 0;y < f.length; y += o.step) {
        M = 0;
        for (var x = y + o.step - 1;x >= y; x--)
          M = (M << 1) + f[x];
        m.push(M);
      }
      for (var S = this.jpoint(null, null, null), E = this.jpoint(null, null, null), B = p;B > 0; B--) {
        for (y = 0;y < m.length; y++)
          M = m[y], M === B ? E = E.mixedAdd(o.points[y]) : M === -B && (E = E.mixedAdd(o.points[y].neg()));
        S = S.add(E);
      }
      return S.toP();
    };
    Xi.prototype._wnafMul = function(e, r) {
      var o = 4, f = e._getNAFPoints(o);
      o = f.wnd;
      for (var p = f.points, m = Vs(r, o, this._bitLength), y = this.jpoint(null, null, null), M = m.length - 1;M >= 0; M--) {
        for (var x = 0;M >= 0 && m[M] === 0; M--)
          x++;
        if (M >= 0 && x++, y = y.dblp(x), M < 0)
          break;
        var S = m[M];
        $s(S !== 0), e.type === "affine" ? S > 0 ? y = y.mixedAdd(p[S - 1 >> 1]) : y = y.mixedAdd(p[-S - 1 >> 1].neg()) : S > 0 ? y = y.add(p[S - 1 >> 1]) : y = y.add(p[-S - 1 >> 1].neg());
      }
      return e.type === "affine" ? y.toP() : y;
    };
    Xi.prototype._wnafMulAdd = function(e, r, o, f, p) {
      var m = this._wnafT1, y = this._wnafT2, M = this._wnafT3, x = 0, S, E, B;
      for (S = 0;S < f; S++) {
        B = r[S];
        var q = B._getNAFPoints(e);
        m[S] = q.wnd, y[S] = q.points;
      }
      for (S = f - 1;S >= 1; S -= 2) {
        var L = S - 1, ge = S;
        if (m[L] !== 1 || m[ge] !== 1) {
          M[L] = Vs(o[L], m[L], this._bitLength), M[ge] = Vs(o[ge], m[ge], this._bitLength), x = Math.max(M[L].length, x), x = Math.max(M[ge].length, x);
          continue;
        }
        var _e = [r[L], null, null, r[ge]];
        r[L].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L].add(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg())) : r[L].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].add(r[ge].neg())) : (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg()));
        var N = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o[L], o[ge]);
        for (x = Math.max(we[0].length, x), M[L] = new Array(x), M[ge] = new Array(x), E = 0;E < x; E++) {
          var ye = we[0][E] | 0, xe = we[1][E] | 0;
          M[L][E] = N[(ye + 1) * 3 + (xe + 1)], M[ge][E] = 0, y[L] = _e;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S = x;S >= 0; S--) {
        for (var Ae = 0;S >= 0; ) {
          var P = true;
          for (E = 0;E < f; E++)
            Ee[E] = M[E][S] | 0, Ee[E] !== 0 && (P = false);
          if (!P)
            break;
          Ae++, S--;
        }
        if (S >= 0 && Ae++, Re = Re.dblp(Ae), S < 0)
          break;
        for (E = 0;E < f; E++) {
          var Se = Ee[E];
          Se !== 0 && (Se > 0 ? B = y[E][Se - 1 >> 1] : Se < 0 && (B = y[E][-Se - 1 >> 1].neg()), B.type === "affine" ? Re = Re.mixedAdd(B) : Re = Re.add(B));
        }
      }
      for (S = 0;S < f; S++)
        y[S] = null;
      return p ? Re : Re.toP();
    };
    function _r(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi.BasePoint = _r;
    _r.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
        e[0] === 6 ? $s(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s(e[e.length - 1] % 2 === 1);
        var f = this.point(e.slice(1, 1 + o), e.slice(1 + o, 1 + 2 * o));
        return f;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
        return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    _r.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f = this, p = 0;p < r; p += e) {
        for (var m = 0;m < e; m++)
          f = f.dbl();
        o.push(f);
      }
      return { step: e, points: o };
    };
    _r.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e) - 1, f = o === 1 ? null : this.dbl(), p = 1;p < o; p++)
        r[p] = r[p - 1].add(f);
      return { wnd: e, points: r };
    };
    _r.prototype._getBeta = function() {
      return null;
    };
    _r.prototype.dblp = function(e) {
      for (var r = this, o = 0;o < e; o++)
        r = r.dbl();
      return r;
    };
  });
  b2 = T((Sk, v2) => {
    var yA = or(), lt = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr(t) {
      Bf.call(this, "short", t), this.a = new lt(t.a, 16).toRed(this.red), this.b = new lt(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr, Bf);
    v2.exports = xr;
    xr.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e.beta)
          r = new lt(e.beta, 16).toRed(this.red);
        else {
          var f = this._getEndoRoots(this.p);
          r = f[0].cmp(f[1]) < 0 ? f[0] : f[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o = new lt(e.lambda, 16);
        else {
          var p = this._getEndoRoots(this.n);
          this.g.mul(p[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p[0] : (o = p[1], wA(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m;
        return e.basis ? m = e.basis.map(function(y) {
          return { a: new lt(y.a, 16), b: new lt(y.b, 16) };
        }) : m = this._getEndoBasis(o), { beta: r, lambda: o, basis: m };
      }
    };
    xr.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt.mont(e), o = new lt(2).toRed(r).redInvm(), f = o.redNeg(), p = new lt(3).toRed(r).redNeg().redSqrt().redMul(o), m = f.redAdd(p).fromRed(), y = f.redSub(p).fromRed();
      return [m, y];
    };
    xr.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, f = this.n.clone(), p = new lt(1), m = new lt(0), y = new lt(0), M = new lt(1), x, S, E, B, q, L, ge, _e = 0, N, we;o.cmpn(0) !== 0; ) {
        var ye = f.div(o);
        N = f.sub(ye.mul(o)), we = y.sub(ye.mul(p));
        var xe = M.sub(ye.mul(m));
        if (!E && N.cmp(r) < 0)
          x = ge.neg(), S = p, E = N.neg(), B = we;
        else if (E && ++_e === 2)
          break;
        ge = N, f = o, o = N, y = p, p = we, M = m, m = xe;
      }
      q = N.neg(), L = we;
      var Re = E.sqr().add(B.sqr()), Ee = q.sqr().add(L.sqr());
      return Ee.cmp(Re) >= 0 && (q = x, L = S), E.negative && (E = E.neg(), B = B.neg()), q.negative && (q = q.neg(), L = L.neg()), [{ a: E, b: B }, { a: q, b: L }];
    };
    xr.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o = r[0], f = r[1], p = f.b.mul(e).divRound(this.n), m = o.b.neg().mul(e).divRound(this.n), y = p.mul(o.a), M = m.mul(f.a), x = p.mul(o.b), S = m.mul(f.b), E = e.sub(y).sub(M), B = x.add(S).neg();
      return { k1: E, k2: B };
    };
    xr.prototype.pointFromX = function(e, r) {
      e = new lt(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f = o.redSqrt();
      if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p = f.fromRed().isOdd();
      return (r && !p || !r && p) && (f = f.redNeg()), this.point(e, f);
    };
    xr.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o } = e, f = this.a.redMul(r), p = r.redSqr().redMul(r).redIAdd(f).redIAdd(this.b);
      return o.redSqr().redISub(p).cmpn(0) === 0;
    };
    xr.prototype._endoWnafMulAdd = function(e, r, o) {
      for (var f = this._endoWnafT1, p = this._endoWnafT2, m = 0;m < e.length; m++) {
        var y = this._endoSplit(r[m]), M = e[m], x = M._getBeta();
        y.k1.negative && (y.k1.ineg(), M = M.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), f[m * 2] = M, f[m * 2 + 1] = x, p[m * 2] = y.k1, p[m * 2 + 1] = y.k2;
      }
      for (var S = this._wnafMulAdd(1, f, p, m * 2, o), E = 0;E < m * 2; E++)
        f[E] = null, p[E] = null;
      return S;
    };
    function Ct(t, e, r, o) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt(e, 16), this.y = new lt(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr.prototype.point = function(e, r, o) {
      return new Ct(this, e, r, o);
    };
    xr.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o = this.curve, f = function(p) {
            return o.point(p.x.redMul(o.endo.beta), p.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f = e.point(r[0], r[1], o);
      if (!r[2])
        return f;
      function p(y) {
        return e.point(y[0], y[1], o);
      }
      var m = r[2];
      return f.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [f].concat(m.doubles.points.map(p)) }, naf: m.naf && { wnd: m.naf.wnd, points: [f].concat(m.naf.points.map(p)) } }, f;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e.x), f = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f = e.redInvm(), p = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f), m = p.redSqr().redISub(this.x.redAdd(this.x)), y = p.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, y);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o) {
      var f = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p) : this.curve._wnafMulAdd(1, f, p, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o) {
      var f = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p, true) : this.curve._wnafMulAdd(1, f, p, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o = this.precomputed, f = function(p) {
          return p.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt(t, e, r, o) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt(0)) : (this.x = new lt(e, 16), this.y = new lt(r, 16), this.z = new lt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt, Bf.BasePoint);
    xr.prototype.jpoint = function(e, r, o) {
      return new Wt(this, e, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o = this.x.redMul(r), f = this.y.redMul(r).redMul(e);
      return this.curve.point(o, f);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o = this.z.redSqr(), f = this.x.redMul(r), p = e.x.redMul(o), m = this.y.redMul(r.redMul(e.z)), y = e.y.redMul(o.redMul(this.z)), M = f.redSub(p), x = m.redSub(y);
      if (M.cmpn(0) === 0)
        return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S = M.redSqr(), E = S.redMul(M), B = f.redMul(S), q = x.redSqr().redIAdd(E).redISub(B).redISub(B), L = x.redMul(B.redISub(q)).redISub(m.redMul(E)), ge = this.z.redMul(e.z).redMul(M);
      return this.curve.jpoint(q, L, ge);
    };
    Wt.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f = e.x.redMul(r), p = this.y, m = e.y.redMul(r).redMul(this.z), y = o.redSub(f), M = p.redSub(m);
      if (y.cmpn(0) === 0)
        return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x = y.redSqr(), S = x.redMul(y), E = o.redMul(x), B = M.redSqr().redIAdd(S).redISub(E).redISub(E), q = M.redMul(E.redISub(B)).redISub(p.redMul(S)), L = this.z.redMul(y);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e; r++)
          o = o.dbl();
        return o;
      }
      var f = this.curve.a, p = this.curve.tinv, m = this.x, y = this.y, M = this.z, x = M.redSqr().redSqr(), S = y.redAdd(y);
      for (r = 0;r < e; r++) {
        var E = m.redSqr(), B = S.redSqr(), q = B.redSqr(), L = E.redAdd(E).redIAdd(E).redIAdd(f.redMul(x)), ge = m.redMul(B), _e = L.redSqr().redISub(ge.redAdd(ge)), N = ge.redISub(_e), we = L.redMul(N);
        we = we.redIAdd(we).redISub(q);
        var ye = S.redMul(M);
        r + 1 < e && (x = x.redMul(q)), m = _e, M = ye, S = we;
      }
      return this.curve.jpoint(m, S.redMul(p), M);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f), x = M.redSqr().redISub(y).redISub(y), S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), e = x, r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E = this.x.redSqr(), B = this.y.redSqr(), q = B.redSqr(), L = this.x.redAdd(B).redSqr().redISub(E).redISub(q);
        L = L.redIAdd(L);
        var ge = E.redAdd(E).redIAdd(E), _e = ge.redSqr(), N = q.redIAdd(q);
        N = N.redIAdd(N), N = N.redIAdd(N), e = _e.redISub(L).redISub(L), r = ge.redMul(L.redISub(e)).redISub(N), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), x = M.redSqr().redISub(y).redISub(y);
        e = x;
        var S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E = this.z.redSqr(), B = this.y.redSqr(), q = this.x.redMul(B), L = this.x.redSub(E).redMul(this.x.redAdd(E));
        L = L.redAdd(L).redIAdd(L);
        var ge = q.redIAdd(q);
        ge = ge.redIAdd(ge);
        var _e = ge.redAdd(ge);
        e = L.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(B).redISub(E);
        var N = B.redSqr();
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N), r = L.redMul(ge.redISub(e)).redISub(N);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o = this.y, f = this.z, p = f.redSqr().redSqr(), m = r.redSqr(), y = o.redSqr(), M = m.redAdd(m).redIAdd(m).redIAdd(e.redMul(p)), x = r.redAdd(r);
      x = x.redIAdd(x);
      var S = x.redMul(y), E = M.redSqr().redISub(S.redAdd(S)), B = S.redISub(E), q = y.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = M.redMul(B).redISub(q), ge = o.redAdd(o).redMul(f);
      return this.curve.jpoint(E, L, ge);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f = r.redSqr(), p = e.redAdd(e).redIAdd(e), m = p.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e).redISub(f);
      y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(m);
      var M = y.redSqr(), x = f.redIAdd(f);
      x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
      var S = p.redIAdd(y).redSqr().redISub(m).redISub(M).redISub(x), E = r.redMul(S);
      E = E.redIAdd(E), E = E.redIAdd(E);
      var B = this.x.redMul(M).redISub(E);
      B = B.redIAdd(B), B = B.redIAdd(B);
      var q = this.y.redMul(S.redMul(x.redISub(S)).redISub(y.redMul(M)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = this.z.redAdd(y).redSqr().redISub(o).redISub(M);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.mul = function(e, r) {
      return e = new lt(e, r), this.curve._wnafMul(this, e);
    };
    Wt.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o = e.z.redSqr();
      if (this.x.redMul(o).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f = r.redMul(this.z), p = o.redMul(e.z);
      return this.y.redMul(p).redISub(e.y.redMul(f)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f = e.clone(), p = this.curve.redN.redMul(r);; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y2 = T((Ek, g2) => {
    var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
    function If(t) {
      Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m2(If, Gs);
    g2.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o = r.redSqr(), f = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p = f.redSqrt();
      return p.redSqr().cmp(f) === 0;
    };
    function Ot(t, e, r) {
      Gs.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m2(Ot, Gs.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o = this.x.redSub(this.z), f = o.redSqr(), p = r.redSub(f), m = r.redMul(f), y = p.redMul(f.redAdd(this.curve.a24.redMul(p)));
      return this.curve.point(m, y);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o = this.x.redAdd(this.z), f = this.x.redSub(this.z), p = e.x.redAdd(e.z), m = e.x.redSub(e.z), y = m.redMul(o), M = p.redMul(f), x = r.z.redMul(y.redAdd(M).redSqr()), S = r.x.redMul(y.redISub(M).redSqr());
      return this.curve.point(x, S);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o = this, f = this.curve.point(null, null), p = this, m = [];r.cmpn(0) !== 0; r.iushrn(1))
        m.push(r.andln(1));
      for (var y = m.length - 1;y >= 0; y--)
        m[y] === 0 ? (o = o.diffAdd(f, p), f = f.dbl()) : (f = o.diffAdd(f, p), o = o.dbl());
      return f;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _2 = T((Ak, M2) => {
    var _A = or(), Ai = ri(), w2 = Ie(), Ys = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w2(ii, Ys);
    M2.exports = ii;
    ii.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii.prototype.jpoint = function(e, r, o, f) {
      return this.point(e, r, o, f);
    };
    ii.prototype.pointFromX = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = this.c2.redSub(this.a.redMul(o)), p = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m = f.redMul(p.redInvm()), y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M = y.fromRed().isOdd();
      return (r && !M || !r && M) && (y = y.redNeg()), this.point(e, y);
    };
    ii.prototype.pointFromY = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = o.redSub(this.c2), p = o.redMul(this.d).redMul(this.c2).redSub(this.a), m = f.redMul(p.redInvm());
      if (m.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e);
    };
    ii.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o = e.y.redSqr(), f = r.redMul(this.a).redAdd(o), p = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f.cmp(p) === 0;
    };
    function at(t, e, r, o, f) {
      Ys.BasePoint.call(this, t, "projective"), e === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e, 16), this.y = new Ai(r, 16), this.z = o ? new Ai(o, 16) : this.curve.one, this.t = f && new Ai(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w2(at, Ys.BasePoint);
    ii.prototype.pointFromJSON = function(e) {
      return at.fromJSON(this, e);
    };
    ii.prototype.point = function(e, r, o, f) {
      return new at(this, e, r, o, f);
    };
    at.fromJSON = function(e, r) {
      return new at(e, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f = this.curve._mulA(e), p = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m = f.redAdd(r), y = m.redSub(o), M = f.redSub(r), x = p.redMul(y), S = m.redMul(M), E = p.redMul(M), B = y.redMul(m);
      return this.curve.point(x, S, B, E);
    };
    at.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f, p, m, y, M, x;
      if (this.curve.twisted) {
        y = this.curve._mulA(r);
        var S = y.redAdd(o);
        this.zOne ? (f = e.redSub(r).redSub(o).redMul(S.redSub(this.curve.two)), p = S.redMul(y.redSub(o)), m = S.redSqr().redSub(S).redSub(S)) : (M = this.z.redSqr(), x = S.redSub(M).redISub(M), f = e.redSub(r).redISub(o).redMul(x), p = S.redMul(y.redSub(o)), m = S.redMul(x));
      } else
        y = r.redAdd(o), M = this.curve._mulC(this.z).redSqr(), x = y.redSub(M).redSub(M), f = this.curve._mulC(e.redISub(y)).redMul(x), p = this.curve._mulC(y).redMul(r.redISub(o)), m = y.redMul(x);
      return this.curve.point(f, p, m);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f = this.t.redMul(this.curve.dd).redMul(e.t), p = this.z.redMul(e.z.redAdd(e.z)), m = o.redSub(r), y = p.redSub(f), M = p.redAdd(f), x = o.redAdd(r), S = m.redMul(y), E = M.redMul(x), B = m.redMul(x), q = y.redMul(M);
      return this.curve.point(S, E, q, B);
    };
    at.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o = r.redSqr(), f = this.x.redMul(e.x), p = this.y.redMul(e.y), m = this.curve.d.redMul(f).redMul(p), y = o.redSub(m), M = o.redAdd(m), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(p), S = r.redMul(y).redMul(x), E, B;
      return this.curve.twisted ? (E = r.redMul(M).redMul(p.redSub(this.curve._mulA(f))), B = y.redMul(M)) : (E = r.redMul(M).redMul(p.redSub(f)), B = this.curve._mulC(y).redMul(M)), this.curve.point(S, E, B);
    };
    at.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at.prototype.mulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, false);
    };
    at.prototype.jmulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e.clone(), f = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Pl = T((x2) => {
    var Xs = x2;
    Xs.base = Oa();
    Xs.short = b2();
    Xs.mont = y2();
    Xs.edwards = _2();
  });
  Cr = T((it) => {
    var SA = ar(), EA = Ie();
    it.inherits = EA;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f = 0;f < t.length; f += 2)
              r.push(parseInt(t[f] + t[f + 1], 16));
        } else
          for (var o = 0, f = 0;f < t.length; f++) {
            var p = t.charCodeAt(f);
            p < 128 ? r[o++] = p : p < 2048 ? (r[o++] = p >> 6 | 192, r[o++] = p & 63 | 128) : AA(t, f) ? (p = 65536 + ((p & 1023) << 10) + (t.charCodeAt(++f) & 1023), r[o++] = p >> 18 | 240, r[o++] = p >> 12 & 63 | 128, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128) : (r[o++] = p >> 12 | 224, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128);
          }
      else
        for (f = 0;f < t.length; f++)
          r[f] = t[f] | 0;
      return r;
    }
    it.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E2(t[r].toString(16));
      return e;
    }
    it.toHex = BA;
    function S2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it.htonl = S2;
    function qA(t, e) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f = t[o];
        e === "little" && (f = S2(f)), r += A2(f.toString(16));
      }
      return r;
    }
    it.toHex32 = qA;
    function E2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = E2;
    function A2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = A2;
    function IA(t, e, r, o) {
      var f = r - e;
      SA(f % 4 === 0);
      for (var p = new Array(f / 4), m = 0, y = e;m < p.length; m++, y += 4) {
        var M;
        o === "big" ? M = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : M = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], p[m] = M >>> 0;
      }
      return p;
    }
    it.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o = 0, f = 0;o < t.length; o++, f += 4) {
        var p = t[o];
        e === "big" ? (r[f] = p >>> 24, r[f + 1] = p >>> 16 & 255, r[f + 2] = p >>> 8 & 255, r[f + 3] = p & 255) : (r[f + 3] = p >>> 24, r[f + 2] = p >>> 16 & 255, r[f + 1] = p >>> 8 & 255, r[f] = p & 255);
      }
      return r;
    }
    it.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it.sum32_3 = DA;
    function PA(t, e, r, o) {
      return t + e + r + o >>> 0;
    }
    it.sum32_4 = PA;
    function CA(t, e, r, o, f) {
      return t + e + r + o + f >>> 0;
    }
    it.sum32_5 = CA;
    function OA(t, e, r, o) {
      var f = t[e], p = t[e + 1], m = o + p >>> 0, y = (m < o ? 1 : 0) + r + f;
      t[e] = y >>> 0, t[e + 1] = m;
    }
    it.sum64 = OA;
    function FA(t, e, r, o) {
      var f = e + o >>> 0, p = (f < e ? 1 : 0) + t + r;
      return p >>> 0;
    }
    it.sum64_hi = FA;
    function UA(t, e, r, o) {
      var f = e + o;
      return f >>> 0;
    }
    it.sum64_lo = UA;
    function zA(t, e, r, o, f, p, m, y) {
      var M = 0, x = e;
      x = x + o >>> 0, M += x < e ? 1 : 0, x = x + p >>> 0, M += x < p ? 1 : 0, x = x + y >>> 0, M += x < y ? 1 : 0;
      var S = t + r + f + m + M;
      return S >>> 0;
    }
    it.sum64_4_hi = zA;
    function HA(t, e, r, o, f, p, m, y) {
      var M = e + o + p + y;
      return M >>> 0;
    }
    it.sum64_4_lo = HA;
    function WA(t, e, r, o, f, p, m, y, M, x) {
      var S = 0, E = e;
      E = E + o >>> 0, S += E < e ? 1 : 0, E = E + p >>> 0, S += E < p ? 1 : 0, E = E + y >>> 0, S += E < y ? 1 : 0, E = E + x >>> 0, S += E < x ? 1 : 0;
      var B = t + r + f + m + M + S;
      return B >>> 0;
    }
    it.sum64_5_hi = WA;
    function KA(t, e, r, o, f, p, m, y, M, x) {
      var S = e + o + p + y + x;
      return S >>> 0;
    }
    it.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o = e << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it.shr64_hi = VA;
    function $A(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.shr64_lo = $A;
  });
  Tf = T((B2) => {
    var R2 = Cr(), GA = ar();
    function Js() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B2.BlockHash = Js;
    Js.prototype.update = function(e, r) {
      if (e = R2.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o = e.length % this._delta8;
        this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = R2.join32(e, 0, e.length - o, this.endian);
        for (var f = 0;f < e.length; f += this._delta32)
          this._update(e, f, f + this._delta32);
      }
      return this;
    };
    Js.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o = r - (e + this.padLength) % r, f = new Array(o + this.padLength);
      f[0] = 128;
      for (var p = 1;p < o; p++)
        f[p] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m = 8;m < this.padLength; m++)
          f[p++] = 0;
        f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = e >>> 24 & 255, f[p++] = e >>> 16 & 255, f[p++] = e >>> 8 & 255, f[p++] = e & 255;
      } else
        for (f[p++] = e & 255, f[p++] = e >>> 8 & 255, f[p++] = e >>> 16 & 255, f[p++] = e >>> 24 & 255, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, m = 8;m < this.padLength; m++)
          f[p++] = 0;
      return f;
    };
  });
  Cl = T((Ri) => {
    var YA = Cr(), ni = YA.rotr32;
    function XA(t, e, r, o) {
      if (t === 0)
        return q2(e, r, o);
      if (t === 1 || t === 3)
        return T2(e, r, o);
      if (t === 2)
        return I2(e, r, o);
    }
    Ri.ft_1 = XA;
    function q2(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri.ch32 = q2;
    function I2(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri.maj32 = I2;
    function T2(t, e, r) {
      return t ^ e ^ r;
    }
    Ri.p32 = T2;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri.g1_256 = tR;
  });
  N2 = T((Tk, L2) => {
    var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k2 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi() {
      if (!(this instanceof fi))
        return new fi;
      k2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi, k2);
    L2.exports = fi;
    fi.blockSize = 512;
    fi.outSize = 160;
    fi.hmacStrength = 80;
    fi.padLength = 64;
    fi.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = Ol(o[f - 3] ^ o[f - 8] ^ o[f - 14] ^ o[f - 16], 1);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4];
      for (f = 0;f < o.length; f++) {
        var S = ~~(f / 20), E = nR(Ol(p, 5), fR(S, m, y, M), x, o[f], aR[S]);
        x = M, M = y, y = Ol(m, 30), m = p, p = E;
      }
      this.h[0] = Fa(this.h[0], p), this.h[1] = Fa(this.h[1], m), this.h[2] = Fa(this.h[2], y), this.h[3] = Fa(this.h[3], M), this.h[4] = Fa(this.h[4], x);
    };
    fi.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T((kk, P2) => {
    var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P2.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = hR(bR(o[f - 2]), o[f - 7], vR(o[f - 15]), o[f - 16]);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4], S = this.h[5], E = this.h[6], B = this.h[7];
      for (sR(this.k.length === o.length), f = 0;f < o.length; f++) {
        var q = uR(B, pR(x), lR(x, S, E), this.k[f], o[f]), L = Or(cR(p), dR(p, m, y));
        B = E, E = S, S = x, x = Or(M, q), M = y, y = m, m = p, p = Or(q, L);
      }
      this.h[0] = Or(this.h[0], p), this.h[1] = Or(this.h[1], m), this.h[2] = Or(this.h[2], y), this.h[3] = Or(this.h[3], M), this.h[4] = Or(this.h[4], x), this.h[5] = Or(this.h[5], S), this.h[6] = Or(this.h[6], E), this.h[7] = Or(this.h[7], B);
    };
    ai.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T((Lk, O2) => {
    var Ul = Cr(), C2 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C2);
    O2.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T((Nk, W2) => {
    var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U2 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr() {
      if (!(this instanceof Fr))
        return new Fr;
      H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir.inherits(Fr, H2);
    W2.exports = Fr;
    Fr.blockSize = 1024;
    Fr.outSize = 512;
    Fr.hmacStrength = 192;
    Fr.padLength = 128;
    Fr.prototype._prepareBlock = function(e, r) {
      for (var o = this.W, f = 0;f < 32; f++)
        o[f] = e[r + f];
      for (;f < o.length; f += 2) {
        var p = DR(o[f - 4], o[f - 3]), m = PR(o[f - 4], o[f - 3]), y = o[f - 14], M = o[f - 13], x = LR(o[f - 30], o[f - 29]), S = NR(o[f - 30], o[f - 29]), E = o[f - 32], B = o[f - 31];
        o[f] = wR(p, m, y, M, x, S, E, B), o[f + 1] = MR(p, m, y, M, x, S, E, B);
      }
    };
    Fr.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o = this.W, f = this.h[0], p = this.h[1], m = this.h[2], y = this.h[3], M = this.h[4], x = this.h[5], S = this.h[6], E = this.h[7], B = this.h[8], q = this.h[9], L = this.h[10], ge = this.h[11], _e = this.h[12], N = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Re = we, Ee = ye, Ae = TR(B, q), P = kR(B, q), Se = ER(B, q, L, ge, _e, N), v = AR(B, q, L, ge, _e, N), i = this.k[xe], a = this.k[xe + 1], h = o[xe], s = o[xe + 1], u = _R(Re, Ee, Ae, P, Se, v, i, a, h, s), c = xR(Re, Ee, Ae, P, Se, v, i, a, h, s);
        Re = qR(f, p), Ee = IR(f, p), Ae = RR(f, p, m, y, M, x), P = BR(f, p, m, y, M, x);
        var b = zl(Re, Ee, Ae, P), l = Hl(Re, Ee, Ae, P);
        we = _e, ye = N, _e = L, N = ge, L = B, ge = q, B = zl(S, E, u, c), q = Hl(E, E, u, c), S = M, E = x, M = m, x = y, m = f, y = p, f = zl(u, c, b, l), p = Hl(u, c, b, l);
      }
      Ji(this.h, 0, f, p), Ji(this.h, 2, m, y), Ji(this.h, 4, M, x), Ji(this.h, 6, S, E), Ji(this.h, 8, B, q), Ji(this.h, 10, L, ge), Ji(this.h, 12, _e, N), Ji(this.h, 14, we, ye);
    };
    Fr.prototype._digest = function(e) {
      return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function ER(t, e, r, o, f) {
      var p = t & r ^ ~t & f;
      return p < 0 && (p += 4294967296), p;
    }
    function AR(t, e, r, o, f, p) {
      var m = e & o ^ ~e & p;
      return m < 0 && (m += 4294967296), m;
    }
    function RR(t, e, r, o, f) {
      var p = t & r ^ t & f ^ r & f;
      return p < 0 && (p += 4294967296), p;
    }
    function BR(t, e, r, o, f, p) {
      var m = e & o ^ e & p ^ o & p;
      return m < 0 && (m += 4294967296), m;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o = oi(e, t, 2), f = oi(e, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function IR(t, e) {
      var r = si(t, e, 28), o = si(e, t, 2), f = si(e, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o = oi(t, e, 18), f = oi(e, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function kR(t, e) {
      var r = si(t, e, 14), o = si(t, e, 18), f = si(e, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o = oi(t, e, 8), f = U2(t, e, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function NR(t, e) {
      var r = si(t, e, 1), o = si(t, e, 8), f = z2(t, e, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o = oi(e, t, 29), f = U2(t, e, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function PR(t, e) {
      var r = si(t, e, 19), o = si(e, t, 29), f = z2(t, e, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
  });
  Z2 = T((Dk, j2) => {
    var Kl = Cr(), K2 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K2);
    j2.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V2 = T((Df) => {
    Df.sha1 = N2();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q2 = T((J2) => {
    var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X2 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On.inherits(hi, X2);
    J2.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o = this.h[0], f = this.h[1], p = this.h[2], m = this.h[3], y = this.h[4], M = o, x = f, S = p, E = m, B = y, q = 0;q < 80; q++) {
        var L = $2(Qs(G2(o, Y2(q, f, p, m), e[UR[q] + r], OR(q)), HR[q]), y);
        o = y, y = m, m = Qs(p, 10), p = f, f = L, L = $2(Qs(G2(M, Y2(79 - q, x, S, E), e[zR[q] + r], FR(q)), WR[q]), B), M = B, B = E, E = Qs(S, 10), S = x, x = L;
      }
      L = Ua(this.h[1], p, E), this.h[1] = Ua(this.h[2], m, B), this.h[2] = Ua(this.h[3], y, M), this.h[3] = Ua(this.h[4], o, x), this.h[4] = Ua(this.h[0], f, S), this.h[0] = L;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
    };
    function Y2(t, e, r, o) {
      return t <= 15 ? e ^ r ^ o : t <= 31 ? e & r | ~e & o : t <= 47 ? (e | ~r) ^ o : t <= 63 ? e & o | r & ~o : e ^ (r | ~o);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T((Ok, ey) => {
    var KR = Cr(), jR = ar();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T((ry) => {
    var Kt = ry;
    Kt.utils = Cr();
    Kt.common = Tf();
    Kt.sha = V2();
    Kt.ripemd = Q2();
    Kt.hmac = ty();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  ny = T((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T((oy) => {
    var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T((Hk, hy) => {
    var VR = e0(), Fn = Nl(), sy = ar();
    function tn(t) {
      if (!(this instanceof tn))
        return new tn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o = Fn.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o);
    }
    hy.exports = tn;
    tn.prototype._init = function(e, r, o) {
      var f = e.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p = 0;p < this.V.length; p++)
        this.K[p] = 0, this.V[p] = 1;
      this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn.prototype.reseed = function(e, r, o, f) {
      typeof r != "string" && (f = o, o = r, r = null), e = Fn.toArray(e, r), o = Fn.toArray(o, f), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o || [])), this._reseed = 1;
    };
    tn.prototype.generate = function(e, r, o, f) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f = o, o = r, r = null), o && (o = Fn.toArray(o, f || "hex"), this._update(o));
      for (var p = [];p.length < e; )
        this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
      var m = p.slice(0, e);
      return this._update(o), this._reseed++, Fn.encode(m, r);
    };
  });
  dy = T((Wk, ly) => {
    var $R = ri(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o) {
      return this.ec.sign(e, this, r, o);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T((Kk, py) => {
    var r0 = ri(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f = 0, p = 0, m = e.place;p < o; p++, m++)
        f <<= 8, f |= t[m], f >>>= 0;
      return f <= 127 ? false : (e.place = m, f);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o = new XR;
      if (e[o.place++] !== 48)
        return false;
      var f = Gl(e, o);
      if (f === false || f + o.place !== e.length || e[o.place++] !== 2)
        return false;
      var p = Gl(e, o);
      if (p === false)
        return false;
      var m = e.slice(o.place, p + o.place);
      if (o.place += p, e[o.place++] !== 2)
        return false;
      var y = Gl(e, o);
      if (y === false || e.length !== y + o.place)
        return false;
      var M = e.slice(o.place, y + o.place);
      if (m[0] === 0)
        if (m[1] & 128)
          m = m.slice(1);
        else
          return false;
      if (M[0] === 0)
        if (M[1] & 128)
          M = M.slice(1);
        else
          return false;
      return this.r = new r0(m), this.s = new r0(M), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = cy(r), o = cy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f = [2];
      Yl(f, r.length), f = f.concat(r), f.push(2), Yl(f, o.length);
      var p = f.concat(o), m = [48];
      return Yl(m, p.length), m = m.concat(p), Xl.encode(m, e);
    };
  });
  yy = T((jk, gy) => {
    var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f = this.n.sub(new Un(2));; ) {
        var p = new Un(r.generate(o));
        if (!(p.cmp(f) > 0))
          return p.iaddn(1), this.keyFromPrivate(p);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o = e.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o, f) {
      typeof o == "object" && (f = o, o = null), f || (f = {}), r = this.keyFromPrivate(r, o), e = this._truncateToN(new Un(e, 16));
      for (var p = this.n.byteLength(), m = r.getPrivate().toArray("be", p), y = e.toArray("be", p), M = new by({ hash: this.hash, entropy: m, nonce: y, pers: f.pers, persEnc: f.persEnc || "utf8" }), x = this.n.sub(new Un(1)), S = 0;; S++) {
        var E = f.k ? f.k(S) : new Un(M.generate(this.n.byteLength()));
        if (E = this._truncateToN(E, true), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) {
          var B = this.g.mul(E);
          if (!B.isInfinity()) {
            var q = B.getX(), L = q.umod(this.n);
            if (L.cmpn(0) !== 0) {
              var ge = E.invm(this.n).mul(L.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e = (B.getY().isOdd() ? 1 : 0) | (q.cmp(L) !== 0 ? 2 : 0);
                return f.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L, s: ge, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o, f) {
      e = this._truncateToN(new Un(e, 16)), o = this.keyFromPublic(o, f), r = new n0(r, "hex");
      var { r: p, s: m } = r;
      if (p.cmpn(1) < 0 || p.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
        return false;
      var y = m.invm(this.n), M = y.mul(e).umod(this.n), x = y.mul(p).umod(this.n), S;
      return this.curve._maxwellTrick ? (S = this.g.jmulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.eqXToP(p)) : (S = this.g.mulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.getX().umod(this.n).cmp(p) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o);
      var f = this.n, p = new Un(t), m = e.r, y = e.s, M = r & 1, x = r >> 1;
      if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
        throw new Error("Unable to find sencond key candinate");
      x ? m = this.curve.pointFromX(m.add(this.curve.n), M) : m = this.curve.pointFromX(m, M);
      var S = e.r.invm(f), E = f.sub(p).mul(S).umod(f), B = y.mul(S).umod(f);
      return this.g.mulAdd(E, m, B);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o) {
      if (e = new n0(e, o), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f = 0;f < 4; f++) {
        var p;
        try {
          p = this.recoverPubKey(t, e, f);
        } catch {
          continue;
        }
        if (p.eq(r))
          return f;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
    function Ft(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft.fromPublic = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { pub: r });
    };
    Ft.fromSecret = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Cf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf(Ft, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o = e.encodingLength - 1, f = r.slice(0, e.encodingLength);
      return f[0] &= 248, f[o] &= 127, f[o] |= 64, f;
    });
    Cf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft;
  });
  Ey = T((Vk, Sy) => {
    var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn;
  });
  Iy = T(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o = this.keyFromSecret(r), f = this.hashInt(o.messagePrefix(), e), p = this.g.mul(f), m = this.encodePoint(p), y = this.hashInt(m, o.pubBytes(), e).mul(o.priv()), M = f.add(y).umod(this.curve.n);
      return this.makeSignature({ R: p, S: M, Rencoded: m });
    };
    nr.prototype.verify = function(e, r, o) {
      e = Ry(e), r = this.makeSignature(r);
      var f = this.keyFromPublic(o), p = this.hashInt(r.Rencoded(), f.pubBytes(), e), m = this.g.mul(r.S()), y = r.R().add(f.pub().mul(p));
      return y.eq(m);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o = e.slice(0, r).concat(e[r] & -129), f = (e[r] & 128) !== 0, p = Of.intFromLE(o);
      return this.curve.pointFromY(p, f);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T((ky, ed) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T((Yk, Ly) => {
    var s0 = Ut(), Ff = s0.Buffer, Er = {}, Ar;
    for (Ar in s0)
      !s0.hasOwnProperty(Ar) || Ar === "SlowBuffer" || Ar === "Buffer" || (Er[Ar] = s0[Ar]);
    var Uf = Er.Buffer = {};
    for (Ar in Ff)
      !Ff.hasOwnProperty(Ar) || Ar === "allocUnsafe" || Ar === "allocUnsafeSlow" || (Uf[Ar] = Ff[Ar]);
    Er.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Ff(t);
      return !e || e.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e, r) : o.fill(e), o;
    });
    if (!Er.kStringMaxLength)
      try {
        Er.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er.constants || (Er.constants = { MAX_LENGTH: Er.kMaxLength }, Er.kStringMaxLength && (Er.constants.MAX_STRING_LENGTH = Er.kStringMaxLength));
    Ly.exports = Er;
  });
  u0 = T((Ny) => {
    var aB = Ie();
    function Rr(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr;
    Rr.prototype.isError = function(e) {
      return e instanceof zf;
    };
    Rr.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr.prototype.leaveKey = function(e, r, o) {
      let f = this._reporterState;
      this.exitKey(e), f.obj !== null && (f.obj[r] = o);
    };
    Rr.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr.prototype.leaveObject = function(e) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e, o;
    };
    Rr.prototype.error = function(e) {
      let r, o = this._reporterState, f = e instanceof zf;
      if (f ? r = e : r = new zf(o.path.map(function(p) {
        return "[" + JSON.stringify(p) + "]";
      }).join(""), e.message || e, e.stack), !o.options.partial)
        throw r;
      return f || o.errors.push(r), r;
    };
    Rr.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br, l0);
    rd.DecoderBuffer = Br;
    Br.isDecoderBuffer = function(e) {
      return e instanceof Br ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br.prototype.restore = function(e) {
      let r = new Br(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new Br(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
    };
    Br.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e, r), r += o.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f) {
        r[f] = e[f];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f = new this.constructor(this);
          return e.children.push(f), f[r].apply(f, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt(r.parent === null), e.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o = e.filter(function(f) {
        return f instanceof this.constructor;
      }, this);
      e = e.filter(function(f) {
        return !(f instanceof this.constructor);
      }, this), o.length !== 0 && (Qt(r.children === null), r.children = o, o.forEach(function(f) {
        f._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt(r.args === null), r.args = e, r.reverseArgs = e.map(function(f) {
        if (typeof f != "object" || f.constructor !== Object)
          return f;
        let p = {};
        return Object.keys(f).forEach(function(m) {
          m == (m | 0) && (m |= 0);
          let y = f[m];
          p[y] = m;
        }), p;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return Qt(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt(e);
      let r = this._baseState;
      return Qt(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o) {
        return e[o];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e.wrapResult(o.children[0]._decode(e, r));
      let f = o.default, p = true, m = null;
      if (o.key !== null && (m = e.enterKey(o.key)), o.optional) {
        let M = null;
        if (o.explicit !== null ? M = o.explicit : o.implicit !== null ? M = o.implicit : o.tag !== null && (M = o.tag), M === null && !o.any) {
          let x = e.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e, r) : this._decodeChoice(e, r), p = true;
          } catch {
            p = false;
          }
          e.restore(x);
        } else if (p = this._peekTag(e, M, o.any), e.isError(p))
          return p;
      }
      let y;
      if (o.obj && p && (y = e.enterObject()), p) {
        if (o.explicit !== null) {
          let x = this._decodeTag(e, o.explicit);
          if (e.isError(x))
            return x;
          e = x;
        }
        let M = e.offset;
        if (o.use === null && o.choice === null) {
          let x;
          o.any && (x = e.save());
          let S = this._decodeTag(e, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e.isError(S))
            return S;
          o.any ? f = e.raw(x) : e = S;
        }
        if (r && r.track && o.tag !== null && r.track(e.path(), M, e.length, "tagged"), r && r.track && o.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? f = this._decodeGeneric(o.tag, e, r) : f = this._decodeChoice(e, r)), e.isError(f))
          return f;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S) {
          S._decode(e, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x = new uB(f);
          f = this._getUse(o.contains, e._reporterState.obj)._decode(x, r);
        }
      }
      return o.obj && p && (f = e.leaveObject(y)), o.key !== null && (f !== null || p === true) ? e.leaveKey(m, o.key, f) : m !== null && e.exitKey(m), f;
    };
    Ue.prototype._decodeGeneric = function(e, r, o) {
      let f = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f.args[0], o) : /str$/.test(e) ? this._decodeStr(r, e, o) : e === "objid" && f.args ? this._decodeObjid(r, f.args[0], f.args[1], o) : e === "objid" ? this._decodeObjid(r, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o) : e === "null_" ? this._decodeNull(r, o) : e === "bool" ? this._decodeBool(r, o) : e === "objDesc" ? this._decodeStr(r, e, o) : e === "int" || e === "enum" ? this._decodeInt(r, f.args && f.args[0], o) : f.use !== null ? this._getUse(f.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e, r), Qt(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o = this._baseState, f = null, p = false;
      return Object.keys(o.choice).some(function(m) {
        let y = e.save(), M = o.choice[m];
        try {
          let x = M._decode(e, r);
          if (e.isError(x))
            return false;
          f = { type: m, value: x }, p = true;
        } catch {
          return e.restore(y), false;
        }
        return true;
      }, this), p ? f : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o) {
      let f = this._baseState;
      if (f.default !== null && f.default === e)
        return;
      let p = this._encodeValue(e, r, o);
      if (p !== undefined && !this._skipDefault(p, r, o))
        return p;
    };
    Ue.prototype._encodeValue = function(e, r, o) {
      let f = this._baseState;
      if (f.parent === null)
        return f.children[0]._encode(e, r || new sB);
      let p = null;
      if (this.reporter = r, f.optional && e === undefined)
        if (f.default !== null)
          e = f.default;
        else
          return;
      let m = null, y = false;
      if (f.any)
        p = this._createEncoderBuffer(e);
      else if (f.choice)
        p = this._encodeChoice(e, r);
      else if (f.contains)
        m = this._getUse(f.contains, o)._encode(e, r), y = true;
      else if (f.children)
        m = f.children.map(function(M) {
          if (M._baseState.tag === "null_")
            return M._encode(null, r, e);
          if (M._baseState.key === null)
            return r.error("Child should have a key");
          let x = r.enterKey(M._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S = M._encode(e[M._baseState.key], r, e);
          return r.leaveKey(x), S;
        }, this).filter(function(M) {
          return M;
        }), m = this._createEncoderBuffer(m);
      else if (f.tag === "seqof" || f.tag === "setof") {
        if (!(f.args && f.args.length === 1))
          return r.error("Too many args for : " + f.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M = this.clone();
        M._baseState.implicit = null, m = this._createEncoderBuffer(e.map(function(x) {
          let S = this._baseState;
          return this._getUse(S.args[0], e)._encode(x, r);
        }, M));
      } else
        f.use !== null ? p = this._getUse(f.use, o)._encode(e, r) : (m = this._encodePrimitive(f.tag, e), y = true);
      if (!f.any && f.choice === null) {
        let M = f.implicit !== null ? f.implicit : f.tag, x = f.implicit === null ? "universal" : "context";
        M === null ? f.use === null && r.error("Tag could be omitted only for .use()") : f.use === null && (p = this._encodeComposite(M, y, x, m));
      }
      return f.explicit !== null && (p = this._encodeComposite(f.explicit, false, "context", p)), p;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o = this._baseState, f = o.choice[e.type];
      return f || Qt(false, e.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e[o] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T((tL, Uy) => {
    var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur, Oy);
    Ur.prototype._encodeComposite = function(e, r, o, f) {
      let p = vB(e, r, o, this.reporter);
      if (f.length < 128) {
        let M = Ii.alloc(2);
        return M[0] = p, M[1] = f.length, this._createEncoderBuffer([M, f]);
      }
      let m = 1;
      for (let M = f.length;M >= 256; M >>= 8)
        m++;
      let y = Ii.alloc(1 + 1 + m);
      y[0] = p, y[1] = 128 | m;
      for (let M = 1 + m, x = f.length;x > 0; M--, x >>= 8)
        y[M] = x & 255;
      return this._createEncoderBuffer([y, f]);
    };
    Ur.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o = Ii.alloc(e.length * 2);
        for (let f = 0;f < e.length; f++)
          o.writeUInt16BE(e.charCodeAt(f), f * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur.prototype._encodeObjid = function(e, r, o) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f = 0;
      for (let y = 0;y < e.length; y++) {
        let M = e[y];
        for (f++;M >= 128; M >>= 7)
          f++;
      }
      let p = Ii.alloc(f), m = p.length - 1;
      for (let y = e.length - 1;y >= 0; y--) {
        let M = e[y];
        for (p[m--] = M & 127;(M >>= 7) > 0; )
          p[m--] = 128 | M & 127;
      }
      return this._createEncoderBuffer(p);
    };
    function qr(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur.prototype._encodeTime = function(e, r) {
      let o, f = new Date(e);
      return r === "gentime" ? o = [qr(f.getUTCFullYear()), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [qr(f.getUTCFullYear() % 100), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii.isBuffer(e)) {
        let p = e.toArray();
        !e.sign && p[0] & 128 && p.unshift(0), e = Ii.from(p);
      }
      if (Ii.isBuffer(e)) {
        let p = e.length;
        e.length === 0 && p++;
        let m = Ii.alloc(p);
        return e.copy(m), e.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o = 1;
      for (let p = e;p >= 256; p >>= 8)
        o++;
      let f = new Array(o);
      for (let p = f.length - 1;p >= 0; p--)
        f[p] = e & 255, e >>= 8;
      return f[0] & 128 && f.unshift(0), this._createEncoderBuffer(Ii.from(f));
    };
    Ur.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur.prototype._skipDefault = function(e, r, o) {
      let f = this._baseState, p;
      if (f.default === null)
        return false;
      let m = e.join();
      if (f.defaultBuffer === undefined && (f.defaultBuffer = this._encodeValue(f.default, r, o).join()), m.length !== f.defaultBuffer.length)
        return false;
      for (p = 0;p < m.length; p++)
        if (m[p] !== f.defaultBuffer[p])
          return false;
      return true;
    };
    function vB(t, e, r, o) {
      let f;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f = t;
      else
        return o.error("Unknown tag: " + t);
      return f >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e || (f |= 32), f |= id.tagClassByName[r || "universal"] << 6, f);
    }
  });
  Hy = T((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f = fd.prototype.encode.call(this, e).toString("base64"), p = ["-----BEGIN " + r.label + "-----"];
      for (let m = 0;m < f.length; m += 64)
        p.push(f.slice(m, m + 64));
      return p.push("-----END " + r.label + "-----"), p.join(`
`);
    };
  });
  od = T((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e, r, o) {
      if (e.isEmpty())
        return false;
      let f = e.save(), p = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p) ? p : (e.restore(f), p.tag === r || p.tagStr === r || p.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e, r, o) {
      let f = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f))
        return f;
      let p = Gy(e, f.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p))
        return p;
      if (!o && f.tag !== r && f.tagStr !== r && f.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f.primitive || p !== null)
        return e.skip(p, 'Failed to match body of: "' + r + '"');
      let m = e.save(), y = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y) ? y : (p = e.offset - m.offset, e.restore(m), e.skip(p, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o = sd(e, r);
        if (e.isError(o))
          return o;
        let f = Gy(e, o.primitive, r);
        if (e.isError(f))
          return f;
        let p;
        if (o.primitive || f !== null ? p = e.skip(f) : p = this._skipUntilEnd(e, r), e.isError(p))
          return p;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o, f) {
      let p = [];
      for (;!e.isEmpty(); ) {
        let m = this._peekTag(e, "end");
        if (e.isError(m))
          return m;
        let y = o.decode(e, "der", f);
        if (e.isError(y) && m)
          break;
        p.push(y);
      }
      return p;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o = e.readUInt8();
        return e.isError(o) ? o : { unused: o, data: e.raw() };
      } else if (r === "bmpstr") {
        let o = e.raw();
        if (o.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f = "";
        for (let p = 0;p < o.length / 2; p++)
          f += String.fromCharCode(o.readUInt16BE(p * 2));
        return f;
      } else if (r === "numstr") {
        let o = e.raw().toString("ascii");
        return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o = e.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o) {
      let f, p = [], m = 0, y = 0;
      for (;!e.isEmpty(); )
        y = e.readUInt8(), m <<= 7, m |= y & 127, (y & 128) === 0 && (p.push(m), m = 0);
      y & 128 && p.push(m);
      let M = p[0] / 40 | 0, x = p[0] % 40;
      if (o ? f = p : f = [M, x].concat(p.slice(1)), r) {
        let S = r[f.join(" ")];
        S === undefined && (S = r[f.join(".")]), S !== undefined && (f = S);
      }
      return f;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o = e.raw().toString(), f, p, m, y, M, x;
      if (r === "gentime")
        f = o.slice(0, 4) | 0, p = o.slice(4, 6) | 0, m = o.slice(6, 8) | 0, y = o.slice(8, 10) | 0, M = o.slice(10, 12) | 0, x = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f = o.slice(0, 2) | 0, p = o.slice(2, 4) | 0, m = o.slice(4, 6) | 0, y = o.slice(6, 8) | 0, M = o.slice(8, 10) | 0, x = o.slice(10, 12) | 0, f < 70 ? f = 2000 + f : f = 1900 + f;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f, p - 1, m, y, M, x, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o = e.raw(), f = new gB(o);
      return r && (f = r[f.toString(10)] || f), f;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o = Zy.tagClass[r >> 6], f = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m = r;
        for (r = 0;(m & 128) === 128; ) {
          if (m = t.readUInt8(e), t.isError(m))
            return m;
          r <<= 7, r |= m & 127;
        }
      } else
        r &= 31;
      let p = Zy.tag[r];
      return { cls: o, primitive: f, tag: r, tagStr: p };
    }
    function Gy(t, e, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f = o & 127;
      if (f > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p = 0;p < f; p++) {
        o <<= 8;
        let m = t.readUInt8(r);
        if (t.isError(m))
          return m;
        o |= m;
      }
      return o;
    }
  });
  Jy = T((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o = e.toString().split(/[\r\n]+/g), f = r.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/, m = -1, y = -1;
      for (let S = 0;S < o.length; S++) {
        let E = o[S].match(p);
        if (E !== null && E[2] === f)
          if (m === -1) {
            if (E[1] !== "BEGIN")
              break;
            m = S;
          } else {
            if (E[1] !== "END")
              break;
            y = S;
            break;
          }
      }
      if (m === -1 || y === -1)
        throw new Error("PEM section not found for: " + f);
      let M = o.slice(m + 1, y).join("");
      M.replace(/[^a-z0-9+/=]+/gi, "");
      let x = wB.from(M, "base64");
      return ud.prototype.decode.call(this, x, r);
    };
  });
  dd = T((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o(f) {
        this._initNamed(f, r);
      }
      return xB(o, e), o.prototype._initNamed = function(p, m) {
        e.call(this, p, m);
      }, new o(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o) {
      return this._getDecoder(r).decode(e, o);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o) {
      return this._getEncoder(r).encode(e, o);
    };
  });
  n3 = T((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f = e[o];
        r[f] = o;
      }), r;
    };
    f3.der = c0();
  });
  cd = T((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T((pL, b3) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b3.exports = function(t, e) {
      var r = t.toString(), o = r.match(HB), f;
      if (o) {
        var m = "aes" + o[1], y = v0.from(o[2], "hex"), M = v0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x = jB(e, y.slice(0, 8), parseInt(o[1], 10)).key, S = [], E = ZB.createDecipheriv(m, x, y);
        S.push(E.update(M)), S.push(E.final()), f = v0.concat(S);
      } else {
        var p = r.match(KB);
        f = v0.from(p[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B = r.match(WB)[1];
      return { tag: B, data: f };
    };
  });
  Ha = T((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o = r.tag, f = r.data, p, m;
      switch (o) {
        case "CERTIFICATE":
          m = fr.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m || (m = fr.PublicKey.decode(f, "der")), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m.subjectPrivateKey = m.subjectPublicKey, { type: "ec", data: m };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.pub_key = fr.DSAparam.decode(m.subjectPublicKey.data, "der"), { type: "dsa", data: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "ENCRYPTED PRIVATE KEY":
          f = fr.EncryptedPrivateKey.decode(f, "der"), f = XB(f, e);
        case "PRIVATE KEY":
          switch (m = fr.PrivateKey.decode(f, "der"), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.priv_key = fr.DSAparam.decode(m.subjectPrivateKey, "der"), { type: "dsa", params: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f, "der") };
        case "EC PRIVATE KEY":
          return f = fr.ECPrivateKey.decode(f, "der"), { curve: f.parameters.value, privateKey: f.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f = VB[t.algorithm.decrypt.cipher.algo.join(".")], p = t.algorithm.decrypt.cipher.iv, m = t.subjectPrivateKey, y = parseInt(f.split("-")[1], 10) / 8, M = YB.pbkdf2Sync(e, r, o, y, "sha1"), x = GB.createDecipheriv(f, M, p), S = [];
      return S.push(x.update(m)), S.push(x.final()), vd.concat(S);
    }
  });
  bd = T((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
    function iq(t, e, r, o, f) {
      var p = tq(e);
      if (p.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f, t]);
      for (var m = p.modulus.byteLength(), y = [0, 1];t.length + y.length + 1 < m; )
        y.push(255);
      y.push(0);
      for (var M = -1;++M < t.length; )
        y.push(t[M]);
      var x = QB(y, p);
      return x;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o = new eq(r), f = o.keyFromPrivate(e.privateKey), p = f.sign(t);
      return Yt.from(p.toDER());
    }
    function fq(t, e, r) {
      for (var o = e.params.priv_key, f = e.params.p, p = e.params.q, m = e.params.g, y = new b0(0), M, x = md(t, p).mod(p), S = false, E = w3(o, p, t, r);S === false; )
        M = M3(p, E, r), y = sq(m, M, f, p), S = M.invm(p).imul(x.add(o.mul(y))).mod(p), S.cmpn(0) === 0 && (S = false, y = new b0(0));
      return aq(y, S);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e.length], e), Yt.from(o);
    }
    function w3(t, e, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f, t]);
      }
      var p = r.length, m = oq(r, e), y = Yt.alloc(p);
      y.fill(1);
      var M = Yt.alloc(p);
      return M = Kn(o, M).update(y).update(Yt.from([0])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), M = Kn(o, M).update(y).update(Yt.from([1])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), { k: M, v: y };
    }
    function md(t, e) {
      var r = new b0(t), o = (t.length << 3) - e.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function M3(t, e, r) {
      var o, f;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o = Yt.concat([o, e.v]);
        f = md(o, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f.cmp(t) !== -1);
      return f;
    }
    function sq(t, e, r, o) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A3 = T((gL, E3) => {
    var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o, f) {
      var p = S3(r);
      if (p.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f, e]);
      for (var m = p.modulus.byteLength(), y = [1], M = 0;e.length + y.length + 2 < m; )
        y.push(255), M++;
      y.push(0);
      for (var x = -1;++x < e.length; )
        y.push(e[x]);
      y = gd.from(y);
      var S = Wa.mont(p.modulus);
      t = new Wa(t).toRed(S), t = t.redPow(new Wa(p.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E = M < 8 ? 1 : 0;
      for (m = Math.min(t.length, y.length), t.length !== y.length && (E = 1), x = -1;++x < m; )
        E |= t[x] ^ y[x];
      return E === 0;
    }
    function dq(t, e, r) {
      var o = uq[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f = new hq(o), p = r.data.subjectPrivateKey.data;
      return f.verify(e, t, p);
    }
    function cq(t, e, r) {
      var o = r.data.p, f = r.data.q, p = r.data.g, m = r.data.pub_key, y = S3.signature.decode(t, "der"), M = y.s, x = y.r;
      x3(M, f), x3(x, f);
      var S = Wa.mont(o), E = M.invm(f), B = p.toRed(S).redPow(new Wa(e).mul(E).mod(f)).fromRed().mul(m.toRed(S).redPow(x.mul(E).mod(f)).fromRed()).mod(o).mod(f);
      return B.cmp(x) === 0;
    }
    function x3(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E3.exports = lq;
  });
  k3 = T((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
    Object.keys(jn).forEach(function(t) {
      jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o = this._hash.digest(), f = pq(o, e, this._hashType, this._signType, this._tag);
      return r ? f.toString(r) : f;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(ja, y0.Writable);
    ja.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o) {
      typeof r == "string" && (r = g0.from(r, o)), this.end();
      var f = this._hash.digest();
      return vq(r, f, e, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N3 = T((L3, yd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P3 = T((wL, D3) => {
    var bq = o0(), mq = N3();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Zn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o = this.curve.keyFromPublic(t).getPublic(), f = o.mul(this.keys.getPrivate()).getX();
      return wd(f, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f = new Buffer(r - o.length);
        f.fill(0), o = Buffer.concat([f, o]);
      }
      return e ? o.toString(e) : o;
    }
  });
  _d = T((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e) {
      for (var r = Md.alloc(0), o = 0, f;r.length < e; )
        f = yq(o++), r = Md.concat([r, gq("sha1").update(t).update(f).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd = T((_L, O3) => {
    O3.exports = function(e, r) {
      for (var o = e.length, f = -1;++f < o; )
        e[f] ^= r[f];
      return e;
    };
  });
  w0 = T((F3, Sd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $ = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re) | 0;
        var qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J), l = l + Math.imul(F, Q) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H, Q) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J), l = l + Math.imul(V, Q) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y, Q) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($, ce) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v, i) {
        this.x = v, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j3 = T((SL, K3) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr = Te().Buffer;
    K3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p = _q(e), m;
      if (f === 4)
        m = Aq(p, r);
      else if (f === 1)
        m = Rq(p, r, o);
      else if (f === 3) {
        if (m = new Rd(r), m.cmp(p.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? Eq(m, p) : Sq(m, p);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o = e.length, f = xq("sha1").update(Kr.alloc(0)).digest(), p = f.length, m = 2 * p;
      if (o > r - m - 2)
        throw new Error("message too long");
      var y = Kr.alloc(r - o - m - 2), M = r - p - 1, x = Ad(p), S = W3(Kr.concat([f, y, Kr.alloc(1, 1), e], M), H3(x, M)), E = W3(x, H3(S, p));
      return new Rd(Kr.concat([Kr.alloc(1), E, S], r));
    }
    function Rq(t, e, r) {
      var o = e.length, f = t.modulus.byteLength();
      if (o > f - 11)
        throw new Error("message too long");
      var p;
      return r ? p = Kr.alloc(f - o - 3, 255) : p = Bq(f - o - 3), new Rd(Kr.concat([Kr.from([0, r ? 1 : 2]), p, Kr.alloc(1), e], f));
    }
    function Bq(t) {
      for (var e = Kr.allocUnsafe(t), r = 0, o = Ad(t * 2), f = 0, p;r < t; )
        f === o.length && (o = Ad(t * 2), f = 0), p = o[f++], p && (e[r++] = p);
      return e;
    }
  });
  Y3 = T((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p = qq(e), m = p.modulus.byteLength();
      if (r.length > m || new $3(r).cmp(p.modulus) >= 0)
        throw new Error("decryption error");
      var y;
      o ? y = kq(new $3(r), p) : y = Iq(r, p);
      var M = Za.alloc(m - y.length);
      if (y = Za.concat([M, y], m), f === 4)
        return Lq(p, y);
      if (f === 1)
        return Nq(p, y, o);
      if (f === 3)
        return y;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o = Tq("sha1").update(Za.alloc(0)).digest(), f = o.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p = e.slice(1, f + 1), m = e.slice(f + 1), y = V3(p, Z3(m, f)), M = V3(m, Z3(y, r - f - 1));
      if (Dq(o, M.slice(0, f)))
        throw new Error("decryption error");
      for (var x = f;M[x] === 0; )
        x++;
      if (M[x++] !== 1)
        throw new Error("decryption error");
      return M.slice(x);
    }
    function Nq(t, e, r) {
      for (var o = e.slice(0, 2), f = 2, p = 0;e[f++] !== 0; )
        if (f >= e.length) {
          p++;
          break;
        }
      var m = e.slice(2, f - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p++, m.length < 8 && p++, p)
        throw new Error("decryption error");
      return e.slice(f);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o = t.length;
      t.length !== e.length && (r++, o = Math.min(t.length, e.length));
      for (var f = -1;++f < o; )
        r += t[f] ^ e[f];
      return r;
    }
  });
  X3 = T((Vn) => {
    Vn.publicEncrypt = j3();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o);
    }
    function aw(t, e, r, o) {
      if (true) {
        var f = t.buffer, p = new Uint8Array(f, e, r);
        if (Bd.getRandomValues(p), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        Q3(r, function(y, M) {
          if (y)
            return o(y);
          M.copy(t, e), o(null, t);
        });
        return;
      }
      var m = Q3(r);
      return m.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
    ke.createHash = ke.Hash = bf();
    ke.createHmac = ke.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke.pbkdf2 = sw.pbkdf2;
    ke.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke.Cipher = ui.Cipher;
    ke.createCipher = ui.createCipher;
    ke.Cipheriv = ui.Cipheriv;
    ke.createCipheriv = ui.createCipheriv;
    ke.Decipher = ui.Decipher;
    ke.createDecipher = ui.createDecipher;
    ke.Decipheriv = ui.Decipheriv;
    ke.createDecipheriv = ui.createDecipheriv;
    ke.getCiphers = ui.getCiphers;
    ke.listCiphers = ui.listCiphers;
    var $a = hg();
    ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke.getDiffieHellman = $a.getDiffieHellman;
    ke.createDiffieHellman = $a.createDiffieHellman;
    ke.DiffieHellman = $a.DiffieHellman;
    var M0 = k3();
    ke.createSign = M0.createSign;
    ke.Sign = M0.Sign;
    ke.createVerify = M0.createVerify;
    ke.Verify = M0.Verify;
    ke.createECDH = P3();
    var _0 = X3();
    ke.publicEncrypt = _0.publicEncrypt;
    ke.privateEncrypt = _0.privateEncrypt;
    ke.publicDecrypt = _0.publicDecrypt;
    ke.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke.randomFill = hw.randomFill;
    ke.randomFillSync = hw.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot(Xt, rn(qd()));
  zq = rn(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o } = e;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e, r, o) => {
    let f = crypto.scryptSync(t, e, r, o);
    return Ga !== "buffer" ? new Buffer(f).toString(Ga) : new Buffer(f);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e, r, o, f) {
    if (typeof o == "function" && (f = o, o = undefined), typeof f != "function") {
      var p = new TypeError("callback must be a function");
      throw p.code = "ERR_INVALID_CALLBACK", p;
    }
    try {
      let m = crypto.scryptSync(t, e, r, o);
      process.nextTick(f, null, Ga !== "buffer" ? new Buffer(m).toString(Ga) : new Buffer(m));
    } catch (m) {
      throw m;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// ../../node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS((exports, module) => {
  (function(global2, pool, math) {
    var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy(state, arc4);
          }
          prng2.state = function() {
            return copy(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0;i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t3, r = 0, i3 = me.i, j2 = me.j, s3 = me.S;
        while (count--) {
          t3 = s3[i3 = mask & i3 + 1];
          r = r * width + s3[mask & (s3[i3] = s3[j2 = mask & j2 + t3]) + (s3[j2] = t3)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten(obj2, depth) {
      var result = [], typ = typeof obj2, prop;
      if (depth && typ == "object") {
        for (prop in obj2) {
          try {
            result.push(flatten(obj2[prop], depth - 1));
          } catch (e) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj2 : obj2 + "\x00";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+new Date, global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math.random(), pool);
    if (typeof module == "object" && module.exports) {
      module.exports = seedrandom;
      try {
        nodecrypto = (init_crypto(), __toCommonJS(exports_crypto));
      } catch (ex) {
      }
    } else if (typeof define == "function" && define.amd) {
      define(function() {
        return seedrandom;
      });
    } else {
      math["seed" + rngname] = seedrandom;
    }
  })(typeof self !== "undefined" ? self : exports, [], Math);
});

// ../../node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS((exports, module) => {
  var alea = require_alea();
  var xor128 = require_xor128();
  var xorwow = require_xorwow();
  var xorshift7 = require_xorshift7();
  var xor4096 = require_xor4096();
  var tychei = require_tychei();
  var sr = require_seedrandom();
  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;
  module.exports = sr;
});

// ../../node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS((exports, module) => {
  (function(factory) {
    if (typeof exports === "object") {
      module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
      define(factory);
    } else {
      var glob;
      try {
        glob = window;
      } catch (e) {
        glob = self;
      }
      glob.SparkMD5 = factory();
    }
  })(function(undefined2) {
    var add32 = function(a, b) {
      return a + b & 4294967295;
    }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function cmn(q, a, b, x, s, t) {
      a = add32(add32(a, q), add32(x, t));
      return add32(a << s | a >>> 32 - s, b);
    }
    function md5cycle(x, k) {
      var a = x[0], b = x[1], c = x[2], d = x[3];
      a += (b & c | ~b & d) + k[0] - 680876936 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[1] - 389564586 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[2] + 606105819 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[4] - 176418897 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[7] - 45705983 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[10] - 42063 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
      a = (a << 7 | a >>> 25) + b | 0;
      d += (a & b | ~a & c) + k[13] - 40341101 | 0;
      d = (d << 12 | d >>> 20) + a | 0;
      c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
      b = (b << 22 | b >>> 10) + c | 0;
      a += (b & d | c & ~d) + k[1] - 165796510 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[11] + 643717713 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[0] - 373897302 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[5] - 701558691 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[10] + 38016083 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[15] - 660478335 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[4] - 405537848 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[9] + 568446438 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[3] - 187363961 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
      a = (a << 5 | a >>> 27) + b | 0;
      d += (a & c | b & ~c) + k[2] - 51403784 | 0;
      d = (d << 9 | d >>> 23) + a | 0;
      c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
      b = (b << 20 | b >>> 12) + c | 0;
      a += (b ^ c ^ d) + k[5] - 378558 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[14] - 35309556 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[7] - 155497632 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[13] + 681279174 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[0] - 358537222 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[3] - 722521979 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[6] + 76029189 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (b ^ c ^ d) + k[9] - 640364487 | 0;
      a = (a << 4 | a >>> 28) + b | 0;
      d += (a ^ b ^ c) + k[12] - 421815835 | 0;
      d = (d << 11 | d >>> 21) + a | 0;
      c += (d ^ a ^ b) + k[15] + 530742520 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b += (c ^ d ^ a) + k[2] - 995338651 | 0;
      b = (b << 23 | b >>> 9) + c | 0;
      a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
      a = (a << 6 | a >>> 26) + b | 0;
      d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
      d = (d << 10 | d >>> 22) + a | 0;
      c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
      b = (b << 21 | b >>> 11) + c | 0;
      x[0] = a + x[0] | 0;
      x[1] = b + x[1] | 0;
      x[2] = c + x[2] | 0;
      x[3] = d + x[3] | 0;
    }
    function md5blk(s) {
      var md5blks = [], i;
      for (i = 0;i < 64; i += 4) {
        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a) {
      var md5blks = [], i;
      for (i = 0;i < 64; i += 4) {
        md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
      }
      return md5blks;
    }
    function md51(s) {
      var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp, lo, hi;
      for (i = 64;i <= n; i += 64) {
        md5cycle(state, md5blk(s.substring(i - 64, i)));
      }
      s = s.substring(i - 64);
      length5 = s.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i = 0;i < length5; i += 1) {
        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
      }
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(state, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = n * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a) {
      var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp, lo, hi;
      for (i = 64;i <= n; i += 64) {
        md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
      }
      a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
      length5 = a.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i = 0;i < length5; i += 1) {
        tail[i >> 2] |= a[i] << (i % 4 << 3);
      }
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(state, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = n * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n) {
      var s = "", j;
      for (j = 0;j < 4; j += 1) {
        s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
      }
      return s;
    }
    function hex(x) {
      var i;
      for (i = 0;i < x.length; i += 1) {
        x[i] = rhex(x[i]);
      }
      return x.join("");
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
      add32 = function(x, y) {
        var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      };
    }
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp(val, length5) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length5, 0);
          }
          return Math.min(val, length5);
        }
        ArrayBuffer.prototype.slice = function(from, to) {
          var length5 = this.byteLength, begin = clamp(from, length5), end = length5, num, target, targetArray, sourceArray;
          if (to !== undefined2) {
            end = clamp(to, length5);
          }
          if (begin > end) {
            return new ArrayBuffer(0);
          }
          num = end - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str7) {
      if (/[\u0080-\uFFFF]/.test(str7)) {
        str7 = unescape(encodeURIComponent(str7));
      }
      return str7;
    }
    function utf8Str2ArrayBuffer(str7, returnUInt8Array) {
      var length5 = str7.length, buff = new ArrayBuffer(length5), arr = new Uint8Array(buff), i;
      for (i = 0;i < length5; i += 1) {
        arr[i] = str7.charCodeAt(i);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return returnUInt8Array ? result : result.buffer;
    }
    function hexToBinaryString(hex2) {
      var bytes = [], length5 = hex2.length, x;
      for (x = 0;x < length5 - 1; x += 2) {
        bytes.push(parseInt(hex2.substr(x, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD5() {
      this.reset();
    }
    SparkMD5.prototype.append = function(str7) {
      this.appendBinary(toUtf8(str7));
      return this;
    };
    SparkMD5.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length5 = this._buff.length, i;
      for (i = 64;i <= length5; i += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
      }
      this._buff = this._buff.substring(i - 64);
      return this;
    };
    SparkMD5.prototype.end = function(raw) {
      var buff = this._buff, length5 = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i = 0;i < length5; i += 1) {
        tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
      }
      this._finish(tail, length5);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD5.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD5.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD5.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD5.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD5.prototype._finish = function(tail, length5) {
      var i = length5, tmp, lo, hi;
      tail[i >> 2] |= 128 << (i % 4 << 3);
      if (i > 55) {
        md5cycle(this._hash, tail);
        for (i = 0;i < 16; i += 1) {
          tail[i] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(this._hash, tail);
    };
    SparkMD5.hash = function(str7, raw) {
      return SparkMD5.hashBinary(toUtf8(str7), raw);
    };
    SparkMD5.hashBinary = function(content, raw) {
      var hash = md51(content), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD5.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD5.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length5 = buff.length, i;
      this._length += arr.byteLength;
      for (i = 64;i <= length5; i += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
      }
      this._buff = i - 64 < length5 ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD5.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length5 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
      for (i = 0;i < length5; i += 1) {
        tail[i >> 2] |= buff[i] << (i % 4 << 3);
      }
      this._finish(tail, length5);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD5.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD5.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD5.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD5.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD5.prototype.setState.call(this, state);
    };
    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
    SparkMD5.ArrayBuffer.hash = function(arr, raw) {
      var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD5;
  });
});

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js
var exports_enums = {};
__export(exports_enums, {
  VoxelManagerEnum: () => VoxelManagerEnum_default,
  ViewportType: () => ViewportType_default,
  ViewportStatus: () => ViewportStatus_default,
  VideoEnums: () => exports_VideoEnums,
  VOILUTFunctionType: () => VOILUTFunctionType_default,
  RequestType: () => RequestType_default,
  OrientationAxis: () => OrientationAxis_default,
  MetadataModules: () => MetadataModules_default,
  InterpolationType: () => InterpolationType_default,
  ImageQualityStatus: () => ImageQualityStatus_default,
  GeometryType: () => GeometryType_default,
  GenerateImageType: () => GenerateImageType,
  Events: () => Events_default,
  DynamicOperatorType: () => DynamicOperatorType_default,
  ContourType: () => ContourType_default,
  CalibrationTypes: () => CalibrationTypes_default,
  BlendModes: () => BlendModes_default
});

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events;
(function(Events2) {
  Events2["ERROR_EVENT"] = "CORNERSTONE_ERROR";
  Events2["CACHE_SIZE_EXCEEDED"] = "CACHE_SIZE_EXCEEDED";
  Events2["IMAGE_LOAD_ERROR"] = "IMAGE_LOAD_ERROR";
  Events2["CAMERA_MODIFIED"] = "CORNERSTONE_CAMERA_MODIFIED";
  Events2["CAMERA_RESET"] = "CORNERSTONE_CAMERA_RESET";
  Events2["VOI_MODIFIED"] = "CORNERSTONE_VOI_MODIFIED";
  Events2["PRESET_MODIFIED"] = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED";
  Events2["DISPLAY_AREA_MODIFIED"] = "CORNERSTONE_DISPLAY_AREA_MODIFIED";
  Events2["ELEMENT_DISABLED"] = "CORNERSTONE_ELEMENT_DISABLED";
  Events2["ELEMENT_ENABLED"] = "CORNERSTONE_ELEMENT_ENABLED";
  Events2["IMAGE_RENDERED"] = "CORNERSTONE_IMAGE_RENDERED";
  Events2["IMAGE_VOLUME_MODIFIED"] = "CORNERSTONE_IMAGE_VOLUME_MODIFIED";
  Events2["IMAGE_VOLUME_LOADING_COMPLETED"] = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED";
  Events2["IMAGE_LOADED"] = "CORNERSTONE_IMAGE_LOADED";
  Events2["IMAGE_RETRIEVAL_STAGE"] = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE";
  Events2["IMAGE_LOAD_FAILED"] = "CORNERSTONE_IMAGE_LOAD_FAILED";
  Events2["VOLUME_VIEWPORT_NEW_VOLUME"] = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME";
  Events2["VOLUME_LOADED"] = "CORNERSTONE_VOLUME_LOADED";
  Events2["VOLUME_LOADED_FAILED"] = "CORNERSTONE_VOLUME_LOADED_FAILED";
  Events2["IMAGE_CACHE_IMAGE_ADDED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED";
  Events2["IMAGE_CACHE_IMAGE_REMOVED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED";
  Events2["VOLUME_CACHE_VOLUME_ADDED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED";
  Events2["VOLUME_CACHE_VOLUME_REMOVED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED";
  Events2["STACK_NEW_IMAGE"] = "CORNERSTONE_STACK_NEW_IMAGE";
  Events2["VOLUME_NEW_IMAGE"] = "CORNERSTONE_VOLUME_NEW_IMAGE";
  Events2["PRE_STACK_NEW_IMAGE"] = "CORNERSTONE_PRE_STACK_NEW_IMAGE";
  Events2["IMAGE_SPACING_CALIBRATED"] = "CORNERSTONE_IMAGE_SPACING_CALIBRATED";
  Events2["VIEWPORT_NEW_IMAGE_SET"] = "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET";
  Events2["STACK_VIEWPORT_SCROLL"] = "CORNERSTONE_STACK_VIEWPORT_SCROLL";
  Events2["STACK_SCROLL_OUT_OF_BOUNDS"] = "STACK_SCROLL_OUT_OF_BOUNDS";
  Events2["GEOMETRY_CACHE_GEOMETRY_ADDED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED";
  Events2["GEOMETRY_CACHE_GEOMETRY_REMOVED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED";
  Events2["VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS"] = "VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS";
  Events2["VOLUME_VIEWPORT_SCROLL"] = "VOLUME_VIEWPORT_SCROLL";
  Events2["CLIPPING_PLANES_UPDATED"] = "CORNERSTONE_CLIPPING_PLANES_UPDATED";
  Events2["WEB_WORKER_PROGRESS"] = "CORNERSTONE_WEB_WORKER_PROGRESS";
  Events2["COLORMAP_MODIFIED"] = "CORNERSTONE_COLORMAP_MODIFIED";
  Events2["DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED"] = "DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED";
  Events2["DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED"] = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED";
  Events2["DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED"] = "DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED";
  Events2["DYNAMIC_VOLUME_TIME_POINT_LOADED"] = "DYNAMIC_VOLUME_TIME_POINT_LOADED";
  Events2["GEOMETRY_LOADED"] = "GEOMETRY_LOADED";
  Events2["GEOMETRY_LOADED_FAILED"] = "GEOMETRY_LOADED_FAILED";
})(Events || (Events = {}));
var Events_default = Events;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/RequestType.js
var RequestType;
(function(RequestType2) {
  RequestType2["Interaction"] = "interaction";
  RequestType2["Thumbnail"] = "thumbnail";
  RequestType2["Prefetch"] = "prefetch";
  RequestType2["Compute"] = "compute";
})(RequestType || (RequestType = {}));
var RequestType_default = RequestType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportType.js
var ViewportType;
(function(ViewportType2) {
  ViewportType2["STACK"] = "stack";
  ViewportType2["ORTHOGRAPHIC"] = "orthographic";
  ViewportType2["PERSPECTIVE"] = "perspective";
  ViewportType2["VOLUME_3D"] = "volume3d";
  ViewportType2["VIDEO"] = "video";
  ViewportType2["WHOLE_SLIDE"] = "wholeSlide";
})(ViewportType || (ViewportType = {}));
var ViewportType_default = ViewportType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/InterpolationType.js
var InterpolationType;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["NEAREST"] = 0] = "NEAREST";
  InterpolationType2[InterpolationType2["LINEAR"] = 1] = "LINEAR";
  InterpolationType2[InterpolationType2["FAST_LINEAR"] = 2] = "FAST_LINEAR";
})(InterpolationType || (InterpolationType = {}));
var InterpolationType_default = InterpolationType;

// ../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5,
  LABELMAP_EDGE_PROJECTION_BLEND: 6
};
var FilterMode = {
  OFF: 0,
  NORMALIZED: 1,
  RAW: 2
};
var Constants = {
  BlendMode,
  FilterMode
};

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/BlendModes.js
var { BlendMode: BlendMode2 } = Constants;
var BlendModes;
(function(BlendModes2) {
  BlendModes2[BlendModes2["COMPOSITE"] = BlendMode2.COMPOSITE_BLEND] = "COMPOSITE";
  BlendModes2[BlendModes2["MAXIMUM_INTENSITY_BLEND"] = BlendMode2.MAXIMUM_INTENSITY_BLEND] = "MAXIMUM_INTENSITY_BLEND";
  BlendModes2[BlendModes2["MINIMUM_INTENSITY_BLEND"] = BlendMode2.MINIMUM_INTENSITY_BLEND] = "MINIMUM_INTENSITY_BLEND";
  BlendModes2[BlendModes2["AVERAGE_INTENSITY_BLEND"] = BlendMode2.AVERAGE_INTENSITY_BLEND] = "AVERAGE_INTENSITY_BLEND";
  BlendModes2[BlendModes2["LABELMAP_EDGE_PROJECTION_BLEND"] = BlendMode2.LABELMAP_EDGE_PROJECTION_BLEND] = "LABELMAP_EDGE_PROJECTION_BLEND";
})(BlendModes || (BlendModes = {}));
var BlendModes_default = BlendModes;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/OrientationAxis.js
var OrientationAxis;
(function(OrientationAxis2) {
  OrientationAxis2["AXIAL"] = "axial";
  OrientationAxis2["CORONAL"] = "coronal";
  OrientationAxis2["SAGITTAL"] = "sagittal";
  OrientationAxis2["ACQUISITION"] = "acquisition";
})(OrientationAxis || (OrientationAxis = {}));
var OrientationAxis_default = OrientationAxis;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/GeometryType.js
var GeometryType;
(function(GeometryType2) {
  GeometryType2["CONTOUR"] = "CONTOUR";
  GeometryType2["SURFACE"] = "SURFACE";
})(GeometryType || (GeometryType = {}));
var GeometryType_default = GeometryType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/ContourType.js
var ContourType;
(function(ContourType2) {
  ContourType2["CLOSED_PLANAR"] = "CLOSED_PLANAR";
  ContourType2["OPEN_PLANAR"] = "OPEN_PLANAR";
})(ContourType || (ContourType = {}));
var ContourType_default = ContourType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/VOILUTFunctionType.js
var VOILUTFunctionType;
(function(VOILUTFunctionType2) {
  VOILUTFunctionType2["LINEAR"] = "LINEAR";
  VOILUTFunctionType2["SAMPLED_SIGMOID"] = "SIGMOID";
  VOILUTFunctionType2["LINEAR_EXACT"] = "LINEAR_EXACT";
})(VOILUTFunctionType || (VOILUTFunctionType = {}));
var VOILUTFunctionType_default = VOILUTFunctionType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/DynamicOperatorType.js
var DynamicOperatorType;
(function(DynamicOperatorType2) {
  DynamicOperatorType2["SUM"] = "SUM";
  DynamicOperatorType2["AVERAGE"] = "AVERAGE";
  DynamicOperatorType2["SUBTRACT"] = "SUBTRACT";
})(DynamicOperatorType || (DynamicOperatorType = {}));
var DynamicOperatorType_default = DynamicOperatorType;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/CalibrationTypes.js
var CalibrationTypes;
(function(CalibrationTypes2) {
  CalibrationTypes2["NOT_APPLICABLE"] = "";
  CalibrationTypes2["ERMF"] = "ERMF";
  CalibrationTypes2["USER"] = "User";
  CalibrationTypes2["PROJECTION"] = "Proj";
  CalibrationTypes2["REGION"] = "Region";
  CalibrationTypes2["ERROR"] = "Error";
  CalibrationTypes2["UNCALIBRATED"] = "Uncalibrated";
})(CalibrationTypes || (CalibrationTypes = {}));
var CalibrationTypes_default = CalibrationTypes;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportStatus.js
var ViewportStatus;
(function(ViewportStatus2) {
  ViewportStatus2["NO_DATA"] = "noData";
  ViewportStatus2["LOADING"] = "loading";
  ViewportStatus2["PRE_RENDER"] = "preRender";
  ViewportStatus2["RESIZE"] = "resize";
  ViewportStatus2["RENDERED"] = "rendered";
})(ViewportStatus || (ViewportStatus = {}));
var ViewportStatus_default = ViewportStatus;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/ImageQualityStatus.js
var ImageQualityStatus;
(function(ImageQualityStatus2) {
  ImageQualityStatus2[ImageQualityStatus2["FAR_REPLICATE"] = 1] = "FAR_REPLICATE";
  ImageQualityStatus2[ImageQualityStatus2["ADJACENT_REPLICATE"] = 3] = "ADJACENT_REPLICATE";
  ImageQualityStatus2[ImageQualityStatus2["SUBRESOLUTION"] = 6] = "SUBRESOLUTION";
  ImageQualityStatus2[ImageQualityStatus2["LOSSY"] = 7] = "LOSSY";
  ImageQualityStatus2[ImageQualityStatus2["FULL_RESOLUTION"] = 8] = "FULL_RESOLUTION";
})(ImageQualityStatus || (ImageQualityStatus = {}));
var ImageQualityStatus_default = ImageQualityStatus;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/VideoEnums.js
var exports_VideoEnums = {};
__export(exports_VideoEnums, {
  SpeedUnit: () => SpeedUnit
});
var SpeedUnit;
(function(SpeedUnit2) {
  SpeedUnit2["FRAME"] = "f";
  SpeedUnit2["SECOND"] = "s";
})(SpeedUnit || (SpeedUnit = {}));

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/MetadataModules.js
var MetadataModules;
(function(MetadataModules2) {
  MetadataModules2["CALIBRATION"] = "calibrationModule";
  MetadataModules2["CINE"] = "cineModule";
  MetadataModules2["GENERAL_IMAGE"] = "generalImageModule";
  MetadataModules2["GENERAL_SERIES"] = "generalSeriesModule";
  MetadataModules2["GENERAL_STUDY"] = "generalStudyModule";
  MetadataModules2["IMAGE_PIXEL"] = "imagePixelModule";
  MetadataModules2["IMAGE_PLANE"] = "imagePlaneModule";
  MetadataModules2["IMAGE_URL"] = "imageUrlModule";
  MetadataModules2["MODALITY_LUT"] = "modalityLutModule";
  MetadataModules2["MULTIFRAME"] = "multiframeModule";
  MetadataModules2["NM_MULTIFRAME_GEOMETRY"] = "nmMultiframeGeometryModule";
  MetadataModules2["OVERLAY_PLANE"] = "overlayPlaneModule";
  MetadataModules2["PATIENT"] = "patientModule";
  MetadataModules2["PATIENT_STUDY"] = "patientStudyModule";
  MetadataModules2["PET_IMAGE"] = "petImageModule";
  MetadataModules2["PET_ISOTOPE"] = "petIsotopeModule";
  MetadataModules2["PET_SERIES"] = "petSeriesModule";
  MetadataModules2["SOP_COMMON"] = "sopCommonModule";
  MetadataModules2["ULTRASOUND_ENHANCED_REGION"] = "ultrasoundEnhancedRegionModule";
  MetadataModules2["VOI_LUT"] = "voiLutModule";
  MetadataModules2["WADO_WEB_CLIENT"] = "wadoWebClient";
})(MetadataModules || (MetadataModules = {}));
var MetadataModules_default = MetadataModules;

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js
var GenerateImageType;
(function(GenerateImageType2) {
  GenerateImageType2["SUM"] = "SUM";
  GenerateImageType2["SUBTRACT"] = "SUBTRACT";
  GenerateImageType2["AVERAGE"] = "AVERAGE";
})(GenerateImageType || (GenerateImageType = {}));

// ../../node_modules/@cornerstonejs/core/dist/esm/enums/VoxelManagerEnum.js
var VoxelManagerEnum;
(function(VoxelManagerEnum2) {
  VoxelManagerEnum2["RLE"] = "RLE";
  VoxelManagerEnum2["Volume"] = "Volume";
})(VoxelManagerEnum || (VoxelManagerEnum = {}));
var VoxelManagerEnum_default = VoxelManagerEnum;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js
var exports_constants = {};
__export(exports_constants, {
  VIEWPORT_PRESETS: () => viewportPresets_default,
  RENDERING_DEFAULTS: () => rendering_default,
  MPR_CAMERA_VALUES: () => mprCameraValues_default,
  EPSILON: () => epsilon_default,
  CPU_COLORMAPS: () => cpuColormaps_default,
  BACKGROUND_COLORS: () => backgroundColors_default
});

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/cpuColormaps.js
var colormapsData = {
  hotIron: {
    name: "Hot Iron",
    numOfColors: 256,
    colors: [
      [0, 0, 0, 255],
      [2, 0, 0, 255],
      [4, 0, 0, 255],
      [6, 0, 0, 255],
      [8, 0, 0, 255],
      [10, 0, 0, 255],
      [12, 0, 0, 255],
      [14, 0, 0, 255],
      [16, 0, 0, 255],
      [18, 0, 0, 255],
      [20, 0, 0, 255],
      [22, 0, 0, 255],
      [24, 0, 0, 255],
      [26, 0, 0, 255],
      [28, 0, 0, 255],
      [30, 0, 0, 255],
      [32, 0, 0, 255],
      [34, 0, 0, 255],
      [36, 0, 0, 255],
      [38, 0, 0, 255],
      [40, 0, 0, 255],
      [42, 0, 0, 255],
      [44, 0, 0, 255],
      [46, 0, 0, 255],
      [48, 0, 0, 255],
      [50, 0, 0, 255],
      [52, 0, 0, 255],
      [54, 0, 0, 255],
      [56, 0, 0, 255],
      [58, 0, 0, 255],
      [60, 0, 0, 255],
      [62, 0, 0, 255],
      [64, 0, 0, 255],
      [66, 0, 0, 255],
      [68, 0, 0, 255],
      [70, 0, 0, 255],
      [72, 0, 0, 255],
      [74, 0, 0, 255],
      [76, 0, 0, 255],
      [78, 0, 0, 255],
      [80, 0, 0, 255],
      [82, 0, 0, 255],
      [84, 0, 0, 255],
      [86, 0, 0, 255],
      [88, 0, 0, 255],
      [90, 0, 0, 255],
      [92, 0, 0, 255],
      [94, 0, 0, 255],
      [96, 0, 0, 255],
      [98, 0, 0, 255],
      [100, 0, 0, 255],
      [102, 0, 0, 255],
      [104, 0, 0, 255],
      [106, 0, 0, 255],
      [108, 0, 0, 255],
      [110, 0, 0, 255],
      [112, 0, 0, 255],
      [114, 0, 0, 255],
      [116, 0, 0, 255],
      [118, 0, 0, 255],
      [120, 0, 0, 255],
      [122, 0, 0, 255],
      [124, 0, 0, 255],
      [126, 0, 0, 255],
      [128, 0, 0, 255],
      [130, 0, 0, 255],
      [132, 0, 0, 255],
      [134, 0, 0, 255],
      [136, 0, 0, 255],
      [138, 0, 0, 255],
      [140, 0, 0, 255],
      [142, 0, 0, 255],
      [144, 0, 0, 255],
      [146, 0, 0, 255],
      [148, 0, 0, 255],
      [150, 0, 0, 255],
      [152, 0, 0, 255],
      [154, 0, 0, 255],
      [156, 0, 0, 255],
      [158, 0, 0, 255],
      [160, 0, 0, 255],
      [162, 0, 0, 255],
      [164, 0, 0, 255],
      [166, 0, 0, 255],
      [168, 0, 0, 255],
      [170, 0, 0, 255],
      [172, 0, 0, 255],
      [174, 0, 0, 255],
      [176, 0, 0, 255],
      [178, 0, 0, 255],
      [180, 0, 0, 255],
      [182, 0, 0, 255],
      [184, 0, 0, 255],
      [186, 0, 0, 255],
      [188, 0, 0, 255],
      [190, 0, 0, 255],
      [192, 0, 0, 255],
      [194, 0, 0, 255],
      [196, 0, 0, 255],
      [198, 0, 0, 255],
      [200, 0, 0, 255],
      [202, 0, 0, 255],
      [204, 0, 0, 255],
      [206, 0, 0, 255],
      [208, 0, 0, 255],
      [210, 0, 0, 255],
      [212, 0, 0, 255],
      [214, 0, 0, 255],
      [216, 0, 0, 255],
      [218, 0, 0, 255],
      [220, 0, 0, 255],
      [222, 0, 0, 255],
      [224, 0, 0, 255],
      [226, 0, 0, 255],
      [228, 0, 0, 255],
      [230, 0, 0, 255],
      [232, 0, 0, 255],
      [234, 0, 0, 255],
      [236, 0, 0, 255],
      [238, 0, 0, 255],
      [240, 0, 0, 255],
      [242, 0, 0, 255],
      [244, 0, 0, 255],
      [246, 0, 0, 255],
      [248, 0, 0, 255],
      [250, 0, 0, 255],
      [252, 0, 0, 255],
      [254, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 2, 0, 255],
      [255, 4, 0, 255],
      [255, 6, 0, 255],
      [255, 8, 0, 255],
      [255, 10, 0, 255],
      [255, 12, 0, 255],
      [255, 14, 0, 255],
      [255, 16, 0, 255],
      [255, 18, 0, 255],
      [255, 20, 0, 255],
      [255, 22, 0, 255],
      [255, 24, 0, 255],
      [255, 26, 0, 255],
      [255, 28, 0, 255],
      [255, 30, 0, 255],
      [255, 32, 0, 255],
      [255, 34, 0, 255],
      [255, 36, 0, 255],
      [255, 38, 0, 255],
      [255, 40, 0, 255],
      [255, 42, 0, 255],
      [255, 44, 0, 255],
      [255, 46, 0, 255],
      [255, 48, 0, 255],
      [255, 50, 0, 255],
      [255, 52, 0, 255],
      [255, 54, 0, 255],
      [255, 56, 0, 255],
      [255, 58, 0, 255],
      [255, 60, 0, 255],
      [255, 62, 0, 255],
      [255, 64, 0, 255],
      [255, 66, 0, 255],
      [255, 68, 0, 255],
      [255, 70, 0, 255],
      [255, 72, 0, 255],
      [255, 74, 0, 255],
      [255, 76, 0, 255],
      [255, 78, 0, 255],
      [255, 80, 0, 255],
      [255, 82, 0, 255],
      [255, 84, 0, 255],
      [255, 86, 0, 255],
      [255, 88, 0, 255],
      [255, 90, 0, 255],
      [255, 92, 0, 255],
      [255, 94, 0, 255],
      [255, 96, 0, 255],
      [255, 98, 0, 255],
      [255, 100, 0, 255],
      [255, 102, 0, 255],
      [255, 104, 0, 255],
      [255, 106, 0, 255],
      [255, 108, 0, 255],
      [255, 110, 0, 255],
      [255, 112, 0, 255],
      [255, 114, 0, 255],
      [255, 116, 0, 255],
      [255, 118, 0, 255],
      [255, 120, 0, 255],
      [255, 122, 0, 255],
      [255, 124, 0, 255],
      [255, 126, 0, 255],
      [255, 128, 4, 255],
      [255, 130, 8, 255],
      [255, 132, 12, 255],
      [255, 134, 16, 255],
      [255, 136, 20, 255],
      [255, 138, 24, 255],
      [255, 140, 28, 255],
      [255, 142, 32, 255],
      [255, 144, 36, 255],
      [255, 146, 40, 255],
      [255, 148, 44, 255],
      [255, 150, 48, 255],
      [255, 152, 52, 255],
      [255, 154, 56, 255],
      [255, 156, 60, 255],
      [255, 158, 64, 255],
      [255, 160, 68, 255],
      [255, 162, 72, 255],
      [255, 164, 76, 255],
      [255, 166, 80, 255],
      [255, 168, 84, 255],
      [255, 170, 88, 255],
      [255, 172, 92, 255],
      [255, 174, 96, 255],
      [255, 176, 100, 255],
      [255, 178, 104, 255],
      [255, 180, 108, 255],
      [255, 182, 112, 255],
      [255, 184, 116, 255],
      [255, 186, 120, 255],
      [255, 188, 124, 255],
      [255, 190, 128, 255],
      [255, 192, 132, 255],
      [255, 194, 136, 255],
      [255, 196, 140, 255],
      [255, 198, 144, 255],
      [255, 200, 148, 255],
      [255, 202, 152, 255],
      [255, 204, 156, 255],
      [255, 206, 160, 255],
      [255, 208, 164, 255],
      [255, 210, 168, 255],
      [255, 212, 172, 255],
      [255, 214, 176, 255],
      [255, 216, 180, 255],
      [255, 218, 184, 255],
      [255, 220, 188, 255],
      [255, 222, 192, 255],
      [255, 224, 196, 255],
      [255, 226, 200, 255],
      [255, 228, 204, 255],
      [255, 230, 208, 255],
      [255, 232, 212, 255],
      [255, 234, 216, 255],
      [255, 236, 220, 255],
      [255, 238, 224, 255],
      [255, 240, 228, 255],
      [255, 242, 232, 255],
      [255, 244, 236, 255],
      [255, 246, 240, 255],
      [255, 248, 244, 255],
      [255, 250, 248, 255],
      [255, 252, 252, 255],
      [255, 255, 255, 255]
    ]
  },
  pet: {
    name: "PET",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 2, 1, 255],
      [0, 4, 3, 255],
      [0, 6, 5, 255],
      [0, 8, 7, 255],
      [0, 10, 9, 255],
      [0, 12, 11, 255],
      [0, 14, 13, 255],
      [0, 16, 15, 255],
      [0, 18, 17, 255],
      [0, 20, 19, 255],
      [0, 22, 21, 255],
      [0, 24, 23, 255],
      [0, 26, 25, 255],
      [0, 28, 27, 255],
      [0, 30, 29, 255],
      [0, 32, 31, 255],
      [0, 34, 33, 255],
      [0, 36, 35, 255],
      [0, 38, 37, 255],
      [0, 40, 39, 255],
      [0, 42, 41, 255],
      [0, 44, 43, 255],
      [0, 46, 45, 255],
      [0, 48, 47, 255],
      [0, 50, 49, 255],
      [0, 52, 51, 255],
      [0, 54, 53, 255],
      [0, 56, 55, 255],
      [0, 58, 57, 255],
      [0, 60, 59, 255],
      [0, 62, 61, 255],
      [0, 65, 63, 255],
      [0, 67, 65, 255],
      [0, 69, 67, 255],
      [0, 71, 69, 255],
      [0, 73, 71, 255],
      [0, 75, 73, 255],
      [0, 77, 75, 255],
      [0, 79, 77, 255],
      [0, 81, 79, 255],
      [0, 83, 81, 255],
      [0, 85, 83, 255],
      [0, 87, 85, 255],
      [0, 89, 87, 255],
      [0, 91, 89, 255],
      [0, 93, 91, 255],
      [0, 95, 93, 255],
      [0, 97, 95, 255],
      [0, 99, 97, 255],
      [0, 101, 99, 255],
      [0, 103, 101, 255],
      [0, 105, 103, 255],
      [0, 107, 105, 255],
      [0, 109, 107, 255],
      [0, 111, 109, 255],
      [0, 113, 111, 255],
      [0, 115, 113, 255],
      [0, 117, 115, 255],
      [0, 119, 117, 255],
      [0, 121, 119, 255],
      [0, 123, 121, 255],
      [0, 125, 123, 255],
      [0, 128, 125, 255],
      [1, 126, 127, 255],
      [3, 124, 129, 255],
      [5, 122, 131, 255],
      [7, 120, 133, 255],
      [9, 118, 135, 255],
      [11, 116, 137, 255],
      [13, 114, 139, 255],
      [15, 112, 141, 255],
      [17, 110, 143, 255],
      [19, 108, 145, 255],
      [21, 106, 147, 255],
      [23, 104, 149, 255],
      [25, 102, 151, 255],
      [27, 100, 153, 255],
      [29, 98, 155, 255],
      [31, 96, 157, 255],
      [33, 94, 159, 255],
      [35, 92, 161, 255],
      [37, 90, 163, 255],
      [39, 88, 165, 255],
      [41, 86, 167, 255],
      [43, 84, 169, 255],
      [45, 82, 171, 255],
      [47, 80, 173, 255],
      [49, 78, 175, 255],
      [51, 76, 177, 255],
      [53, 74, 179, 255],
      [55, 72, 181, 255],
      [57, 70, 183, 255],
      [59, 68, 185, 255],
      [61, 66, 187, 255],
      [63, 64, 189, 255],
      [65, 63, 191, 255],
      [67, 61, 193, 255],
      [69, 59, 195, 255],
      [71, 57, 197, 255],
      [73, 55, 199, 255],
      [75, 53, 201, 255],
      [77, 51, 203, 255],
      [79, 49, 205, 255],
      [81, 47, 207, 255],
      [83, 45, 209, 255],
      [85, 43, 211, 255],
      [86, 41, 213, 255],
      [88, 39, 215, 255],
      [90, 37, 217, 255],
      [92, 35, 219, 255],
      [94, 33, 221, 255],
      [96, 31, 223, 255],
      [98, 29, 225, 255],
      [100, 27, 227, 255],
      [102, 25, 229, 255],
      [104, 23, 231, 255],
      [106, 21, 233, 255],
      [108, 19, 235, 255],
      [110, 17, 237, 255],
      [112, 15, 239, 255],
      [114, 13, 241, 255],
      [116, 11, 243, 255],
      [118, 9, 245, 255],
      [120, 7, 247, 255],
      [122, 5, 249, 255],
      [124, 3, 251, 255],
      [126, 1, 253, 255],
      [128, 0, 255, 255],
      [130, 2, 252, 255],
      [132, 4, 248, 255],
      [134, 6, 244, 255],
      [136, 8, 240, 255],
      [138, 10, 236, 255],
      [140, 12, 232, 255],
      [142, 14, 228, 255],
      [144, 16, 224, 255],
      [146, 18, 220, 255],
      [148, 20, 216, 255],
      [150, 22, 212, 255],
      [152, 24, 208, 255],
      [154, 26, 204, 255],
      [156, 28, 200, 255],
      [158, 30, 196, 255],
      [160, 32, 192, 255],
      [162, 34, 188, 255],
      [164, 36, 184, 255],
      [166, 38, 180, 255],
      [168, 40, 176, 255],
      [170, 42, 172, 255],
      [171, 44, 168, 255],
      [173, 46, 164, 255],
      [175, 48, 160, 255],
      [177, 50, 156, 255],
      [179, 52, 152, 255],
      [181, 54, 148, 255],
      [183, 56, 144, 255],
      [185, 58, 140, 255],
      [187, 60, 136, 255],
      [189, 62, 132, 255],
      [191, 64, 128, 255],
      [193, 66, 124, 255],
      [195, 68, 120, 255],
      [197, 70, 116, 255],
      [199, 72, 112, 255],
      [201, 74, 108, 255],
      [203, 76, 104, 255],
      [205, 78, 100, 255],
      [207, 80, 96, 255],
      [209, 82, 92, 255],
      [211, 84, 88, 255],
      [213, 86, 84, 255],
      [215, 88, 80, 255],
      [217, 90, 76, 255],
      [219, 92, 72, 255],
      [221, 94, 68, 255],
      [223, 96, 64, 255],
      [225, 98, 60, 255],
      [227, 100, 56, 255],
      [229, 102, 52, 255],
      [231, 104, 48, 255],
      [233, 106, 44, 255],
      [235, 108, 40, 255],
      [237, 110, 36, 255],
      [239, 112, 32, 255],
      [241, 114, 28, 255],
      [243, 116, 24, 255],
      [245, 118, 20, 255],
      [247, 120, 16, 255],
      [249, 122, 12, 255],
      [251, 124, 8, 255],
      [253, 126, 4, 255],
      [255, 128, 0, 255],
      [255, 130, 4, 255],
      [255, 132, 8, 255],
      [255, 134, 12, 255],
      [255, 136, 16, 255],
      [255, 138, 20, 255],
      [255, 140, 24, 255],
      [255, 142, 28, 255],
      [255, 144, 32, 255],
      [255, 146, 36, 255],
      [255, 148, 40, 255],
      [255, 150, 44, 255],
      [255, 152, 48, 255],
      [255, 154, 52, 255],
      [255, 156, 56, 255],
      [255, 158, 60, 255],
      [255, 160, 64, 255],
      [255, 162, 68, 255],
      [255, 164, 72, 255],
      [255, 166, 76, 255],
      [255, 168, 80, 255],
      [255, 170, 85, 255],
      [255, 172, 89, 255],
      [255, 174, 93, 255],
      [255, 176, 97, 255],
      [255, 178, 101, 255],
      [255, 180, 105, 255],
      [255, 182, 109, 255],
      [255, 184, 113, 255],
      [255, 186, 117, 255],
      [255, 188, 121, 255],
      [255, 190, 125, 255],
      [255, 192, 129, 255],
      [255, 194, 133, 255],
      [255, 196, 137, 255],
      [255, 198, 141, 255],
      [255, 200, 145, 255],
      [255, 202, 149, 255],
      [255, 204, 153, 255],
      [255, 206, 157, 255],
      [255, 208, 161, 255],
      [255, 210, 165, 255],
      [255, 212, 170, 255],
      [255, 214, 174, 255],
      [255, 216, 178, 255],
      [255, 218, 182, 255],
      [255, 220, 186, 255],
      [255, 222, 190, 255],
      [255, 224, 194, 255],
      [255, 226, 198, 255],
      [255, 228, 202, 255],
      [255, 230, 206, 255],
      [255, 232, 210, 255],
      [255, 234, 214, 255],
      [255, 236, 218, 255],
      [255, 238, 222, 255],
      [255, 240, 226, 255],
      [255, 242, 230, 255],
      [255, 244, 234, 255],
      [255, 246, 238, 255],
      [255, 248, 242, 255],
      [255, 250, 246, 255],
      [255, 252, 250, 255],
      [255, 255, 255, 255]
    ]
  },
  hotMetalBlue: {
    name: "Hot Metal Blue",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 0, 2, 255],
      [0, 0, 4, 255],
      [0, 0, 6, 255],
      [0, 0, 8, 255],
      [0, 0, 10, 255],
      [0, 0, 12, 255],
      [0, 0, 14, 255],
      [0, 0, 16, 255],
      [0, 0, 17, 255],
      [0, 0, 19, 255],
      [0, 0, 21, 255],
      [0, 0, 23, 255],
      [0, 0, 25, 255],
      [0, 0, 27, 255],
      [0, 0, 29, 255],
      [0, 0, 31, 255],
      [0, 0, 33, 255],
      [0, 0, 35, 255],
      [0, 0, 37, 255],
      [0, 0, 39, 255],
      [0, 0, 41, 255],
      [0, 0, 43, 255],
      [0, 0, 45, 255],
      [0, 0, 47, 255],
      [0, 0, 49, 255],
      [0, 0, 51, 255],
      [0, 0, 53, 255],
      [0, 0, 55, 255],
      [0, 0, 57, 255],
      [0, 0, 59, 255],
      [0, 0, 61, 255],
      [0, 0, 63, 255],
      [0, 0, 65, 255],
      [0, 0, 67, 255],
      [0, 0, 69, 255],
      [0, 0, 71, 255],
      [0, 0, 73, 255],
      [0, 0, 75, 255],
      [0, 0, 77, 255],
      [0, 0, 79, 255],
      [0, 0, 81, 255],
      [0, 0, 83, 255],
      [0, 0, 84, 255],
      [0, 0, 86, 255],
      [0, 0, 88, 255],
      [0, 0, 90, 255],
      [0, 0, 92, 255],
      [0, 0, 94, 255],
      [0, 0, 96, 255],
      [0, 0, 98, 255],
      [0, 0, 100, 255],
      [0, 0, 102, 255],
      [0, 0, 104, 255],
      [0, 0, 106, 255],
      [0, 0, 108, 255],
      [0, 0, 110, 255],
      [0, 0, 112, 255],
      [0, 0, 114, 255],
      [0, 0, 116, 255],
      [0, 0, 117, 255],
      [0, 0, 119, 255],
      [0, 0, 121, 255],
      [0, 0, 123, 255],
      [0, 0, 125, 255],
      [0, 0, 127, 255],
      [0, 0, 129, 255],
      [0, 0, 131, 255],
      [0, 0, 133, 255],
      [0, 0, 135, 255],
      [0, 0, 137, 255],
      [0, 0, 139, 255],
      [0, 0, 141, 255],
      [0, 0, 143, 255],
      [0, 0, 145, 255],
      [0, 0, 147, 255],
      [0, 0, 149, 255],
      [0, 0, 151, 255],
      [0, 0, 153, 255],
      [0, 0, 155, 255],
      [0, 0, 157, 255],
      [0, 0, 159, 255],
      [0, 0, 161, 255],
      [0, 0, 163, 255],
      [0, 0, 165, 255],
      [0, 0, 167, 255],
      [3, 0, 169, 255],
      [6, 0, 171, 255],
      [9, 0, 173, 255],
      [12, 0, 175, 255],
      [15, 0, 177, 255],
      [18, 0, 179, 255],
      [21, 0, 181, 255],
      [24, 0, 183, 255],
      [26, 0, 184, 255],
      [29, 0, 186, 255],
      [32, 0, 188, 255],
      [35, 0, 190, 255],
      [38, 0, 192, 255],
      [41, 0, 194, 255],
      [44, 0, 196, 255],
      [47, 0, 198, 255],
      [50, 0, 200, 255],
      [52, 0, 197, 255],
      [55, 0, 194, 255],
      [57, 0, 191, 255],
      [59, 0, 188, 255],
      [62, 0, 185, 255],
      [64, 0, 182, 255],
      [66, 0, 179, 255],
      [69, 0, 176, 255],
      [71, 0, 174, 255],
      [74, 0, 171, 255],
      [76, 0, 168, 255],
      [78, 0, 165, 255],
      [81, 0, 162, 255],
      [83, 0, 159, 255],
      [85, 0, 156, 255],
      [88, 0, 153, 255],
      [90, 0, 150, 255],
      [93, 2, 144, 255],
      [96, 4, 138, 255],
      [99, 6, 132, 255],
      [102, 8, 126, 255],
      [105, 9, 121, 255],
      [108, 11, 115, 255],
      [111, 13, 109, 255],
      [114, 15, 103, 255],
      [116, 17, 97, 255],
      [119, 19, 91, 255],
      [122, 21, 85, 255],
      [125, 23, 79, 255],
      [128, 24, 74, 255],
      [131, 26, 68, 255],
      [134, 28, 62, 255],
      [137, 30, 56, 255],
      [140, 32, 50, 255],
      [143, 34, 47, 255],
      [146, 36, 44, 255],
      [149, 38, 41, 255],
      [152, 40, 38, 255],
      [155, 41, 35, 255],
      [158, 43, 32, 255],
      [161, 45, 29, 255],
      [164, 47, 26, 255],
      [166, 49, 24, 255],
      [169, 51, 21, 255],
      [172, 53, 18, 255],
      [175, 55, 15, 255],
      [178, 56, 12, 255],
      [181, 58, 9, 255],
      [184, 60, 6, 255],
      [187, 62, 3, 255],
      [190, 64, 0, 255],
      [194, 66, 0, 255],
      [198, 68, 0, 255],
      [201, 70, 0, 255],
      [205, 72, 0, 255],
      [209, 73, 0, 255],
      [213, 75, 0, 255],
      [217, 77, 0, 255],
      [221, 79, 0, 255],
      [224, 81, 0, 255],
      [228, 83, 0, 255],
      [232, 85, 0, 255],
      [236, 87, 0, 255],
      [240, 88, 0, 255],
      [244, 90, 0, 255],
      [247, 92, 0, 255],
      [251, 94, 0, 255],
      [255, 96, 0, 255],
      [255, 98, 3, 255],
      [255, 100, 6, 255],
      [255, 102, 9, 255],
      [255, 104, 12, 255],
      [255, 105, 15, 255],
      [255, 107, 18, 255],
      [255, 109, 21, 255],
      [255, 111, 24, 255],
      [255, 113, 26, 255],
      [255, 115, 29, 255],
      [255, 117, 32, 255],
      [255, 119, 35, 255],
      [255, 120, 38, 255],
      [255, 122, 41, 255],
      [255, 124, 44, 255],
      [255, 126, 47, 255],
      [255, 128, 50, 255],
      [255, 130, 53, 255],
      [255, 132, 56, 255],
      [255, 134, 59, 255],
      [255, 136, 62, 255],
      [255, 137, 65, 255],
      [255, 139, 68, 255],
      [255, 141, 71, 255],
      [255, 143, 74, 255],
      [255, 145, 76, 255],
      [255, 147, 79, 255],
      [255, 149, 82, 255],
      [255, 151, 85, 255],
      [255, 152, 88, 255],
      [255, 154, 91, 255],
      [255, 156, 94, 255],
      [255, 158, 97, 255],
      [255, 160, 100, 255],
      [255, 162, 103, 255],
      [255, 164, 106, 255],
      [255, 166, 109, 255],
      [255, 168, 112, 255],
      [255, 169, 115, 255],
      [255, 171, 118, 255],
      [255, 173, 121, 255],
      [255, 175, 124, 255],
      [255, 177, 126, 255],
      [255, 179, 129, 255],
      [255, 181, 132, 255],
      [255, 183, 135, 255],
      [255, 184, 138, 255],
      [255, 186, 141, 255],
      [255, 188, 144, 255],
      [255, 190, 147, 255],
      [255, 192, 150, 255],
      [255, 194, 153, 255],
      [255, 196, 156, 255],
      [255, 198, 159, 255],
      [255, 200, 162, 255],
      [255, 201, 165, 255],
      [255, 203, 168, 255],
      [255, 205, 171, 255],
      [255, 207, 174, 255],
      [255, 209, 176, 255],
      [255, 211, 179, 255],
      [255, 213, 182, 255],
      [255, 215, 185, 255],
      [255, 216, 188, 255],
      [255, 218, 191, 255],
      [255, 220, 194, 255],
      [255, 222, 197, 255],
      [255, 224, 200, 255],
      [255, 226, 203, 255],
      [255, 228, 206, 255],
      [255, 229, 210, 255],
      [255, 231, 213, 255],
      [255, 233, 216, 255],
      [255, 235, 219, 255],
      [255, 237, 223, 255],
      [255, 239, 226, 255],
      [255, 240, 229, 255],
      [255, 242, 232, 255],
      [255, 244, 236, 255],
      [255, 246, 239, 255],
      [255, 248, 242, 255],
      [255, 250, 245, 255],
      [255, 251, 249, 255],
      [255, 253, 252, 255],
      [255, 255, 255, 255]
    ]
  },
  pet20Step: {
    name: "PET 20 Step",
    numColors: 256,
    colors: [
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [0, 0, 0, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [96, 0, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 80, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [48, 48, 112, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [80, 80, 128, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [96, 96, 176, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [112, 112, 192, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [128, 128, 224, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 96, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [48, 144, 48, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [80, 192, 80, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [64, 224, 64, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [224, 224, 80, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 208, 96, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 176, 64, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [208, 144, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [192, 96, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [176, 48, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 0, 0, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255],
      [255, 255, 255, 255]
    ]
  },
  gray: {
    name: "Gray",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [1, 1, 1]
      ]
    }
  },
  jet: {
    name: "Jet",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.35, 0, 0],
        [0.66, 1, 1],
        [0.89, 1, 1],
        [1, 0.5, 0.5]
      ],
      green: [
        [0, 0, 0],
        [0.125, 0, 0],
        [0.375, 1, 1],
        [0.64, 1, 1],
        [0.91, 0, 0],
        [1, 0, 0]
      ],
      blue: [
        [0, 0.5, 0.5],
        [0.11, 1, 1],
        [0.34, 1, 1],
        [0.65, 0, 0],
        [1, 0, 0]
      ]
    }
  },
  hsv: {
    name: "HSV",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [0.15873, 1, 1],
        [0.174603, 0.96875, 0.96875],
        [0.333333, 0.03125, 0.03125],
        [0.349206, 0, 0],
        [0.666667, 0, 0],
        [0.68254, 0.03125, 0.03125],
        [0.84127, 0.96875, 0.96875],
        [0.857143, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.15873, 0.9375, 0.9375],
        [0.174603, 1, 1],
        [0.507937, 1, 1],
        [0.666667, 0.0625, 0.0625],
        [0.68254, 0, 0],
        [1, 0, 0]
      ],
      blue: [
        [0, 0, 0],
        [0.333333, 0, 0],
        [0.349206, 0.0625, 0.0625],
        [0.507937, 1, 1],
        [0.84127, 1, 1],
        [0.857143, 0.9375, 0.9375],
        [1, 0.09375, 0.09375]
      ]
    }
  },
  hot: {
    name: "Hot",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.0416, 0.0416],
        [0.365079, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.365079, 0, 0],
        [0.746032, 1, 1],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [0.746032, 0, 0],
        [1, 1, 1]
      ]
    }
  },
  cool: {
    name: "Cool",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 1, 1],
        [1, 0, 0]
      ],
      blue: [
        [0, 1, 1],
        [1, 1, 1]
      ]
    }
  },
  spring: {
    name: "Spring",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 1, 1],
        [1, 0, 0]
      ]
    }
  },
  summer: {
    name: "Summer",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      green: [
        [0, 0.5, 0.5],
        [1, 1, 1]
      ],
      blue: [
        [0, 0.4, 0.4],
        [1, 0.4, 0.4]
      ]
    }
  },
  autumn: {
    name: "Autumn",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [1, 0, 0]
      ]
    }
  },
  winter: {
    name: "Winter",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [1, 0, 0]
      ],
      green: [
        [0, 0, 0],
        [1, 1, 1]
      ],
      blue: [
        [0, 1, 1],
        [1, 0.5, 0.5]
      ]
    }
  },
  bone: {
    name: "Bone",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.746032, 0.652778, 0.652778],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [0.365079, 0.319444, 0.319444],
        [0.746032, 0.777778, 0.777778],
        [1, 1, 1]
      ],
      blue: [
        [0, 0, 0],
        [0.365079, 0.444444, 0.444444],
        [1, 1, 1]
      ]
    }
  },
  copper: {
    name: "Copper",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.809524, 1, 1],
        [1, 1, 1]
      ],
      green: [
        [0, 0, 0],
        [1, 0.7812, 0.7812]
      ],
      blue: [
        [0, 0, 0],
        [1, 0.4975, 0.4975]
      ]
    }
  },
  spectral: {
    name: "Spectral",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0, 0],
        [0.05, 0.4667, 0.4667],
        [0.1, 0.5333, 0.5333],
        [0.15, 0, 0],
        [0.2, 0, 0],
        [0.25, 0, 0],
        [0.3, 0, 0],
        [0.35, 0, 0],
        [0.4, 0, 0],
        [0.45, 0, 0],
        [0.5, 0, 0],
        [0.55, 0, 0],
        [0.6, 0, 0],
        [0.65, 0.7333, 0.7333],
        [0.7, 0.9333, 0.9333],
        [0.75, 1, 1],
        [0.8, 1, 1],
        [0.85, 1, 1],
        [0.9, 0.8667, 0.8667],
        [0.95, 0.8, 0.8],
        [1, 0.8, 0.8]
      ],
      green: [
        [0, 0, 0],
        [0.05, 0, 0],
        [0.1, 0, 0],
        [0.15, 0, 0],
        [0.2, 0, 0],
        [0.25, 0.4667, 0.4667],
        [0.3, 0.6, 0.6],
        [0.35, 0.6667, 0.6667],
        [0.4, 0.6667, 0.6667],
        [0.45, 0.6, 0.6],
        [0.5, 0.7333, 0.7333],
        [0.55, 0.8667, 0.8667],
        [0.6, 1, 1],
        [0.65, 1, 1],
        [0.7, 0.9333, 0.9333],
        [0.75, 0.8, 0.8],
        [0.8, 0.6, 0.6],
        [0.85, 0, 0],
        [0.9, 0, 0],
        [0.95, 0, 0],
        [1, 0.8, 0.8]
      ],
      blue: [
        [0, 0, 0],
        [0.05, 0.5333, 0.5333],
        [0.1, 0.6, 0.6],
        [0.15, 0.6667, 0.6667],
        [0.2, 0.8667, 0.8667],
        [0.25, 0.8667, 0.8667],
        [0.3, 0.8667, 0.8667],
        [0.35, 0.6667, 0.6667],
        [0.4, 0.5333, 0.5333],
        [0.45, 0, 0],
        [0.5, 0, 0],
        [0.55, 0, 0],
        [0.6, 0, 0],
        [0.65, 0, 0],
        [0.7, 0, 0],
        [0.75, 0, 0],
        [0.8, 0, 0],
        [0.85, 0, 0],
        [0.9, 0, 0],
        [0.95, 0, 0],
        [1, 0.8, 0.8]
      ]
    }
  },
  coolwarm: {
    name: "CoolWarm",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.2298057, 0.2298057],
        [0.03125, 0.26623388, 0.26623388],
        [0.0625, 0.30386891, 0.30386891],
        [0.09375, 0.342804478, 0.342804478],
        [0.125, 0.38301334, 0.38301334],
        [0.15625, 0.424369608, 0.424369608],
        [0.1875, 0.46666708, 0.46666708],
        [0.21875, 0.509635204, 0.509635204],
        [0.25, 0.552953156, 0.552953156],
        [0.28125, 0.596262162, 0.596262162],
        [0.3125, 0.639176211, 0.639176211],
        [0.34375, 0.681291281, 0.681291281],
        [0.375, 0.722193294, 0.722193294],
        [0.40625, 0.761464949, 0.761464949],
        [0.4375, 0.798691636, 0.798691636],
        [0.46875, 0.833466556, 0.833466556],
        [0.5, 0.865395197, 0.865395197],
        [0.53125, 0.897787179, 0.897787179],
        [0.5625, 0.924127593, 0.924127593],
        [0.59375, 0.944468518, 0.944468518],
        [0.625, 0.958852946, 0.958852946],
        [0.65625, 0.96732803, 0.96732803],
        [0.6875, 0.969954137, 0.969954137],
        [0.71875, 0.966811177, 0.966811177],
        [0.75, 0.958003065, 0.958003065],
        [0.78125, 0.943660866, 0.943660866],
        [0.8125, 0.923944917, 0.923944917],
        [0.84375, 0.89904617, 0.89904617],
        [0.875, 0.869186849, 0.869186849],
        [0.90625, 0.834620542, 0.834620542],
        [0.9375, 0.795631745, 0.795631745],
        [0.96875, 0.752534934, 0.752534934],
        [1, 0.705673158, 0.705673158]
      ],
      green: [
        [0, 0.298717966, 0.298717966],
        [0.03125, 0.353094838, 0.353094838],
        [0.0625, 0.406535296, 0.406535296],
        [0.09375, 0.458757618, 0.458757618],
        [0.125, 0.50941904, 0.50941904],
        [0.15625, 0.558148092, 0.558148092],
        [0.1875, 0.604562568, 0.604562568],
        [0.21875, 0.648280772, 0.648280772],
        [0.25, 0.688929332, 0.688929332],
        [0.28125, 0.726149107, 0.726149107],
        [0.3125, 0.759599947, 0.759599947],
        [0.34375, 0.788964712, 0.788964712],
        [0.375, 0.813952739, 0.813952739],
        [0.40625, 0.834302879, 0.834302879],
        [0.4375, 0.849786142, 0.849786142],
        [0.46875, 0.860207984, 0.860207984],
        [0.5, 0.86541021, 0.86541021],
        [0.53125, 0.848937047, 0.848937047],
        [0.5625, 0.827384882, 0.827384882],
        [0.59375, 0.800927443, 0.800927443],
        [0.625, 0.769767752, 0.769767752],
        [0.65625, 0.734132809, 0.734132809],
        [0.6875, 0.694266682, 0.694266682],
        [0.71875, 0.650421156, 0.650421156],
        [0.75, 0.602842431, 0.602842431],
        [0.78125, 0.551750968, 0.551750968],
        [0.8125, 0.49730856, 0.49730856],
        [0.84375, 0.439559467, 0.439559467],
        [0.875, 0.378313092, 0.378313092],
        [0.90625, 0.312874446, 0.312874446],
        [0.9375, 0.24128379, 0.24128379],
        [0.96875, 0.157246067, 0.157246067],
        [1, 0.01555616, 0.01555616]
      ],
      blue: [
        [0, 0.753683153, 0.753683153],
        [0.03125, 0.801466763, 0.801466763],
        [0.0625, 0.84495867, 0.84495867],
        [0.09375, 0.883725899, 0.883725899],
        [0.125, 0.917387822, 0.917387822],
        [0.15625, 0.945619588, 0.945619588],
        [0.1875, 0.968154911, 0.968154911],
        [0.21875, 0.98478814, 0.98478814],
        [0.25, 0.995375608, 0.995375608],
        [0.28125, 0.999836203, 0.999836203],
        [0.3125, 0.998151185, 0.998151185],
        [0.34375, 0.990363227, 0.990363227],
        [0.375, 0.976574709, 0.976574709],
        [0.40625, 0.956945269, 0.956945269],
        [0.4375, 0.931688648, 0.931688648],
        [0.46875, 0.901068838, 0.901068838],
        [0.5, 0.865395561, 0.865395561],
        [0.53125, 0.820880546, 0.820880546],
        [0.5625, 0.774508472, 0.774508472],
        [0.59375, 0.726736146, 0.726736146],
        [0.625, 0.678007945, 0.678007945],
        [0.65625, 0.628751763, 0.628751763],
        [0.6875, 0.579375448, 0.579375448],
        [0.71875, 0.530263762, 0.530263762],
        [0.75, 0.481775914, 0.481775914],
        [0.78125, 0.434243684, 0.434243684],
        [0.8125, 0.387970225, 0.387970225],
        [0.84375, 0.343229596, 0.343229596],
        [0.875, 0.300267182, 0.300267182],
        [0.90625, 0.259301199, 0.259301199],
        [0.9375, 0.220525627, 0.220525627],
        [0.96875, 0.184115123, 0.184115123],
        [1, 0.150232812, 0.150232812]
      ]
    }
  },
  blues: {
    name: "Blues",
    numColors: 256,
    gamma: 1,
    segmentedData: {
      red: [
        [0, 0.9686274528503418, 0.9686274528503418],
        [0.125, 0.8705882430076599, 0.8705882430076599],
        [0.25, 0.7764706015586853, 0.7764706015586853],
        [0.375, 0.6196078658103943, 0.6196078658103943],
        [0.5, 0.41960784792900085, 0.41960784792900085],
        [0.625, 0.25882354378700256, 0.25882354378700256],
        [0.75, 0.12941177189350128, 0.12941177189350128],
        [0.875, 0.0313725508749485, 0.0313725508749485],
        [1, 0.0313725508749485, 0.0313725508749485]
      ],
      green: [
        [0, 0.9843137264251709, 0.9843137264251709],
        [0.125, 0.9215686321258545, 0.9215686321258545],
        [0.25, 0.8588235378265381, 0.8588235378265381],
        [0.375, 0.7921568751335144, 0.7921568751335144],
        [0.5, 0.6823529601097107, 0.6823529601097107],
        [0.625, 0.572549045085907, 0.572549045085907],
        [0.75, 0.4431372582912445, 0.4431372582912445],
        [0.875, 0.3176470696926117, 0.3176470696926117],
        [1, 0.1882352977991104, 0.1882352977991104]
      ],
      blue: [
        [0, 1, 1],
        [0.125, 0.9686274528503418, 0.9686274528503418],
        [0.25, 0.9372549057006836, 0.9372549057006836],
        [0.375, 0.8823529481887817, 0.8823529481887817],
        [0.5, 0.8392156958580017, 0.8392156958580017],
        [0.625, 0.7764706015586853, 0.7764706015586853],
        [0.75, 0.7098039388656616, 0.7098039388656616],
        [0.875, 0.6117647290229797, 0.6117647290229797],
        [1, 0.41960784792900085, 0.41960784792900085]
      ]
    }
  }
};
var cpuColormaps_default = colormapsData;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/rendering.js
var RENDERING_DEFAULTS = {
  MINIMUM_SLAB_THICKNESS: 0.05,
  MAXIMUM_RAY_DISTANCE: 1e6
};
Object.freeze(RENDERING_DEFAULTS);
var rendering_default = RENDERING_DEFAULTS;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/epsilon.js
var EPSILON = 0.001;
var epsilon_default = EPSILON;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepFreeze.js
function deepFreeze(object) {
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
var deepFreeze_default = deepFreeze;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/mprCameraValues.js
var MPR_CAMERA_VALUES = {
  axial: {
    viewPlaneNormal: [0, 0, -1],
    viewUp: [0, -1, 0],
    viewRight: [1, 0, 0]
  },
  sagittal: {
    viewPlaneNormal: [1, 0, 0],
    viewUp: [0, 0, 1],
    viewRight: [0, 1, 0]
  },
  coronal: {
    viewPlaneNormal: [0, -1, 0],
    viewUp: [0, 0, 1],
    viewRight: [1, 0, 0]
  }
};
var mprCameraValues = deepFreeze_default(MPR_CAMERA_VALUES);
var mprCameraValues_default = mprCameraValues;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/viewportPresets.js
var presets = [
  {
    name: "CT-AAA",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-AAA2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Bone",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Bones",
    gradientOpacity: "4 0 1 985.12 1",
    specularPower: "1",
    scalarOpacity: "8 -1000 0 152.19 0 278.93 0.190476 952 0.2",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cardiac3",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Chest-Contrast-Enhanced",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Chest-Vessels",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries-2",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Coronary-Arteries-3",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Cropped-Volume-Bone",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -2048 0 -451 0 -450 1 1050 1 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Fat",
    gradientOpacity: "6 0 1 985.12 1 988 1",
    specularPower: "1",
    scalarOpacity: "14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Liver-Vasculature",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Lung",
    gradientOpacity: "6 0 1 985.12 1 988 1",
    specularPower: "1",
    scalarOpacity: "12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-MIP",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0 -637.62 0 700 1 3071 1",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Muscle",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "CT-Pulmonary-Arteries",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Soft-Tissue",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "10 -2048 0 -167.01 0 -160 1 240 1 3661 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "CT-Air",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "10",
    scalarOpacity: "8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0",
    specular: "0.2",
    shade: "1",
    ambient: "0.1",
    colorTransfer: "16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ",
    diffuse: "0.9",
    interpolation: "1"
  },
  {
    name: "MR-Angio",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-Default",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5",
    specular: "0",
    shade: "1",
    ambient: "0.2",
    colorTransfer: "24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-MIP",
    gradientOpacity: "4 0 1 255 1",
    specularPower: "1",
    scalarOpacity: "8 0 0 98.3725 0 416.637 1 2800 1",
    specular: "0",
    shade: "0",
    ambient: "0.2",
    colorTransfer: "16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1",
    diffuse: "1",
    interpolation: "1"
  },
  {
    name: "MR-T2-Brain",
    gradientOpacity: "4 0 1 160.25 1",
    specularPower: "40",
    scalarOpacity: "10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1",
    specular: "0.5",
    shade: "1",
    ambient: "0.3",
    colorTransfer: "16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1",
    diffuse: "0.6",
    interpolation: "1"
  },
  {
    name: "DTI-FA-Brain",
    gradientOpacity: "4 0 1 0.9950 1",
    specularPower: "40",
    scalarOpacity: "16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0",
    specular: "0.5",
    shade: "1",
    ambient: "0.3",
    colorTransfer: "28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0",
    diffuse: "0.9",
    interpolation: "1"
  }
];
var viewportPresets_default = presets;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/backgroundColors.js
var backgroundColors = {
  slicer3D: [160 / 255, 164 / 255, 217 / 255]
};
var backgroundColors_default = backgroundColors;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/renderingEngineCache.js
var cache = {};
var renderingEngineCache = {
  get: (id) => {
    return cache[id];
  },
  set: (re) => {
    const renderingEngineId = re.id;
    cache[renderingEngineId] = re;
  },
  delete: (id) => {
    return delete cache[id];
  },
  getAll: () => {
    const renderingEngineIds = Object.keys(cache);
    const renderingEngines = renderingEngineIds.map((id) => cache[id]);
    renderingEngines.sort((a, b) => {
      if (a.id[0] === "_" && b.id[0] !== "_") {
        return 1;
      } else if (a.id[0] !== "_" && b.id[0] === "_") {
        return -1;
      } else {
        return 0;
      }
    });
    return renderingEngines;
  }
};
var renderingEngineCache_default = renderingEngineCache;

// ../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
class CornerstoneEventTarget {
  constructor() {
    this.listeners = {};
    this.debouncedListeners = {};
  }
  reset() {
    this.listeners = {};
    this.debouncedListeners = {};
  }
  addEventListenerOnce(type, callback) {
    const onceWrapper = (event) => {
      this.removeEventListener(type, onceWrapper);
      callback.call(this, event);
    };
    this.addEventListener(type, onceWrapper);
  }
  addEventListener(type, callback) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    if (this.listeners[type].indexOf(callback) !== -1) {
      return;
    }
    this.listeners[type].push(callback);
  }
  addEventListenerDebounced(type, callback, delay) {
    this.debouncedListeners[type] = this.debouncedListeners[type] || {};
    const debouncedCallbacks = this.debouncedListeners[type];
    if (!debouncedCallbacks[callback]) {
      const handle = (event) => {
        if (debouncedCallbacks[callback]) {
          clearTimeout(debouncedCallbacks[callback].timeoutId);
        }
        debouncedCallbacks[callback].timeoutId = setTimeout(() => {
          callback.call(this, event);
        }, delay);
      };
      debouncedCallbacks[callback] = {
        original: callback,
        handle,
        timeoutId: null
      };
      this.addEventListener(type, handle);
    }
  }
  removeEventListenerDebounced(type, callback) {
    if (this.debouncedListeners[type]?.[callback]) {
      const debounced = this.debouncedListeners[type][callback];
      this.removeEventListener(type, debounced.handle);
      clearTimeout(debounced.timeoutId);
      delete this.debouncedListeners[type][callback];
    }
  }
  removeEventListener(type, callback) {
    if (!this.listeners[type]) {
      return;
    }
    const stack = this.listeners[type];
    const stackLength = stack.length;
    for (let i = 0;i < stackLength; i++) {
      if (stack[i] === callback) {
        stack.splice(i, 1);
        return;
      }
    }
  }
  dispatchEvent(event) {
    if (!this.listeners[event.type]) {
      return !event.defaultPrevented;
    }
    const stack = this.listeners[event.type].slice();
    const stackLength = stack.length;
    for (let i = 0;i < stackLength; i++) {
      try {
        stack[i].call(this, event);
      } catch (error) {
        console.error(`error in event listener of type:  ${event.type}`, error);
      }
    }
    return !event.defaultPrevented;
  }
}
var eventTarget = new CornerstoneEventTarget;
var eventTarget_default = eventTarget;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
function uuidv4() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  return ([1e7] + -1000 + -4000 + -8000 + -100000000000).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
function triggerEvent(el = eventTarget_default, type, detail = null) {
  if (!type) {
    throw new Error("Event type was not defined");
  }
  const event = new CustomEvent(type, {
    detail,
    cancelable: true
  });
  return el?.dispatchEvent(event);
}

// ../../node_modules/@kitware/vtk.js/macros.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal(), 1);

// ../../node_modules/@kitware/vtk.js/vtk.js
var import_globalthis = __toESM(require_globalthis(), 1);
var vtkGlobal = import_globalthis.default();
var factoryMapping = {
  vtkObject: () => null
};
function vtk(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (obj.isA) {
    return obj;
  }
  if (!obj.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("Invalid VTK object");
    }
    return null;
  }
  const constructor = factoryMapping[obj.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error(`No vtk class found for Object of type ${obj.vtkClass}`);
    }
    return null;
  }
  const model = {
    ...obj
  };
  Object.keys(model).forEach((keyName) => {
    if (model[keyName] && typeof model[keyName] === "object" && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });
  const newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}
vtk.register = register;

// ../../node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js
class ClassHierarchy extends Array {
  push() {
    for (let i = 0;i < arguments.length; i++) {
      if (!this.includes(arguments[i])) {
        super.push(arguments[i]);
      }
    }
    return this.length;
  }
}

// ../../node_modules/@kitware/vtk.js/macros2.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
var globalMTime = 0;
var VOID = Symbol("void");
function getCurrentGlobalMTime() {
  return globalMTime;
}
var fakeConsole = {};
function noOp() {
}
var consoleMethods = ["log", "debug", "info", "warn", "error", "time", "timeEnd", "group", "groupEnd"];
consoleMethods.forEach((methodName) => {
  fakeConsole[methodName] = noOp;
});
vtkGlobal.console = console.hasOwnProperty("log") ? console : fakeConsole;
var loggerFunctions = {
  debug: noOp,
  error: vtkGlobal.console.error || noOp,
  info: vtkGlobal.console.info || noOp,
  log: vtkGlobal.console.log || noOp,
  warn: vtkGlobal.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log(...arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info(...arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug(...arguments);
}
function vtkErrorMacro() {
  loggerFunctions.error(...arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn(...arguments);
}
var ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
}
var TYPED_ARRAYS = Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
try {
  TYPED_ARRAYS.BigInt64Array = BigInt64Array;
  TYPED_ARRAYS.BigUint64Array = BigUint64Array;
} catch {
}
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return new (TYPED_ARRAYS[type] || Float64Array)(...args);
}
function newTypedArrayFrom(type) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (TYPED_ARRAYS[type] || Float64Array).from(...args);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function _capitalize(str) {
  return capitalize(str[0] === "_" ? str.slice(1) : str);
}
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function formatBytesToProperUnit(size) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  let chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  const units = ["TB", "GB", "MB", "KB"];
  let value = Number(size);
  let currentUnit = "B";
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return `${value.toFixed(precision)} ${currentUnit}`;
}
function formatNumbersWithThousandSeparator(n) {
  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : " ";
  const sections = [];
  let size = n;
  while (size > 1000) {
    sections.push(`000${size % 1000}`.slice(-3));
    size = Math.floor(size / 1000);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join(separator);
}
function safeArrays(model) {
  Object.keys(model).forEach((key) => {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function isTypedArray(value) {
  return Object.values(TYPED_ARRAYS).some((ctor) => value instanceof ctor);
}
function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0;i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function enumToString(e, value) {
  return Object.keys(e).find((key) => e[key] === value);
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}
function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}
function measurePromiseExecution(promise, callback) {
  const start = performance.now();
  promise.finally(() => {
    const delta = performance.now() - start;
    callback(delta);
  });
}
function obj() {
  let publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  safeArrays(model);
  const callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!("classHierarchy" in model)) {
    model.classHierarchy = new ClassHierarchy("vtkObject");
  } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
    const hierarchy = new ClassHierarchy;
    for (let i = 0;i < model.classHierarchy.length; i++) {
      hierarchy.push(model.classHierarchy[i]);
    }
    model.classHierarchy = hierarchy;
  }
  function off(index) {
    callbacks[index] = null;
  }
  function on(index) {
    function unsubscribe() {
      off(index);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = () => !!model.deleted;
  publicAPI.modified = (otherMTime) => {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach((callback) => callback && callback(publicAPI));
  };
  publicAPI.onModified = (callback) => {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    const index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };
  publicAPI.getMTime = () => model.mtime;
  publicAPI.isA = (className) => {
    let count = model.classHierarchy.length;
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function() {
    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function() {
    let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let ret = false;
    Object.keys(map).forEach((name) => {
      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn(...map[name]) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        if (["mtime"].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map[name]}`);
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function() {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0;_key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    const subset = {};
    list.forEach((name) => {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = (val) => model[val];
  publicAPI.delete = () => {
    Object.keys(model).forEach((field) => delete model[field]);
    callbacks.forEach((el, index) => off(index));
    model.deleted = true;
  };
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };
    Object.keys(jsonArchive).forEach((keyName) => {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === "_") {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      } else if (isTypedArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
      }
    });
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach((name) => {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
    }
    const otherModel = other.get();
    const keyList = Object.keys(model).sort();
    const otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach((key) => {
      const keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro(`add ${key} in shallowCopy`);
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro(`Untouched keys: ${keyList.join(", ")}`);
    }
    publicAPI.modified();
  };
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };
  return publicAPI;
}
var objectGetterMap = {
  object(publicAPI, model, field) {
    return function getter() {
      return {
        ...model[field.name]
      };
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    if (typeof field === "object") {
      const getter = objectGetterMap[field.type];
      if (getter) {
        publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
      } else {
        publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
      }
    } else {
      publicAPI[`get${_capitalize(field)}`] = () => model[field];
    }
  });
}
var objectSetterMap = {
  enum(publicAPI, model, field) {
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return (value) => {
      if (typeof value === "string") {
        if (field.enum[value] !== undefined) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro(`Set Enum with invalid argument ${field}, ${value}`);
        throw new RangeError("Set Enum with invalid string argument");
      }
      if (typeof value === "number") {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map((key) => field.enum[key]).indexOf(value) !== -1) {
            const previousValue = model[field.name];
            model[field.name] = value;
            model[onChanged]?.(publicAPI, model, value, previousValue);
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro(`Set Enum outside numeric range ${field}, ${value}`);
          throw new RangeError("Set Enum outside numeric range");
        }
        return false;
      }
      vtkErrorMacro(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
      throw new TypeError("Set Enum with invalid argument (String/Number)");
    };
  },
  object(publicAPI, model, field) {
    if (field.params?.length === 1) {
      vtkWarningMacro('Setter of type "object" with a single "param" field is not supported');
    }
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;_key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      let value;
      if (args.length > 1 && field.params?.length) {
        value = field.params.reduce((acc, prop, idx) => Object.assign(acc, {
          [prop]: args[idx]
        }), {});
      } else {
        value = args[0];
      }
      if (!import_fast_deep_equal.default(model[field.name], value)) {
        const previousValue = model[field.name];
        model[field.name] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  }
};
function findSetter(field) {
  if (typeof field === "object") {
    const fn = objectSetterMap[field.type];
    if (fn) {
      return (publicAPI, model) => fn(publicAPI, model, field);
    }
    vtkErrorMacro(`No setter for field ${field}`);
    throw new TypeError("No setter for field");
  }
  return function getSetter(publicAPI, model) {
    const onChanged = `_on${_capitalize(field)}Changed`;
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro("instance deleted - cannot call any method");
        return false;
      }
      if (model[field] !== value) {
        const previousValue = model[field.name];
        model[field] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set(publicAPI, model, fields) {
  fields.forEach((field) => {
    if (typeof field === "object") {
      publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
    }
  });
}
function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}
function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
    publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
  });
}
function setArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  fieldNames.forEach((field) => {
    if (model[field] && size && model[field].length !== size) {
      throw new RangeError(`Invalid initial number of values for array (${field})`);
    }
    const onChanged = `_on${_capitalize(field)}Changed`;
    publicAPI[`set${_capitalize(field)}`] = function() {
      if (model.deleted) {
        vtkErrorMacro("instance deleted - cannot call any method");
        return false;
      }
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0;_key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      let array = args;
      let changeDetected;
      let needCopy = false;
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        array = array[0];
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size && array.length !== size) {
          if (array.length < size && defaultVal !== undefined) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size)
              array.push(defaultVal);
          } else {
            throw new RangeError(`Invalid number of values for array setter (${field})`);
          }
        }
        changeDetected = model[field] == null || model[field].length !== array.length;
        for (let i = 0;!changeDetected && i < array.length; ++i) {
          changeDetected = model[field][i] !== array[i];
        }
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        const previousValue = model[field.name];
        model[field] = array;
        model[onChanged]?.(publicAPI, model, array, previousValue);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI[`set${_capitalize(field)}From`] = (otherArray) => {
      const target = model[field];
      otherArray.forEach((v, i) => {
        target[i] = v;
      });
    };
  });
}
function setGetArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (let i = 0;i < fieldNames.length; i++) {
    const fieldName = fieldNames[i];
    if (model[fieldName] !== undefined) {
      model[`_${fieldName}`] = model[fieldName];
      delete model[fieldName];
    }
  }
}
function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(vtk);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(vtk);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(vtk);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
  } else {
    model.inputArrayToProcess = [];
  }
  model.numberOfInputs = numberOfInputs;
  function setInputData(dataset) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      let msg = `algorithm ${publicAPI.getClassName()} only has `;
      msg += `${model.numberOfInputs}`;
      msg += " input ports. To add more input ports, use addInputConnection()";
      vtkErrorMacro(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    let portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = () => {
    const localMTime = publicAPI.getMTime();
    let minOutputMTime = Infinity;
    let count = numberOfOutputs;
    while (count--) {
      if (!model.output[count] || model.output[count].isDeleted()) {
        return true;
      }
      const mt = model.output[count].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count = model.numberOfInputs;
    while (count--) {
      if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const outputPortAccess = () => getOutputData(port);
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }
  if (model.numberOfInputs) {
    let count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = () => {
    const ins = [];
    if (model.numberOfInputs) {
      let count = 0;
      while (count < model.numberOfInputs) {
        ins[count] = publicAPI.getInputData(count);
        count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
  publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
  publicAPI.getInputArrayToProcess = (inputPort) => {
    const arrayDesc = model.inputArrayToProcess[inputPort];
    const ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function(inputPort, arrayName, fieldAssociation) {
    let attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "Scalars";
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}
var EVENT_ABORT = Symbol("Event abort");
function event(publicAPI, model, eventName) {
  const callbacks = [];
  const previousDelete = publicAPI.delete;
  let curCallbackID = 1;
  function off(callbackID) {
    for (let i = 0;i < callbacks.length; ++i) {
      const [cbID] = callbacks[i];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }
  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    const currentCallbacks = callbacks.slice();
    for (let index = 0;index < currentCallbacks.length; ++index) {
      const [, cb, priority] = currentCallbacks[index];
      if (!cb) {
        continue;
      }
      if (priority < 0) {
        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
      } else {
        const continueNext = cb.apply(publicAPI, arguments);
        if (continueNext === EVENT_ABORT) {
          break;
        }
      }
    }
  }
  publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
  publicAPI[`on${_capitalize(eventName)}`] = function(callback) {
    let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!callback.apply) {
      console.error(`Invalid callback for event ${eventName}`);
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    const callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
    return on(callbackID);
  };
  publicAPI.delete = () => {
    previousDelete();
    callbacks.forEach((_ref) => {
      let [cbID] = _ref;
      return off(cbID);
    });
  };
}
function newInstance(extend, className) {
  const constructor = function() {
    let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const model = {};
    const publicAPI = {};
    extend(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };
  if (className) {
    vtk.register(className, constructor);
  }
  return constructor;
}
function chain() {
  for (var _len6 = arguments.length, fn = new Array(_len6), _key6 = 0;_key6 < _len6; _key6++) {
    fn[_key6] = arguments[_key6];
  }
  return function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0;_key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return fn.filter((i) => !!i).map((i) => i(...args));
  };
}
function isVtkObject(instance) {
  return instance && instance.isA && instance.isA("vtkObject");
}
function traverseInstanceTree(instance, extractFunction) {
  let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  let visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      return accumulator;
    }
    visitedInstances.push(instance);
    const result = extractFunction(instance);
    if (result !== undefined) {
      accumulator.push(result);
    }
    const model = instance.get();
    Object.keys(model).forEach((key) => {
      const modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach((subObj) => {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}
function debounce(func, wait, immediate) {
  var _this = this;
  let timeout;
  const debounced = function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0;_key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    const context = _this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = () => clearTimeout(timeout);
  return debounced;
}
function throttle(callback, delay) {
  let isThrottled = false;
  let argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper(...argsToUse);
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0;_key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback(...args);
    setTimeout(next, delay);
  }
  return wrapper;
}
function keystore(publicAPI, model) {
  let initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = (key, value) => {
    model.keystore[key] = value;
  };
  publicAPI.getKey = (key) => model.keystore[key];
  publicAPI.getAllKeys = () => Object.keys(model.keystore);
  publicAPI.deleteKey = (key) => delete model.keystore[key];
  publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach((key) => delete model.keystore[key]);
}
var nextProxyId = 1;
var ROOT_GROUP_NAME = "__root__";
function proxy(publicAPI, model) {
  keystore(publicAPI, model);
  const parentDelete = publicAPI.delete;
  model.proxyId = `${nextProxyId++}`;
  model.ui = JSON.parse(JSON.stringify(model.ui || []));
  get(publicAPI, model, ["proxyId", "proxyGroup", "proxyName"]);
  setGet(publicAPI, model, ["proxyManager"]);
  const propertyMap = {};
  const groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    const childrenNames = groupChildrenNames[currentGroupName];
    for (let i = 0;i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = (ui) => {
    model.ui = JSON.parse(JSON.stringify(ui || []));
    Object.keys(propertyMap).forEach((k) => delete propertyMap[k]);
    Object.keys(groupChildrenNames).forEach((k) => delete groupChildrenNames[k]);
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    let gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = (propertyName, propUI) => {
    const prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = {
        ...propUI
      };
    }
  };
  publicAPI.activate = () => {
    if (model.proxyManager) {
      const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = (type) => {
    const subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function(id) {
    let persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    let value = null;
    const links = [];
    let count = 0;
    let updateInProgress = false;
    function update(source) {
      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      const needUpdate = [];
      let sourceLink = null;
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          const linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set({
            [linkToUpdate.propertyName]: value
          });
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      const indexToDelete = [];
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind(instance, propertyName) {
      let updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const subscription = instance.onModified(update);
      const other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {
          instance.set({
            [propertyName]: model.propertyLinkMap[id].value
          });
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: () => unbind(instance, propertyName)
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    const linkHandler = {
      bind,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };
  function getProperties() {
    let groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    const values = [];
    const id = model.proxyId;
    const propertyNames = listProxyProperties(groupName) || [];
    for (let i = 0;i < propertyNames.length; i++) {
      const name = propertyNames[i];
      const method = publicAPI[`get${_capitalize(name)}`];
      const value = method ? method() : undefined;
      const prop = {
        id,
        name,
        value
      };
      const children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = () => getProperties().map((p) => p.name);
  publicAPI.getPropertyByName = (name) => getProperties().find((p) => p.name === name);
  publicAPI.getPropertyDomainByName = (name) => (propertyMap[name] || {}).domain;
  publicAPI.getProxySection = () => ({
    id: model.proxyId,
    name: model.proxyGroup,
    ui: model.ui,
    properties: getProperties()
  });
  publicAPI.delete = () => {
    const list = Object.keys(model.propertyLinkMap);
    let count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };
  publicAPI.getState = () => null;
  function registerLinks() {
    if (model.links) {
      for (let i = 0;i < model.links.length; i++) {
        const {
          link,
          property,
          persistent,
          updateOnBind,
          type
        } = model.links[i];
        if (type === "application") {
          const sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, "application");
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}
function proxyPropertyMapping(publicAPI, model, map) {
  const parentDelete = publicAPI.delete;
  const subscriptions = [];
  const propertyNames = Object.keys(map);
  let count = propertyNames.length;
  while (count--) {
    const propertyName = propertyNames[count];
    const {
      modelKey,
      property,
      modified = true
    } = map[propertyName];
    const methodSrc = _capitalize(property);
    const methodDst = _capitalize(propertyName);
    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}
function proxyPropertyState(publicAPI, model) {
  let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    const modelKeys2 = Object.keys(map);
    let count2 = modelKeys2.length;
    while (count2--) {
      const modelKey = modelKeys2[count2];
      model[modelKey].set(map[modelKey]);
    }
  }
  const modelKeys = Object.keys(defaults);
  let count = modelKeys.length;
  while (count--) {
    const key = modelKeys[count];
    model[key] = defaults[key];
    const mapping = state[key];
    publicAPI[`set${_capitalize(key)}`] = (value) => {
      if (value !== model[key]) {
        model[key] = value;
        const propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  }
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  let sX = 0;
  let sY = 0;
  let pX = 0;
  let pY = 0;
  if ("detail" in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ("wheelDelta" in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ("wheelDeltaY" in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }
  if ("axis" in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ("deltaX" in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY || sX,
    pixelX: pX,
    pixelY: pY || pX
  };
}
var macro = {
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  measurePromiseExecution,
  moveToProtected,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  uncapitalize,
  VOID,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro,
  objectSetterMap
};
var macro$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  VOID,
  setLoggerFunction,
  vtkLogMacro,
  vtkInfoMacro,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro,
  vtkOnceErrorMacro,
  TYPED_ARRAYS,
  newTypedArray,
  newTypedArrayFrom,
  capitalize,
  _capitalize,
  uncapitalize,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  setImmediateVTK,
  measurePromiseExecution,
  obj,
  get,
  set,
  setGet,
  getArray,
  setArray,
  setGetArray,
  moveToProtected,
  algo,
  EVENT_ABORT,
  event,
  newInstance,
  chain,
  isVtkObject,
  traverseInstanceTree,
  debounce,
  throttle,
  keystore,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  normalizeWheel,
  default: macro
});
// ../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var VtkDataTypes = {
  VOID: "",
  CHAR: "Int8Array",
  SIGNED_CHAR: "Int8Array",
  UNSIGNED_CHAR: "Uint8Array",
  UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
  SHORT: "Int16Array",
  UNSIGNED_SHORT: "Uint16Array",
  INT: "Int32Array",
  UNSIGNED_INT: "Uint32Array",
  FLOAT: "Float32Array",
  DOUBLE: "Float64Array"
};
var DefaultDataType = VtkDataTypes.FLOAT;
var Constants2 = {
  DefaultDataType,
  DataTypeByteSize,
  VtkDataTypes
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js
var DEFAULT_VIEW_API = "WebGL";
var VIEW_CONSTRUCTORS = Object.create(null);
function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}
function vtkRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindow");
  publicAPI.addRenderer = (renderer) => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);
    publicAPI.modified();
  };
  publicAPI.removeRenderer = (renderer) => {
    model.renderers = model.renderers.filter((r) => r !== renderer);
    publicAPI.modified();
  };
  publicAPI.hasRenderer = (ren) => model.renderers.indexOf(ren) !== -1;
  publicAPI.newAPISpecificView = function(name) {
    let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };
  publicAPI.addView = (view) => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model._views.push(view);
    publicAPI.modified();
  };
  publicAPI.removeView = (view) => {
    model._views = model._views.filter((r) => r !== view);
    publicAPI.modified();
  };
  publicAPI.hasView = (view) => model._views.indexOf(view) !== -1;
  publicAPI.preRender = () => {
    model.renderers.forEach((ren) => {
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = () => {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model._views.forEach((view) => view.traverseAllPasses());
    }
  };
  publicAPI.getStatistics = () => {
    const results = {
      propCount: 0,
      invisiblePropCount: 0,
      gpuMemoryMB: 0
    };
    model._views.forEach((v) => {
      if (v.getGraphicsMemoryInfo)
        results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
    });
    model.renderers.forEach((ren) => {
      const props = ren.getViewProps();
      const gren = model._views[0].getViewNodeFor(ren);
      props.forEach((prop) => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const gmpr = gren.getViewNodeFor(mpr);
            if (gmpr) {
              if (gmpr.getAllocatedGPUMemoryInBytes) {
                results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
              }
              const pcount = mpr.getPrimitiveCount();
              Object.keys(pcount).forEach((keyName) => {
                if (!results[keyName]) {
                  results[keyName] = 0;
                }
                results[keyName] += pcount[keyName];
              });
            }
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map((keyName) => `${keyName}: ${results[keyName]}`).join(`
`);
    return results;
  };
  publicAPI.captureImages = function() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png";
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    macro.setImmediate(publicAPI.render);
    return model._views.map((view) => view.captureNextImage ? view.captureNextImage(format, opts) : undefined).filter((i) => !!i);
  };
  publicAPI.addRenderWindow = (child) => {
    if (model.childRenderWindows.includes(child)) {
      return false;
    }
    model.childRenderWindows.push(child);
    publicAPI.modified();
    return true;
  };
  publicAPI.removeRenderWindow = (child) => {
    const childIndex = model.childRenderWindows.findIndex((x) => x === child);
    if (childIndex < 0) {
      return false;
    }
    model.childRenderWindows.splice(childIndex, 1);
    publicAPI.modified();
    return true;
  };
}
var DEFAULT_VALUES = {
  defaultViewAPI: DEFAULT_VIEW_API,
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
  childRenderWindows: []
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["interactor", "numberOfLayers", "_views", "defaultViewAPI"]);
  macro.get(publicAPI, model, ["neverRendered"]);
  macro.getArray(publicAPI, model, ["renderers", "childRenderWindows"]);
  macro.moveToProtected(publicAPI, model, ["views"]);
  macro.event(publicAPI, model, "completion");
  vtkRenderWindow(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkRenderWindow");
var vtkRenderWindow$1 = {
  newInstance: newInstance2,
  extend,
  registerViewConstructor,
  listViewAPIs,
  newAPISpecificView
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
var Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants3 = {
  Wrap,
  Filter
};

// ../../node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
function toHalf(val) {
  floatView[0] = val;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e === 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  const s = (h & 32768) >> 15;
  const e = (h & 31744) >> 10;
  const f = h & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
  }
  if (e === 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
}
var HalfFloat = {
  fromHalf,
  toHalf
};

// ../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);

// ../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js
var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
var EPSILON2 = 0.000001;
var VTK_SMALL_NUMBER = 0.000000000001;

// ../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var {
  vtkErrorMacro: vtkErrorMacro2,
  vtkWarningMacro: vtkWarningMacro2
} = macro;
var randomSeedValue = 0;
var VTK_MAX_ROTATIONS = 20;
function notImplemented(method) {
  return () => vtkErrorMacro2(`vtkMath::${method} - NOT IMPLEMENTED`);
}
function swapRowsMatrix_nxn(matrix, n, row1, row2) {
  let tmp;
  for (let i = 0;i < n; i++) {
    tmp = matrix[row1 * n + i];
    matrix[row1 * n + i] = matrix[row2 * n + i];
    matrix[row2 * n + i] = tmp;
  }
}
function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
  let tmp;
  for (let i = 0;i < n; i++) {
    tmp = matrix[i * n + column1];
    matrix[i * n + column1] = matrix[i * n + column2];
    matrix[i * n + column2] = tmp;
  }
}
function createArray() {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
  const res = Array(size);
  for (let i = 0;i < size; ++i) {
    res[i] = 0;
  }
  return res;
}
var Pi = () => Math.PI;
function ldexp(x, exponent) {
  if (exponent > 1023) {
    return x * 2 ** 1023 * 2 ** (exponent - 1023);
  }
  if (exponent < -1074) {
    return x * 2 ** -1074 * 2 ** (exponent + 1074);
  }
  return x * 2 ** exponent;
}
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
var {
  round,
  floor,
  ceil,
  min,
  max
} = Math;
function arrayMin(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  for (let i = offset, len = arr.length;i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length;i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length;i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return [minValue, maxValue];
}
var ceilLog2 = notImplemented("ceilLog2");
var factorial = notImplemented("factorial");
function nearestPowerOfTwo(xi) {
  let v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  let r = 1;
  for (let i = 1;i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }
  const r = createArray(n);
  for (let i = 0;i < n; ++i) {
    r[i] = i;
  }
  return r;
}
function nextCombination(m, n, r) {
  let status = 0;
  for (let i = n - 1;i >= 0; --i) {
    if (r[i] < m - n + i) {
      let j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  import_seedrandom.default(`${seed}`, {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  let minValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let maxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  const delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
var gaussian = notImplemented("gaussian");
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  out_3x3[0] = x[0] * y[0];
  out_3x3[1] = x[0] * y[1];
  out_3x3[2] = x[0] * y[2];
  out_3x3[3] = x[1] * y[0];
  out_3x3[4] = x[1] * y[1];
  out_3x3[5] = x[1] * y[2];
  out_3x3[6] = x[2] * y[0];
  out_3x3[7] = x[2] * y[1];
  out_3x3[8] = x[2] * y[2];
}
function cross(x, y, out) {
  const Zx = x[1] * y[2] - x[2] * y[1];
  const Zy = x[2] * y[0] - x[0] * y[2];
  const Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default: {
      let sum = 0;
      for (let i = 0;i < n; i++) {
        sum += x[i] * x[i];
      }
      return Math.sqrt(sum);
    }
  }
}
function normalize(x) {
  const den = norm(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}
function perpendiculars(x, y, z, theta) {
  const x2 = x[0] * x[0];
  const y22 = x[1] * x[1];
  const z2 = x[2] * x[2];
  const r = Math.sqrt(x2 + y22 + z2);
  let dx;
  let dy2;
  let dz;
  if (x2 > y22 && x2 > z2) {
    dx = 0;
    dy2 = 1;
    dz = 2;
  } else if (y22 > z2) {
    dx = 1;
    dy2 = 2;
    dz = 0;
  } else {
    dx = 2;
    dy2 = 0;
    dz = 1;
  }
  const a = x[dx] / r;
  const b = x[dy2] / r;
  const c = x[dz] / r;
  const tmp = Math.sqrt(a * a + c * c);
  if (theta !== 0) {
    const sintheta = Math.sin(theta);
    const costheta = Math.cos(theta);
    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy2] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }
    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy2] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy2] = 0;
      y[dz] = -a / tmp;
    }
    if (z) {
      z[dx] = -a * b / tmp;
      z[dy2] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector(a, b, projection) {
  const bSquared = dot(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }
  const scale = dot(a, b) / bSquared;
  for (let i = 0;i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  const bSquared = dot2D(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }
  const scale = dot2D(a, b) / bSquared;
  for (let i = 0;i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function gaussianAmplitude(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  out_2x2[0] = x[0] * y[0];
  out_2x2[1] = x[0] * y[1];
  out_2x2[2] = x[1] * y[0];
  out_2x2[3] = x[1] * y[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  const den = norm2D(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  let maxI;
  let tmp;
  let largest;
  const scale = [0, 0, 0];
  for (let i = 0;i < 3; i++) {
    largest = Math.abs(mat_3x3[i * 3]);
    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
      largest = tmp;
    }
    scale[i] = 1 / largest;
  }
  largest = scale[0] * Math.abs(mat_3x3[0]);
  maxI = 0;
  if ((tmp = scale[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale[maxI] = scale[0];
  }
  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0];
  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale[1] * Math.abs(mat_3x3[4]);
  maxI = 1;
  if ((tmp = scale[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale[2] = scale[1];
  }
  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4];
  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  let sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];
  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  const a1 = mat_3x3[0];
  const b1 = mat_3x3[1];
  const c1 = mat_3x3[2];
  const a2 = mat_3x3[3];
  const b22 = mat_3x3[4];
  const c2 = mat_3x3[5];
  const a3 = mat_3x3[6];
  const b3 = mat_3x3[7];
  const c3 = mat_3x3[8];
  const d1 = +determinant2x2(b22, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d32 = +determinant2x2(a2, a3, b22, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b22, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b22);
  const det = a1 * d1 + b1 * d2 + c1 * d32;
  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  const v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  const v32 = d32 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v32 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  const x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  const y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  const z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  const copyA = [...a_3x3];
  const copyB = [...b_3x3];
  for (let i = 0;i < 3; i++) {
    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, outRowAColB) {
  if (colA !== rowB) {
    vtkErrorMacro2("Number of columns of A must match number of rows of B.");
  }
  const copyA = [...a];
  const copyB = [...b];
  for (let i = 0;i < rowA; i++) {
    for (let j = 0;j < colB; j++) {
      outRowAColB[i * colB + j] = 0;
      for (let k = 0;k < colA; k++) {
        outRowAColB[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  let tmp;
  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp;
  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  const a1 = in_3x3[0];
  const b1 = in_3x3[1];
  const c1 = in_3x3[2];
  const a2 = in_3x3[3];
  const b22 = in_3x3[4];
  const c2 = in_3x3[5];
  const a3 = in_3x3[6];
  const b3 = in_3x3[7];
  const c3 = in_3x3[8];
  const d1 = +determinant2x2(b22, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d32 = +determinant2x2(a2, a3, b22, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b22, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b22);
  const det = a1 * d1 + b1 * d2 + c1 * d32;
  if (det === 0) {
    vtkWarningMacro2("Matrix has 0 determinant");
  }
  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d2 / det;
  outI_3x3[6] = d32 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e2 / det;
  outI_3x3[7] = e3 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f2 / det;
  outI_3x3[8] = f3 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}
function areEquals(a, b) {
  let eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON2;
  if (a.length !== b.length) {
    return false;
  }
  function isEqual(element, index) {
    return Math.abs(element - b[index]) <= eps;
  }
  return a.every(isEqual);
}
var areMatricesEqual = areEquals;
function identity3x3(mat_3x3) {
  for (let i = 0;i < 3; i++) {
    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
    mat_3x3[i * 3 + i] = 1;
  }
}
function identity(n, mat) {
  for (let i = 0;i < n; i++) {
    for (let j = 0;j < n; j++) {
      mat[i * n + j] = 0;
    }
    mat[i * n + i] = 1;
  }
  return mat;
}
function isIdentity(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON2;
  return areMatricesEqual(mat, IDENTITY, eps);
}
function isIdentity3x3(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON2;
  return areMatricesEqual(mat, IDENTITY_3X3, eps);
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  const ww = quat_4[0] * quat_4[0];
  const wx = quat_4[0] * quat_4[1];
  const wy = quat_4[0] * quat_4[2];
  const wz = quat_4[0] * quat_4[3];
  const xx = quat_4[1] * quat_4[1];
  const yy2 = quat_4[2] * quat_4[2];
  const zz = quat_4[3] * quat_4[3];
  const xy2 = quat_4[1] * quat_4[2];
  const xz = quat_4[1] * quat_4[3];
  const yz = quat_4[2] * quat_4[3];
  const rr = xx + yy2 + zz;
  let f = 1 / (ww + rr);
  const s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0] = xx * f + s;
  mat_3x3[3] = (xy2 + wz) * f;
  mat_3x3[6] = (xz - wy) * f;
  mat_3x3[1] = (xy2 - wz) * f;
  mat_3x3[4] = yy2 * f + s;
  mat_3x3[7] = (yz + wx) * f;
  mat_3x3[2] = (xz + wy) * f;
  mat_3x3[5] = (yz - wx) * f;
  mat_3x3[8] = zz * f + s;
}
function roundNumber(num) {
  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!`${num}`.includes("e")) {
    return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
  }
  const arr = `${num}`.split("e");
  let sig = "";
  if (+arr[1] + digits > 0) {
    sig = "+";
  }
  return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
}
function roundVector(vector) {
  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  let digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  let i;
  let j;
  let k;
  let iq;
  let ip;
  let numPos;
  let tresh;
  let theta;
  let t;
  let tau;
  let sm;
  let s;
  let h;
  let g;
  let c;
  let tmp;
  const b = createArray(n);
  const z = createArray(n);
  const vtkROTATE = (aa, ii, jj) => {
    g = aa[ii];
    h = aa[jj];
    aa[ii] = g - s * (h + g * tau);
    aa[jj] = h + s * (g - h * tau);
  };
  identity(n, v);
  for (ip = 0;ip < n; ip++) {
    b[ip] = w[ip] = a[ip + ip * n];
    z[ip] = 0;
  }
  for (i = 0;i < VTK_MAX_ROTATIONS; i++) {
    sm = 0;
    for (ip = 0;ip < n - 1; ip++) {
      for (iq = ip + 1;iq < n; iq++) {
        sm += Math.abs(a[ip * n + iq]);
      }
    }
    if (sm === 0) {
      break;
    }
    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0;
    }
    for (ip = 0;ip < n - 1; ip++) {
      for (iq = ip + 1;iq < n; iq++) {
        g = 100 * Math.abs(a[ip * n + iq]);
        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
          a[ip * n + iq] = 0;
        } else if (Math.abs(a[ip * n + iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip * n + iq] / h;
          } else {
            theta = 0.5 * h / a[ip * n + iq];
            t = 1 / (Math.abs(theta) + Math.sqrt(1 + theta * theta));
            if (theta < 0) {
              t = -t;
            }
          }
          c = 1 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1 + c);
          h = t * a[ip * n + iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip * n + iq] = 0;
          for (j = 0;j <= ip - 1; j++) {
            vtkROTATE(a, j * n + ip, j * n + iq);
          }
          for (j = ip + 1;j <= iq - 1; j++) {
            vtkROTATE(a, ip * n + j, j * n + iq);
          }
          for (j = iq + 1;j < n; j++) {
            vtkROTATE(a, ip * n + j, iq * n + j);
          }
          for (j = 0;j < n; j++) {
            vtkROTATE(v, j * n + ip, j * n + iq);
          }
        }
      }
    }
    for (ip = 0;ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0;
    }
  }
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro2("vtkMath::Jacobi: Error extracting eigenfunctions");
    return 0;
  }
  for (j = 0;j < n - 1; j++) {
    k = j;
    tmp = w[k];
    for (i = j + 1;i < n; i++) {
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < VTK_SMALL_NUMBER) {
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      swapColumnsMatrix_nxn(v, n, j, k);
    }
  }
  const ceil_half_n = (n >> 1) + (n & 1);
  for (numPos = 0, i = 0;i < n * n; i++) {
    if (v[i] >= 0) {
      numPos++;
    }
  }
  if (numPos < ceil_half_n) {
    for (i = 0;i < n; i++) {
      v[i * n + j] *= -1;
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];
  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const eigenvalues = [0, 0, 0, 0];
  const NTemp = [...tmp];
  jacobiN(NTemp, 4, eigenvalues, eigenvectors);
  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  const ww = quat_1[0] * quat_2[0];
  const wx = quat_1[0] * quat_2[1];
  const wy = quat_1[0] * quat_2[2];
  const wz = quat_1[0] * quat_2[3];
  const xw = quat_1[1] * quat_2[0];
  const xx = quat_1[1] * quat_2[1];
  const xy2 = quat_1[1] * quat_2[2];
  const xz = quat_1[1] * quat_2[3];
  const yw = quat_1[2] * quat_2[0];
  const yx = quat_1[2] * quat_2[1];
  const yy2 = quat_1[2] * quat_2[2];
  const yz = quat_1[2] * quat_2[3];
  const zw = quat_1[3] * quat_2[0];
  const zx = quat_1[3] * quat_2[1];
  const zy = quat_1[3] * quat_2[2];
  const zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy2 - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy2 - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  for (let i = 0;i < 9; i++) {
    out_3x3[i] = a_3x3[i];
  }
  const scale = createArray(3);
  const index = createArray(3);
  let largest;
  for (let i = 0;i < 3; i++) {
    const x12 = Math.abs(out_3x3[i * 3]);
    const x22 = Math.abs(out_3x3[i * 3 + 1]);
    const x32 = Math.abs(out_3x3[i * 3 + 2]);
    largest = x22 > x12 ? x22 : x12;
    largest = x32 > largest ? x32 : largest;
    scale[i] = 1;
    if (largest !== 0) {
      scale[i] /= largest;
    }
  }
  const x1 = Math.abs(out_3x3[0]) * scale[0];
  const x2 = Math.abs(out_3x3[3]) * scale[1];
  const x3 = Math.abs(out_3x3[6]) * scale[2];
  index[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }
  if (x3 >= largest) {
    index[0] = 2;
  }
  if (index[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
    scale[index[0]] = scale[0];
  }
  const y22 = Math.abs(out_3x3[4]) * scale[1];
  const y3 = Math.abs(out_3x3[7]) * scale[2];
  index[1] = 1;
  largest = y22;
  if (y3 >= largest) {
    index[1] = 2;
    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  }
  index[2] = 2;
  let flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (let i = 0;i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }
  const quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);
  if (flip) {
    for (let i = 0;i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }
  if (index[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);
  }
  if (index[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  let i;
  let j;
  let k;
  let maxI;
  let tmp;
  let maxVal;
  const copyA = [...a_3x3];
  jacobiN(copyA, 3, w_3, v_3x3);
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }
  transpose3x3(v_3x3, v_3x3);
  for (i = 0;i < 3; i++) {
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      maxVal = Math.abs(v_3x3[i * 3]);
      maxI = 0;
      for (j = 1;j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
      }
      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      }
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j * 3] = 0;
      v_3x3[j * 3 + 1] = 0;
      v_3x3[j * 3 + 2] = 0;
      v_3x3[j * 3 + j] = 1;
      const vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
      normalize(vectTmp1);
      const vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
      for (let t = 0;t < 3; t++) {
        v_3x3[k * 3 + t] = vectTmp1[t];
        v_3x3[j * 3 + t] = vectTmp2[t];
      }
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }
  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;
  for (i = 1;i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  if (maxI !== 0) {
    const eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  }
  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    const eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  }
  for (i = 0;i < 2; i++) {
    if (v_3x3[i * 3 + i] < 0) {
      v_3x3[i * 3] = -v_3x3[i * 3];
      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
    }
  }
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  }
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  let i;
  const B = [...a_3x3];
  const d = determinant3x3(B);
  if (d < 0) {
    for (i = 0;i < 9; i++) {
      B[i] = -B[i];
    }
  }
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}
function luFactorLinearSystem(A, index, size) {
  let i;
  let j;
  let k;
  let largest;
  let maxI = 0;
  let sum;
  let temp1;
  let temp2;
  const scale = createArray(size);
  for (i = 0;i < size; i++) {
    for (largest = 0, j = 0;j < size; j++) {
      if ((temp2 = Math.abs(A[i * size + j])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    scale[i] = 1 / largest;
  }
  for (j = 0;j < size; j++) {
    for (i = 0;i < j; i++) {
      sum = A[i * size + j];
      for (k = 0;k < i; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
    }
    for (largest = 0, i = j;i < size; i++) {
      sum = A[i * size + j];
      for (k = 0;k < j; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    if (j !== maxI) {
      for (k = 0;k < size; k++) {
        temp1 = A[maxI * size + k];
        A[maxI * size + k] = A[j * size + k];
        A[j * size + k] = temp1;
      }
      scale[maxI] = scale[j];
    }
    index[j] = maxI;
    if (Math.abs(A[j * size + j]) <= VTK_SMALL_NUMBER) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    if (j !== size - 1) {
      temp1 = 1 / A[j * size + j];
      for (i = j + 1;i < size; i++) {
        A[i * size + j] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A, index, x, size) {
  let i;
  let j;
  let ii;
  let idx;
  let sum;
  for (ii = -1, i = 0;i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];
    if (ii >= 0) {
      for (j = ii;j <= i - 1; j++) {
        sum -= A[i * size + j] * x[j];
      }
    } else if (sum !== 0) {
      ii = i;
    }
    x[i] = sum;
  }
  for (i = size - 1;i >= 0; i--) {
    sum = x[i];
    for (j = i + 1;j < size; j++) {
      sum -= A[i * size + j] * x[j];
    }
    x[i] = sum / A[i * size + i];
  }
}
function solveLinearSystem(A, x, size) {
  if (size === 2) {
    const y = createArray(2);
    const det = determinant2x2(A[0], A[1], A[2], A[3]);
    if (det === 0) {
      return 0;
    }
    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }
  if (size === 1) {
    if (A[0] === 0) {
      return 0;
    }
    x[0] /= A[0];
    return 1;
  }
  const index = createArray(size);
  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index, x, size);
  return 1;
}
function invertMatrix(A, AI, size) {
  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  let column = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  const tmp1Size = index || createArray(size);
  const tmp2Size = column || createArray(size);
  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
    return null;
  }
  for (let j = 0;j < size; j++) {
    for (let i = 0;i < size; i++) {
      tmp2Size[i] = 0;
    }
    tmp2Size[j] = 1;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);
    for (let i = 0;i < size; i++) {
      AI[i * size + j] = tmp2Size[i];
    }
  }
  return AI;
}
function estimateMatrixCondition(A, size) {
  let minValue = +Number.MAX_VALUE;
  let maxValue = -Number.MAX_VALUE;
  for (let i = 0;i < size; i++) {
    for (let j = i;j < size; j++) {
      if (Math.abs(A[i * size + j]) > maxValue) {
        maxValue = Math.abs(A[i * size + j]);
      }
    }
  }
  for (let i = 0;i < size; i++) {
    if (Math.abs(A[i * size + i]) < minValue) {
      minValue = Math.abs(A[i * size + i]);
    }
  }
  if (minValue === 0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  if (numberOfSamples < xOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  let i;
  let j;
  let k;
  const XXt = createArray(xOrder * xOrder);
  const eigenvals = createArray(xOrder);
  const eigenvecs = createArray(xOrder * xOrder);
  for (k = 0;k < numberOfSamples; k++) {
    for (i = 0;i < xOrder; i++) {
      for (j = i;j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
    }
  }
  for (i = 0;i < xOrder; i++) {
    for (j = 0;j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);
  for (i = 0;i < xOrder; i++) {
    mt[i] = eigenvecs[i * xOrder + xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  let checkHomogeneous = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  const homogenFlags = createArray(yOrder);
  let allHomogeneous = 1;
  let hmt;
  let homogRC = 0;
  let i;
  let j;
  let k;
  let someHomogeneous = 0;
  if (checkHomogeneous) {
    for (j = 0;j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0;i < numberOfSamples; i++) {
      for (j = 0;j < yOrder; j++) {
        if (Math.abs(yt[i * yOrder + j]) > VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro2("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()");
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0;j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }
  if (someHomogeneous) {
    hmt = createArray(xOrder);
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }
  const XXt = createArray(xOrder * xOrder);
  const XXtI = createArray(xOrder * xOrder);
  const XYt = createArray(xOrder * yOrder);
  for (k = 0;k < numberOfSamples; k++) {
    for (i = 0;i < xOrder; i++) {
      for (j = i;j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
      for (j = 0;j < yOrder; j++) {
        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
      }
    }
  }
  for (i = 0;i < xOrder; i++) {
    for (j = 0;j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  const successFlag = invertMatrix(XXt, XXtI, xOrder);
  if (successFlag) {
    for (i = 0;i < xOrder; i++) {
      for (j = 0;j < yOrder; j++) {
        mt[i * yOrder + j] = 0;
        for (k = 0;k < xOrder; k++) {
          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
        }
      }
    }
  }
  if (someHomogeneous) {
    for (j = 0;j < yOrder; j++) {
      if (homogenFlags[j]) {
        for (i = 0;i < xOrder; i++) {
          mt[i * yOrder + j] = hmt[i * yOrder];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  let outFloatArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  let h;
  let s;
  const [r, g, b] = rgb;
  const onethird = 1 / 3;
  const onesixth = 1 / 6;
  const twothird = 2 / 3;
  let cmax = r;
  let cmin = r;
  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  const v = cmax;
  if (v > 0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g - b) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g) / (cmax - cmin);
    }
    if (h < 0) {
      h += 1;
    }
  } else {
    h = 0;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  const [h, s, v] = hsv;
  const onethird = 1 / 3;
  const onesixth = 1 / 6;
  const twothird = 2 / 3;
  const fivesixth = 5 / 6;
  let r;
  let g;
  let b;
  if (h > onesixth && h <= onethird) {
    g = 1;
    r = (onethird - h) / onesixth;
    b = 0;
  } else if (h > onethird && h <= 0.5) {
    g = 1;
    b = (h - onethird) / onesixth;
    r = 0;
  } else if (h > 0.5 && h <= twothird) {
    b = 1;
    g = (twothird - h) / onesixth;
    r = 0;
  } else if (h > twothird && h <= fivesixth) {
    b = 1;
    r = (h - twothird) / onesixth;
    g = 0;
  } else if (h > fivesixth && h <= 1) {
    r = 1;
    b = (1 - h) / onesixth;
    g = 0;
  } else {
    r = 1;
    g = h / onesixth;
    b = 0;
  }
  r = s * r + (1 - s);
  g = s * g + (1 - s);
  b = s * b + (1 - s);
  r *= v;
  g *= v;
  b *= v;
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  const [L, a, b] = lab;
  let var_Y = (L + 16) / 116;
  let var_X = a / 500 + var_Y;
  let var_Z = var_Y - b / 200;
  if (var_Y ** 3 > 0.008856) {
    var_Y **= 3;
  } else {
    var_Y = (var_Y - 16 / 116) / 7.787;
  }
  if (var_X ** 3 > 0.008856) {
    var_X **= 3;
  } else {
    var_X = (var_X - 16 / 116) / 7.787;
  }
  if (var_Z ** 3 > 0.008856) {
    var_Z **= 3;
  } else {
    var_Z = (var_Z - 16 / 116) / 7.787;
  }
  const ref_X = 0.9505;
  const ref_Y = 1;
  const ref_Z = 1.089;
  xyz[0] = ref_X * var_X;
  xyz[1] = ref_Y * var_Y;
  xyz[2] = ref_Z * var_Z;
}
function xyz2lab(xyz, lab) {
  const [x, y, z] = xyz;
  const ref_X = 0.9505;
  const ref_Y = 1;
  const ref_Z = 1.089;
  let var_X = x / ref_X;
  let var_Y = y / ref_Y;
  let var_Z = z / ref_Z;
  if (var_X > 0.008856)
    var_X **= 1 / 3;
  else
    var_X = 7.787 * var_X + 16 / 116;
  if (var_Y > 0.008856)
    var_Y **= 1 / 3;
  else
    var_Y = 7.787 * var_Y + 16 / 116;
  if (var_Z > 0.008856)
    var_Z **= 1 / 3;
  else
    var_Z = 7.787 * var_Z + 16 / 116;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  const [x, y, z] = xyz;
  let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  let b = x * 0.0557 + y * -0.204 + z * 1.057;
  if (r > 0.0031308)
    r = 1.055 * r ** (1 / 2.4) - 0.055;
  else
    r *= 12.92;
  if (g > 0.0031308)
    g = 1.055 * g ** (1 / 2.4) - 0.055;
  else
    g *= 12.92;
  if (b > 0.0031308)
    b = 1.055 * b ** (1 / 2.4) - 0.055;
  else
    b *= 12.92;
  let maxVal = r;
  if (maxVal < g)
    maxVal = g;
  if (maxVal < b)
    maxVal = b;
  if (maxVal > 1) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }
  if (r < 0)
    r = 0;
  if (g < 0)
    g = 0;
  if (b < 0)
    b = 0;
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  let [r, g, b] = rgb;
  if (r > 0.04045)
    r = ((r + 0.055) / 1.055) ** 2.4;
  else
    r /= 12.92;
  if (g > 0.04045)
    g = ((g + 0.055) / 1.055) ** 2.4;
  else
    g /= 12.92;
  if (b > 0.04045)
    b = ((b + 0.055) / 1.055) ** 2.4;
  else
    b /= 12.92;
  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  const xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  const xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1;
  bounds[1] = -1;
  bounds[2] = 1;
  bounds[3] = -1;
  bounds[4] = 1;
  bounds[5] = -1;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0);
}
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  let out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  let result = 0;
  if (range[0] !== range[1]) {
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
var getScalarTypeFittingRange = notImplemented("GetScalarTypeFittingRange");
var getAdjustedScalarRange = notImplemented("GetAdjustedScalarRange");
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (let i = 0;i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (let i = 0;i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (let i = 0;i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p2, p32, center) {
  const v21 = createArray(3);
  const v32 = createArray(3);
  const v13 = createArray(3);
  const v12 = createArray(3);
  const v23 = createArray(3);
  const v31 = createArray(3);
  for (let i = 0;i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p32[i];
    v13[i] = p32[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }
  const norm12 = norm(v12);
  const norm23 = norm(v23);
  const norm13 = norm(v13);
  const crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  const normCross = norm(crossv21v32);
  const radius = norm12 * norm23 * norm13 / (2 * normCross);
  const normCross22 = 2 * normCross * normCross;
  const alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  const beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  const gamma = norm12 * norm12 * dot(v13, v23) / normCross22;
  for (let i = 0;i < 3; ++i) {
    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p32[i];
  }
  return radius;
}
var inf = Infinity;
var negInf = -Infinity;
var isInf = (value) => !Number.isFinite(value);
var {
  isFinite: isFinite2,
  isNaN: isNaN2
} = Number;
var isNan = isNaN2;
function createUninitializedBounds() {
  return [].concat([
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE
  ]);
}
function getMajorAxisIndex(vector) {
  let maxValue = -1;
  let axisIndex = -1;
  for (let i = 0;i < vector.length; i++) {
    const value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }
  return axisIndex;
}
function getSparseOrthogonalMatrix(matrix) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  const rows = new Array(n);
  const cols = new Array(n);
  for (let i = 0;i < n; ++i) {
    rows[i] = i;
    cols[i] = i;
  }
  for (let i = n - 1;i > 0; i--) {
    let bestValue = -Infinity;
    let bestRowI = 0;
    let bestColI = 0;
    for (let rowI = 0;rowI <= i; ++rowI) {
      const row = rows[rowI];
      for (let colI = 0;colI <= i; ++colI) {
        const col = cols[colI];
        const absVal = Math.abs(matrix[row + n * col]);
        if (absVal > bestValue) {
          bestValue = absVal;
          bestRowI = rowI;
          bestColI = colI;
        }
      }
    }
    [rows[i], rows[bestRowI]] = [rows[bestRowI], rows[i]];
    [cols[i], cols[bestColI]] = [cols[bestColI], cols[i]];
  }
  const output = new Array(n * n).fill(0);
  for (let i = 0;i < n; ++i) {
    const matIdx = rows[i] + n * cols[i];
    output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;
  }
  return output;
}
function floatToHex2(value) {
  const integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return `0${integer.toString(16)}`;
}
function floatRGB2HexCode(rgbArray) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#";
  return `${prefix}${rgbArray.map(floatToHex2).join("")}`;
}
function floatToChar(f) {
  return Math.round(f * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return `rgb(${rgbArray.map(floatToChar).join(", ")})`;
  }
  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
}
var vtkMath = {
  Pi,
  ldexp,
  radiansFromDegrees,
  degreesFromRadians,
  round,
  floor,
  ceil,
  ceilLog2,
  min,
  max,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random,
  gaussian,
  add,
  subtract,
  multiplyScalar,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot,
  outer,
  cross,
  norm,
  normalize,
  perpendiculars,
  projectVector,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  identity,
  isIdentity,
  isIdentity3x3,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  roundNumber,
  roundVector,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN2,
  isNaN: isNaN2,
  isFinite: isFinite2,
  createUninitializedBounds,
  getMajorAxisIndex,
  getSparseOrthogonalMatrix,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA
};

// ../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var {
  vtkErrorMacro: vtkErrorMacro3
} = macro$1;
var {
  DefaultDataType: DefaultDataType2
} = Constants2;
var EPSILON3 = 0.000001;
function fastComputeRange(arr, offset, numberOfComponents) {
  const len = arr.length;
  let min2 = Number.MAX_VALUE;
  let max2 = -Number.MAX_VALUE;
  let x;
  let i;
  for (i = offset;i < len; i += numberOfComponents) {
    if (!Number.isNaN(arr[i])) {
      min2 = arr[i];
      max2 = min2;
      break;
    }
  }
  for (;i < len; i += numberOfComponents) {
    x = arr[i];
    if (x < min2) {
      min2 = x;
    } else if (x > max2) {
      max2 = x;
    }
  }
  return {
    min: min2,
    max: max2
  };
}
function createRangeHelper() {
  let min2 = Number.MAX_VALUE;
  let max2 = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;
  return {
    add(value) {
      if (min2 > value) {
        min2 = value;
      }
      if (max2 < value) {
        max2 = value;
      }
      count++;
      sum += value;
    },
    get() {
      return {
        min: min2,
        max: max2,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange() {
      return {
        min: min2,
        max: max2
      };
    }
  };
}
function computeRange(values) {
  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    const size = values.length;
    const numberOfValues = size / numberOfComponents;
    const data = new Float64Array(numberOfValues);
    for (let i = 0, j = 0;i < numberOfValues; ++i) {
      for (let nextJ = j + numberOfComponents;j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      data[i] **= 0.5;
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const ranges = rangeArray || [];
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0;
  const tuple = new Array(numComps);
  for (let i = 0;i < normArray.getNumberOfTuples(); ++i) {
    normArray.getTuple(i, tuple);
    const norm$1 = norm(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}
var STATIC = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};
function vtkDataArray(publicAPI, model) {
  model.classHierarchy.push("vtkDataArray");
  function resize(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    const numComps = publicAPI.getNumberOfComponents();
    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === curNumTuples) {
      return true;
    }
    if (requestedNumTuples > curNumTuples) {
      const oldValues = model.values;
      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }
    if (model.size > requestedNumTuples * numComps) {
      model.size = requestedNumTuples * numComps;
      publicAPI.dataChange();
    }
    return true;
  }
  publicAPI.dataChange = () => {
    model.ranges = null;
    publicAPI.modified();
  };
  publicAPI.resize = (requestedNumTuples) => {
    resize(requestedNumTuples);
    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
    if (model.size !== newSize) {
      model.size = newSize;
      publicAPI.dataChange();
      return true;
    }
    return false;
  };
  publicAPI.initialize = () => {
    publicAPI.resize(0);
  };
  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;
  publicAPI.getComponent = function(tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.dataChange();
    }
  };
  publicAPI.getValue = (valueIdx) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = (valueIdx, value) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  publicAPI.getRange = function() {
    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    let rangeIdx = componentIndex;
    if (rangeIdx < 0) {
      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
    }
    let range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setTuple = (idx, tuple) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0;i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.setTuples = (idx, tuples) => {
    let i = idx * model.numberOfComponents;
    const last = Math.min(tuples.length, model.size - i);
    for (let j = 0;j < last; ) {
      model.values[i++] = tuples[j++];
    }
  };
  publicAPI.insertTuple = (idx, tuple) => {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = (idx, tuples) => {
    const end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = (tuple) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = (tuples) => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.findTuple = function(tuple) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON3;
    for (let i = 0;i < model.size; i += model.numberOfComponents) {
      if (Math.abs(tuple[0] - model.values[i]) <= precision) {
        let match = true;
        for (let j = 1;j < model.numberOfComponents; ++j) {
          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
            match = false;
            break;
          }
        }
        if (match) {
          return i / model.numberOfComponents;
        }
      }
    }
    return -1;
  };
  publicAPI.getTuple = function(idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    const offset = idx * numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset + 3];
      case 3:
        tupleToFill[2] = model.values[offset + 2];
      case 2:
        tupleToFill[1] = model.values[offset + 1];
      case 1:
        tupleToFill[0] = model.values[offset];
        break;
      default:
        for (let i = numberOfComponents - 1;i >= 0; --i) {
          tupleToFill[i] = model.values[offset + i];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = (fromId, toId) => {
    const from = (fromId ?? 0) * model.numberOfComponents;
    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    const arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function() {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.size;
  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  publicAPI.newClone = () => newInstance3({
    empty: true,
    name: model.name,
    dataType: model.dataType,
    numberOfComponents: model.numberOfComponents
  });
  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.dataChange();
  };
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;
    Object.keys(jsonArchive).forEach((keyName) => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach((name) => {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.deepCopy = (other) => {
    const currentType = publicAPI.getDataType();
    const currentArray = model.values;
    publicAPI.shallowCopy(other);
    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {
      currentArray.set(other.getData());
      model.values = currentArray;
      publicAPI.dataChange();
    } else {
      publicAPI.setData(other.getData().slice());
    }
  };
  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro3("numberOfComponents must match");
    }
    const tuple1 = source1.getTuple(source1Idx);
    const tuple2 = source2.getTuple(source2Idx);
    const out = [];
    out.length = numberOfComponents;
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
        break;
      default:
        for (let i = 0;i < numberOfComponents; i++) {
          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}
var DEFAULT_VALUES2 = {
  name: "",
  numberOfComponents: 1,
  dataType: DefaultDataType2,
  rangeTuple: [0, 0]
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  if (Array.isArray(initialValues.values) && initialValues.dataType === undefined) {
    console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array");
  }
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = newTypedArray(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = newTypedArrayFrom(model.dataType, model.values);
  }
  if (model.values) {
    model.size = model.size ?? model.values.length;
    model.dataType = getDataType(model.values);
  }
  obj(publicAPI, model);
  set(publicAPI, model, ["name", "numberOfComponents"]);
  if (model.size % model.numberOfComponents !== 0) {
    throw new RangeError("model.size is not a multiple of model.numberOfComponents");
  }
  vtkDataArray(publicAPI, model);
}
var newInstance3 = newInstance(extend2, "vtkDataArray");
var vtkDataArray$1 = {
  newInstance: newInstance3,
  extend: extend2,
  ...STATIC,
  ...Constants2
};

// ../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var {
  vtkErrorMacro: vtkErrorMacro4
} = macro;
var PASS_TYPES = ["Build", "Render"];
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  publicAPI.build = (prepass) => {
  };
  publicAPI.render = (prepass) => {
  };
  publicAPI.traverse = (renderPass) => {
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (let index = 0;index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = (dataObject) => {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (let index = 0;index < model.children.length; ++index) {
      const child = model.children[index];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return;
  };
  publicAPI.getFirstAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.getLastAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    const lastAncestor = model._parent.getLastAncestorOfType(type);
    if (lastAncestor) {
      return lastAncestor;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return null;
  };
  publicAPI.addMissingNode = (dobj) => {
    if (!dobj) {
      return;
    }
    const result = model._renderableChildMap.get(dobj);
    if (result !== undefined) {
      result.setVisited(true);
      return result;
    }
    const newNode = publicAPI.createViewNode(dobj);
    if (newNode) {
      newNode.setParent(publicAPI);
      newNode.setVisited(true);
      model._renderableChildMap.set(dobj, newNode);
      model.children.push(newNode);
      return newNode;
    }
    return;
  };
  publicAPI.addMissingNodes = (dataObjs) => {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (let index = 0;index < dataObjs.length; ++index) {
      const dobj = dataObjs[index];
      publicAPI.addMissingNode(dobj);
    }
  };
  publicAPI.addMissingChildren = (children) => {
    if (!children || !children.length) {
      return;
    }
    for (let index = 0;index < children.length; ++index) {
      const child = children[index];
      const cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
        const childRenderable = child.getRenderable();
        if (childRenderable) {
          model._renderableChildMap.set(childRenderable, child);
        }
      }
      child.setVisited(true);
    }
  };
  publicAPI.removeNode = (child) => {
    const childIdx = model.children.findIndex((x) => x === child);
    if (childIdx < 0) {
      return false;
    }
    const renderable = child.getRenderable();
    if (renderable) {
      model._renderableChildMap.delete(renderable);
    }
    child.delete();
    model.children.splice(childIdx, 1);
    return true;
  };
  publicAPI.prepareNodes = () => {
    for (let index = 0;index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };
  publicAPI.setVisited = (val) => {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = () => {
    let visitedCount = 0;
    for (let index = 0;index < model.children.length; ++index) {
      const child = model.children[index];
      const visited = child.getVisited();
      if (visited) {
        model.children[visitedCount++] = child;
        child.setVisited(false);
      } else {
        const renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        child.delete();
      }
    }
    model.children.length = visitedCount;
  };
  publicAPI.createViewNode = (dataObj) => {
    if (!model.myFactory) {
      vtkErrorMacro4("Cannot create view nodes without my own factory");
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
  const parentDelete = publicAPI.delete;
  publicAPI.delete = () => {
    for (let i = 0;i < model.children.length; i++) {
      model.children[i].delete();
    }
    parentDelete();
  };
}
var DEFAULT_VALUES3 = {
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = new Map;
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkViewNode");
var vtkViewNode$1 = {
  newInstance: newInstance4,
  extend: extend3,
  PASS_TYPES
};

// ../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = (dataObject) => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
}
var DEFAULT_VALUES4 = {};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend4, "vtkViewNodeFactory");
var vtkViewNodeFactory$1 = {
  newInstance: newInstance5,
  extend: extend4
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
var DEFAULT_VALUES5 = {};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5, "vtkOpenGLViewNodeFactory");
var vtkViewNodeFactory2 = {
  newInstance: newInstance6,
  extend: extend5
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js
function supportsNorm16Linear() {
  try {
    const canvasSize = 4;
    const texWidth = 2;
    const texHeight = 1;
    const texData = new Int16Array([0, 2 ** 15 - 1]);
    const pixelToCheck = [1, 1];
    const canvas = document.createElement("canvas");
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const gl = canvas.getContext("webgl2");
    if (!gl) {
      return false;
    }
    const ext = gl.getExtension("EXT_texture_norm16");
    if (!ext) {
      return false;
    }
    const vs2 = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
    const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vs2);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      return false;
    }
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.useProgram(program);
    gl.drawArrays(gl.POINTS, 0, 1);
    const pixel = new Uint8Array(4);
    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    const [r, g, b] = pixel;
    const webglLoseContext = gl.getExtension("WEBGL_lose_context");
    if (webglLoseContext) {
      webglLoseContext.loseContext();
    }
    return r === g && g === b && r !== 0;
  } catch (e) {
    return false;
  }
}
var supportsNorm16LinearCache;
function supportsNorm16LinearCached() {
  if (supportsNorm16LinearCache === undefined) {
    supportsNorm16LinearCache = supportsNorm16Linear();
  }
  return supportsNorm16LinearCache;
}

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var {
  Wrap: Wrap2,
  Filter: Filter2
} = Constants3;
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
var {
  vtkDebugMacro: vtkDebugMacro2,
  vtkErrorMacro: vtkErrorMacro5,
  vtkWarningMacro: vtkWarningMacro3
} = macro$1;
var {
  toHalf: toHalf2
} = HalfFloat;
function vtkOpenGLTexture(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTexture");
  publicAPI.render = function() {
    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter2.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter2.NEAREST);
      publicAPI.setMagnificationFilter(Filter2.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap2.REPEAT);
      publicAPI.setWrapS(Wrap2.REPEAT);
      publicAPI.setWrapT(Wrap2.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        const canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes2.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        const jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes2.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        const data = [];
        for (let i = 0;i < model.renderable.getNumberOfInputPorts(); ++i) {
          const indata = model.renderable.getInputData(i);
          const scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  const getNorm16Ext = () => {
    if ((model.minificationFilter === Filter2.LINEAR || model.magnificationFilter === Filter2.LINEAR) && !supportsNorm16LinearCached()) {
      return;
    }
    return model.oglNorm16Ext;
  };
  publicAPI.destroyTexture = () => {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = () => {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = () => {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = () => {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = () => {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = (rwin) => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      model.allocatedGPUMemoryInBytes = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro3("impossible case");
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = () => {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model._forceInternalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro2(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension("OES_texture_float_linear")) {
      vtkWarningMacro3("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.");
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());
    if (result) {
      return result;
    }
    if (!result) {
      vtkDebugMacro2("Unsupported internal texture type!");
      vtkDebugMacro2(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    return result;
  };
  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;
  publicAPI.setInternalFormat = (iFormat) => {
    model._forceInternalFormat = true;
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = () => {
    model.format = 0;
    model.internalFormat = 0;
    model._forceInternalFormat = false;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = (vtkScalarType) => {
    const useHalfFloat = publicAPI.useHalfFloat();
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes2.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (getNorm16Ext() && !useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.SHORT;
        case (getNorm16Ext() && !useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.UNSIGNED_SHORT;
        case (useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.HALF_FLOAT;
        case (useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes2.FLOAT:
        case VtkDataTypes2.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes2.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes2.FLOAT:
      case VtkDataTypes2.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          const halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!model.openGLDataType || forceUpdate) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = () => {
    let shift = 0;
    let scale = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255;
        shift = 0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536;
        shift = 0;
        break;
      case model.context.INT:
        scale = 2147483647.5;
        shift = scale - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295;
        shift = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale
    };
  };
  publicAPI.getOpenGLFilterMode = (emode) => {
    switch (emode) {
      case Filter2.NEAREST:
        return model.context.NEAREST;
      case Filter2.LINEAR:
        return model.context.LINEAR;
      case Filter2.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter2.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter2.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter2.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = (vtktype) => {
    switch (vtktype) {
      case Wrap2.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap2.REPEAT:
        return model.context.REPEAT;
      case Wrap2.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  publicAPI.updateArrayDataTypeForGL = function(dataType, data) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const pixData = [];
    let pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    if (dataType !== VtkDataTypes2.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (let idx = 0;idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Float32Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes2.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (let idx = 0;idx < data.length; idx++) {
        if (data[idx]) {
          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Uint8Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    let halfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    if (halfFloat) {
      for (let idx = 0;idx < data.length; idx++) {
        if (data[idx]) {
          const newArray = new Uint16Array(pixCount);
          const src = data[idx];
          for (let i = 0;i < pixCount; i++) {
            newArray[i] = toHalf2(src[i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i = 0;i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  };
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      const halfFloat = model.context.getExtension("OES_texture_half_float");
      const newWidth = nearestPowerOfTwo(width);
      const newHeight = nearestPowerOfTwo(height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0;idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          let usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (let j = 0;j < newHeight; j++) {
            const joff = j * newWidth * numComps;
            const jidx = j * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i = 0;i < newWidth; i++) {
              const ioff = i * numComps;
              const iidx = i * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c = 0;c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i = 0;i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  }
  function useTexStorage(dataType) {
    if (model._openGLRenderWindow) {
      if (model.resizable || model.renderable?.getResizable()) {
        return false;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const webGLInfo = model._openGLRenderWindow.getGLInformations();
        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes2.UNSIGNED_SHORT || dataType === VtkDataTypes2.SHORT)) {
          return false;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  publicAPI.create2DFromRaw = function(width, height, numComps, dataType, data) {
    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    publicAPI.getOpenGLDataType(dataType, true);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const dataArray = [data];
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (scaledData[0] != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i = 0;i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (let y = 0;y < heightLevel; ++y) {
        const row1 = y * widthLevel * model.components;
        const row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
    }
    for (let i = 0;i < 6; i++) {
      let j = 0;
      let w = model.width;
      let h = model.height;
      while (w >= 1 && h >= 1) {
        let tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + i];
        }
        if (useTexStorage(dataType)) {
          if (tempData != null) {
            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
          }
        } else {
          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        }
        j++;
        w /= 2;
        h /= 2;
      }
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes2.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (data != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = (image) => {
    publicAPI.getOpenGLDataType(VtkDataTypes2.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));
    const canvas = document.createElement("canvas");
    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;
    model.width = canvas.width;
    model.height = canvas.height;
    const ctx = canvas.getContext("2d");
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    const safeImage = canvas;
    if (useTexStorage(VtkDataTypes2.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (safeImage != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes2.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(min2, max2, numComps) {
    const offset = new Array(numComps);
    const scale = new Array(numComps);
    for (let c = 0;c < numComps; ++c) {
      offset[c] = min2[c];
      scale[c] = max2[c] - min2[c] || 1;
    }
    return {
      scale,
      offset
    };
  }
  function hasExactHalfFloat(offset, scale) {
    for (let c = 0;c < offset.length; c++) {
      const min2 = offset[c];
      const max2 = scale[c] + min2;
      if (min2 < -2048 || min2 > 2048 || max2 < -2048 || max2 > 2048) {
        return false;
      }
    }
    return true;
  }
  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
    publicAPI.getOpenGLDataType(dataType);
    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;
    let useHalfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension("OES_texture_float_linear") === null && isExactHalfFloat;
      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;
  }
  function processDataArray(dataArray, preferSizeOverAccuracy) {
    const numComps = dataArray.getNumberOfComponents();
    const dataType = dataArray.getDataType();
    const data = dataArray.getData();
    const minArray = new Array(numComps);
    const maxArray = new Array(numComps);
    for (let c = 0;c < numComps; ++c) {
      const [min2, max2] = dataArray.getRange(c);
      minArray[c] = min2;
      maxArray[c] = max2;
    }
    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);
    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);
    if (!publicAPI.useHalfFloat()) {
      publicAPI.getOpenGLDataType(dataType, true);
    }
    return {
      numComps,
      dataType,
      data,
      scaleOffsets
    };
  }
  publicAPI.create2DFilterableFromRaw = function(width, height, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray$1.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };
  publicAPI.create2DFilterableFromDataArray = function(width, height, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const {
      numComps,
      dataType,
      data
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);
  };
  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
    let isScalingApplied = false;
    const useHalfFloat = publicAPI.useHalfFloat();
    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {
      model.volumeInfo = {
        scale: new Array(numComps),
        offset: new Array(numComps)
      };
    }
    for (let c = 0;c < numComps; ++c) {
      model.volumeInfo.scale[c] = 1;
      model.volumeInfo.offset[c] = 0;
    }
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes2.SHORT) {
      for (let c = 0;c < numComps; ++c) {
        model.volumeInfo.scale[c] = 32767;
      }
      isScalingApplied = true;
    }
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes2.UNSIGNED_SHORT) {
      for (let c = 0;c < numComps; ++c) {
        model.volumeInfo.scale[c] = 65535;
      }
      isScalingApplied = true;
    }
    if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
      for (let c = 0;c < numComps; ++c) {
        model.volumeInfo.scale[c] = 255;
      }
      isScalingApplied = true;
    }
    if (dataType === VtkDataTypes2.FLOAT || useHalfFloat && (dataType === VtkDataTypes2.SHORT || dataType === VtkDataTypes2.UNSIGNED_SHORT)) {
      isScalingApplied = true;
    }
    return isScalingApplied;
  };
  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {
    let dataTypeToUse = dataType;
    let dataToUse = data;
    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {
      const numPixelsIn = width * height * depth;
      const scaleOffsetsCopy = structuredClone(model.volumeInfo);
      const newArray = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let count = 0;
      const scaleInverse = scaleOffsetsCopy.scale.map((s) => 1 / s);
      for (let i = 0;i < numPixelsIn; i++) {
        for (let nc = 0;nc < numComps; nc++) {
          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      dataTypeToUse = VtkDataTypes2.FLOAT;
      dataToUse = newArray;
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const dataArray = [dataToUse];
    const is3DArray = true;
    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
      if (scaledData[0] != null) {
        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function(width, height, depth, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray$1.newInstance({
      numberOfComponents,
      dataType,
      values
    }), preferSizeOverAccuracy);
  };
  publicAPI.create3DFilterableFromDataArray = function(width, height, depth, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    const {
      numComps,
      dataType,
      data,
      scaleOffsets
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    const offset = [];
    const scale = [];
    for (let c = 0;c < numComps; ++c) {
      offset[c] = 0;
      scale[c] = 1;
    }
    model.volumeInfo = {
      scale,
      offset,
      dataComputedScale: scaleOffsets.scale,
      dataComputedOffset: scaleOffsets.offset,
      width,
      height,
      depth
    };
    if (model._openGLRenderWindow.getWebgl2()) {
      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
    }
    const numPixelsIn = width * height * depth;
    const scaleOffsetsCopy = structuredClone(scaleOffsets);
    let volCopyData = (outArray, outIdx2, inValue, smin, smax) => {
      outArray[outIdx2] = inValue;
    };
    let dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
      for (let c = 0;c < numComps; ++c) {
        scaleOffsetsCopy.offset[c] = 0;
        scaleOffsetsCopy.scale[c] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes2.FLOAT;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro5("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes2.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    const xreps = Math.floor(targetWidth * xstride / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = scaleOffsetsCopy.offset;
    model.volumeInfo.scale = scaleOffsetsCopy.scale;
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes2.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    let outIdx = 0;
    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);
    for (let yRep = 0;yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0;tileY < tileHeight; tileY++) {
        for (let xRep = 0;xRep < xrepsThisRow; xRep++) {
          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (let tileX = 0;tileX < tileWidth; tileX++) {
            for (let nc = 0;nc < numComps; nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (newArray != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = (ctx) => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
  publicAPI.enableUseHalfFloat = (use) => {
    model.enableUseHalfFloat = use;
  };
}
var DEFAULT_VALUES6 = {
  _openGLRenderWindow: null,
  _forceInternalFormat: false,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap2.CLAMP_TO_EDGE,
  wrapT: Wrap2.CLAMP_TO_EDGE,
  wrapR: Wrap2.CLAMP_TO_EDGE,
  minificationFilter: Filter2.NEAREST,
  magnificationFilter: Filter2.NEAREST,
  minLOD: -1000,
  maxLOD: 1000,
  baseLevel: 0,
  maxLevel: 1000,
  generateMipmap: false,
  oglNorm16Ext: null,
  allocatedGPUMemoryInBytes: 0,
  enableUseHalfFloat: true,
  canUseHalfFloat: false
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap", "oglNorm16Ext"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target", "allocatedGPUMemoryInBytes"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLTexture(publicAPI, model);
}
var newInstance7 = newInstance(extend6, "vtkOpenGLTexture");
var vtkOpenGLTexture$1 = {
  newInstance: newInstance7,
  extend: extend6,
  ...Constants3
};
registerOverride("vtkTexture", newInstance7);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
function vtkFramebuffer(publicAPI, model) {
  model.classHierarchy.push("vtkFramebuffer");
  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  publicAPI.saveCurrentBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
      return;
    }
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = (modeIn) => {
  };
  publicAPI.restorePreviousBindingsAndBuffers = (modeIn) => {
    const mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = (modeIn) => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
      return;
    }
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = (modeIn) => {
  };
  publicAPI.bind = function() {
    let modeArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (let i = 0;i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = (width, height) => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling create");
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function(texture) {
    let attachment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling setColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function() {
    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const gl = model.context;
    if (!gl) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling removeColorBuffer");
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = (texture) => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling setDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      vtkErrorMacro("Attaching depth buffer textures to fbo requires WebGL 2");
    }
  };
  publicAPI.removeDepthBuffer = () => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      vtkErrorMacro("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }
  };
  publicAPI.getGLFramebuffer = () => model.glFramebuffer;
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = () => {
    if (model.glFramebuffer == null)
      return null;
    return [model.glFramebuffer.width, model.glFramebuffer.height];
  };
  publicAPI.populateFramebuffer = () => {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
      return;
    }
    publicAPI.bind();
    const gl = model.context;
    const texture = vtkOpenGLTexture$1.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(Filter.LINEAR);
    texture.setMagnificationFilter(Filter.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, VtkDataTypes.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };
  publicAPI.getColorTexture = () => model.colorBuffers[0];
}
var DEFAULT_VALUES7 = {
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  obj(publicAPI, model);
  if (model.colorBuffers) {
    vtkErrorMacro("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
  }
  model.colorBuffers = [];
  getArray(publicAPI, model, ["colorBuffers"]);
  vtkFramebuffer(publicAPI, model);
}
var newInstance8 = newInstance(extend7, "vtkFramebuffer");
var vtkOpenGLFramebuffer = {
  newInstance: newInstance8,
  extend: extend7
};

// ../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
function vtkRenderPass(publicAPI, model) {
  model.classHierarchy.push("vtkRenderPass");
  publicAPI.getOperation = () => model.currentOperation;
  publicAPI.setCurrentOperation = (val) => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${macro.capitalize(model.currentOperation)}`;
  };
  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    model.preDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach((val) => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}
var DEFAULT_VALUES8 = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["currentOperation"]);
  macro.setGet(publicAPI, model, ["delegates", "_currentParent", "preDelegateOperations", "postDelegateOperations"]);
  macro.moveToProtected(publicAPI, model, ["currentParent"]);
  vtkRenderPass(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8, "vtkRenderPass");
var vtkRenderPass$1 = {
  newInstance: newInstance9,
  extend: extend8
};

// ../../node_modules/gl-matrix/esm/common.js
var exports_common = {};
__export(exports_common, {
  toRadian: () => toRadian,
  setMatrixArrayType: () => setMatrixArrayType,
  equals: () => equals,
  RANDOM: () => RANDOM,
  EPSILON: () => EPSILON4,
  ARRAY_TYPE: () => ARRAY_TYPE
});
var EPSILON4 = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
  return a * degree;
}
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON4 * Math.max(1, Math.abs(a), Math.abs(b));
}
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// ../../node_modules/gl-matrix/esm/mat3.js
var exports_mat3 = {};
__export(exports_mat3, {
  transpose: () => transpose,
  translate: () => translate,
  subtract: () => subtract2,
  sub: () => sub,
  str: () => str,
  set: () => set2,
  scale: () => scale,
  rotate: () => rotate,
  projection: () => projection,
  normalFromMat4: () => normalFromMat4,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  multiplyScalar: () => multiplyScalar2,
  multiply: () => multiply,
  mul: () => mul,
  invert: () => invert,
  identity: () => identity2,
  fromValues: () => fromValues,
  fromTranslation: () => fromTranslation,
  fromScaling: () => fromScaling,
  fromRotation: () => fromRotation,
  fromQuat: () => fromQuat,
  fromMat4: () => fromMat4,
  fromMat2d: () => fromMat2d,
  frob: () => frob,
  exactEquals: () => exactEquals,
  equals: () => equals2,
  determinant: () => determinant,
  create: () => create,
  copy: () => copy,
  clone: () => clone,
  adjoint: () => adjoint,
  add: () => add2
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y22 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy2 = y * y22;
  var zx = z * x2;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy2 - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy2;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale2) {
  out[0] = a[0] + b[0] * scale2;
  out[1] = a[1] + b[1] * scale2;
  out[2] = a[2] + b[2] * scale2;
  out[3] = a[3] + b[3] * scale2;
  out[4] = a[4] + b[4] * scale2;
  out[5] = a[5] + b[5] * scale2;
  out[6] = a[6] + b[6] * scale2;
  out[7] = a[7] + b[7] * scale2;
  out[8] = a[8] + b[8] * scale2;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b22 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON4 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON4 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b22) <= EPSILON4 * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON4 * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON4 * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON4 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON4 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON4 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON4 * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract2;

// ../../node_modules/gl-matrix/esm/mat4.js
var exports_mat4 = {};
__export(exports_mat4, {
  transpose: () => transpose2,
  translate: () => translate2,
  targetTo: () => targetTo,
  subtract: () => subtract3,
  sub: () => sub2,
  str: () => str2,
  set: () => set3,
  scale: () => scale2,
  rotateZ: () => rotateZ,
  rotateY: () => rotateY,
  rotateX: () => rotateX,
  rotate: () => rotate2,
  perspectiveZO: () => perspectiveZO,
  perspectiveNO: () => perspectiveNO,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspective: () => perspective,
  orthoZO: () => orthoZO,
  orthoNO: () => orthoNO,
  ortho: () => ortho,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  multiplyScalar: () => multiplyScalar3,
  multiply: () => multiply2,
  mul: () => mul2,
  lookAt: () => lookAt,
  invert: () => invert2,
  identity: () => identity3,
  getTranslation: () => getTranslation,
  getScaling: () => getScaling,
  getRotation: () => getRotation,
  frustum: () => frustum,
  fromZRotation: () => fromZRotation,
  fromYRotation: () => fromYRotation,
  fromXRotation: () => fromXRotation,
  fromValues: () => fromValues2,
  fromTranslation: () => fromTranslation2,
  fromScaling: () => fromScaling2,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotation: () => fromRotation2,
  fromQuat2: () => fromQuat2,
  fromQuat: () => fromQuat3,
  frob: () => frob2,
  exactEquals: () => exactEquals2,
  equals: () => equals3,
  determinant: () => determinant2,
  create: () => create2,
  copy: () => copy2,
  clone: () => clone2,
  adjoint: () => adjoint2,
  add: () => add3
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b22 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b22 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b22 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b22 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < EPSILON4) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < EPSILON4) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y22 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy2 = x * y22;
  var xz = x * z2;
  var yy2 = y * y22;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - (yy2 + zz);
  out[1] = xy2 + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy2 - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy2);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw2 = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw2 * bw2;
  if (magnitude > 0) {
    translation[0] = (ax * bw2 + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw2 + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw2 + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw2 + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw2 + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw2 + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y22 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy2 = x * y22;
  var xz = x * z2;
  var yy2 = y * y22;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy2 + zz)) * sx;
  out[1] = (xy2 + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy2 - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy2)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y22 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy2 = x * y22;
  var xz = x * z2;
  var yy2 = y * y22;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y22;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy2 + zz)) * sx;
  var out1 = (xy2 + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy2 - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy2)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y22 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy2 = y * y22;
  var zx = z * x2;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy2 - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x02, x1, x2, y0, y1, y22, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON4 && Math.abs(eyey - centery) < EPSILON4 && Math.abs(eyez - centerz) < EPSILON4) {
    return identity3(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x02 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x02, x1, x2);
  if (!len) {
    x02 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x02 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x02 - z0 * x2;
  y22 = z0 * x1 - z1 * x02;
  len = Math.hypot(y0, y1, y22);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y22 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y22 *= len;
  }
  out[0] = x02;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y22;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x02 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x02 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len = x02 * x02 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x02 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x02;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x02 - z0 * x2;
  out[6] = z0 * x1 - z1 * x02;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale3) {
  out[0] = a[0] + b[0] * scale3;
  out[1] = a[1] + b[1] * scale3;
  out[2] = a[2] + b[2] * scale3;
  out[3] = a[3] + b[3] * scale3;
  out[4] = a[4] + b[4] * scale3;
  out[5] = a[5] + b[5] * scale3;
  out[6] = a[6] + b[6] * scale3;
  out[7] = a[7] + b[7] * scale3;
  out[8] = a[8] + b[8] * scale3;
  out[9] = a[9] + b[9] * scale3;
  out[10] = a[10] + b[10] * scale3;
  out[11] = a[11] + b[11] * scale3;
  out[12] = a[12] + b[12] * scale3;
  out[13] = a[13] + b[13] * scale3;
  out[14] = a[14] + b[14] * scale3;
  out[15] = a[15] + b[15] * scale3;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b22 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON4 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON4 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b22) <= EPSILON4 * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON4 * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON4 * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON4 * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON4 * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON4 * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON4 * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON4 * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON4 * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON4 * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON4 * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON4 * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON4 * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON4 * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract3;

// ../../node_modules/gl-matrix/esm/quat.js
var exports_quat = {};
__export(exports_quat, {
  str: () => str5,
  squaredLength: () => squaredLength3,
  sqrLen: () => sqrLen3,
  sqlerp: () => sqlerp,
  slerp: () => slerp,
  setAxisAngle: () => setAxisAngle,
  setAxes: () => setAxes,
  set: () => set6,
  scale: () => scale5,
  rotationTo: () => rotationTo,
  rotateZ: () => rotateZ3,
  rotateY: () => rotateY3,
  rotateX: () => rotateX3,
  random: () => random4,
  pow: () => pow,
  normalize: () => normalize4,
  multiply: () => multiply5,
  mul: () => mul5,
  ln: () => ln,
  lerp: () => lerp3,
  length: () => length3,
  len: () => len3,
  invert: () => invert3,
  identity: () => identity4,
  getAxisAngle: () => getAxisAngle,
  getAngle: () => getAngle,
  fromValues: () => fromValues5,
  fromMat3: () => fromMat3,
  fromEuler: () => fromEuler,
  exp: () => exp,
  exactEquals: () => exactEquals5,
  equals: () => equals6,
  dot: () => dot4,
  create: () => create5,
  copy: () => copy5,
  conjugate: () => conjugate,
  clone: () => clone5,
  calculateW: () => calculateW,
  add: () => add6
});

// ../../node_modules/gl-matrix/esm/vec3.js
var exports_vec3 = {};
__export(exports_vec3, {
  zero: () => zero,
  transformQuat: () => transformQuat,
  transformMat4: () => transformMat4,
  transformMat3: () => transformMat3,
  subtract: () => subtract4,
  sub: () => sub3,
  str: () => str3,
  squaredLength: () => squaredLength,
  squaredDistance: () => squaredDistance,
  sqrLen: () => sqrLen,
  sqrDist: () => sqrDist,
  set: () => set4,
  scaleAndAdd: () => scaleAndAdd,
  scale: () => scale3,
  round: () => round2,
  rotateZ: () => rotateZ2,
  rotateY: () => rotateY2,
  rotateX: () => rotateX2,
  random: () => random2,
  normalize: () => normalize2,
  negate: () => negate,
  multiply: () => multiply3,
  mul: () => mul3,
  min: () => min2,
  max: () => max2,
  lerp: () => lerp,
  length: () => length,
  len: () => len,
  inverse: () => inverse,
  hermite: () => hermite,
  fromValues: () => fromValues3,
  forEach: () => forEach,
  floor: () => floor2,
  exactEquals: () => exactEquals3,
  equals: () => equals4,
  dot: () => dot2,
  divide: () => divide,
  div: () => div,
  distance: () => distance,
  dist: () => dist,
  cross: () => cross2,
  create: () => create3,
  copy: () => copy3,
  clone: () => clone3,
  ceil: () => ceil2,
  bezier: () => bezier,
  angle: () => angle,
  add: () => add4
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set4(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale4) {
  out[0] = a[0] + b[0] * scale4;
  out[1] = a[1] + b[1] * scale4;
  out[2] = a[2] + b[2] * scale4;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random2(out, scale4) {
  scale4 = scale4 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale4;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale4;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot2(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b22 = b[2];
  return Math.abs(a0 - b0) <= EPSILON4 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON4 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b22) <= EPSILON4 * Math.max(1, Math.abs(a2), Math.abs(b22));
}
var sub3 = subtract4;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset;i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../../node_modules/gl-matrix/esm/vec4.js
var exports_vec4 = {};
__export(exports_vec4, {
  zero: () => zero2,
  transformQuat: () => transformQuat2,
  transformMat4: () => transformMat42,
  subtract: () => subtract5,
  sub: () => sub4,
  str: () => str4,
  squaredLength: () => squaredLength2,
  squaredDistance: () => squaredDistance2,
  sqrLen: () => sqrLen2,
  sqrDist: () => sqrDist2,
  set: () => set5,
  scaleAndAdd: () => scaleAndAdd2,
  scale: () => scale4,
  round: () => round3,
  random: () => random3,
  normalize: () => normalize3,
  negate: () => negate2,
  multiply: () => multiply4,
  mul: () => mul4,
  min: () => min3,
  max: () => max3,
  lerp: () => lerp2,
  length: () => length2,
  len: () => len2,
  inverse: () => inverse2,
  fromValues: () => fromValues4,
  forEach: () => forEach2,
  floor: () => floor3,
  exactEquals: () => exactEquals4,
  equals: () => equals5,
  dot: () => dot3,
  divide: () => divide2,
  div: () => div2,
  distance: () => distance2,
  dist: () => dist2,
  cross: () => cross3,
  create: () => create4,
  copy: () => copy4,
  clone: () => clone4,
  ceil: () => ceil3,
  add: () => add5
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set5(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale5) {
  out[0] = a[0] + b[0] * scale5;
  out[1] = a[1] + b[1] * scale5;
  out[2] = a[2] + b[2] * scale5;
  out[3] = a[3] + b[3] * scale5;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
function dot3(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross3(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random3(out, scale5) {
  scale5 = scale5 || 1;
  var v1, v2, v32, v4;
  var s1, s22;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v32 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s22 = v32 * v32 + v4 * v4;
  } while (s22 >= 1);
  var d = Math.sqrt((1 - s1) / s22);
  out[0] = scale5 * v1;
  out[1] = scale5 * v2;
  out[2] = scale5 * v32 * d;
  out[3] = scale5 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b22 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON4 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON4 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b22) <= EPSILON4 * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON4 * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract5;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset;i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// ../../node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON4) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot4(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw2 = b[3];
  out[0] = ax * bw2 + aw * bx + ay * bz - az * by;
  out[1] = ay * bw2 + aw * by + az * bx - ax * bz;
  out[2] = az * bw2 + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw2 - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw2 = Math.cos(rad);
  out[0] = ax * bw2 + aw * bx;
  out[1] = ay * bw2 + az * bx;
  out[2] = az * bw2 - ay * bx;
  out[3] = aw * bw2 - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw2 = Math.cos(rad);
  out[0] = ax * bw2 - az * by;
  out[1] = ay * bw2 + aw * by;
  out[2] = az * bw2 + ax * by;
  out[3] = aw * bw2 - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw2 = Math.cos(rad);
  out[0] = ax * bw2 + ay * bz;
  out[1] = ay * bw2 - ax * bz;
  out[2] = az * bw2 + aw * bz;
  out[3] = aw * bw2 - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw2 = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw2;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw2 = -bw2;
  }
  if (1 - cosom > EPSILON4) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw2;
  return out;
}
function random4(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot4 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot4 ? 1 / dot4 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set6 = set5;
var add6 = add5;
var mul5 = multiply5;
var scale5 = scale4;
var dot4 = dot3;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize4 = normalize3;
var exactEquals5 = exactEquals4;
var equals6 = equals5;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot5 = dot2(a, b);
    if (dot5 < -0.999999) {
      cross2(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001)
        cross2(tmpvec3, yUnitVec3, a);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize4(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// ../../node_modules/gl-matrix/esm/vec2.js
var exports_vec2 = {};
__export(exports_vec2, {
  zero: () => zero3,
  transformMat4: () => transformMat43,
  transformMat3: () => transformMat32,
  transformMat2d: () => transformMat2d,
  transformMat2: () => transformMat2,
  subtract: () => subtract6,
  sub: () => sub5,
  str: () => str6,
  squaredLength: () => squaredLength4,
  squaredDistance: () => squaredDistance3,
  sqrLen: () => sqrLen4,
  sqrDist: () => sqrDist3,
  set: () => set7,
  scaleAndAdd: () => scaleAndAdd3,
  scale: () => scale6,
  round: () => round4,
  rotate: () => rotate3,
  random: () => random5,
  normalize: () => normalize5,
  negate: () => negate3,
  multiply: () => multiply6,
  mul: () => mul6,
  min: () => min4,
  max: () => max4,
  lerp: () => lerp4,
  length: () => length4,
  len: () => len4,
  inverse: () => inverse3,
  fromValues: () => fromValues6,
  forEach: () => forEach3,
  floor: () => floor4,
  exactEquals: () => exactEquals6,
  equals: () => equals7,
  dot: () => dot5,
  divide: () => divide3,
  div: () => div3,
  distance: () => distance3,
  dist: () => dist3,
  cross: () => cross4,
  create: () => create6,
  copy: () => copy6,
  clone: () => clone6,
  ceil: () => ceil4,
  angle: () => angle2,
  add: () => add7
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues6(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set7(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add7(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract6(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil4(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor4(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min4(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max4(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round4(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize5(out, a) {
  var x = a[0], y = a[1];
  var len4 = x * x + y * y;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  return out;
}
function dot5(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross4(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random5(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale7;
  out[1] = Math.sin(r) * scale7;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y22 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y22 * y22), cosine = mag && (x1 * x2 + y1 * y22) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals7(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON4 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON4 * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract6;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset;i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants4 = {
  ObjectType
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var {
  ObjectType: ObjectType2
} = Constants4;
var STATIC2 = {};
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType2.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType2.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType2.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = "";
  publicAPI.getType = () => internalType;
  publicAPI.setType = (value) => {
    internalType = value;
  };
  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;
  publicAPI.generateBuffer = (type) => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = (data, type) => {
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
    dirty = false;
    return true;
  };
  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
      model.allocatedGPUMemoryInBytes = 0;
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = () => error;
}
var DEFAULT_VALUES9 = {
  objectType: ObjectType2.ARRAY_BUFFER,
  context: null,
  allocatedGPUMemoryInBytes: 0
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow", "allocatedGPUMemoryInBytes"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9);
var vtkBufferObject = {
  newInstance: newInstance10,
  extend: extend9,
  ...STATIC2,
  ...Constants4
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
var Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
var Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
var {
  vtkErrorMacro: vtkErrorMacro6
} = macro;
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = new Float64Array(3);
  exports_vec3.inverse(inverseScale, coordScale);
  const matrix = new Float64Array(16);
  exports_mat4.fromRotationTranslationScale(matrix, exports_quat.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(exports_vec3.exactEquals(coordShift, [0, 0, 0]) && exports_vec3.exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;
    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach((a) => {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;
    const cellBuilders = {
      anythingToPoints(numPoints, cellPts, offset, cellId) {
        for (let i = 0;i < numPoints; ++i) {
          addAPoint(cellPts[offset + i], cellId);
        }
      },
      linesToWireframe(numPoints, cellPts, offset, cellIdx) {
        for (let i = 0;i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
        }
      },
      polysToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          for (let i = 0;i < numPoints; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);
          }
        }
      },
      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          for (let i = 0;i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
          }
          for (let i = 0;i < numPoints - 2; i++) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 2], cellIdx);
          }
        }
      },
      polysToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0;i < npts - 2; i++) {
          addAPoint(cellPts[offset + 0], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
          addAPoint(cellPts[offset + i + 2], cellIdx);
        }
      },
      stripsToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0;i < npts - 2; i++) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);
          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);
        }
      }
    };
    const cellCounters = {
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    let func = null;
    let countFunc = null;
    if (outRep === Representation.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }
    const array = cellArray.getData();
    const size = array.length;
    let caboCount = 0;
    for (let index = 0;index < size; ) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }
    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;
    let diagSq = 0;
    let distSq = 0;
    for (let i = 0;i < 3; ++i) {
      const range = options.points.getRange(i);
      const delta = range[1] - range[0];
      diagSq += delta * delta;
      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || Math.abs(Math.log10(diagSq)) > 3 || diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      const coordShift = new Float64Array(3);
      const coordScale = new Float64Array(3);
      for (let i = 0;i < 3; ++i) {
        const range = options.points.getRange(i);
        const delta = range[1] - range[0];
        coordShift[i] = 0.5 * (range[1] + range[0]);
        coordScale[i] = delta > 0 ? 1 / delta : 1;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    let pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(pointId, cellId) {
      if (selectionMaps) {
        selectionMaps.points[pointCount] = pointId;
        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
      }
      ++pointCount;
      pointIdx = pointId * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = pointId * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach((attr) => {
        custIdx = pointId * attr.components;
        for (let j = 0;j < attr.components; ++j) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        if (options.useTCoordsPerCell) {
          tcoordIdx = cellId * textureComponents;
        } else {
          tcoordIdx = pointId * textureComponents;
        }
        for (let j = 0;j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = pointId * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (let index = 0;index < size; index += array[index] + 1, cellCount++) {
      func(array[index], array, index + 1, cellCount + options.cellOffset);
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro6("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro6("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !exports_vec3.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !exports_vec3.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
var DEFAULT_VALUES10 = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend10);
var vtkCellArrayBufferObject = {
  newInstance: newInstance11,
  extend: extend10
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
var {
  vtkErrorMacro: vtkErrorMacro7
} = macro;
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro7(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
var DEFAULT_VALUES11 = {
  shaderType: "Unknown",
  source: "",
  error: "",
  handle: 0,
  dirty: false,
  context: null
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend11, "vtkShader");
var vtkShader$1 = {
  newInstance: newInstance12,
  extend: extend11
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
var {
  vtkErrorMacro: vtkErrorMacro8
} = macro;
function substitute(source, search, replace, all) {
  const replaceStr = typeof replace === "string" ? replace : replace.join(`
`);
  const replaceSearch = all === false ? search : new RegExp(search, "g");
  const resultstr = source.replace(replaceSearch, replaceStr);
  return {
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro8(model.vertexShader.getSource().split(`
`).map((line, index) => `${index}: ${line}`).join(`
`));
      vtkErrorMacro8(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro8(model.fragmentShader.getSource().split(`
`).map((line, index) => `${index}: ${line}`).join(`
`));
      vtkErrorMacro8(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro8(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro8(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro8(`Links failed: ${model.error}`);
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    publicAPI.release();
    if (model.vertexShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.vertexShaderHandle);
      model.vertexShaderHandle = 0;
    }
    if (model.fragmentShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.fragmentShaderHandle);
      model.fragmentShaderHandle = 0;
    }
    model.context.deleteProgram(model.handle);
    model.handle = 0;
    publicAPI.setCompiled(false);
  };
  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = () => !!model.bound;
  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = (ctx) => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = () => {
    if (model.linked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro8(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = (name, a1, a2, a3) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a3 === undefined) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = (name, a) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1;_key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    let array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = (name) => {
    if (!name || !model.linked) {
      return -1;
    }
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = (name) => {
    if (!name) {
      return false;
    }
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro8("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = (name) => {
    if (!name) {
      return false;
    }
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro8("attempt to find uniform when the shader program is not linked");
      return false;
    }
    const loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = (ctx) => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = (mtime) => {
    model.lastCameraMTime = mtime;
  };
}
var DEFAULT_VALUES12 = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: "",
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};
function extend12(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12, "vtkShaderProgram");
var vtkShaderProgram$1 = {
  newInstance: newInstance13,
  extend: extend12,
  substitute
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = () => {
  };
  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = () => model.handleVAO !== 0 || model.supported === false;
  publicAPI.bind = () => {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0;ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0;iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0;i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = () => {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0;ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0;iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0;i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, 0, false);
  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, isMatrix) => {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    const gl = model.context;
    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize6;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      let buffFound = false;
      for (let ibuff = 0;ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0;iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor) => {
    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, true);
    if (!result) {
      return result;
    }
    const gl = model.context;
    const index = gl.getAttribLocation(model.handleProgram, name);
    for (let i = 1;i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize6, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = (name) => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (let ibuff = 0;ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0;iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES13 = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13, "vtkOpenGLVertexArrayObject");
var vtkVertexArrayObject = {
  newInstance: newInstance14,
  extend: extend13
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
var primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = (win) => {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = (oglwin) => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
    if (model.CABO.getElementCount()) {
      const mode = publicAPI.getOpenGLMode(rep);
      const wideLines = publicAPI.haveWideLines(ren, actor);
      const gl = model.context;
      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      const drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        gl.lineWidth(1);
      }
      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = (rep) => {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    const type = model.primitiveType;
    if (rep === Representation.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = (ren, actor) => {
    if (actor.getProperty().getLineWidth() > 1) {
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (ren, actor, oglMapper) => {
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);
      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (ren, actor, size) => {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f("viewportSize", size.usize, size.vsize);
      const lineWidth = parseFloat(actor.getProperty().getLineWidth());
      const halfLineWidth = lineWidth / 2;
      publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {
      publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = () => {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
}
var DEFAULT_VALUES14 = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend14);
var vtkHelper = {
  newInstance: newInstance15,
  extend: extend14,
  primTypes
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var {
  Representation: Representation2,
  Interpolation: Interpolation2
} = PropertyConst;
function notImplemented2(method) {
  return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented2("ComputeCompositeColor");
  publicAPI.getColor = () => {
    let norm2 = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm2 = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i = 0;i < 3; i++) {
      model.color[i] = norm2 * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = (specularPower) => {
    const roughness = 1 / Math.max(1, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower;
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented2("AddShaderVariable");
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation2.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation2.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation2.PHONG);
  publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation2, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation2.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation2.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation2.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation2, model.representation);
}
var DEFAULT_VALUES15 = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation2.GOURAUD,
  representation: Representation2.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null
};
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkProperty");
var vtkProperty$1 = {
  newInstance: newInstance16,
  extend: extend15,
  ...PropertyConst
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
var {
  Representation: Representation3
} = vtkProperty$1;
var {
  vtkErrorMacro: vtkErrorMacro9
} = macro;
function translucentShaderReplacement(shaders) {
  const substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
  shaders.Fragment = substituteRes.result;
}
var oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
  publicAPI.createVertexBuffer = () => {
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    const tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    const cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation3.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = (viewNode) => {
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.create(...size);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, "Float32Array", null);
    model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, "Float32Array", null);
    model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size[0], size[1], "Float32Array", null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = (viewNode) => {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join(`
`), oitpFragTemplate, "");
  };
  publicAPI.createVBO = (viewNode) => {
    const gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    const program = model.copyShader;
    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro9("Error setting vertexDC in copy shader VAO.");
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro9("Error setting vertexDC in copy shader VAO.");
    }
  };
  publicAPI.traverse = (viewNode, renNode, forwardPass) => {
    if (model.deleted) {
      return;
    }
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      const fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1]);
    gl.colorMask(false, false, false, false);
    if (forwardPass.getOpaqueActorCount() > 0) {
      forwardPass.setCurrentOperation("opaqueZBufferPass");
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
    gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    publicAPI.setCurrentOperation("translucentPass");
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }
    if (!model.copyVAO) {
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();
    const ts = renNode.getTiledSizeAndOrigin();
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
  };
  publicAPI.getShaderReplacement = () => {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = (viewNode) => {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES16 = {
  framebuffer: null,
  copyShader: null,
  tris: null
};
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkOpenGLOrderIndependentTranslucentPass");
var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: newInstance17,
  extend: extend16
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
function vtkForwardPass(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model._currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    const numlayers = viewNode.getRenderable().getNumberOfLayers();
    const renderers = viewNode.getRenderable().getRenderersByReference();
    for (let i = 0;i < numlayers; i++) {
      for (let index = 0;index < renderers.length; index++) {
        const ren = renderers[index];
        const renNode = viewNode.getViewNodeFor(ren);
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
            const size = viewNode.getFramebufferSize();
            if (model.framebuffer === null) {
              model.framebuffer = vtkOpenGLFramebuffer.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation("zBufferPass");
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation("opaquePass");
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation("volumePass");
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation("overlayPass");
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = () => {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
}
var DEFAULT_VALUES17 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};
function extend17(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
  vtkForwardPass(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17, "vtkForwardPass");
var vtkForwardPass$1 = {
  newInstance: newInstance18,
  extend: extend17
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants5 = {
  PassTypes
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
var {
  vtkErrorMacro: vtkErrorMacro10,
  vtkWarningMacro: vtkWarningMacro4
} = macro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  const superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map((item) => ({
      data: vtk(item.data)
    }));
  }
  publicAPI.initialize = () => {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = () => {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = (other) => {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x);
    model.arrays = other.arrays().map((x) => ({
      array: x
    }));
  };
  publicAPI.getNumberOfArrays = () => model.arrays.length;
  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
  publicAPI.addArray = (arr) => {
    const name = arr.getName();
    const {
      array,
      index
    } = publicAPI.getArrayWithIndex(name);
    if (array != null) {
      model.arrays[index] = {
        data: arr
      };
      return index;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
  };
  publicAPI.removeArray = (arrayName) => {
    const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return publicAPI.removeArrayByIndex(index);
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
      model.arrays.splice(arrayIdx, 1);
      return true;
    }
    return false;
  };
  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
  publicAPI.getArray = (arraySpec) => typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  publicAPI.getArrayByName = (arrayName) => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);
  publicAPI.getArrayWithIndex = (arrayName) => {
    const index = model.arrays.findIndex((array) => array.data.getName() === arrayName);
    return {
      array: index !== -1 ? model.arrays[index].data : null,
      index
    };
  };
  publicAPI.getArrayByIndex = (idx) => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  publicAPI.hasArray = (arrayName) => publicAPI.getArrayWithIndex(arrayName).index >= 0;
  publicAPI.getArrayName = (idx) => {
    const arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
  publicAPI.passData = function(other) {
    let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    let toId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro10("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    let fromId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    let fromId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    let toId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            vtkWarningMacro4("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro10("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = (arrayName) => {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = (arrayName) => {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = () => {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = () => {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = () => {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = (other) => {
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);
  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);
  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  publicAPI.getState = () => {
    const result = superGetState();
    if (result) {
      result.arrays = model.arrays.map((item) => ({
        data: item.data.getState()
      }));
    }
    return result;
  };
}
var DEFAULT_VALUES18 = {
  arrays: [],
  copyFieldFlags: [],
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend18, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance: newInstance19,
  extend: extend18
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  HIGHCONNECTIVITYCELL: 2,
  LOWCONNECTIVITYCELL: 4,
  REFINEDCELL: 8,
  EXTERIORCELL: 16,
  HIDDENCELL: 32
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  HIDDENPOINT: 2
};
var AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  SINGLE: 1,
  DOUBLE: 2
};
var Constants6 = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
var {
  AttributeTypes: AttributeTypes2,
  AttributeCopyOperations: AttributeCopyOperations2
} = Constants6;
var {
  vtkWarningMacro: vtkWarningMacro5
} = macro;
function vtkDataSetAttributes(publicAPI, model) {
  const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    let cleanAttType = attrTypes.find((ee) => AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase());
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  const superClass = {
    ...publicAPI
  };
  publicAPI.checkNumberOfComponents = (x) => true;
  publicAPI.setAttribute = (arr, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro5(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro5(`Cannot set attribute ${attType}. Incorrect number of components.`);
      return -1;
    }
    let currentAttribute = model[`active${attType}`];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model[`active${attType}`] = currentAttribute;
    } else {
      model[`active${attType}`] = -1;
    }
    publicAPI.modified();
    return model[`active${attType}`];
  };
  publicAPI.getAttributes = (arr) => attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);
  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        const arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro5(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro5(`Cannot set attribute ${attType}. Incorrect number of components.`);
          return -1;
        }
      }
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = (attType) => {
    const cleanAttType = cleanAttributeType(attType);
    return publicAPI[`get${cleanAttType}`]();
  };
  publicAPI.removeAllArrays = () => {
    attrTypes.forEach((attType) => {
      model[`active${attType}`] = -1;
    });
    superClass.removeAllArrays();
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1) {
      attrTypes.forEach((attType) => {
        if (arrayIdx === model[`active${attType}`]) {
          model[`active${attType}`] = -1;
        } else if (arrayIdx < model[`active${attType}`]) {
          model[`active${attType}`] -= 1;
        }
      });
    }
    return superClass.removeArrayByIndex(arrayIdx);
  };
  attrTypes.forEach((value) => {
    const activeVal = `active${value}`;
    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
    publicAPI[`setActive${value}`] = (arrayName) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    publicAPI[`copy${value}Off`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
    publicAPI[`copy${value}On`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = () => {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter((op) => op !== "ALLCOPY").forEach((attCopyOp) => {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter((ty2) => ty2 !== "NUM_ATTRIBUTES").reduce((a, b) => {
        a[AttributeTypes2[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach((name) => {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug) => {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES19 = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = {
  newInstance: newInstance20,
  extend: extend19,
  ...Constants6
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes = {
  UNIFORM: 0,
  DATA_OBJECT_FIELD: 0,
  COORDINATE: 1,
  POINT_DATA: 1,
  POINT: 2,
  POINT_FIELD_DATA: 2,
  CELL: 3,
  CELL_FIELD_DATA: 3,
  VERTEX: 4,
  VERTEX_FIELD_DATA: 4,
  EDGE: 5,
  EDGE_FIELD_DATA: 5,
  ROW: 6,
  ROW_DATA: 6
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants7 = {
  FieldDataTypes,
  FieldAssociations
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach((fieldName) => {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach((fieldName) => {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}
var DEFAULT_VALUES20 = {};
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  vtkDataSet(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend20, "vtkDataSet");
var vtkDataSet$1 = {
  newInstance: newInstance21,
  extend: extend20,
  ...Constants7
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
var {
  FieldAssociations: FieldAssociations2
} = vtkDataSet$1;
function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkHardwareSelector");
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
  };
  publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
    if (srcData) {
      return srcData.generateSelection(fx1, fy1, fx2, fy2);
    }
    return [];
  };
}
var DEFAULT_VALUES21 = {
  fieldAssociation: FieldAssociations2.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
  vtkHardwareSelector(publicAPI, model);
}
var newInstance22 = macro.newInstance(extend21, "vtkHardwareSelector");
var vtkHardwareSelector$1 = {
  newInstance: newInstance22,
  extend: extend21
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
var SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
var SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants8 = {
  SelectionContent,
  SelectionField
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
function vtkSelectionNode(publicAPI, model) {
  model.classHierarchy.push("vtkSelectionNode");
  publicAPI.getBounds = () => model.points.getBounds();
}
var DEFAULT_VALUES22 = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  macro.obj(publicAPI, model);
  model.properties = {};
  macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
  vtkSelectionNode(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend22, "vtkSelectionNode");
var vtkSelectionNode$1 = {
  newInstance: newInstance23,
  extend: extend22,
  ...Constants8
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
var {
  PassTypes: PassTypes2
} = Constants5;
var {
  SelectionContent: SelectionContent2,
  SelectionField: SelectionField2
} = vtkSelectionNode$1;
var {
  FieldAssociations: FieldAssociations3
} = vtkDataSet$1;
var {
  vtkErrorMacro: vtkErrorMacro11
} = macro;
var idOffset = 1;
function getInfoHash(info) {
  return `${info.propID} ${info.compositeID}`;
}
function getAlpha(xx, yy2, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy2 * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset + 3];
}
function convert(xx, yy2, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy2 * (area[2] - area[0] + 1) + xx) * 4;
  const r = pb[offset];
  const g = pb[offset + 1];
  const b = pb[offset + 2];
  return (b * 256 + g) * 256 + r;
}
function getID(low24, high8) {
  let val = high8;
  val <<= 24;
  val |= low24;
  return val;
}
function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }
    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      return null;
    }
    const info2 = {};
    info2.valid = true;
    info2.propID = actorid - idOffset;
    info2.prop = buffdata.props[info2.propID];
    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    info2.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      info2.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535;
      info2.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes2.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area) === 0) {
        return info2;
      }
    }
    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_LOW24], buffdata.area);
    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ID_HIGH24], buffdata.area);
    info2.attributeID = getID(low24, high24);
    return info2;
  }
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (let dist4 = 1;dist4 < maxDist; ++dist4) {
    for (let y = dispPos[1] > dist4 ? dispPos[1] - dist4 : 0;y <= dispPos[1] + dist4; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist4) {
        curPos[0] = dispPos[0] - dist4;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist4;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    for (let x = dispPos[0] >= dist4 ? dispPos[0] - (dist4 - 1) : 0;x <= dispPos[0] + (dist4 - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist4) {
        curPos[1] = dispPos[1] - dist4;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist4;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent2.INDICES);
    switch (fieldassociation) {
      case FieldAssociations3.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField2.CELL);
        break;
      case FieldAssociations3.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField2.POINT);
        break;
      default:
        vtkErrorMacro11("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y22 = Math.floor(fy2);
  const dataMap = new Map;
  const outSelectedPosition = [0, 0];
  for (let yy2 = y1;yy2 <= y22; yy2++) {
    for (let xx = x1;xx <= x2; xx++) {
      const pos = [xx, yy2];
      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        const hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}
function vtkOpenGLHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHardwareSelector");
  publicAPI.releasePixBuffers = () => {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };
  publicAPI.beginSelection = () => {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model.maxAttributeId = 0;
    const size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === FieldAssociations3.FIELD_ASSOCIATION_POINTS) {
      const gl = model._openGLRenderWindow.getContext();
      const originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    model._renderer = renderer;
    if (fx1 === undefined) {
      const size = model._openGLRenderWindow.getSize();
      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
    } else {
      publicAPI.setArea(fx1, fy1, fx2, fy2);
    }
    if (!publicAPI.captureBuffers()) {
      return false;
    }
    const result = {
      area: [...model.area],
      pixBuffer: [...model.pixBuffer],
      captureZValues: model.captureZValues,
      zBuffer: model.zBuffer,
      props: [...model.props],
      fieldAssociation: model.fieldAssociation,
      renderer,
      openGLRenderWindow: model._openGLRenderWindow
    };
    result.generateSelection = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return generateSelectionWithData(result, ...args);
    };
    return result;
  };
  publicAPI.captureBuffers = () => {
    if (!model._renderer || !model._openGLRenderWindow) {
      vtkErrorMacro11("Renderer and view must be set before calling Select.");
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model._openGLRenderWindow.getRenderable().preRender();
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0, 0, 0, 0);
    const rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    const pixelBufferSavedPasses = [];
    for (model.currentPass = PassTypes2.MIN_KNOWN_PASS;model.currentPass <= PassTypes2.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes2.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        pixelBufferSavedPasses.push(model.currentPass);
      }
    }
    pixelBufferSavedPasses.forEach((pass) => {
      model.currentPass = pass;
      publicAPI.processPixelBuffers();
    });
    model.currentPass = PassTypes2.MAX_KNOWN_PASS;
    publicAPI.endSelection();
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    return true;
  };
  publicAPI.processPixelBuffers = () => {
    model.props.forEach((prop, index) => {
      if (publicAPI.isPropHit(index)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
      }
    });
  };
  publicAPI.passRequired = (pass) => {
    if (pass === PassTypes2.ID_HIGH24) {
      if (model.fieldAssociation === FieldAssociations3.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 16777215;
      }
      if (model.fieldAssociation === FieldAssociations3.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 16777215;
      }
    }
    return true;
  };
  publicAPI.savePixelBuffer = (passNo) => {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes2.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };
  publicAPI.buildPropHitList = (pixelbuffer) => {
    let offset = 0;
    for (let yy2 = 0;yy2 <= model.area[3] - model.area[1]; yy2++) {
      for (let xx = 0;xx <= model.area[2] - model.area[0]; xx++) {
        let val = convert(xx, yy2, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset * 4);
        }
        ++offset;
      }
    }
  };
  publicAPI.renderProp = (prop) => {
    if (model.currentPass === PassTypes2.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };
  publicAPI.renderCompositeIndex = (index) => {
    if (model.currentPass === PassTypes2.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };
  publicAPI.renderAttributeId = (attribid) => {
    if (attribid < 0) {
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
  };
  publicAPI.passTypeToString = (type) => macro.enumToString(PassTypes2, type);
  publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);
  publicAPI.setPropColorValueFromInt = (val) => {
    model.propColorValue[0] = val % 256 / 255;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
  };
  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }
      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        return null;
      }
      const info2 = {};
      info2.valid = true;
      info2.propID = actorid - idOffset;
      info2.prop = model.props[info2.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      info2.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        info2.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535;
        info2.displayPosition = inDisplayPosition;
      }
      if (model.pixBuffer[PassTypes2.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area) === 0) {
          return info2;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_LOW24], model.area);
      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ID_HIGH24], model.area);
      info2.attributeID = getID(low24, high24);
      return info2;
    }
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist4 = 1;dist4 < maxDist; ++dist4) {
      for (let y = dispPos[1] > dist4 ? dispPos[1] - dist4 : 0;y <= dispPos[1] + dist4; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist4) {
          curPos[0] = dispPos[0] - dist4;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist4;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (let x = dispPos[0] >= dist4 ? dispPos[0] - (dist4 - 1) : 0;x <= dispPos[0] + (dist4 - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist4) {
          curPos[1] = dispPos[1] - dist4;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist4;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y22 = Math.floor(fy2);
    const dataMap = new Map;
    const outSelectedPosition = [0, 0];
    for (let yy2 = y1;yy2 <= y22; yy2++) {
      for (let xx = x1;xx <= x2; xx++) {
        const pos = [xx, yy2];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = (passNo) => model.rawPixBuffer[passNo];
  publicAPI.getPixelBuffer = (passNo) => model.pixBuffer[passNo];
  publicAPI.attach = (openGLRenderWindow, renderer) => {
    model._openGLRenderWindow = openGLRenderWindow;
    model._renderer = renderer;
  };
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = function() {
    if (superSetArea(...arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES23 = {
  area: undefined,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};
function extend23(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macro.setGetArray(publicAPI, model, ["area"], 4);
  macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow", "maximumPointId", "maximumCellId"]);
  macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
  macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
  macro.event(publicAPI, model, "event");
  vtkOpenGLHardwareSelector(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend23, "vtkOpenGLHardwareSelector");
var vtkHardwareSelector2 = {
  newInstance: newInstance24,
  extend: extend23,
  ...Constants5
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
var import_spark_md5 = __toESM(require_spark_md5(), 1);
var SET_GET_FIELDS = ["lastShaderProgramBound", "context", "_openGLRenderWindow"];
function vtkShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkShaderCache");
  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
    }
    const gl2 = model._openGLRenderWindow.getWebgl2();
    let fragDepthString = `
`;
    let version = `#version 100
`;
    if (gl2) {
      version = `#version 300 es
` + `#define attribute in
` + `#define textureCube texture
` + `#define texture2D texture
` + `#define textureCubeLod textureLod
` + `#define texture2DLod textureLod
`;
    } else {
      model.context.getExtension("OES_standard_derivatives");
      if (model.context.getExtension("EXT_frag_depth")) {
        fragDepthString = `#extension GL_EXT_frag_depth : enable
`;
      }
      if (model.context.getExtension("EXT_shader_texture_lod")) {
        fragDepthString += `#extension GL_EXT_shader_texture_lod : enable
` + `#define textureCubeLod textureCubeLodEXT
` + "#define texture2DLod texture2DLodEXT";
      }
    }
    nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", [`${version}
`, gl2 ? "" : `#extension GL_OES_standard_derivatives : enable
`, fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    let nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", [`${version}
`, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    if (gl2) {
      nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
      let shaderOutputs = "";
      let outputCount = 0;
      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};
`;
        outputCount++;
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
    }
    const nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };
  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shaderProgram);
  };
  publicAPI.readyShaderProgram = (program) => {
    if (!program) {
      return null;
    }
    if (!program.getCompiled() && !program.compileShader()) {
      return null;
    }
    if (!publicAPI.bindShaderProgram(program)) {
      return null;
    }
    return program;
  };
  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = import_spark_md5.default.hash(hashInput);
    if (!(result in model.shaderPrograms)) {
      const sps = vtkShaderProgram$1.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = (win) => {
    publicAPI.releaseCurrentShaderProgram();
    Object.keys(model.shaderPrograms).map((key) => model.shaderPrograms[key]).forEach((sp) => sp.cleanup());
    model.shaderPrograms = {};
  };
  publicAPI.releaseCurrentShaderProgram = () => {
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.cleanup();
      model.lastShaderProgramBound = null;
    }
  };
  publicAPI.bindShaderProgram = (program) => {
    if (model.lastShaderProgramBound === program) {
      return 1;
    }
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.release();
    }
    program.bind();
    model.lastShaderProgramBound = program;
    return 1;
  };
}
var DEFAULT_VALUES24 = {
  lastShaderProgramBound: null,
  shaderPrograms: null,
  context: null
};
function extend24(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  model.shaderPrograms = {};
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, SET_GET_FIELDS);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkShaderCache(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend24, "vtkShaderCache");
var vtkShaderCache$1 = {
  newInstance: newInstance25,
  extend: extend24
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
var {
  vtkErrorMacro: vtkErrorMacro12
} = macro;
function vtkOpenGLTextureUnitManager(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTextureUnitManager");
  publicAPI.deleteTable = () => {
    for (let i = 0;i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        vtkErrorMacro12("some texture units  were not properly released");
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };
  publicAPI.setContext = (ctx) => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (let i = 0;i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.allocate = () => {
    for (let i = 0;i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = (unit) => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };
  publicAPI.isAllocated = (textureUnitId) => model.textureUnits[textureUnitId];
  publicAPI.free = (val) => {
    model.textureUnits[val] = false;
  };
  publicAPI.freeAll = () => {
    for (let i = 0;i < model.numberOfTextureUnits; ++i) {
      model.textureUnits[i] = false;
    }
  };
}
var DEFAULT_VALUES25 = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};
function extend25(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  macro.obj(publicAPI, model);
  model.textureUnits = [];
  macro.get(publicAPI, model, ["numberOfTextureUnits"]);
  macro.setGet(publicAPI, model, ["context"]);
  vtkOpenGLTextureUnitManager(publicAPI, model);
}
var newInstance26 = macro.newInstance(extend25, "vtkOpenGLTextureUnitManager");
var vtkTextureUnitManager = {
  newInstance: newInstance26,
  extend: extend25
};

// ../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
function vtkRenderWindowViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowViewNode");
  publicAPI.getViewNodeFactory = () => null;
  publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
  publicAPI.getAspectRatioForRenderer = (renderer) => {
    const viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = (x, y, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = (viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = (viewport) => {
    const size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
  publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
  publicAPI.worldToDisplay = (x, y, z, renderer) => {
    const val = renderer.worldToView(x, y, z);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = (x, y, z, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x, y, z);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1), y / (size[1] - 1), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1), y * (size[1] - 1), z];
  };
  publicAPI.displayToLocalDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    const x2 = x + vCoords[0] + 0.5;
    const y22 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y22, z);
  };
  publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
  publicAPI.getContainerSize = () => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.getPixelData = (x1, y1, x2, y22) => {
    macro.vtkErrorMacro("not implemented");
  };
  publicAPI.createSelector = () => {
    macro.vtkErrorMacro("not implemented");
  };
}
var DEFAULT_VALUES26 = {
  size: undefined,
  selector: undefined
};
function extend26(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macro.getArray(publicAPI, model, ["size"], 2);
  macro.get(publicAPI, model, ["selector"]);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkRenderWindowViewNode(publicAPI, model);
}
var newInstance27 = macro.newInstance(extend26, "vtkRenderWindowViewNode");
var vtkRenderWindowViewNode$1 = {
  newInstance: newInstance27,
  extend: extend26
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
var GET_UNDERLYING_CONTEXT = "__getUnderlyingContext";
function createContextProxyHandler() {
  const cache2 = new Map;
  const getParameterHandler = {
    apply(target, gl, args) {
      if (cache2.has(args[0])) {
        return cache2.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };
  function cachedSetterHandler(key) {
    return {
      apply(target, gl, args) {
        cache2.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }
  const propHandlers = Object.create(null);
  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);
  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  return {
    get(gl, prop, receiver) {
      if (prop === GET_UNDERLYING_CONTEXT)
        return () => gl;
      let value = Reflect.get(gl, prop, gl);
      if (value instanceof Function) {
        value = value.bind(gl);
      }
      const propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var {
  vtkDebugMacro: vtkDebugMacro3,
  vtkErrorMacro: vtkErrorMacro13
} = macro;
var SCREENSHOT_PLACEHOLDER = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
var parentMethodsToProxy = ["activateTexture", "deactivateTexture", "disableCullFace", "enableCullFace", "get3DContext", "getActiveFramebuffer", "getContext", "getDefaultTextureByteSize", "getDefaultTextureInternalFormat", "getDefaultToWebgl2", "getGLInformations", "getGraphicsMemoryInfo", "getGraphicsResourceForObject", "getHardwareMaximumLineWidth", "getPixelData", "getShaderCache", "getTextureUnitForTexture", "getTextureUnitManager", "getWebgl2", "makeCurrent", "releaseGraphicsResources", "registerGraphicsResourceUser", "unregisterGraphicsResourceUser", "restoreContext", "setActiveFramebuffer", "setContext", "setDefaultToWebgl2", "setGraphicsResourceForObject"];
function checkRenderTargetSupport(gl, format, type) {
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}
var GL_CONTEXT_COUNT = 0;
var GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}
function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}
function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}
function _preventDefault(e) {
  e.preventDefault();
}
function vtkOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderWindow");
  let cachingContextHandler;
  function getCachingContextHandler() {
    if (!cachingContextHandler) {
      cachingContextHandler = createContextProxyHandler();
    }
    return cachingContextHandler;
  }
  publicAPI.getViewNodeFactory = () => model.myFactory;
  model.canvas.addEventListener("webglcontextlost", _preventDefault, false);
  model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
  const previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach((child) => {
        child.setOpenGLRenderWindow?.(publicAPI);
      });
    }
  };
  publicAPI.initialize = () => {
    if (!model.initialized) {
      model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (model.rootOpenGLRenderWindow) {
        model.context2D = publicAPI.get2DContext();
      } else {
        model.context = publicAPI.get3DContext();
        publicAPI.resizeFromChildRenderWindows();
        if (model.context) {
          createGLContext();
        }
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
      }
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro13("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => {
    const fbSize = model.activeFramebuffer?.getSize();
    return fbSize || model.size;
  };
  publicAPI.getPixelData = (x1, y1, x2, y22) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y22 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y22 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: "high-performance"
    };
    let result = null;
    const webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext("webgl2", options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro3("using webgl2");
      }
    }
    if (!result) {
      vtkDebugMacro3("using webgl1");
      result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
    }
    return new Proxy(result, getCachingContextHandler());
  };
  publicAPI.get2DContext = function() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return model.canvas.getContext("2d", options);
  };
  publicAPI.restoreContext = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro13("Hardware does not support the number of textures defined.");
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      publicAPI.getTextureUnitManager().free(result);
      model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = (texture) => {
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureByteSize = function(vtkType) {
    let oglNorm16Ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let useHalfFloat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (model.webgl2) {
      switch (vtkType) {
        case VtkDataTypes.CHAR:
        case VtkDataTypes.SIGNED_CHAR:
        case VtkDataTypes.UNSIGNED_CHAR:
          return 1;
        case oglNorm16Ext:
        case useHalfFloat:
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.VOID:
          return 2;
        default:
          return 4;
      }
    }
    return 1;
  };
  publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps) {
    let oglNorm16Ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let useHalfFloat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (model.webgl2) {
      switch (vtktype) {
        case VtkDataTypes.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_EXT;
            case 2:
              return oglNorm16Ext.RG16_EXT;
            case 3:
              return oglNorm16Ext.RGB16_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_EXT;
          }
        case (oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT):
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_SNORM_EXT;
            case 2:
              return oglNorm16Ext.RG16_SNORM_EXT;
            case 3:
              return oglNorm16Ext.RGB16_SNORM_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_SNORM_EXT;
          }
        case VtkDataTypes.UNSIGNED_SHORT:
        case VtkDataTypes.SHORT:
        case VtkDataTypes.FLOAT:
        default:
          switch (numComps) {
            case 1:
              return useHalfFloat ? model.context.R16F : model.context.R32F;
            case 2:
              return useHalfFloat ? model.context.RG16F : model.context.RG32F;
            case 3:
              return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
            case 4:
            default:
              return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
          }
      }
    }
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;
    const temporaryCanvas = document.createElement("canvas");
    const temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach((renderer) => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach((viewProp) => {
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName("canvas");
          for (let i = 0;i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png";
    let {
      resetCamera = false,
      size = null,
      scale: scale7 = 1
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale7 !== 1 ? size || model.size.map((val) => val * scale7) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach((_ref) => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          const tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model.rootOpenGLRenderWindow?.resizeFromChildRenderWindows();
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map((renderer) => {
              const camera = renderer.getActiveCamera();
              const params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : undefined,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach((_ref2) => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  let hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = () => {
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    const gl = publicAPI.get3DContext();
    const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = () => {
    if (model._glInformation) {
      return model._glInformation;
    }
    const gl = publicAPI.get3DContext();
    const glTextureFloat = gl.getExtension("OES_texture_float");
    const glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
    const glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
    const glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    const params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    model._glInformation = result;
    return result;
  };
  publicAPI.traverseAllPasses = () => {
    if (model.renderPasses) {
      for (let index = 0;index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    publicAPI.copyParentContent();
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    for (let i = 0;i < childrenRW.length; ++i) {
      publicAPI.getViewNodeFor(childrenRW[i])?.traverseAllPasses();
    }
  };
  publicAPI.copyParentContent = () => {
    const rootParent = model.rootOpenGLRenderWindow;
    if (!rootParent || !model.context2D || model.children.some((oglRenderer) => !!oglRenderer.getSelector?.())) {
      return;
    }
    const parentCanvas = rootParent.getCanvas();
    const selfCanvas = model.canvas;
    model.context2D.drawImage(parentCanvas, 0, parentCanvas.height - selfCanvas.height, selfCanvas.width, selfCanvas.height, 0, 0, selfCanvas.width, selfCanvas.height);
  };
  publicAPI.resizeFromChildRenderWindows = () => {
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    if (childrenRW.length > 0) {
      const maxSize = [0, 0];
      for (let i = 0;i < childrenRW.length; ++i) {
        const childSize = publicAPI.getViewNodeFor(childrenRW[i])?.getSize();
        if (childSize) {
          maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
          maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
        }
      }
      publicAPI.setSize(...maxSize);
    }
  };
  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady((e) => publicAPI.setBackgroundImage(e.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = () => {
    const ret = vtkHardwareSelector2.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  function clearEvents() {
    model.canvas.removeEventListener("webglcontextlost", _preventDefault);
    model.canvas.removeEventListener("webglcontextrestored", publicAPI.restoreContext);
  }
  publicAPI.delete = macro.chain(() => {
    if (model.context) {
      deleteGLContext();
    }
    publicAPI.setContainer();
    publicAPI.setViewStream();
  }, clearEvents, publicAPI.delete);
  publicAPI.setActiveFramebuffer = (newActiveFramebuffer) => {
    model.activeFramebuffer = newActiveFramebuffer;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.registerGraphicsResourceUser = (coreObject, newUser) => {
    if (!model._graphicsResources.has(coreObject)) {
      publicAPI.setGraphicsResourceForObject(coreObject, null, null);
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    sharedResource?.users.add(newUser);
  };
  publicAPI.unregisterGraphicsResourceUser = (coreObject, oldUser) => {
    const sharedResource = model._graphicsResources.get(coreObject);
    if (!sharedResource) {
      return;
    }
    sharedResource.users.delete(oldUser);
    if (!sharedResource.users.size) {
      sharedResource.oglObject?.releaseGraphicsResources(publicAPI);
      model._graphicsResources.delete(coreObject);
    }
  };
  publicAPI.getGraphicsResourceForObject = (coreObject) => model._graphicsResources.get(coreObject);
  publicAPI.setGraphicsResourceForObject = (coreObject, oglObject, hash) => {
    if (!coreObject) {
      return;
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    sharedResource?.oglObject?.releaseGraphicsResources(publicAPI);
    model._graphicsResources.set(coreObject, {
      coreObject,
      oglObject,
      hash,
      users: sharedResource?.users ?? new Set
    });
  };
  publicAPI.getGraphicsMemoryInfo = () => {
    let memUsed = 0;
    model._graphicsResources.forEach((_ref3) => {
      let {
        oglObject
      } = _ref3;
      memUsed += oglObject.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.shaderCache !== null) {
      model.shaderCache.releaseGraphicsResources(publicAPI);
    }
    model._graphicsResources.forEach((_ref4) => {
      let {
        oglObject
      } = _ref4;
      oglObject.releaseGraphicsResources(publicAPI);
    });
    model._graphicsResources.clear();
    if (model.textureUnitManager !== null) {
      model.textureUnitManager.freeAll();
    }
    model.renderable.getRenderersByReference().forEach((ren) => {
      const glRen = publicAPI.getViewNodeFor(ren);
      glRen?.releaseGraphicsResources();
    });
  };
  const publicAPIBeforeProxy = {
    ...publicAPI
  };
  parentMethodsToProxy.forEach((methodName) => {
    publicAPI[methodName] = function() {
      if (model.rootOpenGLRenderWindow) {
        return model.rootOpenGLRenderWindow[methodName](...arguments);
      }
      return publicAPIBeforeProxy[methodName](...arguments);
    };
  });
}
var DEFAULT_VALUES27 = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  context2D: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  activeFramebuffer: null,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false
};
function extend27(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
    model.canvas.style.width = "100%";
  }
  if (!model.selector) {
    model.selector = vtkHardwareSelector2.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }
  model.bgImage = new Image;
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  model._textureResourceIds = new Map;
  model._graphicsResources = new Map;
  model._glInformation = null;
  model.myFactory = vtkViewNodeFactory2.newInstance();
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);
  model.renderPasses[0] = vtkForwardPass$1.newInstance();
  macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "useBackgroundImage", "activeFramebuffer", "rootOpenGLRenderWindow"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "context2D", "canvas", "renderPasses", "notifyStartCaptureImage", "defaultToWebgl2", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "windowResizeEvent");
  vtkOpenGLRenderWindow(publicAPI, model);
}
var newInstance28 = macro.newInstance(extend27, "vtkOpenGLRenderWindow");
registerViewConstructor("WebGL", newInstance28);
var vtkRenderWindow2 = {
  newInstance: newInstance28,
  extend: extend27,
  pushMonitorGLContextCount,
  popMonitorGLContextCount
};
registerOverride("vtkRenderWindow", newInstance28);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
function vtkOpenGLActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0;index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0;index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0;index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0;index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      exports_mat4.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      exports_mat4.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        exports_mat3.identity(model.keyMatrices.normalMatrix);
      } else {
        exports_mat3.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        exports_mat3.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        exports_mat3.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES28 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null
};
function extend28(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: exports_mat3.identity(new Float64Array(9)),
    mcwc: exports_mat4.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor(publicAPI, model);
}
var newInstance29 = newInstance(extend28);
var vtkActor = {
  newInstance: newInstance29,
  extend: extend28
};
registerOverride("vtkActor", newInstance29);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
function vtkOpenGLActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0;index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0;index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0;index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0;index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.overlayPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0;index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
}
var DEFAULT_VALUES29 = {
  context: null,
  activeTextures: null
};
function extend29(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor2D(publicAPI, model);
}
var newInstance30 = newInstance(extend29);
var vtkActor2D = {
  newInstance: newInstance30,
  extend: extend29
};
registerOverride("vtkActor2D", newInstance30);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = (ren) => {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      exports_mat4.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      exports_mat3.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      exports_mat3.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      exports_mat4.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      exports_mat4.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      exports_mat4.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      exports_mat4.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES30 = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend30(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var newInstance31 = newInstance(extend30);
var vtkCamera = {
  newInstance: newInstance31,
  extend: extend30
};
registerOverride("vtkCamera", newInstance31);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = (plane) => {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = (clippingPlane) => {
    const i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = (planes) => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0;i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();
        const v1 = normal[0];
        const v2 = normal[1];
        const v32 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v32 * origin[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v32 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v32 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v32 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v32 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}
var DEFAULT_VALUES31 = {
  clippingPlanes: []
};
function extend31(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var vtkAbstractMapper$1 = {
  extend: extend31
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/ImplicitFunction.js
function vtkImplicitFunction(publicAPI, model) {
  model.classHierarchy.push("vtkImplicitFunction");
  publicAPI.functionValue = (xyz) => {
    if (!model.transform) {
      return publicAPI.evaluateFunction(xyz);
    }
    const transformedXYZ = [];
    model.transform.transformPoint(xyz, transformedXYZ);
    return publicAPI.evaluateFunction(transformedXYZ);
  };
  publicAPI.evaluateFunction = (_xyz) => {
    macro.vtkErrorMacro("not implemented");
  };
}
var DEFAULT_VALUES32 = {};
function extend32(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["transform"]);
  vtkImplicitFunction(publicAPI, model);
}
var newInstance32 = macro.newInstance(extend32, "vtkImplicitFunction");
var vtkImplicitFunction$1 = {
  newInstance: newInstance32,
  extend: extend32
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js
var PLANE_TOLERANCE = 0.000001;
var COINCIDE = "coincide";
var DISJOINT = "disjoint";
function evaluate(normal, origin, x) {
  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
}
function distanceToPlane(x, origin, normal) {
  const distance4 = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  return Math.abs(distance4);
}
function projectPoint(x, origin, normal, xproj) {
  const xo = [];
  subtract(x, origin, xo);
  const t = dot(normal, xo);
  xproj[0] = x[0] - t * normal[0];
  xproj[1] = x[1] - t * normal[1];
  xproj[2] = x[2] - t * normal[2];
}
function projectVector2(v, normal, vproj) {
  const t = dot(v, normal);
  let n2 = dot(normal, normal);
  if (n2 === 0) {
    n2 = 1;
  }
  vproj[0] = v[0] - t * normal[0] / n2;
  vproj[1] = v[1] - t * normal[1] / n2;
  vproj[2] = v[2] - t * normal[2] / n2;
  return vproj;
}
function generalizedProjectPoint(x, origin, normal, xproj) {
  const xo = [];
  subtract(x, origin, xo);
  const t = dot(normal, xo);
  const n2 = dot(normal, normal);
  if (n2 !== 0) {
    xproj[0] = x[0] - t * normal[0] / n2;
    xproj[1] = x[1] - t * normal[1] / n2;
    xproj[2] = x[2] - t * normal[2] / n2;
  } else {
    xproj[0] = x[0];
    xproj[1] = x[1];
    xproj[2] = x[2];
  }
}
function intersectWithLine(p1, p2, origin, normal) {
  const outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: []
  };
  const p21 = [];
  const p1Origin = [];
  subtract(p2, p1, p21);
  subtract(origin, p1, p1Origin);
  const num = dot(normal, p1Origin);
  const den = dot(normal, p21);
  let fabsden;
  let fabstolerance;
  if (den < 0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }
  outObj.t = num / den;
  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];
  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
  return outObj;
}
function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
  const outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null
  };
  const cross$1 = [];
  cross(plane1Normal, plane2Normal, cross$1);
  const absCross = cross$1.map((n) => Math.abs(n));
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    const v = [];
    subtract(plane1Origin, plane2Origin, v);
    if (dot(plane1Normal, v) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }
  let maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = "x";
  } else if (absCross[1] > absCross[2]) {
    maxc = "y";
  } else {
    maxc = "z";
  }
  const iP = [];
  const d1 = -dot(plane1Normal, plane1Origin);
  const d2 = -dot(plane2Normal, plane2Origin);
  switch (maxc) {
    case "x":
      iP[0] = 0;
      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];
      break;
    case "y":
      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];
      iP[1] = 0;
      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
      break;
    case "z":
      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];
      iP[2] = 0;
      break;
  }
  outObj.l0 = iP;
  add(iP, cross$1, outObj.l1);
  outObj.intersection = true;
  return outObj;
}
var STATIC3 = {
  evaluate,
  distanceToPlane,
  projectPoint,
  projectVector: projectVector2,
  generalizedProjectPoint,
  intersectWithLine,
  intersectWithPlane,
  DISJOINT,
  COINCIDE
};
function vtkPlane(publicAPI, model) {
  model.classHierarchy.push("vtkPlane");
  publicAPI.distanceToPlane = (x) => distanceToPlane(x, model.origin, model.normal);
  publicAPI.projectPoint = (x, xproj) => {
    projectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.projectVector = (v, vproj) => projectVector2(v, model.normal, vproj);
  publicAPI.push = (distance4) => {
    if (distance4 === 0) {
      return;
    }
    for (let i = 0;i < 3; i++) {
      model.origin[i] += distance4 * model.normal[i];
    }
  };
  publicAPI.generalizedProjectPoint = (x, xproj) => {
    generalizedProjectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.evaluateFunction = (x, y, z) => {
    if (!Array.isArray(x)) {
      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
    }
    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
  };
  publicAPI.evaluateGradient = (xyz) => {
    const retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };
  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);
  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
}
var DEFAULT_VALUES33 = {
  normal: [0, 0, 1],
  origin: [0, 0, 0]
};
function extend33(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES33, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
  vtkPlane(publicAPI, model);
}
var newInstance33 = macro.newInstance(extend33, "vtkPlane");
var vtkPlane$1 = {
  newInstance: newInstance33,
  extend: extend33,
  ...STATIC3
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var INIT_BOUNDS = [
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  Number.MAX_VALUE,
  -Number.MAX_VALUE
];
function equals8(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function isValid(bounds) {
  return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
}
function setBounds(bounds, otherBounds) {
  bounds[0] = otherBounds[0];
  bounds[1] = otherBounds[1];
  bounds[2] = otherBounds[2];
  bounds[3] = otherBounds[3];
  bounds[4] = otherBounds[4];
  bounds[5] = otherBounds[5];
  return bounds;
}
function reset(bounds) {
  return setBounds(bounds, INIT_BOUNDS);
}
function addPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = xMin < x ? xMin : x;
  bounds[1] = xMax > x ? xMax : x;
  bounds[2] = yMin < y ? yMin : y;
  bounds[3] = yMax > y ? yMax : y;
  bounds[4] = zMin < z ? zMin : z;
  bounds[5] = zMax > z ? zMax : z;
  return bounds;
}
function addPoints(bounds, points) {
  if (points.length === 0) {
    return bounds;
  }
  if (Array.isArray(points[0])) {
    for (let i = 0;i < points.length; ++i) {
      addPoint(bounds, ...points[i]);
    }
  } else {
    for (let i = 0;i < points.length; i += 3) {
      addPoint(bounds, ...points.slice(i, i + 3));
    }
  }
  return bounds;
}
function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;
  if (zMax === undefined) {
    bounds[0] = Math.min(xMin[0], _xMin);
    bounds[1] = Math.max(xMin[1], _xMax);
    bounds[2] = Math.min(xMin[2], _yMin);
    bounds[3] = Math.max(xMin[3], _yMax);
    bounds[4] = Math.min(xMin[4], _zMin);
    bounds[5] = Math.max(xMin[5], _zMax);
  } else {
    bounds[0] = Math.min(xMin, _xMin);
    bounds[1] = Math.max(xMax, _xMax);
    bounds[2] = Math.min(yMin, _yMin);
    bounds[3] = Math.max(yMax, _yMax);
    bounds[4] = Math.min(zMin, _zMin);
    bounds[5] = Math.max(zMax, _zMax);
  }
  return bounds;
}
function setMinPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x;
  bounds[1] = x > xMax ? x : xMax;
  bounds[2] = y;
  bounds[3] = y > yMax ? y : yMax;
  bounds[4] = z;
  bounds[5] = z > zMax ? z : zMax;
  return xMin !== x || yMin !== y || zMin !== z;
}
function setMaxPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x < xMin ? x : xMin;
  bounds[1] = x;
  bounds[2] = y < yMin ? y : yMin;
  bounds[3] = y;
  bounds[4] = z < zMin ? z : zMin;
  bounds[5] = z;
  return xMax !== x || yMax !== y || zMax !== z;
}
function inflate(bounds, delta) {
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
function scale7(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  if (sx >= 0) {
    bounds[0] *= sx;
    bounds[1] *= sx;
  } else {
    bounds[0] = sx * bounds[1];
    bounds[1] = sx * bounds[0];
  }
  if (sy >= 0) {
    bounds[2] *= sy;
    bounds[3] *= sy;
  } else {
    bounds[2] = sy * bounds[3];
    bounds[3] = sy * bounds[2];
  }
  if (sz >= 0) {
    bounds[4] *= sz;
    bounds[5] *= sz;
  } else {
    bounds[4] = sz * bounds[5];
    bounds[5] = sz * bounds[4];
  }
  return true;
}
function getCenter(bounds) {
  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
}
function scaleAboutCenter(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  const center = getCenter(bounds);
  bounds[0] -= center[0];
  bounds[1] -= center[0];
  bounds[2] -= center[1];
  bounds[3] -= center[1];
  bounds[4] -= center[2];
  bounds[5] -= center[2];
  scale7(bounds, sx, sy, sz);
  bounds[0] += center[0];
  bounds[1] += center[0];
  bounds[2] += center[1];
  bounds[3] += center[1];
  bounds[4] += center[2];
  bounds[5] += center[2];
  return true;
}
function getLength(bounds, index) {
  return bounds[index * 2 + 1] - bounds[index * 2];
}
function getLengths(bounds) {
  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];
}
function getXRange(bounds) {
  return bounds.slice(0, 2);
}
function getYRange(bounds) {
  return bounds.slice(2, 4);
}
function getZRange(bounds) {
  return bounds.slice(4, 6);
}
function getMaxLength(bounds) {
  const l = getLengths(bounds);
  if (l[0] > l[1]) {
    if (l[0] > l[2]) {
      return l[0];
    }
    return l[2];
  }
  if (l[1] > l[2]) {
    return l[1];
  }
  return l[2];
}
function getDiagonalLength(bounds) {
  if (isValid(bounds)) {
    const l = getLengths(bounds);
    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);
  }
  return null;
}
function getMinPoint(bounds) {
  return [bounds[0], bounds[2], bounds[4]];
}
function getMaxPoint(bounds) {
  return [bounds[1], bounds[3], bounds[5]];
}
function oppositeSign(a, b) {
  return a <= 0 && b >= 0 || a >= 0 && b <= 0;
}
function getCorners(bounds, corners) {
  let count = 0;
  for (let ix = 0;ix < 2; ix++) {
    for (let iy = 2;iy < 4; iy++) {
      for (let iz = 4;iz < 6; iz++) {
        corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];
      }
    }
  }
  return corners;
}
function computeCornerPoints(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function transformBounds(bounds, transform) {
  let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const corners = getCorners(bounds, []);
  for (let i = 0;i < corners.length; ++i) {
    exports_vec3.transformMat4(corners[i], corners[i], transform);
  }
  reset(out);
  return addPoints(out, corners);
}
function computeScale3(bounds) {
  let scale32 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  scale32[0] = 0.5 * (bounds[1] - bounds[0]);
  scale32[1] = 0.5 * (bounds[3] - bounds[2]);
  scale32[2] = 0.5 * (bounds[5] - bounds[4]);
  return scale32;
}
function computeLocalBounds(points, u, v, w) {
  const bounds = [].concat(INIT_BOUNDS);
  const pointsData = points.getData();
  for (let i = 0;i < pointsData.length; i += 3) {
    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
    const du = dot(point, u);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    const dv = dot(point, v);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    const dw2 = dot(point, w);
    bounds[4] = Math.min(dw2, bounds[4]);
    bounds[5] = Math.max(dw2, bounds[5]);
  }
  return bounds;
}
function intersectBox(bounds, origin, dir, coord, tolerance) {
  let inside = true;
  const quadrant = [];
  let whichPlane = 0;
  const maxT = [];
  const candidatePlane = [0, 0, 0];
  const RIGHT = 0;
  const LEFT = 1;
  const MIDDLE = 2;
  for (let i = 0;i < 3; i++) {
    if (origin[i] < bounds[2 * i]) {
      quadrant[i] = LEFT;
      candidatePlane[i] = bounds[2 * i];
      inside = false;
    } else if (origin[i] > bounds[2 * i + 1]) {
      quadrant[i] = RIGHT;
      candidatePlane[i] = bounds[2 * i + 1];
      inside = false;
    } else {
      quadrant[i] = MIDDLE;
    }
  }
  if (inside) {
    coord[0] = origin[0];
    coord[1] = origin[1];
    coord[2] = origin[2];
    tolerance[0] = 0;
    return 1;
  }
  for (let i = 0;i < 3; i++) {
    if (quadrant[i] !== MIDDLE && dir[i] !== 0) {
      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
    } else {
      maxT[i] = -1;
    }
  }
  for (let i = 0;i < 3; i++) {
    if (maxT[whichPlane] < maxT[i]) {
      whichPlane = i;
    }
  }
  if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
    return 0;
  }
  tolerance[0] = maxT[whichPlane];
  for (let i = 0;i < 3; i++) {
    if (whichPlane !== i) {
      coord[i] = origin[i] + maxT[whichPlane] * dir[i];
      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {
        return 0;
      }
    } else {
      coord[i] = candidatePlane[i];
    }
  }
  return 1;
}
function intersectPlane(bounds, origin, normal) {
  const p = [];
  let d = 0;
  let sign = 1;
  let firstOne = 1;
  for (let z = 4;z <= 5; ++z) {
    p[2] = bounds[z];
    for (let y = 2;y <= 3; ++y) {
      p[1] = bounds[y];
      for (let x = 0;x <= 1; ++x) {
        p[0] = bounds[x];
        d = vtkPlane$1.evaluate(normal, origin, p);
        if (firstOne) {
          sign = d >= 0 ? 1 : -1;
          firstOne = 0;
        }
        if (d === 0 || sign > 0 && d < 0 || sign < 0 && d > 0) {
          return 1;
        }
      }
    }
  }
  return 0;
}
function intersect(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  const newBounds = [0, 0, 0, 0, 0, 0];
  let intersection;
  for (let i = 0;i < 3; i++) {
    intersection = false;
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2] = bBounds[i * 2];
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2] = bounds[i * 2];
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2 + 1] = bBounds[2 * i + 1];
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      intersection = true;
      newBounds[i * 2 + 1] = bounds[i * 2 + 1];
    }
    if (!intersection) {
      return false;
    }
  }
  bounds[0] = newBounds[0];
  bounds[1] = newBounds[1];
  bounds[2] = newBounds[2];
  bounds[3] = newBounds[3];
  bounds[4] = newBounds[4];
  bounds[5] = newBounds[5];
  return true;
}
function intersects(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  for (let i = 0;i < 3; i++) {
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      continue;
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      continue;
    }
    return false;
  }
  return true;
}
function containsPoint(bounds, x, y, z) {
  if (x < bounds[0] || x > bounds[1]) {
    return false;
  }
  if (y < bounds[2] || y > bounds[3]) {
    return false;
  }
  if (z < bounds[4] || z > bounds[5]) {
    return false;
  }
  return true;
}
function contains(bounds, otherBounds) {
  if (!intersects(bounds, otherBounds)) {
    return false;
  }
  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {
    return false;
  }
  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {
    return false;
  }
  return true;
}
function cutWithPlane(bounds, origin, normal) {
  const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
  const d = [0, 0, 0, 0, 0, 0, 0, 0];
  let idx = 0;
  for (let ix = 0;ix < 2; ix++) {
    for (let iy = 2;iy < 4; iy++) {
      for (let iz = 4;iz < 6; iz++) {
        const x = [bounds[ix], bounds[iy], bounds[iz]];
        d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
      }
    }
  }
  let dir = 2;
  while (dir--) {
    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {
      break;
    }
  }
  if (dir < 0) {
    return false;
  }
  const sign = Math.sign(normal[dir]);
  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
  let t = sign > 0 ? 1 : 0;
  for (let i = 0;i < 4; i++) {
    if (size === 0) {
      continue;
    }
    const ti = Math.abs(d[index[dir][i]]) / size;
    if (sign > 0 && ti < t) {
      t = ti;
    }
    if (sign < 0 && ti > t) {
      t = ti;
    }
  }
  const bound = (1 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
  if (sign > 0) {
    bounds[dir * 2] = bound;
  } else {
    bounds[dir * 2 + 1] = bound;
  }
  return true;
}

class BoundingBox {
  constructor(refBounds) {
    this.bounds = refBounds;
    if (!this.bounds) {
      this.bounds = new Float64Array(INIT_BOUNDS);
    }
  }
  getBounds() {
    return this.bounds;
  }
  equals(otherBounds) {
    return equals8(this.bounds, otherBounds);
  }
  isValid() {
    return isValid(this.bounds);
  }
  setBounds(otherBounds) {
    return setBounds(this.bounds, otherBounds);
  }
  reset() {
    return reset(this.bounds);
  }
  addPoint() {
    for (var _len = arguments.length, xyz = new Array(_len), _key = 0;_key < _len; _key++) {
      xyz[_key] = arguments[_key];
    }
    return addPoint(this.bounds, ...xyz);
  }
  addPoints(points) {
    return addPoints(this.bounds, points);
  }
  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
  }
  setMinPoint(x, y, z) {
    return setMinPoint(this.bounds, x, y, z);
  }
  setMaxPoint(x, y, z) {
    return setMaxPoint(this.bounds, x, y, z);
  }
  inflate(delta) {
    return inflate(this.bounds, delta);
  }
  scale(sx, sy, sz) {
    return scale7(this.bounds, sx, sy, sz);
  }
  getCenter() {
    return getCenter(this.bounds);
  }
  getLength(index) {
    return getLength(this.bounds, index);
  }
  getLengths() {
    return getLengths(this.bounds);
  }
  getMaxLength() {
    return getMaxLength(this.bounds);
  }
  getDiagonalLength() {
    return getDiagonalLength(this.bounds);
  }
  getMinPoint() {
    return getMinPoint(this.bounds);
  }
  getMaxPoint() {
    return getMaxPoint(this.bounds);
  }
  getXRange() {
    return getXRange(this.bounds);
  }
  getYRange() {
    return getYRange(this.bounds);
  }
  getZRange() {
    return getZRange(this.bounds);
  }
  getCorners(corners) {
    return getCorners(this.bounds, corners);
  }
  computeCornerPoints(point1, point2) {
    return computeCornerPoints(this.bounds, point1, point2);
  }
  computeLocalBounds(u, v, w) {
    return computeLocalBounds(this.bounds, u, v, w);
  }
  transformBounds(transform) {
    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return transformBounds(this.bounds, transform, out);
  }
  computeScale3(scale32) {
    return computeScale3(this.bounds, scale32);
  }
  cutWithPlane(origin, normal) {
    return cutWithPlane(this.bounds, origin, normal);
  }
  intersectBox(origin, dir, coord, tolerance) {
    return intersectBox(this.bounds, origin, dir, coord, tolerance);
  }
  intersectPlane(origin, normal) {
    return intersectPlane(this.bounds, origin, normal);
  }
  intersect(otherBounds) {
    return intersect(this.bounds, otherBounds);
  }
  intersects(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
  containsPoint(x, y, z) {
    return containsPoint(this.bounds, x, y, z);
  }
  contains(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
}
function newInstance34(initialValues) {
  const bounds = initialValues && initialValues.bounds;
  return new BoundingBox(bounds);
}
var STATIC4 = {
  equals: equals8,
  isValid,
  setBounds,
  reset,
  addPoint,
  addPoints,
  addBounds,
  setMinPoint,
  setMaxPoint,
  inflate,
  scale: scale7,
  scaleAboutCenter,
  getCenter,
  getLength,
  getLengths,
  getMaxLength,
  getDiagonalLength,
  getMinPoint,
  getMaxPoint,
  getXRange,
  getYRange,
  getZRange,
  getCorners,
  computeCornerPoints,
  computeLocalBounds,
  transformBounds,
  computeScale3,
  cutWithPlane,
  intersectBox,
  intersectPlane,
  intersect,
  intersects,
  containsPoint,
  contains,
  INIT_BOUNDS
};
var vtkBoundingBox = {
  newInstance: newInstance34,
  ...STATIC4
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return createUninitializedBounds();
  };
  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBounds();
    model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
    return model.center?.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return vtkBoundingBox.getDiagonalLength(bounds);
  };
}
var defaultValues = (initialValues) => ({
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {},
  ...initialValues
});
function extend34(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["viewSpecificProperties"]);
  vtkAbstractMapper3D(publicAPI, model);
}
var vtkAbstractMapper3D$1 = {
  extend: extend34
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
var StructuredType = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9
};
var Constants9 = {
  StructuredType
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
var {
  StructuredType: StructuredType2
} = Constants9;
function getDataDescriptionFromExtent(inExt) {
  let dataDim = 0;
  for (let i = 0;i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType2.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType2.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType2.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType2.XZ_PLANE;
    }
    return StructuredType2.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType2.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType2.Y_LINE;
    }
    return StructuredType2.Z_LINE;
  }
  return StructuredType2.SINGLE_POINT;
}
var vtkStructuredData = {
  getDataDescriptionFromExtent,
  ...Constants9
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var {
  vtkErrorMacro: vtkErrorMacro14
} = macro;
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro14("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0;_key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    let i;
    let j;
    let k;
    if (model.deleted) {
      vtkErrorMacro14("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      const array = arguments.length <= 0 ? undefined : arguments[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? undefined : arguments[0];
      j = arguments.length <= 1 ? undefined : arguments[1];
      k = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      vtkErrorMacro14("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;
    for (let i = 0;i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = (index) => {
    const dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro14("Requesting a point from an empty image.");
      return null;
    }
    const ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType.EMPTY:
        return null;
      case StructuredType.SINGLE_POINT:
        break;
      case StructuredType.X_LINE:
        ijk[0] = index;
        break;
      case StructuredType.Y_LINE:
        ijk[1] = index;
        break;
      case StructuredType.Z_LINE:
        ijk[2] = index;
        break;
      case StructuredType.XY_PLANE:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0];
        break;
      case StructuredType.YZ_PLANE:
        ijk[1] = index % dims[1];
        ijk[2] = index / dims[1];
        break;
      case StructuredType.XZ_PLANE:
        ijk[0] = index % dims[0];
        ijk[2] = index / dims[0];
        break;
      case StructuredType.XYZ_GRID:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0] % dims[1];
        ijk[2] = index / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro14("Invalid dataDescription");
        break;
    }
    const coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  publicAPI.extentToBounds = (ex) => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);
  publicAPI.computeTransforms = () => {
    exports_mat4.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    exports_mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    exports_mat4.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.indexToWorld = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    exports_vec3.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    exports_vec3.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);
  };
  publicAPI.worldToIndexBounds = function(bin) {
    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);
  };
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
  publicAPI.computeHistogram = function(worldBounds) {
    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    const dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];
    const pixels = publicAPI.getPointData().getScalars().getData();
    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;
    for (let z = point1[2];z <= point2[2]; z++) {
      for (let y = point1[1];y <= point2[1]; y++) {
        let index = point1[0] + y * yStride + z * zStride;
        for (let x = point1[0];x <= point2[0]; x++) {
          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {
            const pixel = pixels[index];
            if (pixel > maximum)
              maximum = pixel;
            if (pixel < minimum)
              minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index;
        }
      }
    }
    const average = inum > 0 ? isum / inum : 0;
    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    const sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent) {
    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const increments = [];
    let incr = numberOfComponents;
    for (let idx = 0;idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = (_ref) => {
    let [i, j, k] = _ref;
    const extent = publicAPI.getExtent();
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent, numberOfComponents);
    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = (xyz) => {
    const extent = publicAPI.getExtent();
    const index = publicAPI.worldToIndex(xyz);
    for (let idx = 0;idx < 3; ++idx) {
      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro14(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro14(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
}
var DEFAULT_VALUES34 = {
  direction: null,
  indexToWorld: null,
  worldToIndex: null,
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: StructuredType.EMPTY
};
function extend35(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES34, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = exports_mat3.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.setGetArray(publicAPI, model, ["direction"], 9);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var newInstance35 = macro.newInstance(extend35, "vtkImageData");
var vtkImageData$1 = {
  newInstance: newInstance35,
  extend: extend35
};

// ../../node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
var VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
var ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
var ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
var GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants10 = {
  ColorMode,
  GetArray,
  ScalarMode
};

// ../../node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var {
  ScalarMappingTarget: ScalarMappingTarget2,
  VectorMode: VectorMode2
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes3
} = vtkDataArray$1;
var {
  ColorMode: ColorMode2
} = Constants10;
var {
  vtkErrorMacro: vtkErrorMacro15
} = macro;
function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255 + 0.5);
}
function vtkScalarsToColors2(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode2.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
  publicAPI.build = () => {
  };
  publicAPI.isOpaque = () => true;
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro15("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0;i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;
  publicAPI.getAnnotatedValue = (idx) => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = (idx) => {
    if (model.annotationArray[idx] === undefined) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = (val) => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  publicAPI.removeAnnotation = (value) => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = (value) => publicAPI.getAnnotatedValueIndexInternal(value);
  publicAPI.getAnnotatedValueIndexInternal = (value) => {
    if (model.annotatedValueMap[value] !== undefined) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0;
    rgba[1] = 0;
    rgba[2] = 0;
    rgba[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i = 0;i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;
    if (colorMode === ColorMode2.DEFAULT && (scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes3.UNSIGNED_CHAR
      };
      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      let component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length5 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i = 0;i < length5; i++) {
      let sum = 0;
      for (let j = 0;j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode2.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode2.COMPONENT;
      }
    }
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode2.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode2.RGBCOLORS: {
        break;
      }
      case VectorMode2.MAGNITUDE:
      default: {
        const magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;
    let count = 0;
    for (let i = component;i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;
    let count = 0;
    for (let i = component;i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;
    let count = 0;
    for (let i = component;i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;
    let count = 0;
    for (let i = component;i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes3.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes3.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes3.FLOAT || colors.getDataType() === VtkDataTypes3.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro15("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min5, max5) => publicAPI.setMappingRange(min5, max5);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();
    if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS) {
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1;
      }
      const range = scalars.getRange(numberOfComponents - 1);
      return range[0] === 255;
    }
    return true;
  };
}
var DEFAULT_VALUES35 = {
  alpha: 1,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode2.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false
};
function extend36(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES35, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors2(publicAPI, model);
}
var newInstance36 = macro.newInstance(extend36, "vtkScalarsToColors");
var vtkScalarsToColors$1 = {
  newInstance: newInstance36,
  extend: extend36,
  ...vtkScalarsToColors
};

// ../../node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var {
  vtkErrorMacro: vtkErrorMacro16
} = macro;
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (let i = 3;i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;
    const nv = Number(v);
    if (nv < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p.shift) * p.scale;
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v, table, p) => {
    let index = 0;
    if (isNan(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index;
    return table.slice(offset, offset + 4);
  };
  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.lookupShiftAndScale = (range, p) => {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    const alpha = publicAPI.getAlpha();
    const length5 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0;i < length5; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0;i < length5; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = () => {
    let hinc = 0;
    let sinc = 0;
    let vinc = 0;
    let ainc = 0;
    const maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    model.table.length = 4 * maxIndex + 16;
    const hsv = [];
    const rgba = [];
    for (let i = 0;i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      hsv2rgb(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;
      model.table[i * 4] = rgba[0] * 255 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = (table) => {
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset = 0;
      for (let i = 0;i < model.numberOfColors; i++) {
        model.table[i * 4] = 255;
        model.table[i * 4 + 1] = 255;
        model.table[i * 4 + 2] = 255;
        model.table[i * 4 + 3] = 255;
      }
      for (let i = 0;i < table.length; i++) {
        const color = table[i];
        for (let j = 0;j < nbComponents; j++) {
          model.table[offset++] = color[j];
        }
        offset += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro16("Expected 4 components for RGBA colors");
      return false;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro16("Expected unsigned char values for RGBA colors");
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i = 0;i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
  }
}
var DEFAULT_VALUES36 = {
  numberOfColors: 256,
  hueRange: [0, 0.66667],
  saturationRange: [1, 1],
  valueRange: [1, 1],
  alphaRange: [1, 1],
  nanColor: [0.5, 0, 0, 1],
  belowRangeColor: [0, 0, 0, 1],
  aboveRangeColor: [1, 1, 1, 1],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1
};
function extend37(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES36, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var newInstance37 = macro.newInstance(extend37, "vtkLookupTable");
var vtkLookupTable$1 = {
  newInstance: newInstance37,
  extend: extend37
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Resolve = {
  Off: 0,
  PolygonOffset: 1
};
var resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
var resolveCoincidentTopology = Resolve.Off;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
  resolveCoincidentTopologyPolygonOffsetFaces = value;
  return changed;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const changed = resolveCoincidentTopology === mode;
  resolveCoincidentTopology = mode;
  return changed;
}
function setResolveCoincidentTopologyToDefault() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToOff() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  return setResolveCoincidentTopology(Resolve.PolygonOffset);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  Resolve,
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};
// ../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach((item) => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = macro.objectSetterMap.object(publicAPI, model, {
      name: item.key,
      params: ["factor", "offset"]
    });
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var noOp2 = () => {
  return;
};
var staticOffsetAPI = {
  modified: noOp2
};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map((key) => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === undefined) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach((methodName) => {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).filter((methodName) => methodName !== "modified").forEach((methodName) => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map((key) => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods,
  CATEGORIES,
  Resolve
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var {
  FieldAssociations: FieldAssociations4
} = vtkDataSet$1;
var {
  staticOffsetAPI: staticOffsetAPI2,
  otherStaticMethods: otherStaticMethods2
} = CoincidentTopologyHelper;
var {
  ColorMode: ColorMode3,
  ScalarMode: ScalarMode2,
  GetArray: GetArray2
} = Constants10;
var {
  VectorMode: VectorMode3
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes4
} = vtkDataArray$1;
function notImplemented3(method) {
  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}
var colorTextureCoordinatesCache = new WeakMap;
function getOrCreateColorTextureCoordinates(input, component, range, numberOfColorsInRange, dimensions, useLogScale, useZigzagPattern) {
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0;argIndex < arguments.length; ++argIndex) {
    const arg = arguments[argIndex];
    argStrings[argIndex] = arg.getMTime?.() ?? arg;
  }
  const stringHash = argStrings.join("/");
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }
  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = vtkDataArray$1.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0;scalarIdx < numScalars; ++scalarIdx) {
    let scalarValue;
    if (useMagnitude) {
      let sum = 0;
      for (let compIdx = 0;compIdx < numComps; ++compIdx) {
        const compValue = inputV[inputIdx + compIdx];
        sum += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum);
    } else {
      scalarValue = inputV[inputIdx + component];
    }
    inputIdx += numComps;
    if (useLogScale) {
      scalarValue = vtkLookupTable$1.applyLogScale(scalarValue, range, range);
    }
    if (isNan(scalarValue)) {
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        texelIndexPosition = numberOfColorsInRange + 1;
      }
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      textureCoordinate[1] = 0.49;
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1000) {
        textureCoordinate[0] = 1000;
      } else if (textureS < -1000) {
        textureCoordinate[0] = -1000;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0;i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = (v) => {
    model.forceCompileOnly = v;
  };
  publicAPI.setSelectionWebGLIdsToVTKIds = (selectionWebGLIdsToVTKIds) => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
  };
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode3, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode2, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode2.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
      const cd2 = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = cd2.getArrayByIndex(arrayId);
      } else {
        scalars = cd2.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString)
      return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      vtkLookupTable$1.getLogRange(range, range);
    }
    const origAlpha = model.lookupTable.getAlpha();
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3;
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2;
      const minColorsInRange = 2;
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3;
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2;
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);
      scalarsArray.fill(NaN);
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = range[0];
      const rangeDifference = range[1] - range[0];
      for (let i = 0;i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);
        const scalarValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        scalarsArray[scalarsArrayIndex] = useLogScale ? 10 ** scalarValue : scalarValue;
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, range, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), useLogScale, cellFlag);
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode3.DIRECT_SCALARS)) {
      return true;
    }
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      return false;
    }
    if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented3("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented3("ValueToColor");
  publicAPI.colorToValue = notImplemented3("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented3("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented3("ClearInvertibleColor");
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations4.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach((pos) => {
      if (currentPass === PassTypes.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
        lowData[pos] = outValue & 255;
        lowData[pos + 1] = (outValue & 65280) >> 8;
        lowData[pos + 2] = (outValue & 16711680) >> 16;
      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
        highData[pos] = (outValue & 4278190080) >> 24;
      }
    });
  };
}
var DEFAULT_VALUES37 = {
  colorMapColors: null,
  areScalarsMappedFromCells: false,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  numberOfColorsInRange: 0,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};
function extend38(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES37, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["areScalarsMappedFromCells", "colorCoordinates", "colorMapColors", "colorTextureMap", "numberOfColorsInRange", "selectionWebGLIdsToVTKIds"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "populateSelectionSettings",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "useLookupTableScalarRange",
    "customShaderAttributes"
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var newInstance38 = macro.newInstance(extend38, "vtkMapper");
var vtkMapper$1 = {
  newInstance: newInstance38,
  extend: extend38,
  ...staticOffsetAPI2,
  ...otherStaticMethods2,
  ...Constants10
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants11 = {
  CoordinateSystem
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
var {
  CoordinateSystem: CoordinateSystem2
} = Constants11;
function notImplemented4(method) {
  return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0;index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
  };
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented4("pick");
  publicAPI.hasKey = notImplemented4("hasKey");
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = (t) => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = (t) => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = (t) => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
}
var DEFAULT_VALUES38 = {
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend39(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES38, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance39 = macro.newInstance(extend39, "vtkProp");
var vtkProp$1 = {
  newInstance: newInstance39,
  extend: extend39,
  ...Constants11
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexMC;

// frag position in VC
//VTK::PositionVC::Dec

// optional normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// Texture coordinates
//VTK::TCoord::Dec

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

// Apple Bug
//VTK::PrimID::Dec

// picking support
//VTK::Picking::Dec

void main()
{
  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  //VTK::PrimID::Impl

  //VTK::PositionVC::Impl

  //VTK::Light::Impl

  //VTK::Picking::Impl
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the polydata mappers fragment shader

uniform int PrimitiveIDOffset;

// VC position of this fragment
//VTK::PositionVC::Dec

// optional color passed in from the vertex shader, vertexColor
//VTK::Color::Dec

// optional surface normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// Depth Peeling Support
//VTK::DepthPeeling::Dec

// clipping plane vars
//VTK::Clip::Dec

// label outline 
//VTK::LabelOutline::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

//VTK::LabelOutlineHelperFunction

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Clip::Impl

  //VTK::Color::Impl

  // Generate the normal if we are not passed in one
  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Light::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i = 0;i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== undefined && vertexSpecProp !== "") {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== undefined && fragmentSpecProp !== "") {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== undefined) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var {
  FieldAssociations: FieldAssociations5
} = vtkDataSet$1;
var {
  primTypes: primTypes2
} = vtkHelper;
var {
  Representation: Representation4,
  Shading: Shading2
} = vtkProperty$1;
var {
  ScalarMode: ScalarMode3
} = vtkMapper$1;
var {
  Filter: Filter3,
  Wrap: Wrap3
} = vtkOpenGLTexture$1;
var {
  vtkErrorMacro: vtkErrorMacro17
} = macro$1;
var StartEvent = {
  type: "StartEvent"
};
var EndEvent = {
  type: "EndEvent"
};
var {
  CoordinateSystem: CoordinateSystem3
} = vtkProp$1;
function getPickState(renderer) {
  const selector = renderer.getSelector();
  if (selector) {
    return selector.getCurrentPass();
  }
  return PassTypes.MIN_KNOWN_PASS - 1;
}
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType("vtkOpenGLActor");
      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes2.Start;i < primTypes2.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity", "uniform vec3 ambientColorUniform;", "uniform vec3 diffuseColorUniform;"];
    if (lastLightComplexity) {
      colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
    }
    let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
    }
    colorImpl = colorImpl.concat(["  ambientColor = ambientColorUniform;", "  diffuseColor = diffuseColorUniform;", "  opacity = opacityUniform;"]);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else {
      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  ambientColor = texColor.rgb;", "  opacity = opacity*texColor.a;"])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform float opacityUniformBF; // the fragment opacity", "uniform float ambientIntensityBF; // the material ambient", "uniform float diffuseIntensityBF; // the material diffuse", "uniform vec3 ambientColorUniformBF; // ambient material color", "uniform vec3 diffuseColorUniformBF; // diffuse material color"]);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(["uniform float specularIntensityBF; // the material specular intensity", "uniform vec3 specularColorUniformBF; // intensity weighted color", "uniform float specularPowerUniformBF;"]);
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  specularColor = specularIntensityBF * specularColorUniformBF;", "  specularPower = specularPowerUniformBF;", "  opacity = opacityUniformBF; }"]);
          } else {
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  opacity = opacityUniformBF; }"]);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform samplerBuffer texture1;"]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    const shadowFactor = "";
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    let sstring = [];
    switch (lastLightComplexity) {
      case 0:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 1:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  float df = max(0.0, normalVCVSOutput.z);", "  float sf = pow(df, specularPower);", "  vec3 diffuseL = df * diffuseColor;", "  vec3 specularL = sf * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 2:
        for (let lc = 0;lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  float df;"];
        for (let lc = 0;lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, "    {", `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      case 3:
        for (let lc = 0;lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  vec3 vertLightDirectionVC;", "  float attenuation;", "  float df;"];
        for (let lc = 0;lc < lastLightCount; ++lc) {
          sstring = sstring.concat(["  attenuation = 1.0;", `  if (lightPositional${lc} == 0)`, "    {", `      vertLightDirectionVC = lightDirectionVC${lc};`, "    }", "  else", "    {", `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, "    float distanceVC = length(vertLightDirectionVC);", "    vertLightDirectionVC = normalize(vertLightDirectionVC);", "    attenuation = 1.0 /", `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, "    // per OpenGL standard cone angle is 90 or less for a spot light", `    if (lightConeAngle${lc} <= 90.0)`, "      {", `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, "      // if inside the cone", `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, "        {", `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, "        }", "      else", "        {", "        attenuation = 0.0;", "        }", "      }", "    }", "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));", `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)", "      {", `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      default:
        vtkErrorMacro17("bad light complexity");
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * normalMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Dec", ["in vec3 normalVCVSOutput[];", "out vec3 normalVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Impl", ["normalVCGSOutput = normalVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["varying vec3 normalVCVSOutput;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform mat3 normalMatrix;", "uniform samplerBuffer textureN;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput = normalize(normalMatrix *", "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);", "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result;
        } else {
          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["  vec3 fdx = dFdx(vertexVC.xyz);", "  vec3 fdy = dFdy(vertexVC.xyz);", "  //VTK::UniformFlow::Impl"]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput;", "  if (abs(fdx.x) > 0.0)", "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }", "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform int cameraParallel;"]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", [
              "  vec3 fdx = dFdx(vertexVC.xyz);",
              "  vec3 fdy = dFdy(vertexVC.xyz);",
              "  //VTK::UniformFlow::Impl"
            ]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
              "  fdx = normalize(fdx);",
              "  fdy = normalize(fdy);",
              "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
              "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
              "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
            ]).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vertexVCVSOutput = MCVCMatrix * vertexMC;", "  gl_Position = MCPCMatrix * vertexMC;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Dec", ["in vec4 vertexVCVSOutput[];", "out vec4 vertexVCGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Impl", ["vertexVCGSOutput = vertexVCVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;"]).result;
    } else {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
          }
        }
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec3 tcoordVCVSOutput[];", "out vec3 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec3 tcoordVCVSOutput;", "uniform samplerCube texture1;"]).result;
        switch (tNumComp) {
          case 1:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
            break;
          case 2:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
            break;
          default:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    let cp = {
      factor: 0,
      offset: 0
    };
    const prop = actor.getProperty();
    if (model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation4.SURFACE) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes2.Points || prop.getRepresentation() === Representation4.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes2.Lines || prop.getRepresentation() === Representation4.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes2.Tris || primType === primTypes2.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes2.TrisEdges || primType === primTypes2.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2;
        cp.offset /= 2;
      }
    }
    const selector = model._openGLRenderer.getSelector();
    if (selector && selector.getFieldAssociation() === FieldAssociations5.FIELD_ASSOCIATION_POINTS) {
      cp.offset -= 2;
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    let VSSource = shaders.Vertex;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform int picking;", "//VTK::Picking::Dec"]).result;
    if (!model._openGLRenderer.getSelector()) {
      return;
    }
    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", [`flat out int vertexIDVSOutput;
`, `uniform int VertexIDOffset;
`]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", `  vertexIDVSOutput = gl_VertexID + VertexIDOffset;
`).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", `flat in int vertexIDVSOutput;
`).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  int idx = vertexIDVSOutput;", "//VTK::Picking::Impl"]).result;
    }
    switch (model.lastSelectionState) {
      case PassTypes.ID_LOW24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
        break;
      case PassTypes.ID_HIGH24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;
        break;
      default:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    }
    shaders.Fragment = FSSource;
    shaders.Vertex = VSSource;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;
    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading2.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode = cellBO.getOpenGLMode(representation, primType);
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
    } else if (!flat && pointNormals) {
      needLighting = true;
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    if (actor.getProperty().getLighting() && needLighting) {
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0;index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isUniformUsed("VertexIDOffset")) {
      cellBO.getProgram().setUniformi("VertexIDOffset", model.vertexIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro17("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("normalMC") && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "normalMC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro17("Error setting normalMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("normalMC");
      }
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro17(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro17("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro17("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      const planeEquations = [];
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? exports_mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        exports_mat4.transpose(mat, mat);
        exports_mat4.multiply(mat, mat, inverseShiftScaleMatrix);
        exports_mat4.transpose(mat, mat);
      }
      for (let i = 0;i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (let j = 0;j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
      cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index = 0;index < tus.length; ++index) {
        const tex = tus[index];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
    const selector = model._openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
    cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 2) {
      return;
    }
    const program = cellBO.getProgram();
    let numberOfLights = 0;
    const lights = ren.getLightsByReference();
    for (let index = 0;index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();
        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          normalize(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        normalize(model.lightDirection);
        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
        numberOfLights++;
      }
    }
    if (lastLightComplexity < 3) {
      return;
    }
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    exports_mat4.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (let index = 0;index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0) {
        const lp = light.getTransformedPosition();
        const np2 = new Float64Array(3);
        exports_vec3.transformMat4(np2, lp, viewTF);
        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np2[0], np2[1], np2[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();
    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    if (actor.getCoordinateSystem() === CoordinateSystem3.DISPLAY) {
      const size = model._openGLRenderer.getTiledSizeAndOrigin();
      exports_mat4.identity(model.tmpMat4);
      model.tmpMat4[0] = 2 / size.usize;
      model.tmpMat4[12] = -1;
      model.tmpMat4[5] = 2 / size.vsize;
      model.tmpMat4[13] = -1;
      exports_mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
      program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    } else {
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], exports_mat4, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], exports_mat4, model.tmpMat4));
    }
    if (program.isUniformUsed("normalMatrix")) {
      program.setUniformMatrix3x3("normalMatrix", safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], exports_mat3, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed("cameraParallel")) {
        program.setUniformi("cameraParallel", cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    let ppty = actor.getProperty();
    let opacity = ppty.getOpacity();
    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    let aIntensity = model.drawingEdges ? 1 : ppty.getAmbient();
    let dIntensity = model.drawingEdges ? 0 : ppty.getDiffuse();
    let sIntensity = model.drawingEdges ? 0 : ppty.getSpecular();
    const specularPower = ppty.getSpecularPower();
    program.setUniformf("opacityUniform", opacity);
    program.setUniform3fArray("ambientColorUniform", aColor);
    program.setUniform3fArray("diffuseColorUniform", dColor);
    program.setUniformf("ambient", aIntensity);
    program.setUniformf("diffuse", dIntensity);
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 1) {
      return;
    }
    let sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray("specularColorUniform", sColor);
    program.setUniformf("specularPowerUniform", specularPower);
    program.setUniformf("specular", sIntensity);
    if (program.isUniformUsed("ambientIntensityBF")) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf("ambientIntensityBF", aIntensity);
      program.setUniformf("diffuseIntensityBF", dIntensity);
      program.setUniformf("opacityUniformBF", opacity);
      program.setUniform3fArray("ambientColorUniformBF", aColor);
      program.setUniform3fArray("diffuseColorUniformBF", dColor);
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf("specularIntensityBF", sIntensity);
      program.setUniform3fArray("specularColorUniformBF", sColor);
      program.setUniformf("specularPowerUniformBF", specularPower);
    }
  };
  publicAPI.updateMaximumPointCellIds = (ren, actor) => {
    const selector = model._openGLRenderer.getSelector();
    if (!selector) {
      return;
    }
    if (model.selectionWebGLIdsToVTKIds?.points?.length) {
      const length5 = model.selectionWebGLIdsToVTKIds.points.length;
      selector.setMaximumPointId(length5 - 1);
    }
    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {
      const length5 = model.selectionWebGLIdsToVTKIds.cells.length;
      selector.setMaximumCellId(length5 - 1);
    }
    const fieldAssociation = selector.getFieldAssociation();
    if (fieldAssociation === FieldAssociations5.FIELD_ASSOCIATION_POINTS) {
      model.pointPicking = true;
    }
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    model.vertexIDOffset = 0;
    const picking = getPickState(model._openGLRenderer);
    if (model.lastSelectionState !== picking) {
      model.selectionStateChanged.modified();
      model.lastSelectionState = picking;
    }
    if (model._openGLRenderer.getSelector()) {
      switch (picking) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    publicAPI.updateBufferObjects(ren, actor);
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation4.SURFACE;
    const selector = model._openGLRenderer.getSelector();
    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations5.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);
    for (let i = primTypes2.Start;i < primTypes2.End; i++) {
      model.primitives[i].setPointPicking(pointPicking);
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes2.TrisEdges || i === primTypes2.TriStripsEdges);
        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
        }
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro17("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    publicAPI.updateMaximumPointCellIds();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      if ((scalarMode === ScalarMode3.USE_CELL_DATA || scalarMode === ScalarMode3.USE_CELL_FIELD_DATA || scalarMode === ScalarMode3.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode3.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    let n = actor.getProperty().getInterpolation() !== Shading2.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }
    let useTCoordsPerCell = false;
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter3.NEAREST);
      tex.setMagnificationFilter(Filter3.NEAREST);
      tex.setWrapS(Wrap3.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap3.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;
    if (model.VBOBuildString !== toString) {
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        vertexOffset: 0,
        useTCoordsPerCell,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
      };
      if (model.renderable.getPopulateSelectionSettings()) {
        model.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        };
      }
      const primitives = [{
        inRep: "verts",
        cells: poly.getVerts()
      }, {
        inRep: "lines",
        cells: poly.getLines()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }];
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation4.SURFACE;
      for (let i = primTypes2.Start;i < primTypes2.End; i++) {
        if (i !== primTypes2.TrisEdges && i !== primTypes2.TriStripsEdges) {
          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
          options.vertexOffset += model.primitives[i].getCABO().getElementCount();
        } else {
          if (drawSurfaceWithEdges) {
            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation4.WIREFRAME, {
              ...options,
              tcoords: null,
              colors: null,
              haveCellScalars: false,
              haveCellNormals: false
            });
          } else {
            model.primitives[i].releaseGraphicsResources();
          }
        }
      }
      if (model.renderable.getPopulateSelectionSettings()) {
        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
      }
      model.VBOBuildString = toString;
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES39 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [],
  diffuseColor: [],
  specularColor: [],
  lightColor: [],
  lightDirection: [],
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,
  selectionStateChanged: null,
  selectionWebGLIdsToVTKIds: null,
  pointPicking: false
};
function extend40(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES39, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes2;
  model.tmpMat3 = exports_mat3.identity(new Float64Array(9));
  model.tmpMat4 = exports_mat4.identity(new Float64Array(16));
  for (let i = primTypes2.Start;i < primTypes2.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.selectionStateChanged = {};
  obj(model.selectionStateChanged, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper(publicAPI, model);
}
var newInstance40 = newInstance(extend40, "vtkOpenGLPolyDataMapper");
var vtkOpenGLPolyDataMapper$1 = {
  newInstance: newInstance40,
  extend: extend40
};
registerOverride("vtkMapper", newInstance40);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js
var {
  vtkErrorMacro: vtkErrorMacro18
} = macro$1;
var {
  Representation: Representation5
} = vtkProperty$1;
var {
  ObjectType: ObjectType3
} = vtkBufferObject;
var {
  PassTypes: PassTypes3
} = vtkHardwareSelector2;
var StartEvent2 = {
  type: "StartEvent"
};
var EndEvent2 = {
  type: "EndEvent"
};
function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLGlyph3DMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent2);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent2);
    if (!model.currentInput) {
      vtkErrorMacro18("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    if (model._openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension("ANGLE_instanced_arrays");
      model.hardwareSupport = !!model.extension;
    }
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[off];
    let b1 = b[off + 1];
    let b22 = b[off + 2];
    let b3 = b[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b[off + 4];
    b1 = b[off + 5];
    b22 = b[off + 6];
    b3 = b[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b[off + 8];
    b1 = b[off + 9];
    b22 = b[off + 10];
    b3 = b[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b[off + 12];
    b1 = b[off + 13];
    b22 = b[off + 14];
    b3 = b[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "attribute mat3 gNormal;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity"];
      if (lastLightComplexity) {
        colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
      }
      let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
      }
      colorImpl = colorImpl.concat(["  opacity = opacityUniform;"]);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
      }
      if (!model.drawingEdges) {
        colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 gColor;", "varying vec4 vertexColorVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput = gColor;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
        colorImpl = colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"]);
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "vertexVCVSOutput = MCVCMatrix * gVertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["attribute vec3 mapperIndexVS;", "varying vec3 mapperIndexVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  mapperIndexVSOutput = mapperIndexVS;").result;
      shaders.Vertex = VSSource;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["varying vec3 mapperIndexVSOutput;", "uniform vec3 mapperIndex;", "uniform int picking;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);", "  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };
  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {
    const program = cellBO.getProgram();
    if (normalMatrixUsed) {
      const a = model.normalMatrix;
      const b = narray;
      const ofs = p * 9;
      const out = model.tmpMat3;
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a10 = a[3];
      const a11 = a[4];
      const a12 = a[5];
      const a20 = a[6];
      const a21 = a[7];
      const a22 = a[8];
      const b00 = b[ofs];
      const b01 = b[ofs + 1];
      const b02 = b[ofs + 2];
      const b10 = b[ofs + 3];
      const b11 = b[ofs + 4];
      const b12 = b[ofs + 5];
      const b20 = b[ofs + 6];
      const b21 = b[ofs + 7];
      const b22 = b[ofs + 8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      program.setUniformMatrix3x3("normalMatrix", model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);
    program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);
      program.setUniformMatrix("MCVCMatrix", model.tmpMat4);
    }
    if (carray) {
      const cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255;
      program.setUniform3fArray("ambientColorUniform", model.tmpColor);
      program.setUniform3fArray("diffuseColorUniform", model.tmpColor);
    }
    if (selector) {
      program.setUniform3fArray("mapperIndex", selector.getPropColorValue());
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation5.SURFACE;
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLActor.getKeyMatrices();
    exports_mat3.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    exports_mat4.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    exports_mat4.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);
    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    const carray = model.renderable.getColorArray();
    const numPts = garray.length / 16;
    let compositePass = false;
    if (model._openGLRenderer.getSelector()) {
      if (model._openGLRenderer.getSelector().getCurrentPass() === PassTypes3.COMPOSITE_INDEX_PASS) {
        compositePass = true;
      }
    }
    for (let i = model.primTypes.Start;i < model.primTypes.End; i++) {
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);
        model.lastBoundBO = model.primitives[i];
        model.primitives[i].updateShaders(ren, actor, publicAPI);
        const program = model.primitives[i].getProgram();
        const mode = model.primitives[i].getOpenGLMode(representation);
        const normalMatrixUsed = program.isUniformUsed("normalMatrix");
        const mcvcMatrixUsed = program.isUniformUsed("MCVCMatrix");
        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          for (let p = 0;p < numPts; ++p) {
            if (compositePass) {
              model._openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("gMatrix")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, "gMatrix", 0, 64, model.context.FLOAT, 4, false, 1)) {
          vtkErrorMacro18("Error setting gMatrix in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gMatrix");
      }
      if (cellBO.getProgram().isAttributeUsed("gNormal")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, "gNormal", 0, 36, model.context.FLOAT, 3, false, 1)) {
          vtkErrorMacro18("Error setting gNormal in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gNormal");
      }
      if (cellBO.getProgram().isAttributeUsed("gColor")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, "gColor", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro18("Error setting gColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gColor");
      }
      if (cellBO.getProgram().isAttributeUsed("mapperIndexVS")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, "mapperIndexVS", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro18("Error setting mapperIndexVS in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("mapperIndexVS");
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    model.renderable.buildArrays();
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    if (model.hardwareSupport) {
      const garray = model.renderable.getMatrixArray();
      const narray = model.renderable.getNormalArray();
      const carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = vtkBufferObject.newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.normalBuffer = vtkBufferObject.newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.colorBuffer = vtkBufferObject.newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.pickBuffer = vtkBufferObject.newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
        model.matrixBuffer.upload(garray, ObjectType3.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType3.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType3.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        const numPts = garray.length / 16;
        const parray = new Uint8Array(4 * numPts);
        for (let i = 0;i < numPts; ++i) {
          let value = i + 1;
          const offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType3.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    return superClass.buildBufferObjects(ren, actor);
  };
}
var DEFAULT_VALUES40 = {
  normalMatrix: null,
  mcpcMatrix: null,
  mcwcMatrix: null
};
function extend41(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES40, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  model.tmpMat3 = exports_mat3.identity(new Float64Array(9));
  model.normalMatrix = exports_mat3.identity(new Float64Array(9));
  model.mcpcMatrix = exports_mat4.identity(new Float64Array(16));
  model.mcvcMatrix = exports_mat4.identity(new Float64Array(16));
  model.tmpColor = [];
  model.glyphBOBuildTime = {};
  obj(model.glyphBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}
var newInstance41 = newInstance(extend41, "vtkOpenGLGlyph3DMapper");
var vtkGlyph3DMapper = {
  newInstance: newInstance41,
  extend: extend41
};
registerOverride("vtkGlyph3DMapper", newInstance41);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants12 = {
  SlicingMode
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var InterpolationType2 = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants13 = {
  InterpolationType: InterpolationType2
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
function getTransferFunctionHash(transferFunction, useIndependentComponents, numberOfComponents) {
  return transferFunction ? `${transferFunction.getMTime()}-${useIndependentComponents}-${numberOfComponents}` : "0";
}
function getImageDataHash(image, scalars) {
  return `${image.getMTime()}A${scalars.getMTime()}`;
}

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var {
  vtkErrorMacro: vtkErrorMacro19
} = macro$1;
var {
  SlicingMode: SlicingMode2
} = Constants12;
function splitStringOnEnter(inputString) {
  const lines = inputString.split(`
`);
  const trimmedLines = [];
  for (let i = 0;i < lines.length; ++i) {
    const trimmedLine = lines[i].trim();
    if (trimmedLine.length > 0) {
      trimmedLines.push(trimmedLine);
    }
  }
  return trimmedLines;
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  function unregisterGraphicsResources(renderWindow) {
    model.openGLTexture.releaseGraphicsResources(renderWindow);
    [model._colorTransferFunc, model._pwFunc, model._labelOutlineThicknessArray].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      if (model.renderable.isA("vtkImageMapper") && model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      "uniform float cshift0;",
      "uniform float cscale0;",
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform sampler2D labelOutlineTexture1;",
      "uniform float opacity;",
      "uniform float outlineOpacity;"
    ];
    if (iComps) {
      for (let comp = 1;comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro19("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutline::Dec", ["uniform int outlineThickness;", "uniform float vpWidth;", "uniform float vpHeight;", "uniform float vpOffsetX;", "uniform float vpOffsetY;", "uniform mat4 PCWCMatrix;", "uniform mat4 vWCtoIDX;", "uniform ivec3 imageDimensions;", "uniform int sliceAxis;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelOutlineHelperFunction", ["#ifdef vtkImageLabelOutlineOn", "vec3 fragCoordToIndexSpace(vec4 fragCoord) {", "  vec4 pcPos = vec4(", "    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,", "    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,", "    (fragCoord.z - 0.5) * 2.0,", "    1.0);", "", "  vec4 worldCoord = PCWCMatrix * pcPos;", "  vec4 vertex = (worldCoord/worldCoord.w);", "", "  vec3 index = (vWCtoIDX * vertex).xyz;", "", "  // half voxel fix for labelmapOutline", "  return (index + vec3(0.5)) / vec3(imageDimensions);", "}", "vec2 getSliceCoords(vec3 coord, int axis) {", "  if (axis == 0) return coord.yz;", "  if (axis == 1) return coord.xz;", "  if (axis == 2) return coord.xy;", "}", "#endif"]).result;
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      let tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (let comp = 0;comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro19("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", [...splitStringOnEnter(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        case 3:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro19("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro19("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i = 0;i < numComp; i++) {
        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }
    const oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (let i = 0;i < numComp; i++) {
      let cw2 = actor.getProperty().getColorWindow();
      let cl2 = actor.getProperty().getColorLevel();
      const target = iComps ? i : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw2 = cRange[1] - cRange[0];
        cl2 = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale8 = oglShiftScale.scale / cw2;
      const shift = (oglShiftScale.shift - cl2) / cw2 + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i}`, shift);
      cellBO.getProgram().setUniformf(`cscale${i}`, scale8);
    }
    for (let i = 0;i < numComp; i++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length5 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length5;
        pwfShift = (oglShiftScale.shift - mid) / length5 + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("labelOutlineTexture1", outlineThicknessUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? exports_mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        exports_mat4.transpose(mat, mat);
        exports_mat4.multiply(mat, mat, inverseShiftScaleMatrix);
        exports_mat4.transpose(mat, mat);
      }
      exports_mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      exports_mat4.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0;i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0;j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      cellBO.getProgram().setUniformf("outlineOpacity", outlineOpacity);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image = model.currentInput;
    const i2wmat4 = image.getIndexToWorld();
    exports_mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    exports_mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      exports_mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const worldToIndex = image.getWorldToIndex();
      const imageDimensions = image.getDimensions();
      let sliceAxis = model.renderable.getClosestIJKAxis().ijkMode;
      if (sliceAxis === SlicingMode2.NONE) {
        sliceAxis = SlicingMode2.K;
      }
      program.setUniform3i("imageDimensions", imageDimensions[0], imageDimensions[1], imageDimensions[2]);
      program.setUniformi("sliceAxis", sliceAxis);
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      exports_mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset[0] / size[0]);
      program.setUniformf("vpOffsetY", offset[1] / size[1]);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getCurrentImage();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro19("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    const dataType = imgScalars.getDataType();
    const numComp = imgScalars.getNumberOfComponents();
    const actorProperty = actor.getProperty();
    const iType = actorProperty.getInterpolationType();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = actorProperty.getRGBTransferFunction();
    const cfunToString = getTransferFunctionHash(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== cfunToString;
    if (reBuildC) {
      model.colorTexture = vtkOpenGLTexture$1.newInstance({
        resizable: true
      });
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      if (iType === InterpolationType2.NEAREST) {
        model.colorTexture.setMinificationFilter(Filter.NEAREST);
        model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.colorTexture.setMinificationFilter(Filter.LINEAR);
        model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0;c < numIComps; c++) {
          const cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0;i < cWidth * 3; ++i) {
          cTable[i] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, cfunToString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    const pwFunc = actorProperty.getPiecewiseFunction();
    const pwfunToString = getTransferFunctionHash(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== pwfunToString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = vtkOpenGLTexture$1.newInstance({
        resizable: true
      });
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (iType === InterpolationType2.NEAREST) {
        model.pwfTexture.setMinificationFilter(Filter.NEAREST);
        model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        model.pwfTexture.setMinificationFilter(Filter.LINEAR);
        model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
      }
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0;c < numIComps; ++c) {
          const pwfun = actorProperty.getPiecewiseFunction(c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfunToString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    publicAPI.updatelabelOutlineThicknessTexture(actor);
    const {
      ijkMode
    } = model.renderable.getClosestIJKAxis();
    let slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice = model.renderable.getSliceAtPosition(slice);
    }
    const nSlice = model.renderable.isA("vtkImageArrayMapper") ? model.renderable.getSubSlice() : Math.round(slice);
    const ext = image.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode2.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode2.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;
    if (model.VBOBuildString !== toString) {
      const dims = image.getDimensions();
      if (!model.openGLTexture) {
        model.openGLTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      if (iType === InterpolationType2.NEAREST) {
        if (new Set([1, 3, 4]).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;
      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i = 0;i < 4; i++) {
        tcoordArray[i * 2] = i % 2 ? 1 : 0;
        tcoordArray[i * 2 + 1] = i > 1 ? 1 : 0;
      }
      const sliceDepth = [SlicingMode2.X, SlicingMode2.Y, SlicingMode2.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      const spatialExt = image.getSpatialExtent();
      const basicScalars = imgScalars.getData();
      let scalars = null;
      if (ijkMode === SlicingMode2.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k = 0;k < dims[2]; k++) {
          for (let j = 0;j < dims[1]; j++) {
            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k = 0;k < dims[2]; k++) {
          for (let i = 0;i < dims[0]; i++) {
            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[0] + i) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro19("Reformat slicing not yet supported.");
      }
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, model.renderable.getPreferSizeOverAccuracy?.());
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.updatelabelOutlineThicknessTexture = (image) => {
    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThicknessByReference();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const toString = `${labelOutlineThicknessArray.join("-")}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i = 0;i < lWidth; ++i) {
        const thickness = typeof labelOutlineThicknessArray[i] !== "undefined" ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance({
        resizable: false
      });
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.delete = chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}
var DEFAULT_VALUES41 = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
};
function extend42(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES41, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.imagemat = exports_mat4.identity(new Float64Array(16));
  model.imagematinv = exports_mat4.identity(new Float64Array(16));
  model.projectionToWorld = exports_mat4.identity(new Float64Array(16));
  model.idxToView = exports_mat4.identity(new Float64Array(16));
  model.idxNormalMatrix = exports_mat3.identity(new Float64Array(9));
  model.modelToView = exports_mat4.identity(new Float64Array(16));
  model.projectionToView = exports_mat4.identity(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var newInstance42 = newInstance(extend42, "vtkOpenGLImageMapper");
var vtkImageMapper = {
  newInstance: newInstance42,
  extend: extend42
};
registerOverride("vtkAbstractImageMapper", newInstance42);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageCPRMapper/Constants.js
var ProjectionMode = {
  MAX: 0,
  MIN: 1,
  AVERAGE: 2
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js
var {
  vtkErrorMacro: vtkErrorMacro20
} = macro;
function vtkOpenGLImageCPRMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageCPRMapper");
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology() === Resolve.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const prop = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, prop);
  };
  publicAPI.renderPiece = (ren, prop) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.renderable.preRenderCheck()) {
      return;
    }
    model.currentImageDataInput = model.renderable.getInputData(0);
    model.currentCenterlineInput = model.renderable.getOrientedCenterline();
    publicAPI.renderPieceStart(ren, prop);
    publicAPI.renderPieceDraw(ren, prop);
    publicAPI.renderPieceFinish(ren, prop);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.volumeTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.volumeTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    const actorProperty = actor.getProperty();
    if (actorProperty.getInterpolationType() === InterpolationType2.NEAREST) {
      model.volumeTexture.setMinificationFilter(Filter.NEAREST);
      model.volumeTexture.setMagnificationFilter(Filter.NEAREST);
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.volumeTexture.setMinificationFilter(Filter.LINEAR);
      model.volumeTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    return vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime() || !model.volumeTexture?.getHandle();
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentImageDataInput;
    const centerline = model.currentCenterlineInput;
    const scalars = image?.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const cachedScalarsEntry = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const volumeTextureHash = getImageDataHash(image, scalars);
    const reBuildTex = !cachedScalarsEntry?.oglObject?.getHandle() || cachedScalarsEntry?.hash !== volumeTextureHash;
    if (reBuildTex) {
      model.volumeTexture = vtkOpenGLTexture$1.newInstance();
      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const dims = image.getDimensions();
      model.volumeTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.volumeTexture.resetFormatAndType();
      model.volumeTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.volumeTexture, volumeTextureHash);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.volumeTexture = cachedScalarsEntry.oglObject;
    }
    const numComp = scalars.getNumberOfComponents();
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    const colorTextureHash = getTransferFunctionHash(colorTransferFunc, iComps, numIComps);
    const cachedColorEntry = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildColorTexture = !cachedColorEntry?.oglObject?.getHandle() || cachedColorEntry?.hash !== colorTextureHash;
    if (reBuildColorTexture) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = vtkOpenGLTexture$1.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0;c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0;i < cWidth * 3; ++i) {
          cTable[i] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, colorTextureHash);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cachedColorEntry.oglObject;
    }
    const pwFunc = ppty.getPiecewiseFunction();
    const pwfTextureHash = getTransferFunctionHash(pwFunc, iComps, numIComps);
    const cachedPwfEntry = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !cachedPwfEntry?.oglObject?.getHandle() || cachedPwfEntry?.hash !== pwfTextureHash;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = vtkOpenGLTexture$1.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0;c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfTextureHash);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = cachedPwfEntry.oglObject;
    }
    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {
      const nPoints = centerline.getNumberOfPoints();
      const nLines = nPoints <= 1 ? 0 : nPoints - 1;
      const distances = centerline.getDistancesToFirstPoint();
      const totalHeight = model.renderable.getHeight();
      const nPts = 4 * nLines;
      const ptsArray = new Float32Array(3 * nPts);
      const widthMC = model.renderable.getWidth();
      for (let lineIdx = 0, offset = 0;lineIdx < nLines; ++lineIdx) {
        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
      }
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cellArray = new Uint16Array(5 * nLines);
      for (let lineIdx = 0, offset = 0, ptIdx = 0;lineIdx < nLines; ++lineIdx) {
        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset);
        offset += 5;
        ptIdx += 4;
      }
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      const pointsDataArray = centerline.getPoints();
      const centerlinePositionArray = new Float32Array(3 * nPts);
      const pa2 = new Array(3);
      const pb = new Array(3);
      for (let lineIdx = 0, offset = 0;lineIdx < nLines; ++lineIdx) {
        pointsDataArray.getPoint(lineIdx, pa2);
        pointsDataArray.getPoint(lineIdx + 1, pb);
        centerlinePositionArray.set(pa2, offset);
        offset += 3;
        centerlinePositionArray.set(pa2, offset);
        offset += 3;
        centerlinePositionArray.set(pb, offset);
        offset += 3;
        centerlinePositionArray.set(pb, offset);
        offset += 3;
      }
      const centerlinePosition = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: centerlinePositionArray,
        name: "centerlinePosition"
      });
      const quadIndexArray = new Float32Array(nPts);
      for (let lineIdx = 0, offset = 0;lineIdx < nLines; ++lineIdx) {
        quadIndexArray.set([
          0,
          1,
          3,
          2
        ], offset);
        offset += 4;
      }
      const quadIndex = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: quadIndexArray,
        name: "quadIndex"
      });
      const customAttributes = [centerlinePosition, quadIndex];
      if (!model.renderable.getUseUniformOrientation()) {
        const orientationQuats = model.renderable.getOrientedCenterline().getOrientations() ?? [];
        const centerlineTopOrientationArray = new Float32Array(4 * nPts);
        const centerlineBotOrientationArray = new Float32Array(4 * nPts);
        for (let quadIdx = 0;quadIdx < nLines; ++quadIdx) {
          const topQuat = orientationQuats[quadIdx];
          const botQuat = orientationQuats[quadIdx + 1];
          for (let pointInQuadIdx = 0;pointInQuadIdx < 4; ++pointInQuadIdx) {
            const pointIdx = pointInQuadIdx + 4 * quadIdx;
            const quaternionArrayOffset = 4 * pointIdx;
            centerlineTopOrientationArray.set(topQuat, quaternionArrayOffset);
            centerlineBotOrientationArray.set(botQuat, quaternionArrayOffset);
          }
        }
        const centerlineTopOrientation = vtkDataArray$1.newInstance({
          numberOfComponents: 4,
          values: centerlineTopOrientationArray,
          name: "centerlineTopOrientation"
        });
        const centerlineBotOrientation = vtkDataArray$1.newInstance({
          numberOfComponents: 4,
          values: centerlineBotOrientationArray,
          name: "centerlineBotOrientation"
        });
        customAttributes.push(centerlineTopOrientation, centerlineBotOrientation);
      }
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        customAttributes
      });
      model.VBOBuildTime.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const tNumComp = model.volumeTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const useCenterPoint = !!model.renderable.getCenterPoint();
    const useUniformOrientation = model.renderable.getUseUniformOrientation();
    const projectionMode = model.renderable.isProjectionEnabled() && model.renderable.getProjectionMode();
    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastProjectionMode !== projectionMode || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastUseCenterPoint = useCenterPoint;
      model.lastUseUniformOrientation = useUniformOrientation;
      model.lastProjectionMode = projectionMode;
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    const applyQuaternionToVecShaderFunction = ["vec3 applyQuaternionToVec(vec4 q, vec3 v) {", "  float uvx = q.y * v.z - q.z * v.y;", "  float uvy = q.z * v.x - q.x * v.z;", "  float uvz = q.x * v.y - q.y * v.x;", "  float uuvx = q.y * uvz - q.z * uvy;", "  float uuvy = q.z * uvx - q.x * uvz;", "  float uuvz = q.x * uvy - q.y * uvx;", "  float w2 = q.w * 2.0;", "  uvx *= w2;", "  uvy *= w2;", "  uvz *= w2;", "  uuvx *= 2.0;", "  uuvy *= 2.0;", "  uuvz *= 2.0;", "  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);", "}"];
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    const vsColorDec = ["attribute vec3 centerlinePosition;", "attribute float quadIndex;", "uniform float width;", "out vec2 quadOffsetVSOutput;", "out vec3 centerlinePosVSOutput;"];
    const useProjection = model.renderable.isProjectionEnabled();
    const isDirectionUniform = model.renderable.getUseUniformOrientation();
    if (isDirectionUniform) {
      vsColorDec.push("out vec3 samplingDirVSOutput;", "uniform vec4 centerlineOrientation;", "uniform vec3 tangentDirection;", ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        vsColorDec.push("out vec3 projectionDirVSOutput;", "uniform vec3 bitangentDirection;");
      }
    } else {
      vsColorDec.push("out vec4 centerlineTopOrientationVSOutput;", "out vec4 centerlineBotOrientationVSOutput;", "attribute vec4 centerlineTopOrientation;", "attribute vec4 centerlineBotOrientation;");
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", vsColorDec).result;
    const vsColorImpl = [
      "quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);",
      "centerlinePosVSOutput = centerlinePosition;"
    ];
    if (isDirectionUniform) {
      vsColorImpl.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);");
      if (useProjection) {
        vsColorImpl.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);");
      }
    } else {
      vsColorImpl.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;", "centerlineBotOrientationVSOutput = centerlineBotOrientation;");
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", vsColorImpl).result;
    const tNumComp = model.volumeTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
      "uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates",
      "in vec2 quadOffsetVSOutput;",
      "in vec3 centerlinePosVSOutput;",
      "uniform highp sampler3D volumeTexture;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;",
      "uniform vec4 backgroundColor;",
      `uniform float cshift0;`,
      `uniform float cscale0;`,
      `uniform float pwfshift0;`,
      `uniform float pwfscale0;`
    ];
    if (useProjection) {
      tcoordFSDec.push("uniform vec3 volumeSizeMC;", "uniform int projectionSlabNumberOfSamples;", "uniform float projectionConstantOffset;", "uniform float projectionStepLength;");
    }
    if (isDirectionUniform) {
      tcoordFSDec.push("in vec3 samplingDirVSOutput;");
      if (useProjection) {
        tcoordFSDec.push("in vec3 projectionDirVSOutput;");
      }
    } else {
      tcoordFSDec.push("uniform vec3 tangentDirection;", "in vec4 centerlineTopOrientationVSOutput;", "in vec4 centerlineBotOrientationVSOutput;", ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        tcoordFSDec.push("uniform vec3 bitangentDirection;");
      }
    }
    const centerPoint = model.renderable.getCenterPoint();
    if (centerPoint) {
      tcoordFSDec.push("uniform vec3 globalCenterPoint;");
    }
    if (iComps) {
      for (let comp = 1;comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro20("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordFSDec).result;
    let tcoordFSImpl = [];
    if (isDirectionUniform) {
      tcoordFSImpl.push("vec3 samplingDirection = samplingDirVSOutput;");
      if (useProjection) {
        tcoordFSImpl.push("vec3 projectionDirection = projectionDirVSOutput;");
      }
    } else {
      tcoordFSImpl.push("vec4 q0 = centerlineBotOrientationVSOutput;", "vec4 q1 = centerlineTopOrientationVSOutput;", "float qCosAngle = dot(q0, q1);", "vec4 interpolatedOrientation;", "if (qCosAngle > 0.999 || qCosAngle < -0.999) {", "  // Use LERP instead of SLERP when the two quaternions are close or opposite", "  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));", "} else {", "  float omega = acos(qCosAngle);", "  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);", "}", "vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);");
      if (useProjection) {
        tcoordFSImpl.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);");
      }
    }
    if (centerPoint) {
      tcoordFSImpl.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);", "float horizontalOffset = quadOffsetVSOutput.x + baseOffset;");
    } else {
      tcoordFSImpl.push("float horizontalOffset = quadOffsetVSOutput.x;");
    }
    tcoordFSImpl.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;", "vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;", "if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}");
    if (useProjection) {
      const projectionMode = model.renderable.getProjectionMode();
      switch (projectionMode) {
        case ProjectionMode.MIN:
          tcoordFSImpl.push("const vec4 initialProjectionTextureValue = vec4(1.0);");
          break;
        case ProjectionMode.MAX:
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push("const vec4 initialProjectionTextureValue = vec4(0.0);");
          break;
      }
      tcoordFSImpl.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;", "vec3 projectionStep = projectionStepLength * projectionScaledDirection;", "vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;", "vec4 tvalue = initialProjectionTextureValue;", "for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {", "  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;", "  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);");
      switch (projectionMode) {
        case ProjectionMode.MAX:
          tcoordFSImpl.push("  tvalue = max(tvalue, sampledTextureValue);");
          break;
        case ProjectionMode.MIN:
          tcoordFSImpl.push("  tvalue = min(tvalue, sampledTextureValue);");
          break;
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push("  tvalue = tvalue + sampledTextureValue;");
          break;
      }
      tcoordFSImpl.push("}");
      if (projectionMode === ProjectionMode.AVERAGE) {
        tcoordFSImpl.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);");
      }
    } else {
      tcoordFSImpl.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      for (let comp = 0;comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro20("Unsupported number of independent coordinates.");
      }
    } else {
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["// Dependent components", "float intensity = tvalue.r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float intensity = tvalue.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordFSImpl).result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macro.vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cellArrayBufferObject = cellBO.getCABO();
    if (cellArrayBufferObject.getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, "vertexMC", cellArrayBufferObject.getVertexOffset(), cellArrayBufferObject.getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro20("Error setting vertexMC in shader VAO.");
        }
      }
      cellBO.getCABO().getCustomData().forEach((data) => {
        if (data && program.isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, data.name, data.offset, cellArrayBufferObject.getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {
          vtkErrorMacro20(`Error setting ${data.name} in shader VAO.`);
        }
      });
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.volumeTexture.getTextureUnit();
    program.setUniformi("volumeTexture", texUnit);
    program.setUniformf("width", model.renderable.getWidth());
    cellBO.getProgram().setUniform4fv("backgroundColor", model.renderable.getBackgroundColor());
    if (program.isUniformUsed("tangentDirection")) {
      const tangentDirection = model.renderable.getTangentDirection();
      cellBO.getProgram().setUniform3fArray("tangentDirection", tangentDirection);
    }
    if (program.isUniformUsed("bitangentDirection")) {
      const bitangentDirection = model.renderable.getBitangentDirection();
      cellBO.getProgram().setUniform3fArray("bitangentDirection", bitangentDirection);
    }
    if (program.isUniformUsed("centerlineOrientation")) {
      const uniformOrientation = model.renderable.getUniformOrientation();
      cellBO.getProgram().setUniform4fv("centerlineOrientation", uniformOrientation);
    }
    if (program.isUniformUsed("globalCenterPoint")) {
      const centerPoint = model.renderable.getCenterPoint();
      program.setUniform3fArray("globalCenterPoint", centerPoint);
    }
    if (model.renderable.isProjectionEnabled()) {
      const image2 = model.currentImageDataInput;
      const spacing = image2.getSpacing();
      const dimensions = image2.getDimensions();
      const projectionSlabThickness = model.renderable.getProjectionSlabThickness();
      const projectionSlabNumberOfSamples = model.renderable.getProjectionSlabNumberOfSamples();
      const volumeSize = exports_vec3.mul([], spacing, dimensions);
      program.setUniform3fArray("volumeSizeMC", volumeSize);
      program.setUniformi("projectionSlabNumberOfSamples", projectionSlabNumberOfSamples);
      const constantOffset = -0.5 * projectionSlabThickness;
      program.setUniformf("projectionConstantOffset", constantOffset);
      const stepLength = projectionSlabThickness / (projectionSlabNumberOfSamples - 1);
      program.setUniformf("projectionStepLength", stepLength);
    }
    const image = model.currentImageDataInput;
    const MCICMatrix = image.getWorldToIndex();
    const ICTCMatrix = exports_mat4.fromScaling(new Float32Array(16), exports_vec3.inverse([], image.getDimensions()));
    const MCTCMatrix = exports_mat4.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);
    program.setUniformMatrix("MCTCMatrix", MCTCMatrix);
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macro.vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellArrayBufferObject.getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellArrayBufferObject.getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? exports_mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        exports_mat4.transpose(mat, mat);
        exports_mat4.multiply(mat, mat, inverseShiftScaleMatrix);
        exports_mat4.transpose(mat, mat);
      }
      exports_mat4.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());
      exports_mat4.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0;i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0;j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      program.setUniformi("numClipPlanes", numClipPlanes);
      program.setUniform4fv("clipPlanes", planeEquations);
    }
    if (program.isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      program.setUniformf("coffset", cp.offset);
      if (program.isUniformUsed("cfactor")) {
        program.setUniformf("cfactor", cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;
    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;
    exports_mat4.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      exports_mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    cellBO.getProgram().setUniformMatrix("MCPCMatrix", model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
    const numComp = model.volumeTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0;i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }
    const volInfo = model.volumeTexture.getVolumeInfo();
    for (let i = 0;i < numComp; i++) {
      let cw2 = ppty.getColorWindow();
      let cl2 = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw2 = cRange[1] - cRange[0];
        cl2 = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale8 = volInfo.scale[i] / cw2;
      const shift = (volInfo.offset[i] - cl2) / cw2 + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale8);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi("colorTexture1", texColorUnit);
    for (let i = 0;i < numComp; i++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length5 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length5;
        pwfShift = (volInfo.offset[i] - mid) / length5 + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi("pwfTexture1", texOpacityUnit);
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.delete = macro.chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}
var DEFAULT_VALUES42 = {
  currentRenderPass: null,
  volumeTexture: null,
  colorTexture: null,
  pwfTexture: null,
  tris: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
  lastIndependentComponents: 0,
  imagemat: null,
  imagematinv: null
};
function extend43(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES42, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  macro.algo(publicAPI, model, 2, 0);
  model.tris = vtkHelper.newInstance();
  model.volumeTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.imagemat = exports_mat4.identity(new Float64Array(16));
  model.imagematinv = exports_mat4.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLImageCPRMapper(publicAPI, model);
}
var newInstance43 = macro.newInstance(extend43, "vtkOpenGLImageCPRMapper");
var STATIC5 = {};
var index = {
  newInstance: newInstance43,
  extend: extend43,
  ...STATIC5
};
registerOverride("vtkImageCPRMapper", newInstance43);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      exports_mat4.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      exports_mat4.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES43 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend44(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES43, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: exports_mat4.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var newInstance44 = newInstance(extend44, "vtkOpenGLImageSlice");
var vtkImageSlice = {
  newInstance: newInstance44,
  extend: extend44
};
registerOverride("vtkImageSlice", newInstance44);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var {
  vtkDebugMacro: vtkDebugMacro4
} = macro$1;
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro4("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
var DEFAULT_VALUES44 = {};
function extend45(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES44, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance45 = newInstance(extend45, "vtkOpenGLPixelSpaceCallbackMapper");
var vtkPixelSpaceCallbackMapper = {
  newInstance: newInstance45,
  extend: extend45
};
registerOverride("vtkPixelSpaceCallbackMapper", newInstance45);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro5
} = macro$1;
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0;index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro5("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.cameraPass = (prepass) => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    if (model.renderable) {
      model.renderable.getViewProps().forEach((prop) => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES45 = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};
function extend46(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES45, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var newInstance46 = newInstance(extend46, "vtkOpenGLRenderer");
var vtkRenderer = {
  newInstance: newInstance46,
  extend: extend46
};
registerOverride("vtkRenderer", newInstance46);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var {
  vtkErrorMacro: vtkErrorMacro21
} = macro$1;
function vtkOpenGLSkybox(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSkybox");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model._openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi("sbtexture", texUnit);
      const ren = model._openGLRenderer.getRenderable();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = new Float64Array(16);
      exports_mat4.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix("IMCPCMatrix", imat);
      if (model.lastFormat === "box") {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f("camPos", camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = () => {
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0;i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = 1;
      }
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === "box") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ""));
      }
      if (model.lastFormat === "background") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ""));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), "vertexMC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro21("Error setting vertexMC in shader VAO.");
      }
    }
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro21("vtkSkybox requires a texture map");
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}
var DEFAULT_VALUES46 = {
  context: null
};
function extend47(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES46, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.tris = vtkHelper.newInstance();
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: exports_mat3.identity(new Float64Array(9)),
    mcwc: exports_mat4.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLSkybox(publicAPI, model);
}
var newInstance47 = newInstance(extend47);
var vtkSkybox = {
  newInstance: newInstance47,
  extend: extend47
};
registerOverride("vtkSkybox", newInstance47);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js
var vtkSphereMapperVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkSphereMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Spheres

attribute vec4 vertexMC;
attribute vec2 offsetMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying vec3 centerVCVSOutput;

uniform int cameraParallel;
uniform float scaleFactor;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  // compute the projected vertex position
  vec2 scaledOffsetMC = scaleFactor * offsetMC;
  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = length(scaledOffsetMC)*0.5;

  // make the triangle face the camera
  if (cameraParallel == 0)
    {
    vec3 dir = normalize(-vertexVCVSOutput.xyz);
    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));
    vec3 base1 = cross(base2,dir);
    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;
    }
  else
    {
    // add in the offset
    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;
    }

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js
var {
  vtkErrorMacro: vtkErrorMacro22
} = macro$1;
function vtkOpenGLSphereMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSphereMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkSphereMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", [`uniform mat4 VCPCMatrix;
`, "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", [`vec4 vertexVC = vertexVCVSOutput;
`]).result;
    const replacement = [`uniform float invertedDepth;
`, `uniform int cameraParallel;
`, `varying float radiusVCVSOutput;
`, `varying vec3 centerVCVSOutput;
`, `uniform mat4 VCPCMatrix;
`];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    let fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = `gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      `  vec3 EyePos;
`,
      `  vec3 EyeDir;
`,
      `  if (cameraParallel != 0) {
`,
      `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
      `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
      `  else {
`,
      `    EyeDir = vertexVC.xyz;
`,
      `    EyePos = vec3(0.0,0.0,0.0);
`,
      `    float lengthED = length(EyeDir);
`,
      `    EyeDir = normalize(EyeDir);
`,
      `    if (lengthED > radiusVCVSOutput*3.0) {
`,
      `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
      `    }
`,
      `  EyePos = EyePos - centerVCVSOutput;
`,
      `  EyePos = EyePos/radiusVCVSOutput;
`,
      `  float b = 2.0*dot(EyePos,EyeDir);
`,
      `  float c = dot(EyePos,EyePos) - 1.0;
`,
      `  float d = b*b - 4.0*c;
`,
      `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
      `  if (d < 0.0) { discard; }
`,
      `  else {
`,
      `    float t = (-b - invertedDepth*sqrt(d))*0.5;
`,
      `    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);
`,
      `    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;
`,
      `    }
`,
      `  vec4 pos = VCPCMatrix * vertexVC;
`,
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed("offsetMC")) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "offsetMC", 12, cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {
        vtkErrorMacro22("Error setting 'offsetMC' in shader VAO.");
      }
    }
    if (cellBO.getProgram().isUniformUsed("invertedDepth")) {
      cellBO.getProgram().setUniformf("invertedDepth", model.invert ? -1 : 1);
    }
    if (cellBO.getProgram().isUniformUsed("scaleFactor")) {
      const poly = model.currentInput;
      const pointData = poly.getPointData();
      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
        cellBO.getProgram().setUniformf("scaleFactor", model.renderable.getScaleFactor());
      } else {
        cellBO.getProgram().setUniformf("scaleFactor", 1);
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      if (!actor.getIsIdentity()) {
        const actMats = model.openGLActor.getKeyMatrices();
        const tmp4 = new Float64Array(16);
        exports_mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix("MCVCMatrix", tmp4);
      } else {
        program.setUniformMatrix("MCVCMatrix", keyMats.wcvc);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    const pointSize = 5;
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    let colorData = null;
    let colorComponents = 0;
    let packedUCVBO = null;
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c.getData();
      packedUCVBO = new Uint8Array(3 * numPoints * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(vtkBufferObject.newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);
    const packedVBO = new Float32Array(pointSize * numPoints * 3);
    vbo.setStride(pointSize * 4);
    const cos30 = Math.cos(radiansFromDegrees(30));
    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0;i < numPoints; ++i) {
      let radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = -2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 0;
      packedVBO[vboIdx++] = 2 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (c) {
      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES47 = {};
function extend48(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES47, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLSphereMapper(publicAPI, model);
}
var newInstance48 = newInstance(extend48, "vtkOpenGLSphereMapper");
var vtkSphereMapper = {
  newInstance: newInstance48,
  extend: extend48
};
registerOverride("vtkSphereMapper", newInstance48);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js
var vtkStickMapperVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkStickMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Sticks

attribute vec4 vertexMC;
attribute vec3 orientMC;
attribute vec4 offsetMC;
attribute float radiusMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying float lengthVCVSOutput;
varying vec3 centerVCVSOutput;
varying vec3 orientVCVSOutput;

uniform int cameraParallel;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = radiusMC;
  lengthVCVSOutput = length(orientMC);
  orientVCVSOutput = normalMatrix * normalize(orientMC);

  // make sure it is pointing out of the screen
  if (orientVCVSOutput.z < 0.0)
    {
    orientVCVSOutput = -orientVCVSOutput;
    }

  // make the basis
  vec3 xbase;
  vec3 ybase;
  vec3 dir = vec3(0.0,0.0,1.0);
  if (cameraParallel == 0)
    {
    dir = normalize(-vertexVCVSOutput.xyz);
    }
  if (abs(dot(dir,orientVCVSOutput)) == 1.0)
    {
    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));
    ybase = cross(xbase,orientVCVSOutput);
    }
  else
    {
    xbase = normalize(cross(orientVCVSOutput,dir));
    ybase = cross(orientVCVSOutput,xbase);
    }

  vec3 offsets = offsetMC.xyz*2.0-1.0;
  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +
    radiusVCVSOutput*offsets.x*xbase +
    radiusVCVSOutput*offsets.y*ybase +
    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js
var {
  vtkErrorMacro: vtkErrorMacro23
} = macro$1;
function vtkOpenGLStickMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLStickMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkStickMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", [`uniform mat4 VCPCMatrix;
`, "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", "varying vec4 vertexVCVSOutput;").result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", `  vec4 vertexVC = vertexVCVSOutput;
`).result;
    const replacement = [`uniform int cameraParallel;
`, `varying float radiusVCVSOutput;
`, `varying vec3 orientVCVSOutput;
`, `varying float lengthVCVSOutput;
`, `varying vec3 centerVCVSOutput;
`, `uniform mat4 VCPCMatrix;
`];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    let fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = `  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      `  vec3 EyePos;
`,
      `  vec3 EyeDir;
`,
      `  if (cameraParallel != 0) {
`,
      `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
      `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
      `  else {
`,
      `    EyeDir = vertexVC.xyz;
`,
      `    EyePos = vec3(0.0,0.0,0.0);
`,
      `    float lengthED = length(EyeDir);
`,
      `    EyeDir = normalize(EyeDir);
`,
      `    if (lengthED > radiusVCVSOutput*3.0) {
`,
      `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
      `    }
`,
      `  EyePos = EyePos - centerVCVSOutput;
`,
      `  vec3 base1;
`,
      `  if (abs(orientVCVSOutput.z) < 0.99) {
`,
      `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }
`,
      `  else {
`,
      `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }
`,
      `  vec3 base2 = cross(orientVCVSOutput,base1);
`,
      `  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));
`,
      `  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));
`,
      `  EyePos = EyePos/radiusVCVSOutput;
`,
      `  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;
`,
      `  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);
`,
      `  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;
`,
      `  float d = b*b - 4.0*a*c;
`,
      `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
      `  if (d < 0.0) { discard; }
`,
      `  else {
`,
      `    float t =  (-b - sqrt(d))/(2.0*a);
`,
      `    float tz = EyePos.z + t*EyeDir.z;
`,
      `    vec3 iPoint = EyePos + t*EyeDir;
`,
      `    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {
`,
      `      float t2 = (-b + sqrt(d))/(2.0*a);
`,
      `      float tz2 = EyePos.z + t2*EyeDir.z;
`,
      `      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }
`,
      `      else {
`,
      `        normalVCVSOutput = orientVCVSOutput;
`,
      `        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;
`,
      `        iPoint = EyePos + t3*EyeDir;
`,
      `        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
      `        }
`,
      `      }
`,
      `    else {
`,
      `      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;
`,
      `      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
      `      }
`,
      `    }
`,
      `  vec4 pos = VCPCMatrix * vertexVC;
`,
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("orientMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "orientMC", 12, cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro23("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("offsetMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "offsetMC", 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {
          vtkErrorMacro23("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("radiusMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "radiusMC", 24, cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {
          vtkErrorMacro23("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    if (!actor.getIsIdentity()) {
      const actMats = model.openGLActor.getKeyMatrices();
      if (program.isUniformUsed("MCVCMatrix")) {
        const tmp4 = new Float64Array(16);
        exports_mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix("MCVCMatrix", tmp4);
      }
      if (program.isUniformUsed("normalMatrix")) {
        const anorms = new Float64Array(9);
        exports_mat3.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3("normalMatrix", anorms);
      }
    } else {
      if (program.isUniformUsed("MCVCMatrix")) {
        program.setUniformMatrix("MCVCMatrix", keyMats.wcvc);
      }
      if (program.isUniformUsed("normalMatrix")) {
        program.setUniformMatrix3x3("normalMatrix", keyMats.normalMatrix);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    let pointSize = 3;
    pointSize += 4;
    let colorData = null;
    let colorComponents = 0;
    vbo.setColorBOStride(4);
    if (!vbo.getColorBO()) {
      vbo.setColorBO(vtkBufferObject.newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);
    vbo.setStride(pointSize * 4);
    const packedVBO = new Float32Array(pointSize * numPoints * 12);
    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));
    let scales = null;
    let orientationArray = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      vtkErrorMacro23([`Error setting orientationArray.
`, "You have to specify the stick orientation"]);
    }
    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];
    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0;i < numPoints; ++i) {
      let length5 = model.renderable.getLength();
      let radius = model.renderable.getRadius();
      if (scales) {
        length5 = scales[i * 2];
        radius = scales[i * 2 + 1];
      }
      for (let j = 0;j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length5;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length5;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length5;
        packedVBO[vboIdx++] = radius;
        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;
        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES48 = {};
function extend49(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES48, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLStickMapper(publicAPI, model);
}
var newInstance49 = newInstance(extend49, "vtkOpenGLStickMapper");
var vtkStickMapper = {
  newInstance: newInstance49,
  extend: extend49
};
registerOverride("vtkStickMapper", newInstance49);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      exports_mat4.copy(model.MCWCMatrix, model.renderable.getMatrix());
      exports_mat4.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        exports_mat3.identity(model.normalMatrix);
      } else {
        exports_mat3.fromMat4(model.normalMatrix, model.MCWCMatrix);
        exports_mat3.invert(model.normalMatrix, model.normalMatrix);
        exports_mat3.transpose(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
var DEFAULT_VALUES49 = {};
function extend50(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES49, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var newInstance50 = newInstance(extend50, "vtkOpenGLVolume");
var vtkVolume = {
  newInstance: newInstance50,
  extend: extend50
};
registerOverride("vtkVolume", newInstance50);

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var import_fast_deep_equal3 = __toESM(require_fast_deep_equal(), 1);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var InterpolationType3 = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
var OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
var ColorMixPreset = {
  CUSTOM: 0,
  ADDITIVE: 1,
  COLORIZE: 2
};
var Constants14 = {
  InterpolationType: InterpolationType3,
  OpacityMode,
  ColorMixPreset
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexDC;

varying vec3 vertexVCVSOutput;
uniform mat4 PCVCMatrix;

uniform float dcxmin;
uniform float dcxmax;
uniform float dcymin;
uniform float dcymax;

void main()
{
  // dcsmall is the device coords reduced to the
  // x y area covered by the volume
  vec4 dcsmall = vec4(
    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),
    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),
    vertexDC.z,
    vertexDC.w);
  vec4 vcpos = PCVCMatrix * dcsmall;
  vertexVCVSOutput = vcpos.xyz/vcpos.w;
  gl_Position = dcsmall;
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define UseIndependentComponents
//VTK::IndependentComponentsOn

// possibly define vtkCustomComponentsColorMix
//VTK::CustomComponentsColorMixOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// possibly define any components that are forced to nearest interpolation
//VTK::vtkForceNearestComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Possibly define vtkLabelEdgeProjectionOn
//VTK::LabelEdgeProjectionOn


#ifdef vtkImageLabelOutlineOn
  uniform float outlineOpacity;
  uniform float vpWidth;
  uniform float vpHeight;
  uniform float vpOffsetX;
  uniform float vpOffsetY;
  uniform mat4 PCWCMatrix;
  uniform mat4 vWCtoIDX;

  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum
  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];
  #define MAX_SEGMENTS 256
  #define UINT_SIZE 32
  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)

  uint bitmask[BITMASK_SIZE];

  // Set the corresponding bit in the bitmask
  void setBit(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    bitmask[index] |= 1u << bitIndex;
  }

  // Check if a bit is set in the bitmask
  bool isBitSet(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    return ((bitmask[index] & (1u << bitIndex)) != 0u);
  }
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#ifdef UseIndependentComponents
#if vtkNumComponents > 1
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents > 2
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#if vtkNumComponents > 3
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

// jitter texture
uniform sampler2D jtexture;
uniform sampler2D ttexture;


// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;
uniform vec3 volumeSpacings; // spacing in the world coorindates


// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef UseIndependentComponents
#if vtkNumComponents == 1
uniform float mix0;
#define height0 0.5
#endif
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);

  #if defined(vtkComponent0ForceNearest) || \\
      defined(vtkComponent1ForceNearest) || \\
      defined(vtkComponent2ForceNearest) || \\
      defined(vtkComponent3ForceNearest)
    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);
    vec4 nearestValue = texture(texture1, nearestPos);
    #ifdef vtkComponent0ForceNearest
      tmp[0] = nearestValue[0];
    #endif
    #ifdef vtkComponent1ForceNearest
      tmp[1] = nearestValue[1];
    #endif
    #ifdef vtkComponent2ForceNearest
      tmp[2] = nearestValue[2];
    #endif
    #ifdef vtkComponent3ForceNearest
      tmp[3] = nearestValue[3];
    #endif
  #endif

  #ifndef UseIndependentComponents
    #if vtkNumComponents == 1
      tmp.a = tmp.r;
    #endif
    #if vtkNumComponents == 2
      tmp.a = tmp.g;
    #endif
    #if vtkNumComponents == 3
      tmp.a = length(tmp.rgb);
    #endif
  #endif

  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 +
         posVC.y * vPlaneNormal2 +
         posVC.z * vPlaneNormal4 +
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
  return clamp(normalMag * goscale + goshift, gomin, gomax);
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkClippingPlanesOn
    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)
    {
      vec3 g1VC[3];
      for (int i = 0; i < 3; ++i)
      {
        g1VC[i] = IStoVC(texPos[i]);
      }
      vec3 posVC = IStoVC(pos);
      for (int i = 0; i < clip_numPlanes; ++i)
      {
        for (int j = 0; j < 3; ++j)
        {
          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)
          {
            g1[j] = 0.0;
          }
        }
      }
    }
  #endif

  #ifdef vtkComputeNormalFromOpacity
    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {
      vec3 opacityG1, opacityG2;
      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;
      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;
      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;
      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;
      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;
      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;
      opacityG1.xyz *= gradientOpacity;
      opacityG2.xyz *= gradientOpacity;

      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);
      // divide by spacing
      opacityG.xyz /= vSpacing;
      opacityG.w = length(opacityG.xyz);
      // rotate to View Coords
      rotateToViewCoord(opacityG.xyz);
      if (!all(equal(opacityG.xyz, vec3(0.0)))) {
        return vec4(normalize(opacityG.xyz),opacityG.w);
      } else {
        return vec4(0.0);
      }
    }

    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)
    {
      vec3 xvec = vec3(tstep.x, 0.0, 0.0);
      vec3 yvec = vec3(0.0, tstep.y, 0.0);
      vec3 zvec = vec3(0.0, 0.0, tstep.z);
      vec3 texPosPVec[3];
      texPosPVec[0] = pos + xvec;
      texPosPVec[1] = pos + yvec;
      texPosPVec[2] = pos + zvec;
      vec3 texPosNVec[3];
      texPosNVec[0] = pos - xvec;
      texPosNVec[1] = pos - yvec;
      texPosNVec[2] = pos - zvec;
      vec3 g1, g2;

      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];
      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];
      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];
      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];
      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];
      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];

      #ifdef vtkClippingPlanesOn
        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);
        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);
      #endif
      vec4 result;
      result.x = scalarInterp[0].x - scalarInterp[1].x;
      result.y = scalarInterp[0].y - scalarInterp[1].y;
      result.z = scalarInterp[0].z - scalarInterp[1].z;
      // divide by spacing
      result.xyz /= vSpacing;
      result.w = length(result.xyz);
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      if (length(result.xyz) > 0.0) {
        return vec4(normalize(result.xyz),result.w);
      } else {
        return vec4(0.0);
      }
    }
  #endif

  // only works with dependent components
  vec4 computeNormal(vec3 pos, vec3 tstep)
  {
    vec3 xvec = vec3(tstep.x, 0.0, 0.0);
    vec3 yvec = vec3(0.0, tstep.y, 0.0);
    vec3 zvec = vec3(0.0, 0.0, tstep.z);
    vec3 texPosPVec[3];
    texPosPVec[0] = pos + xvec;
    texPosPVec[1] = pos + yvec;
    texPosPVec[2] = pos + zvec;
    vec3 texPosNVec[3];
    texPosNVec[0] = pos - xvec;
    texPosNVec[1] = pos - yvec;
    texPosNVec[2] = pos - zvec;
    vec3 g1, g2;
    g1.x = getTextureValue(texPosPVec[0]).a;
    g1.y = getTextureValue(texPosPVec[1]).a;
    g1.z = getTextureValue(texPosPVec[2]).a;
    g2.x = getTextureValue(texPosNVec[0]).a;
    g2.y = getTextureValue(texPosNVec[1]).a;
    g2.z = getTextureValue(texPosNVec[2]).a;
    #ifdef vtkClippingPlanesOn
      adjustClippedVoxelValues(pos, texPosPVec, g1);
      adjustClippedVoxelValues(pos, texPosNVec, g2);
    #endif
    vec4 result;
    result = vec4(g1 - g2, -1.0);
    // divide by spacing
    result.xyz /= vSpacing;
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);
    } else {
      return vec4(0.0);
    }
  }
#endif


#ifdef vtkImageLabelOutlineOn
  vec4 fragCoordToPCPos(vec4 fragCoord) {
    return vec4(
      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
      (fragCoord.z - 0.5) * 2.0,
      1.0);
  }

  vec4 pcPosToWorldCoord(vec4 pcPos) {
    return PCWCMatrix * pcPos;
  }

  vec3 fragCoordToIndexSpace(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    vec4 vertex = (worldCoord / worldCoord.w);

    vec3 index = (vWCtoIDX * vertex).xyz;

    // half voxel fix for labelmapOutline
    return (index + vec3(0.5)) / vec3(volumeDimensions);
  }

  vec3 fragCoordToWorld(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    return worldCoord.xyz;
  }
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 1.5 and 3.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;

  // in case the first sample near surface has a very tiled light ray, we need to offset start position
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;

  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  float maxdist = hit.tmax;

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);
  if(maxdist < EPSILON) {
    return 1.0;
  }

  float current_dist = 0.0;
  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);
  float clamped_step = 0.0;

  vec4 scalar = vec4(0.0);
  while(current_dist < maxdist)
  {
#ifdef vtkClippingPlanesOn
    vec3 posVC = IStoVC(posIS);
    for (int i = 0; i < clip_numPlanes; ++i)
    {
      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)
      {
        current_dist = maxdist;
      }
    }
#endif
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)
      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    clamped_step = min(maxdist - current_dist, current_step);
    posIS += clamped_step * lightDirNormIS;
    current_dist += current_step;
  }

  return shadow;
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;
    secondary_contrib += tColor * vAmbient;
  }
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && op > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i];
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif
  #endif
#endif

// LAO of surface shadows and volume shadows only work with dependent components
vec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {
  #if vtkLightComplexity > 0
    // surface shadows if needed
    #ifdef SurfaceShadowOn
      #if vtkLightComplexity < 3
        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);
      #else
        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));
      #endif
    #endif

    // volume shadows if needed
    #ifdef VolumeShadowOn
      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);
    #endif

    // merge
    #ifdef VolumeShadowOn
      #ifdef SurfaceShadowOn
        // surface shadows + volumetric shadows
        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
      #else
        // volumetric shadows only
        tColor = tColorVS;
      #endif
    #else
      #ifdef SurfaceShadowOn
        // surface shadows only
        tColor = tColorS;
      #else
        // no shadows
        applyLighting(tColor, normal3);
      #endif
    #endif
  #endif
  return tColor;
}

  
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{

// If labeloutline and not the edge labelmap, since in the edge labelmap blend
// we need the underlying data to sample through
#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  int segmentIndex = int(centerValue.r * 255.0);
  
  // Use texture sampling for outlineThickness
  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

  int actualThickness = int(textureValue * 255.0);


  // If it is the background (segment index 0), we should quickly bail out. 
  // Previously, this was determined by tColor.a, which was incorrect as it
  // prevented the outline from appearing when the fill is 0.
  if (segmentIndex == 0){
    return vec4(0, 0, 0, 0);
  }

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  for (int i = -actualThickness; i <= actualThickness; i++) {
    for (int j = -actualThickness; j <= actualThickness; j++) {
      if (i == 0 || j == 0) {
        continue;
      }

      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
        gl_FragCoord.y + float(j),
        gl_FragCoord.z, gl_FragCoord.w);

      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
      vec4 value = getTextureValue(neighborPosIS);

      // If any of my neighbours are not the same value as I
      // am, this means I am on the border of the segment.
      // We can break the loops
      if (any(notEqual(value, centerValue))) {
        pixelOnBorder = true;
        break;
      }
    }

    if (pixelOnBorder == true) {
      break;
    }
  }

  // If I am on the border, I am displayed at full opacity
  if (pixelOnBorder == true) {
    tColor.a = outlineOpacity;
  }

  return tColor;

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4

  #ifdef UseIndependentComponents

    // sample textures
    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;

    #if vtkNumComponents > 1
      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;

      #if vtkNumComponents > 2
        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;

        #if vtkNumComponents > 3
          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #endif
      #endif
    #endif

    #if !defined(vtkCustomComponentsColorMix)
      // default path for component color mix

      // compute the normal vectors as needed
      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #endif

      // compute gradient opacity factors as needed
      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);
      #if defined(vtkGradientOpacityOn)
        #if !defined(vtkComponent0Proportional)
          goFactor.x =
            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
        #endif
        #if vtkNumComponents > 1
          #if !defined(vtkComponent1Proportional)
            goFactor.y =
              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          #endif
          #if vtkNumComponents > 2
            #if !defined(vtkComponent2Proportional)
              goFactor.z =
                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);
            #endif
            #if vtkNumComponents > 3
              #if !defined(vtkComponent3Proportional)
                goFactor.w =
                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);
              #endif
            #endif
          #endif
        #endif
      #endif

      // process color and opacity for each component
      #if !defined(vtkComponent0Proportional)
        float alpha = goFactor.x*mix0*pwfValue0;
        #if vtkLightComplexity > 0
          applyLighting(tColor0, normalMat[0]);
        #endif
      #else
        tColor0 *= pwfValue0;
        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));
      #endif

      #if vtkNumComponents > 1
        #if !defined(vtkComponent1Proportional)
          alpha += goFactor.y*mix1*pwfValue1;
          #if vtkLightComplexity > 0
            applyLighting(tColor1, normalMat[1]);
          #endif
        #else
          tColor1 *= pwfValue1;
          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));
        #endif

        #if vtkNumComponents > 2
          #if !defined(vtkComponent2Proportional)
            alpha += goFactor.z*mix2*pwfValue2;
            #if vtkLightComplexity > 0
              applyLighting(tColor2, normalMat[2]);
            #endif
          #else
            tColor2 *= pwfValue2;
            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));
          #endif
        #endif

        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            alpha += goFactor.w*mix3*pwfValue3;
            #if vtkLightComplexity > 0
              applyLighting(tColor3, normalMat[3]);
            #endif
          #else
            tColor3 *= pwfValue3;
            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));
          #endif
        #endif
      #endif

      // perform final independent blend
      vec3 tColor = mix0 * tColor0;
      #if vtkNumComponents > 1
        tColor += mix1 * tColor1;
        #if vtkNumComponents > 2
          tColor += mix2 * tColor2;
          #if vtkNumComponents > 3
            tColor += mix3 * tColor3;
          #endif
        #endif
      #endif

      return vec4(tColor, alpha);
    #else
      /*
       * Mix the color information from all the independent components to get a single rgba output
       * Gradient opactity factors and normals are not computed
       *
       * You can compute these using:
       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix
       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),
       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper
       * - computeGradientOpacityFactor: always available, used in a lot of places
       *
       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)
       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight
       */
      //VTK::CustomComponentsColorMix::Impl
    #endif
  #else
    // dependent components

    // compute normal if needed
    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value
      #ifdef vtkComputeNormalFromOpacity
        vec3 scalarInterp[2];
        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);
      #else
        vec4 normal0 = computeNormal(posIS, tstep);
      #endif
    #endif

    // compute gradient opacity factor enabled
    #if defined(vtkGradientOpacityOn)
      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #else
      const float gradientOpacity = 1.0;
    #endif

    // get color and opacity
    #if vtkNumComponents == 1
      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      if (alpha < EPSILON){
        return vec4(0.0);
      }
    #endif
    #if vtkNumComponents == 2
      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    #endif
    #if vtkNumComponents == 3
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
    #endif
    #if vtkNumComponents == 4
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
    #endif

    // lighting
    #if (vtkLightComplexity > 0)
      #ifdef vtkComputeNormalFromOpacity
        vec4 normalLight;
        if (!all(equal(normal0, vec4(0.0)))) {
          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;
          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;
          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);
          if (all(equal(normalLight, vec4(0.0)))) {
            normalLight = normal0;
          }
        }
      #else
        vec4 normalLight = normal0;
      #endif
      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);
    #endif

    return vec4(tColor, alpha);
  #endif // dependent
#endif
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #else
    #ifdef UseIndependentComponents
      #if vtkNumComponents == 2
        if (val.r >= min.r && val.r <= max.r &&
            val.g >= min.g && val.g <= max.g) {
          withinRange = true;
        }
      #else
        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
            all(lessThanEqual(val, ipScalarRangeMax))) {
          withinRange = true;
        }
      #endif
    #endif
  #endif
  return withinRange;
}

#if vtkBlendMode == 6 
bool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {
    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);
    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);

    bool justSawIt = false;

    vec3 neighborPosIS = originalNeighborPosIS;

    float stepsTraveled = 0.0;


    // float neighborValue;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS += stepIS;
    }

    if (justSawIt){
      return false;
    }

   
    neighborPosIS = originalNeighborPosIS;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS -= stepIS;
    }


    if (!justSawIt) {
        // onedge
        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;
        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;
        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);
        return true;
    }

    // not on edge
    return false;
}

#endif


//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // Initialize arrays to false
  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);
  
  #if vtkBlendMode == 6 
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);
    vec3 maxPosIS = posIS; // Store the position of the max value
    int segmentIndex = int(value.g);
    bool originalPosHasSeenNonZero = false;

    uint bitmask = 0u;

    if (segmentIndex != 0) {
      // Tried using the segment index in an boolean array but reading 
      // from the array by dynamic indexing was horrondously slow
      // so use bit masking instead and assign 1 to the bit corresponding to the segment index
      // and later check if the bit is set via bit operations
      setBit(segmentIndex);
    }
    
    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);
      segmentIndex = int(tValue.g);

      if (segmentIndex != 0) {
        originalPosHasSeenNonZero = true;
        setBit(segmentIndex);
      }

      if (tValue.r > value.r) {
        value =  tValue; // Update the max value
        maxPosIS = posIS; // Update the position where max occurred
      }

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);

    if (tValue.r > value.r) {
      value = tValue; // Update the max value
      maxPosIS = posIS; // Update the position where max occurred
    }  

    // If we have not seen any non-zero segments, we can return early
    // and grab color from the actual center value first component (image)
    if (!originalPosHasSeenNonZero) {
      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);
      return;
    }

    // probably we can make this configurable but for now we will use the same
    // sample distance as the original sample distance
    float neighborSampleDistanceIS = sampleDistanceIS;

    vec3 neighborRayStepsIS = stepIS;
    float neighborRaySteps = raySteps;
    bool shouldLookInAllNeighbors = false;

    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));
    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);

    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);
    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);

    vec3 baseWorld = fragCoordToWorld(base);
    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);
    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);

    float XPlusDiff = length(baseXPlusWorld - baseWorld);
    float YPlusDiff = length(baseYPlusWorld - baseWorld);

    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);

    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {
      // bail out quickly if the segment index has not 
      // been seen by the center segment
      if (!isBitSet(s)) {
       continue;
      }

      // Use texture sampling for outlineThickness so that we can have 
      // per segment thickness
      float textureCoordinate = float(s - 1) / 1024.0;
      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

      int actualThickness = int(textureValue * 255.0);

      // check the extreme points in the neighborhood since there is a better
      // chance of finding the edge there, so that we can bail out 
      // faster if we find the edge
      bool onEdge =
          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);

      if (onEdge) {
        return;
      }

      // since the next step is computationally expensive, we need to perform
      // some optimizations to avoid it if possible. One of the optimizations
      // is to check the whether the minimum of the voxel spacing is greater than 
      // the 2 * the thickness of the outline segment. If that is the case
      // then we can safely skip the next step since we can be sure that the
      // the previous 4 checks on the extreme points would caught the entirety 
      // of the all the fragments inside. i.e., this happens when we zoom out, 
      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {
        continue;
      }
      
      // Loop through the rest, skipping the processed extremes and the center
      for (int i = -actualThickness; i <= actualThickness; i++) {
            for (int j = -actualThickness; j <= actualThickness; j++) {
                if (i == 0 && j == 0) continue; // Skip the center
                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners
                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {
                    return;
                }
          }
      }
    }

    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;
    gl_FragData[0] = vec4(tColor0, pwfValue0);
  #endif
  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var {
  vtkWarningMacro: vtkWarningMacro6,
  vtkErrorMacro: vtkErrorMacro24
} = macro$1;
function getColorCodeFromPreset(colorMixPreset) {
  switch (colorMixPreset) {
    case ColorMixPreset.CUSTOM:
      return "//VTK::CustomColorMix";
    case ColorMixPreset.ADDITIVE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
    case ColorMixPreset.COLORIZE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
    default:
      return null;
  }
}
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._scalarOpacityFunc, model._colorTransferFunc, model._labelOutlineThicknessArray].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };
  publicAPI.zBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      const actor = model.openGLVolume.getRenderable();
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.useIndependentComponents = (actorProperty) => {
    const iComps = actorProperty.getIndependentComponents();
    const image = model.currentInput;
    const numComp = image?.getPointData()?.getScalars()?.getNumberOfComponents();
    const colorMixPreset = actorProperty.getColorMixPreset();
    return iComps && numComp >= 2 || !!colorMixPreset;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    const actorProps = actor.getProperty();
    let FSSource = shaders.Fragment;
    const iType = actorProps.getInterpolationType();
    if (iType === InterpolationType3.LINEAR) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result;
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
    }
    const LabelEdgeProjection = model.renderable.getBlendMode() === BlendMode.LABELMAP_EDGE_PROJECTION_BLEND;
    if (LabelEdgeProjection) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LabelEdgeProjectionOn", "#define vtkLabelEdgeProjectionOn").result;
    }
    const numComp = model.scalarTexture.getComponents();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumComponents", `#define vtkNumComponents ${numComp}`).result;
    const useIndependentComps = publicAPI.useIndependentComponents(actorProps);
    if (useIndependentComps) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::IndependentComponentsOn", "#define UseIndependentComponents").result;
    }
    const proportionalComponents = [];
    const forceNearestComponents = [];
    for (let nc = 0;nc < numComp; nc++) {
      if (actorProps.getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {
        proportionalComponents.push(`#define vtkComponent${nc}Proportional`);
      }
      if (actorProps.getForceNearestInterpolation(nc)) {
        forceNearestComponents.push(`#define vtkComponent${nc}ForceNearest`);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", proportionalComponents.join(`
`)).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkForceNearestComponents", forceNearestComponents.join(`
`)).result;
    const colorMixPreset = actorProps.getColorMixPreset();
    const colorMixCode = getColorCodeFromPreset(colorMixPreset);
    if (colorMixCode) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::CustomComponentsColorMixOn", "#define vtkCustomComponentsColorMix").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::CustomComponentsColorMix::Impl", colorMixCode).result;
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    exports_vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = exports_vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumSamplesValue", `${Math.ceil(maxSamples)}`).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LightComplexity", `#define vtkLightComplexity ${model.lightComplexity}`).result;
    if (model.lightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadowOn", `#define VolumeShadowOn`).result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::SurfaceShadowOn", `#define SurfaceShadowOn`).result;
      }
      if (model.renderable.getLocalAmbientOcclusion() && actorProps.getAmbient() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::localAmbientOcclusionOn", `#define localAmbientOcclusionOn`).result;
      }
    }
    const numIComps = useIndependentComps ? numComp : 1;
    model.gopacity = false;
    for (let nc = 0;!model.gopacity && nc < numIComps; ++nc) {
      model.gopacity ||= actorProps.getUseGradientOpacity(nc);
    }
    if (model.gopacity) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result;
    }
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkComputeNormalFromOpacity", `#define vtkComputeNormalFromOpacity`).result;
    }
    if (model.zBufferTexture !== null) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpZWidth;", "uniform float vpZHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "if (cameraParallel == 0) {", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}", "else {", `zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}
`, "zdepth = -zdepth/rayDir.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", `${model.renderable.getBlendMode()}`).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    if (model.lightComplexity === 0) {
      return;
    }
    let FSSource = shaders.Fragment;
    let lightNum = 0;
    ren.getLights().forEach((light) => {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, "//VTK::Light::Dec"], false).result;
    if (model.lightComplexity === 3) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadow::Dec", [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LAO::Dec", [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      const clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, "//VTK::ClipPlane::Dec", "#define vtkClippingPlanesOn"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  const recomputeLightComplexity = (actor, lights) => {
    let lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {
      lightComplexity = 0;
      model.numberOfLights = 0;
      lights.forEach((light) => {
        const status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    if (lightComplexity !== model.lightComplexity) {
      model.lightComplexity = lightComplexity;
      publicAPI.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const actorProps = actor.getProperty();
    recomputeLightComplexity(actor, ren.getLights());
    const numComp = model.scalarTexture.getComponents();
    const opacityModes = [];
    const forceNearestInterps = [];
    for (let nc = 0;nc < numComp; nc++) {
      opacityModes.push(actorProps.getOpacityMode(nc));
      forceNearestInterps.push(actorProps.getForceNearestInterpolation(nc));
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    exports_vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = exports_vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    const hasZBufferTexture = !!model.zBufferTexture;
    const state = {
      iComps: actorProps.getIndependentComponents(),
      colorMixPreset: actorProps.getColorMixPreset(),
      interpolationType: actorProps.getInterpolationType(),
      useLabelOutline: publicAPI.isLabelmapOutlineRequired(actor),
      numComp,
      maxSamples,
      useGradientOpacity: actorProps.getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      hasZBufferTexture,
      opacityModes,
      forceNearestInterps
    };
    if (cellBO.getProgram()?.getHandle() === 0 || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || !model.previousState || !import_fast_deep_equal3.default(model.previousState, state)) {
      model.previousState = state;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro24("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi("texture1", model.scalarTexture.getTextureUnit());
    program.setUniformf("sampleDistance", publicAPI.getCurrentSampleDistance(ren));
    const volInfo = model.scalarTexture.getVolumeInfo();
    const ipScalarRange = model.renderable.getIpScalarRange();
    if (volInfo?.dataComputedScale?.length) {
      const minVals = [];
      const maxVals = [];
      for (let i = 0;i < 4; i++) {
        minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
        maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      }
      program.setUniform4f("ipScalarRangeMin", minVals[0], minVals[1], minVals[2], minVals[3]);
      program.setUniform4f("ipScalarRangeMax", maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    }
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf("vpZWidth", size[0]);
      program.setUniformf("vpZHeight", size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();
    exports_mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    const program = cellBO.getProgram();
    const cam = model.openGLCamera.getRenderable();
    const crange = cam.getClippingRange();
    program.setUniformf("camThick", crange[1] - crange[0]);
    program.setUniformf("camNear", crange[0]);
    program.setUniformf("camFar", crange[1]);
    const bounds = model.currentInput.getBounds();
    const dims = model.currentInput.getDimensions();
    const pos = new Float64Array(3);
    const dir = new Float64Array(3);
    let dcxmin = 1;
    let dcxmax = -1;
    let dcymin = 1;
    let dcymax = -1;
    for (let i = 0;i < 8; ++i) {
      exports_vec3.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      exports_vec3.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        exports_vec3.normalize(dir, pos);
        const t = -crange[0] / pos[2];
        exports_vec3.scale(pos, dir, t);
      }
      exports_vec3.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf("dcxmin", dcxmin);
    program.setUniformf("dcxmax", dcxmax);
    program.setUniformf("dcymin", dcymin);
    program.setUniformf("dcymax", dcymax);
    if (program.isUniformUsed("cameraParallel")) {
      program.setUniformi("cameraParallel", cam.getParallelProjection());
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    exports_vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f("vSpacing", spc[0], spc[1], spc[2]);
    exports_vec3.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    exports_vec3.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f("vOriginVC", pos[0], pos[1], pos[2]);
    const i2wmat4 = model.currentInput.getIndexToWorld();
    exports_mat4.multiply(model.idxToView, model.modelToView, i2wmat4);
    exports_mat3.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    exports_mat3.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());
    const maxSamples = exports_vec3.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro6(`The number of steps required ${Math.ceil(maxSamples)} is larger than the
        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
    }
    const vctoijk = new Float64Array(3);
    exports_vec3.set(vctoijk, 1, 1, 1);
    exports_vec3.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f("vVCToIJK", vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i("volumeDimensions", dims[0], dims[1], dims[2]);
    program.setUniform3f("volumeSpacings", spc[0], spc[1], spc[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      const volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf("texWidth", model.scalarTexture.getWidth());
      program.setUniformf("texHeight", model.scalarTexture.getHeight());
      program.setUniformi("xreps", volInfo.xreps);
      program.setUniformi("xstride", volInfo.xstride);
      program.setUniformi("ystride", volInfo.ystride);
    }
    const normal = new Float64Array(3);
    const pos2 = new Float64Array(3);
    for (let i = 0;i < 6; ++i) {
      switch (i) {
        case 1:
          exports_vec3.set(normal, -1, 0, 0);
          exports_vec3.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          exports_vec3.set(normal, 0, 1, 0);
          exports_vec3.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          exports_vec3.set(normal, 0, -1, 0);
          exports_vec3.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          exports_vec3.set(normal, 0, 0, 1);
          exports_vec3.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          exports_vec3.set(normal, 0, 0, -1);
          exports_vec3.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          exports_vec3.set(normal, 1, 0, 0);
          exports_vec3.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      exports_vec3.transformMat3(normal, normal, model.idxNormalMatrix);
      exports_vec3.transformMat4(pos2, pos2, model.idxToView);
      const dist4 = -1 * exports_vec3.dot(pos2, normal);
      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);
      program.setUniformf(`vPlaneDistance${i}`, dist4);
    }
    if (publicAPI.isLabelmapOutlineRequired(actor)) {
      const image = model.currentInput;
      const worldToIndex = image.getWorldToIndex();
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      const camera = ren.getActiveCamera();
      const [cRange0, cRange1] = camera.getClippingRange();
      const distance4 = camera.getDistance();
      camera.setClippingRange(distance4, distance4 + 0.1);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);
      exports_mat4.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      camera.setClippingRange(cRange0, cRange1);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset[0] / size[0]);
      program.setUniformf("vpOffsetY", offset[1] / size[1]);
    }
    exports_mat4.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", model.projectionToView);
    if (model.lightComplexity === 0) {
      return;
    }
    let lightNum = 0;
    const lightColor = [];
    const lightDir = [];
    const halfAngle = [];
    ren.getLights().forEach((light) => {
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColor();
        const intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        const ldir = light.getDirection();
        exports_vec3.set(normal, ldir[0], ldir[1], ldir[2]);
        exports_vec3.transformMat3(normal, normal, keyMats.normalMatrix);
        exports_vec3.normalize(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1);
        lightNum++;
      }
    });
    program.setUniformi("twoSidedLighting", ren.getTwoSidedLighting());
    program.setUniformi("lightNum", lightNum);
    program.setUniform3fv("lightColor", lightColor);
    program.setUniform3fv("lightDirectionVC", lightDir);
    program.setUniform3fv("lightHalfAngleVC", halfAngle);
    if (model.lightComplexity === 3) {
      lightNum = 0;
      const lightPositionVC = [];
      const lightAttenuation = [];
      const lightConeAngle = [];
      const lightExponent = [];
      const lightPositional = [];
      ren.getLights().forEach((light) => {
        const status = light.getSwitch();
        if (status > 0) {
          const attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          const lp = light.getTransformedPosition();
          exports_vec3.transformMat4(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv("lightPositionVC", lightPositionVC);
      program.setUniform3fv("lightAttenuation", lightAttenuation);
      program.setUniformfv("lightConeAngle", lightConeAngle);
      program.setUniformfv("lightExponent", lightExponent);
      program.setUniformiv("lightPositional", lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      program.setUniformf("giReach", model.renderable.getGlobalIlluminationReach());
      program.setUniformf("volumetricScatteringBlending", model.renderable.getVolumetricScatteringBlending());
      program.setUniformf("volumeShadowSamplingDistFactor", model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf("anisotropy", model.renderable.getAnisotropy());
      program.setUniformf("anisotropy2", model.renderable.getAnisotropy() ** 2);
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      const ks = model.renderable.getLAOKernelSize();
      program.setUniformi("kernelSize", ks);
      const kernelSample = [];
      for (let i = 0;i < ks; i++) {
        kernelSample[i * 2] = Math.random() * 0.5;
        kernelSample[i * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv("kernelSample", kernelSample);
      program.setUniformi("kernelRadius", model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    program.setUniformi("ctexture", model.colorTexture.getTextureUnit());
    program.setUniformi("otexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    program.setUniformi("ttexture", model.labelOutlineThicknessTexture.getTextureUnit());
    const volInfo = model.scalarTexture.getVolumeInfo();
    const vprop = actor.getProperty();
    const numComp = model.scalarTexture.getComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    if (useIndependentComps) {
      for (let i = 0;i < numComp; i++) {
        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }
    for (let i = 0;i < numComp; i++) {
      const target = useIndependentComps ? i : 0;
      const sscale = volInfo.scale[i];
      const ofun = vprop.getScalarOpacity(target);
      const oRange = ofun.getRange();
      const oscale = sscale / (oRange[1] - oRange[0]);
      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf(`oshift${i}`, oshift);
      program.setUniformf(`oscale${i}`, oscale);
      const cfun = vprop.getRGBTransferFunction(target);
      const cRange = cfun.getRange();
      const cshift = (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]);
      const cScale = sscale / (cRange[1] - cRange[0]);
      program.setUniformf(`cshift${i}`, cshift);
      program.setUniformf(`cscale${i}`, cScale);
    }
    if (model.gopacity) {
      if (useIndependentComps) {
        for (let nc = 0;nc < numComp; ++nc) {
          const sscale = volInfo.scale[nc];
          const useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf(`gomin${nc}`, gomin);
            program.setUniformf(`gomax${nc}`, gomax);
            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf(`gomin${nc}`, 1);
            program.setUniformf(`gomax${nc}`, 1);
            program.setUniformf(`goscale${nc}`, 0);
            program.setUniformf(`goshift${nc}`, 1);
          }
        }
      } else {
        const sscale = volInfo.scale[numComp - 1];
        const gomin = vprop.getGradientOpacityMinimumOpacity(0);
        const gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf("gomin0", gomin);
        program.setUniformf("gomax0", gomax);
        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf("goscale0", sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
        program.setUniformf("goshift0", -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
      }
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      program.setUniformf("outlineOpacity", labelOutlineOpacity);
    }
    if (model.lightComplexity > 0) {
      program.setUniformf("vAmbient", vprop.getAmbient());
      program.setUniformf("vDiffuse", vprop.getDiffuse());
      program.setUniformf("vSpecular", vprop.getSpecular());
      program.setUniformf("vSpecularPower", vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {
    if (model.renderable.getClippingPlanes().length > 0) {
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const clipPlaneNormals = [];
      const clipPlaneDistances = [];
      const clipPlaneOrigins = [];
      const clipPlanes = model.renderable.getClippingPlanes();
      const clipPlaneSize = clipPlanes.length;
      for (let i = 0;i < clipPlaneSize; ++i) {
        const clipPlaneNormal = clipPlanes[i].getNormal();
        const clipPlanePos = clipPlanes[i].getOrigin();
        exports_vec3.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        exports_vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        const clipPlaneDist = -1 * exports_vec3.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
        clipPlaneOrigins.push(clipPlanePos[0]);
        clipPlaneOrigins.push(clipPlanePos[1]);
        clipPlaneOrigins.push(clipPlanePos[2]);
      }
      const program = cellBO.getProgram();
      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);
      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);
      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);
      program.setUniformi(`clip_numPlanes`, clipPlaneSize);
    }
  };
  publicAPI.delete = chain(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, () => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.getCurrentSampleDistance = (ren) => {
    const rwi = ren.getVTKWindow().getInteractor();
    const baseSampleDistance = model.renderable.getSampleDistance();
    if (rwi.isAnimating()) {
      const factor = model.renderable.getInteractionSampleDistanceFactor();
      return baseSampleDistance * factor;
    }
    return baseSampleDistance;
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    const rwi = ren.getVTKWindow().getInteractor();
    if (!model._lastScale) {
      model._lastScale = model.renderable.getInitialInteractionScale();
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
      });
    }
    if (model._useSmallViewport) {
      const size = model._openGLRenderWindow.getFramebufferSize();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);
      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType3.NEAREST) {
      model.scalarTexture.setMinificationFilter(Filter.NEAREST);
      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Filter.LINEAR);
      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);
    }
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join(`
`), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join(`
`), "");
        const program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro24("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      const size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      const gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro24("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.scalarTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    const vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i = 0;i < 32 * 32; ++i) {
        oTable[i] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
    }
    const numComp = scalars.getNumberOfComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    const numIComps = useIndependentComps ? numComp : 1;
    const scalarOpacityFunc = vprop.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
    let toString = getTransferFunctionHash(scalarOpacityFunc, useIndependentComps, numIComps);
    const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
    if (reBuildOp) {
      model.opacityTexture = vtkOpenGLTexture$1.newInstance();
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c = 0;c < numIComps; ++c) {
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (let i = 0;i < oWidth; ++i) {
          ofTable[c * oWidth * 2 + i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
        }
      }
      model.opacityTexture.resetFormatAndType();
      model.opacityTexture.setMinificationFilter(Filter.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i = 0;i < oSize; ++i) {
          oTable[i] = 255 * ofTable[i];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
      }
      if (scalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
        if (scalarOpacityFunc !== model._scalarOpacityFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
        }
        model._scalarOpacityFunc = scalarOpacityFunc;
      }
    } else {
      model.opacityTexture = opTex.oglObject;
    }
    const colorTransferFunc = vprop.getRGBTransferFunction();
    toString = getTransferFunctionHash(colorTransferFunc, useIndependentComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      model.colorTexture = vtkOpenGLTexture$1.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c = 0;c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0;i < cWidth * 3; ++i) {
          cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
          cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
        }
      }
      model.colorTexture.resetFormatAndType();
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    publicAPI.updateLabelOutlineThicknessTexture(actor);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    toString = getImageDataHash(image, scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    if (reBuildTex) {
      model.scalarTexture = vtkOpenGLTexture$1.newInstance();
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const dims = image.getDimensions();
      model.scalarTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      if (scalars) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, toString);
        if (scalars !== model._scalars) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
        }
        model._scalars = scalars;
      }
    } else {
      model.scalarTexture = tex.oglObject;
    }
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0;i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = -1;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.updateLabelOutlineThicknessTexture = (volume) => {
    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);
    const toString = `${labelOutlineThicknessArray.join("-")}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      model.labelOutlineThicknessTexture = vtkOpenGLTexture$1.newInstance();
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);
      for (let i = 0;i < lWidth; ++i) {
        const thickness = typeof labelOutlineThicknessArray[i] !== "undefined" ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Filter.NEAREST);
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, VtkDataTypes.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.isLabelmapOutlineRequired = (actor) => {
    const prop = actor.getProperty();
    const renderable = model.renderable;
    return prop.getUseLabelOutline() || renderable.getBlendMode() === BlendMode.LABELMAP_EDGE_PROJECTION_BLEND;
  };
}
var DEFAULT_VALUES50 = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1,
  targetXYF: 1,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lightComplexity: 0,
  fullViewportTime: 1,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0,
  avgFrameTime: 0
};
function extend51(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES50, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap.REPEAT);
  model.jitterTexture.setWrapT(Wrap.REPEAT);
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  model.idxToView = exports_mat4.identity(new Float64Array(16));
  model.idxNormalMatrix = exports_mat3.identity(new Float64Array(9));
  model.modelToView = exports_mat4.identity(new Float64Array(16));
  model.projectionToView = exports_mat4.identity(new Float64Array(16));
  model.projectionToWorld = exports_mat4.identity(new Float64Array(16));
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var newInstance51 = newInstance(extend51, "vtkOpenGLVolumeMapper");
var vtkVolumeMapper = {
  newInstance: newInstance51,
  extend: extend51
};
registerOverride("vtkVolumeMapper", newInstance51);

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getBufferConfiguration.js
function getConstructorFromType(bufferType, isVolumeBuffer) {
  switch (bufferType) {
    case "Float32Array":
      return Float32Array;
    case "Uint8Array":
      return Uint8Array;
    case "Uint16Array":
    case "Int16Array":
      if (!isVolumeBuffer) {
        return bufferType === "Uint16Array" ? Uint16Array : Int16Array;
      } else {
        console.debug(`${bufferType} is not supported for volume rendering, switching back to Float32Array`);
        return Float32Array;
      }
    default:
      if (bufferType) {
        throw new Error("TargetBuffer should be Float32Array, Uint8Array, Uint16Array, or Int16Array");
      } else {
        return Float32Array;
      }
  }
}
function getBufferConfiguration(targetBufferType, length5, options = {}) {
  const { isVolumeBuffer = false } = options;
  const TypedArrayConstructor = getConstructorFromType(targetBufferType, isVolumeBuffer);
  const bytesPerElement = TypedArrayConstructor.BYTES_PER_ELEMENT;
  const numBytes = length5 * bytesPerElement;
  return { numBytes, TypedArrayConstructor };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
function getRenderingEngine(id) {
  return renderingEngineCache_default.get(id);
}
function getRenderingEngines() {
  return renderingEngineCache_default.getAll();
}
var getRenderingEngine_default = getRenderingEngine;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepMerge.js
var isMergeableObject = (val) => {
  const nonNullObject = val && typeof val === "object";
  return nonNullObject && Object.prototype.toString.call(val) !== "[object RegExp]" && Object.prototype.toString.call(val) !== "[object Date]";
};
var emptyTarget = (val) => {
  const isEmpty = Array.isArray(val) ? [] : {};
  return isEmpty;
};
var cloneIfNecessary = (value, optionsArgument) => {
  const clone7 = optionsArgument && optionsArgument.clone === true;
  return clone7 && isMergeableObject(value) ? deepMerge(emptyTarget(value), value, optionsArgument) : value;
};
var defaultArrayMerge = (target, source, optionsArgument) => {
  const destination = target.slice();
  source.forEach(function(e, i) {
    if (typeof destination[i] === "undefined") {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    } else if (isMergeableObject(e)) {
      destination[i] = deepMerge(target[i], e, optionsArgument);
    } else if (target.indexOf(e) === -1) {
      destination[i] = cloneIfNecessary(e, optionsArgument);
    }
  });
  return destination;
};
var mergeObject = (target, source, optionsArgument) => {
  const destination = {};
  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument);
    } else {
      destination[key] = deepMerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
};
var deepMerge = (target = {}, source = {}, optionsArgument = undefined) => {
  const array = Array.isArray(source);
  const options = optionsArgument || { arrayMerge: defaultArrayMerge };
  const arrayMerge = options.arrayMerge || defaultArrayMerge;
  if (array) {
    return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument);
  }
  return mergeObject(target, source, optionsArgument);
};
var deepMerge_default = deepMerge;

// ../../node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj2) {
    const { port1, port2 } = new MessageChannel;
    expose(obj2, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && (throwMarker in value),
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj2, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj3, prop) => obj3[prop], obj2);
      const rawValue = path.reduce((obj3, prop) => obj3[prop], obj2);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy2(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel;
            expose(obj2, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = undefined;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj2 && typeof obj2[finalizer] === "function") {
          obj2[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  const pendingListeners = new Map;
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, new Map, {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = new WeakMap;
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, pendingListeners, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = new WeakMap;
function transfer(obj2, transfers) {
  transferCache.set(obj2, transfers);
  return obj2;
}
function proxy2(obj2) {
  return Object.assign(obj2, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    pendingListeners.set(id, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// ../../node_modules/@cornerstonejs/core/dist/esm/requestPool/requestPoolManager.js
class RequestPoolManager {
  constructor(id) {
    this.numRequests = {
      [RequestType_default.Interaction]: 0,
      [RequestType_default.Thumbnail]: 0,
      [RequestType_default.Prefetch]: 0,
      [RequestType_default.Compute]: 0
    };
    this.id = id ? id : uuidv4();
    this.requestPool = {
      [RequestType_default.Interaction]: { 0: [] },
      [RequestType_default.Thumbnail]: { 0: [] },
      [RequestType_default.Prefetch]: { 0: [] },
      [RequestType_default.Compute]: { 0: [] }
    };
    this.grabDelay = 5;
    this.awake = false;
    this.numRequests = {
      [RequestType_default.Interaction]: 0,
      [RequestType_default.Thumbnail]: 0,
      [RequestType_default.Prefetch]: 0,
      [RequestType_default.Compute]: 0
    };
    this.maxNumRequests = {
      [RequestType_default.Interaction]: 6,
      [RequestType_default.Thumbnail]: 6,
      [RequestType_default.Prefetch]: 5,
      [RequestType_default.Compute]: 1000
    };
  }
  setMaxSimultaneousRequests(type, maxNumRequests) {
    this.maxNumRequests[type] = maxNumRequests;
  }
  getMaxSimultaneousRequests(type) {
    return this.maxNumRequests[type];
  }
  destroy() {
    if (this.timeoutHandle) {
      window.clearTimeout(this.timeoutHandle);
    }
  }
  addRequest(requestFn, type, additionalDetails, priority = 0) {
    const requestDetails = {
      requestFn,
      type,
      additionalDetails
    };
    if (this.requestPool[type][priority] === undefined) {
      this.requestPool[type][priority] = [];
    }
    this.requestPool[type][priority].push(requestDetails);
    this.startGrabbing();
  }
  filterRequests(filterFunction) {
    Object.keys(this.requestPool).forEach((type) => {
      const requestType = this.requestPool[type];
      Object.keys(requestType).forEach((priority) => {
        requestType[priority] = requestType[priority].filter((requestDetails) => {
          return filterFunction(requestDetails);
        });
      });
    });
  }
  clearRequestStack(type) {
    if (!this.requestPool[type]) {
      throw new Error(`No category for the type ${type} found`);
    }
    this.requestPool[type] = { 0: [] };
  }
  sendRequests(type) {
    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];
    let syncImageCount = 0;
    for (let i = 0;i < requestsToSend; i++) {
      const requestDetails = this.getNextRequest(type);
      if (requestDetails === null) {
        return false;
      } else if (requestDetails) {
        this.numRequests[type]++;
        this.awake = true;
        let requestResult;
        try {
          requestResult = requestDetails.requestFn();
        } catch (e) {
          console.warn("sendRequest failed", e);
        }
        if (requestResult?.finally) {
          requestResult.finally(() => {
            this.numRequests[type]--;
            this.startAgain();
          });
        } else {
          this.numRequests[type]--;
          syncImageCount++;
        }
      }
    }
    if (syncImageCount) {
      this.startAgain();
    }
    return true;
  }
  getNextRequest(type) {
    const interactionPriorities = this.getSortedPriorityGroups(type);
    for (const priority of interactionPriorities) {
      if (this.requestPool[type][priority].length) {
        return this.requestPool[type][priority].shift();
      }
    }
    return null;
  }
  startGrabbing() {
    const hasRemainingInteractionRequests = this.sendRequests(RequestType_default.Interaction);
    const hasRemainingThumbnailRequests = this.sendRequests(RequestType_default.Thumbnail);
    const hasRemainingPrefetchRequests = this.sendRequests(RequestType_default.Prefetch);
    const hasRemainingComputeRequests = this.sendRequests(RequestType_default.Compute);
    if (!hasRemainingInteractionRequests && !hasRemainingThumbnailRequests && !hasRemainingPrefetchRequests && !hasRemainingComputeRequests) {
      this.awake = false;
    }
  }
  startAgain() {
    if (!this.awake) {
      return;
    }
    if (this.grabDelay !== undefined) {
      if (!this.timeoutHandle) {
        this.timeoutHandle = window.setTimeout(() => {
          this.timeoutHandle = null;
          this.startGrabbing();
        }, this.grabDelay);
      }
    } else {
      this.startGrabbing();
    }
  }
  getSortedPriorityGroups(type) {
    const priorities = Object.keys(this.requestPool[type]).map(Number).filter((priority) => this.requestPool[type][priority].length).sort((a, b) => a - b);
    return priorities;
  }
  getRequestPool() {
    return this.requestPool;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/webWorkerManager/webWorkerManager.js
class CentralizedWorkerManager {
  constructor() {
    this.workerRegistry = {};
    this.workerPoolManager = new RequestPoolManager("webworker");
  }
  registerWorker(workerName, workerFn, options = {}) {
    const { maxWorkerInstances = 1, overwrite = false, autoTerminateOnIdle = {
      enabled: false,
      idleTimeThreshold: 3000
    } } = options;
    if (this.workerRegistry[workerName] && !overwrite) {
      console.warn(`Worker type '${workerName}' is already registered...`);
      return;
    }
    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {
      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);
    }
    const workerProperties = {
      workerFn: null,
      instances: [],
      loadCounters: [],
      lastActiveTime: [],
      nativeWorkers: [],
      autoTerminateOnIdle: autoTerminateOnIdle.enabled,
      idleCheckIntervalId: null,
      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold
    };
    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);
    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);
    for (let i = 0;i < maxWorkerInstances; i++) {
      const worker = workerFn();
      workerProperties.instances.push(wrap(worker));
      workerProperties.nativeWorkers.push(worker);
      workerProperties.workerFn = workerFn;
    }
    this.workerRegistry[workerName] = workerProperties;
  }
  getNextWorkerAPI(workerName) {
    const workerProperties = this.workerRegistry[workerName];
    if (!workerProperties) {
      console.error(`Worker type '${workerName}' is not registered.`);
      return null;
    }
    const workerInstances = workerProperties.instances.filter((instance) => instance !== null);
    let minLoadIndex = 0;
    let minLoadValue = workerProperties.loadCounters[0] || 0;
    for (let i = 1;i < workerInstances.length; i++) {
      const currentLoadValue = workerProperties.loadCounters[i] || 0;
      if (currentLoadValue < minLoadValue) {
        minLoadIndex = i;
        minLoadValue = currentLoadValue;
      }
    }
    if (workerProperties.instances[minLoadIndex] === null) {
      const worker = workerProperties.workerFn();
      workerProperties.instances[minLoadIndex] = wrap(worker);
      workerProperties.nativeWorkers[minLoadIndex] = worker;
    }
    workerProperties.loadCounters[minLoadIndex] += 1;
    return {
      api: workerProperties.instances[minLoadIndex],
      index: minLoadIndex
    };
  }
  executeTask(workerName, methodName, args = {}, { requestType = RequestType_default.Compute, priority = 0, options = {}, callbacks = [] } = {}) {
    return new Promise((resolve, reject) => {
      const requestFn = async () => {
        const { api, index: index2 } = this.getNextWorkerAPI(workerName);
        if (!api) {
          const error = new Error(`No available worker instance for '${workerName}'`);
          console.error(error);
          reject(error);
          return;
        }
        try {
          let finalCallbacks = [];
          if (callbacks.length) {
            finalCallbacks = callbacks.map((cb) => {
              return proxy2(cb);
            });
          }
          const workerProperties = this.workerRegistry[workerName];
          workerProperties.processing = true;
          const results = await api[methodName](args, ...finalCallbacks);
          workerProperties.processing = false;
          workerProperties.lastActiveTime[index2] = Date.now();
          if (workerProperties.autoTerminateOnIdle && !workerProperties.idleCheckIntervalId && workerProperties.idleTimeThreshold) {
            workerProperties.idleCheckIntervalId = setInterval(() => {
              this.terminateIdleWorkers(workerName, workerProperties.idleTimeThreshold);
            }, workerProperties.idleTimeThreshold);
          }
          resolve(results);
        } catch (err) {
          console.error(`Error executing method '${methodName}' on worker '${workerName}':`, err);
          reject(err);
        } finally {
          this.workerRegistry[workerName].loadCounters[index2]--;
        }
      };
      this.workerPoolManager.addRequest(requestFn, requestType, options, priority);
    });
  }
  terminateIdleWorkers(workerName, idleTimeThreshold) {
    const workerProperties = this.workerRegistry[workerName];
    if (workerProperties.processing) {
      return;
    }
    const now = Date.now();
    workerProperties.instances.forEach((_, index2) => {
      const lastActiveTime = workerProperties.lastActiveTime[index2];
      const isWorkerActive = lastActiveTime !== null && workerProperties.loadCounters[index2] > 0;
      const idleTime = now - lastActiveTime;
      if (!isWorkerActive && idleTime > idleTimeThreshold) {
        this.terminateWorkerInstance(workerName, index2);
      }
    });
  }
  terminate(workerName) {
    const workerProperties = this.workerRegistry[workerName];
    if (!workerProperties) {
      console.error(`Worker type '${workerName}' is not registered.`);
      return;
    }
    workerProperties.instances.forEach((_, index2) => {
      this.terminateWorkerInstance(workerName, index2);
    });
  }
  terminateWorkerInstance(workerName, index2) {
    const workerProperties = this.workerRegistry[workerName];
    const workerInstance = workerProperties.instances[index2];
    if (workerInstance !== null) {
      workerInstance[releaseProxy]();
      workerProperties.nativeWorkers[index2].terminate();
      workerProperties.instances[index2] = null;
      workerProperties.lastActiveTime[index2] = null;
    }
  }
}
var webWorkerManager_default = CentralizedWorkerManager;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/textureSupport.js
var canvasSize = 4;
var texWidth = 5;
var texHeight = 1;
var pixelToCheck = [1, 1];
function main({ ext, filterType, texData, internalFormat, glDataType }) {
  try {
    const canvas = document.createElement("canvas");
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const gl = canvas.getContext("webgl2");
    if (!gl) {
      return false;
    }
    const vs2 = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
    const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
    let extToUse;
    if (ext) {
      extToUse = gl.getExtension(ext);
      if (!extToUse) {
        return false;
      }
    }
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vs2);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      return false;
    }
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat(gl, extToUse), texWidth, texHeight, 0, gl.RED, glDataType(gl, extToUse), texData);
    const filter = filterType === "LINEAR" ? gl.LINEAR : gl.NEAREST;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.useProgram(program);
    gl.drawArrays(gl.POINTS, 0, 1);
    const pixel = new Uint8Array(4);
    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    const [r, g, b] = pixel;
    const webglLoseContext = gl.getExtension("WEBGL_lose_context");
    if (webglLoseContext) {
      webglLoseContext.loseContext();
    }
    return r === g && g === b && r !== 0;
  } catch (e) {
    return false;
  }
}
function getSupportedTextureFormats() {
  const norm16TexData = new Int16Array([
    32767,
    2000,
    3000,
    4000,
    5000,
    16784,
    7000,
    8000,
    9000,
    32767
  ]);
  return {
    norm16: main({
      ext: "EXT_texture_norm16",
      filterType: "NEAREST",
      texData: norm16TexData,
      internalFormat: (gl, ext) => ext.R16_SNORM_EXT,
      glDataType: (gl) => gl.SHORT
    }),
    norm16Linear: main({
      ext: "EXT_texture_norm16",
      filterType: "LINEAR",
      texData: norm16TexData,
      internalFormat: (gl, ext) => ext.R16_SNORM_EXT,
      glDataType: (gl) => gl.SHORT
    })
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/init.js
var csRenderInitialized = false;
var defaultConfig = {
  gpuTier: { tier: 2 },
  isMobile: false,
  rendering: {
    useCPURendering: false,
    preferSizeOverAccuracy: false,
    strictZSpacingForVolumeViewport: true
  },
  peerImport: (moduleId) => null
};
var config = {
  ...defaultConfig,
  rendering: { ...defaultConfig.rendering }
};
var webWorkerManager = null;
var canUseNorm16Texture = false;
function _getGLContext() {
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2") || canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  return gl;
}
function _hasActiveWebGLContext() {
  const gl = _getGLContext();
  return gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext;
}
function _hasNorm16TextureSupport() {
  const supportedTextureFormats = getSupportedTextureFormats();
  return supportedTextureFormats.norm16 && supportedTextureFormats.norm16Linear;
}
function isIOS() {
  if (/iPad|iPhone|iPod/.test(navigator.platform)) {
    return true;
  } else {
    return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && navigator.platform.includes("MacIntel");
  }
}
function init(configuration = config) {
  if (csRenderInitialized) {
    return csRenderInitialized;
  }
  canUseNorm16Texture = _hasNorm16TextureSupport();
  config = deepMerge_default(defaultConfig, configuration);
  if (isIOS()) {
    if (configuration.rendering?.preferSizeOverAccuracy) {
      config.rendering.preferSizeOverAccuracy = true;
    } else {
      console.log("norm16 texture not supported, you can turn on the preferSizeOverAccuracy flag to use native data type, but be aware of the inaccuracy of the rendering in high bits");
    }
  }
  const hasWebGLContext = _hasActiveWebGLContext();
  if (!hasWebGLContext) {
    console.log("CornerstoneRender: GPU not detected, using CPU rendering");
    config.rendering.useCPURendering = true;
  } else {
    console.log("CornerstoneRender: using GPU rendering");
  }
  csRenderInitialized = true;
  if (!webWorkerManager) {
    webWorkerManager = new webWorkerManager_default;
  }
  return csRenderInitialized;
}
function getCanUseNorm16Texture() {
  return canUseNorm16Texture;
}
function setUseCPURendering(status, updateViewports = true) {
  config.rendering.useCPURendering = status;
  csRenderInitialized = true;
  if (updateViewports) {
    _updateRenderingPipelinesForAllViewports();
  }
}
function setPreferSizeOverAccuracy(status) {
  config.rendering.preferSizeOverAccuracy = status;
  csRenderInitialized = true;
  _updateRenderingPipelinesForAllViewports();
}
function canRenderFloatTextures() {
  if (!isIOS()) {
    return true;
  }
  return false;
}
function resetUseCPURendering() {
  config.rendering.useCPURendering = !_hasActiveWebGLContext();
  _updateRenderingPipelinesForAllViewports();
}
function getShouldUseCPURendering() {
  return config.rendering.useCPURendering;
}
function isCornerstoneInitialized() {
  return csRenderInitialized;
}
function resetInitialization() {
  csRenderInitialized = false;
}
function getConfiguration() {
  return config;
}
function setConfiguration(c) {
  config = c;
  _updateRenderingPipelinesForAllViewports();
}
function _updateRenderingPipelinesForAllViewports() {
  getRenderingEngines().forEach((engine) => {
    engine.getViewports().forEach((viewport) => {
      viewport.updateRenderingPipeline();
    });
  });
}
function getWebWorkerManager() {
  if (!webWorkerManager) {
    webWorkerManager = new webWorkerManager_default;
  }
  return webWorkerManager;
}
async function peerImport(moduleId) {
  return config.peerImport(moduleId);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLVolumeMapper.js
function vtkStreamingOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkStreamingOpenGLVolumeMapper");
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i = 0;i < 32 * 32; ++i) {
        oTable[i] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
    }
    const { numberOfComponents: numIComps } = image.get("numberOfComponents");
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    const scalarOpacityFunc = vprop.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
    let toString = getTransferFunctionHash(scalarOpacityFunc, useIndependentComps, numIComps);
    const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
    if (reBuildOp) {
      model.opacityTexture = vtkOpenGLTexture$1.newInstance();
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c = 0;c < numIComps; ++c) {
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (let i = 0;i < oWidth; ++i) {
          ofTable[c * oWidth * 2 + i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
        }
      }
      model.opacityTexture.resetFormatAndType();
      model.opacityTexture.setMinificationFilter(Filter.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() && model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i = 0;i < oSize; ++i) {
          oTable[i] = 255 * ofTable[i];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
      }
      if (scalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
        if (scalarOpacityFunc !== model._scalarOpacityFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
        }
        model._scalarOpacityFunc = scalarOpacityFunc;
      }
    } else {
      model.opacityTexture = opTex.oglObject;
    }
    const colorTransferFunc = vprop.getRGBTransferFunction();
    toString = getTransferFunctionHash(colorTransferFunc, useIndependentComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      model.colorTexture = vtkOpenGLTexture$1.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c = 0;c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0;i < cWidth * 3; ++i) {
          cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
          cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
        }
      }
      model.colorTexture.resetFormatAndType();
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    publicAPI.updateLabelOutlineThicknessTexture(actor);
    toString = `${image.getMTime()}-${model.scalarTexture.getMTime()}`;
    if (model.scalarTextureString !== toString) {
      const dims = image.getDimensions();
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.scalarTexture.enableUseHalfFloat(false);
      const previousTextureParameters = model.scalarTexture.getTextureParameters();
      const dataType = image.get("dataType").dataType;
      let shouldReset = true;
      if (previousTextureParameters?.dataType === dataType) {
        if (previousTextureParameters?.width === dims[0]) {
          if (previousTextureParameters?.height === dims[1]) {
            if (previousTextureParameters?.depth === dims[2]) {
              shouldReset = false;
            }
          }
        }
      }
      if (shouldReset) {
        const norm16Ext = model.context.getExtension("EXT_texture_norm16");
        model.scalarTexture.setOglNorm16Ext(getCanUseNorm16Texture() ? norm16Ext : null);
        model.scalarTexture.resetFormatAndType();
        model.scalarTexture.setTextureParameters({
          width: dims[0],
          height: dims[1],
          depth: dims[2],
          numberOfComponents: numIComps,
          dataType
        });
        model.scalarTexture.create3DFromRaw(dims[0], dims[1], dims[2], numIComps, dataType, null);
        model.scalarTexture.update3DFromRaw();
      } else {
        model.scalarTexture.deactivate();
        model.scalarTexture.update3DFromRaw();
      }
      model.scalarTextureString = toString;
    }
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0;i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = -1;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.scalarTexture?.getMTime() || model.VBOBuildTime.getMTime() < model.colorTexture?.getMTime() || model.VBOBuildTime.getMTime() < model.labelOutlineThicknessTexture?.getMTime() || !model.scalarTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle()) {
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES51 = {};
function extend52(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES51, initialValues);
  vtkVolumeMapper.extend(publicAPI, model, initialValues);
  model.scalarTexture = initialValues.scalarTexture;
  model.previousState = {};
  vtkStreamingOpenGLVolumeMapper(publicAPI, model);
}
var newInstance52 = macro.newInstance(extend52, "vtkStreamingOpenGLVolumeMapper");
var vtkStreamingOpenGLVolumeMapper_default = { newInstance: newInstance52, extend: extend52 };

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLViewNodeFactory.js
var CLASS_MAPPING2 = Object.create(null);
function registerOverride2(className, fn) {
  CLASS_MAPPING2[className] = fn;
}
function vtkStreamingOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkStreamingOpenGLViewNodeFactory");
  publicAPI.createNode = (dataObject) => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject2 = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject2) {
      if (keys.includes(className)) {
        isObject2 = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject2) {
      return null;
    }
    const initialValues = model.getModelInitialValues(dataObject);
    const vn = model.overrides[className](initialValues);
    vn.setMyFactory(publicAPI);
    return vn;
  };
  model.overrides = CLASS_MAPPING2;
  model.getModelInitialValues = (dataObject) => {
    const initialValues = {};
    const className = dataObject.getClassName();
    if (className === "vtkSharedVolumeMapper") {
      initialValues.scalarTexture = dataObject.getScalarTexture();
    }
    return initialValues;
  };
}
var DEFAULT_VALUES52 = {};
function extend53(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES52, initialValues);
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkStreamingOpenGLViewNodeFactory(publicAPI, model);
  registerOverride2("vtkActor", vtkActor.newInstance);
  registerOverride2("vtkActor2D", vtkActor2D.newInstance);
  registerOverride2("vtkCamera", vtkCamera.newInstance);
  registerOverride2("vtkGlyph3DMapper", vtkGlyph3DMapper.newInstance);
  registerOverride2("vtkImageMapper", vtkImageMapper.newInstance);
  registerOverride2("vtkImageCPRMapper", index.newInstance);
  registerOverride2("vtkImageSlice", vtkImageSlice.newInstance);
  registerOverride2("vtkMapper", vtkOpenGLPolyDataMapper$1.newInstance);
  registerOverride2("vtkPixelSpaceCallbackMapper", vtkPixelSpaceCallbackMapper.newInstance);
  registerOverride2("vtkRenderer", vtkRenderer.newInstance);
  registerOverride2("vtkSkybox", vtkSkybox.newInstance);
  registerOverride2("vtkSphereMapper", vtkSphereMapper.newInstance);
  registerOverride2("vtkStickMapper", vtkStickMapper.newInstance);
  registerOverride2("vtkTexture", vtkOpenGLTexture$1.newInstance);
  registerOverride2("vtkVolume", vtkVolume.newInstance);
  registerOverride2("vtkVolumeMapper", vtkVolumeMapper.newInstance);
  registerOverride2("vtkSharedVolumeMapper", vtkStreamingOpenGLVolumeMapper_default.newInstance);
}
var newInstance53 = macro.newInstance(extend53, "vtkStreamingOpenGLViewNodeFactory");
var vtkStreamingOpenGLViewNodeFactory_default = { newInstance: newInstance53, extend: extend53 };

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLRenderWindow.js
function vtkStreamingOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkStreamingOpenGLRenderWindow");
}
function extend54(publicAPI, model, initialValues = {}) {
  Object.assign(model, initialValues);
  vtkRenderWindow2.extend(publicAPI, model, initialValues);
  model.myFactory = vtkStreamingOpenGLViewNodeFactory_default.newInstance();
  registerOverride2("vtkRenderWindow", newInstance54);
  vtkStreamingOpenGLRenderWindow(publicAPI, model);
}
var newInstance54 = macro.newInstance(extend54, "vtkStreamingOpenGLRenderWindow");
var vtkStreamingOpenGLRenderWindow_default = { newInstance: newInstance54, extend: extend54 };

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var {
  vtkDebugMacro: vtkDebugMacro6
} = macro;
function vtkCamera2(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  const origin = new Float64Array(3);
  const dopbasis = new Float64Array([0, 0, -1]);
  const upbasis = new Float64Array([0, 1, 0]);
  const tmpMatrix = exports_mat4.identity(new Float64Array(16));
  const tmpMatrix2 = exports_mat4.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  const tmpvec2 = new Float64Array(3);
  const tmpvec3 = new Float64Array(3);
  const rotateMatrix = exports_mat4.identity(new Float64Array(16));
  const trans = exports_mat4.identity(new Float64Array(16));
  const newPosition = new Float64Array(3);
  const newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = (x, y, z) => {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = (x, y, z) => {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = (d) => {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 0.00000000000000000001) {
      model.distance = 0.00000000000000000001;
      vtkDebugMacro6("Distance is set to minimum.");
    }
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy2 = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy2 * dy2 + dz * dz);
    if (model.distance < 0.00000000000000000001) {
      model.distance = 0.00000000000000000001;
      vtkDebugMacro6("Distance is set to minimum.");
      const vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy2 / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = (amount) => {
    if (amount <= 0) {
      return;
    }
    const d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = (angle3) => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    exports_mat4.identity(rotateMatrix);
    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    exports_mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle3), viewDir);
    exports_vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = (angle3) => {
    const fp = model.focalPoint;
    exports_mat4.identity(trans);
    exports_mat4.translate(trans, trans, fp);
    exports_mat4.rotate(trans, trans, radiansFromDegrees(angle3), model.viewUp);
    exports_mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    exports_vec3.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = (angle3) => {
    const position = model.position;
    exports_mat4.identity(trans);
    exports_mat4.translate(trans, trans, position);
    exports_mat4.rotate(trans, trans, radiansFromDegrees(angle3), model.viewUp);
    exports_mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    exports_vec3.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = (angle3) => {
    const fp = model.focalPoint;
    const vt = publicAPI.getViewMatrix();
    const axis = [-vt[0], -vt[1], -vt[2]];
    exports_mat4.identity(trans);
    exports_mat4.translate(trans, trans, fp);
    exports_mat4.rotate(trans, trans, radiansFromDegrees(angle3), axis);
    exports_mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    exports_vec3.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = (angle3) => {
    const position = model.position;
    const vt = publicAPI.getViewMatrix();
    const axis = [vt[0], vt[1], vt[2]];
    exports_mat4.identity(trans);
    exports_mat4.translate(trans, trans, position);
    exports_mat4.rotate(trans, trans, radiansFromDegrees(angle3), axis);
    exports_mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    exports_vec3.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(...newFocalPoint);
  };
  publicAPI.zoom = (factor) => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = (x, y, z) => {
    const offset = [x, y, z];
    add(model.position, offset, model.position);
    add(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = (transformMat44) => {
    const vuOld = [...model.viewUp, 1];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    exports_vec4.transformMat4(posNew, [...model.position, 1], transformMat44);
    exports_vec4.transformMat4(fpNew, [...model.focalPoint, 1], transformMat44);
    exports_vec4.transformMat4(vuNew, vuOld, transformMat44);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };
  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
  publicAPI.setThickness = (thickness) => {
    let t = thickness;
    if (t < 0.00000000000000000001) {
      t = 0.00000000000000000001;
      vtkDebugMacro6("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = (thickness) => {
    let t = thickness;
    if (t < 0.00000000000000000001) {
      t = 0.00000000000000000001;
      vtkDebugMacro6("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };
  publicAPI.setRoll = (angle3) => {
  };
  publicAPI.getRoll = () => {
  };
  publicAPI.setObliqueAngles = (alpha, beta) => {
  };
  publicAPI.getOrientation = () => {
  };
  publicAPI.getOrientationWXYZ = () => {
  };
  publicAPI.getFrustumPlanes = (aspect) => {
  };
  publicAPI.getCameraLightTransformMatrix = (matrix) => {
    exports_mat4.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = () => {
    exports_mat4.copy(tmpMatrix, publicAPI.getViewMatrix());
    exports_mat4.invert(tmpMatrix, tmpMatrix);
    exports_mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    exports_mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    exports_mat4.identity(model.cameraLightTransform);
    exports_mat4.translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
  };
  publicAPI.deepCopy = (sourceCamera) => {
  };
  publicAPI.physicalOrientationToWorldDirection = (ori) => {
    const oriq = exports_quat.fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = exports_quat.create();
    const qdir = exports_quat.fromValues(0, 0, 1, 0);
    exports_quat.conjugate(coriq, oriq);
    exports_quat.multiply(qdir, oriq, qdir);
    exports_quat.multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = (result) => {
    publicAPI.getWorldToPhysicalMatrix(result);
    exports_mat4.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = (result) => {
    exports_mat4.identity(result);
    const physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    exports_mat4.transpose(result, result);
    exports_vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    exports_mat4.scale(result, result, tmpvec1);
    exports_mat4.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = (vmat) => {
    exports_mat4.invert(tmpMatrix, vmat);
    exports_vec3.transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
    exports_vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    exports_vec3.subtract(tmpvec2, tmpvec2, tmpvec1);
    exports_vec3.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    exports_vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);
    exports_vec3.subtract(tmpvec3, tmpvec3, tmpvec1);
    exports_vec3.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    exports_mat4.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = (mat) => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      exports_mat4.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      exports_mat4.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    exports_mat4.lookAt(tmpMatrix, model.position, model.focalPoint, model.viewUp);
    exports_mat4.transpose(tmpMatrix, tmpMatrix);
    const result = new Float64Array(16);
    exports_mat4.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = (mat) => {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = new Float64Array(16);
    exports_mat4.identity(result);
    if (model.projectionMatrix) {
      const scale8 = 1 / model.physicalScale;
      exports_vec3.set(tmpvec1, scale8, scale8, scale8);
      exports_mat4.copy(result, model.projectionMatrix);
      exports_mat4.scale(result, result, tmpvec1);
      exports_mat4.transpose(result, result);
      return result;
    }
    exports_mat4.identity(tmpMatrix);
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      exports_mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      exports_mat4.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = model.clippingRange[0] * tmp / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (xmax - xmin);
      tmpMatrix[5] = 2 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    exports_mat4.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    exports_mat4.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = (x, y, z) => {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    const vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    const rotmat = exports_mat4.identity(new Float64Array(16));
    exports_mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    exports_mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    exports_mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    exports_mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    const vup = new Float64Array(model.physicalViewNorth);
    exports_vec3.transformMat4(dop, dop, rotmat);
    exports_vec3.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
    const quatMat = exports_mat4.identity(new Float64Array(16));
    if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
      const angle3 = radiansFromDegrees(degrees);
      const q = exports_quat.create();
      exports_quat.setAxisAngle(q, [x, y, z], angle3);
      exports_mat4.fromQuat(quatMat, q);
    }
    const newdop = new Float64Array(3);
    exports_vec3.transformMat4(newdop, [0, 0, -1], quatMat);
    const newvup = new Float64Array(3);
    exports_vec3.transformMat4(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = (bounds) => {
    let vn = null;
    let position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    const a = -vn[0];
    const b = -vn[1];
    const c = -vn[2];
    const d = -(a * position[0] + b * position[1] + c * position[2]);
    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 0.000000000000000001];
    for (let k = 0;k < 2; k++) {
      for (let j = 0;j < 2; j++) {
        for (let i = 0;i < 2; i++) {
          const dist4 = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist4 < range[0] ? dist4 : range[0];
          range[1] = dist4 > range[1] ? dist4 : range[1];
        }
      }
    }
    return range;
  };
}
var DEFAULT_VALUES53 = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: exports_mat4.create(),
  physicalTranslation: [0, 0, 0],
  physicalScale: 1,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};
function extend55(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES53, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera2(publicAPI, model);
}
var newInstance55 = macro.newInstance(extend55, "vtkCamera");
var vtkCamera$1 = {
  newInstance: newInstance55,
  extend: extend55
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Light.js
var LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
function vtkLight(publicAPI, model) {
  model.classHierarchy.push("vtkLight");
  const tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      exports_vec3.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      exports_vec3.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      exports_vec3.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      exports_vec3.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      exports_vec3.sub(model.direction, model.focalPoint, model.position);
      normalize(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };
  publicAPI.setDirection = (directionVector) => {
    const newFocalPoint = new Float64Array(3);
    exports_vec3.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = radiansFromDegrees(elevation);
    const azimuthRadians = radiansFromDegrees(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType("HeadLight");
  };
  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType("CameraLight");
  };
  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType("SceneLight");
  };
  publicAPI.lightTypeIsHeadLight = () => model.lightType === "HeadLight";
  publicAPI.lightTypeIsSceneLight = () => model.lightType === "SceneLight";
  publicAPI.lightTypeIsCameraLight = () => model.lightType === "CameraLight";
}
var DEFAULT_VALUES54 = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: "SceneLight",
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};
function extend56(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES54, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "coneFalloff", "transformMatrix", "lightType", "shadowAttenuation", "attenuationValues"]);
  macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
  vtkLight(publicAPI, model);
}
var newInstance56 = macro.newInstance(extend56, "vtkLight");
var vtkLight$1 = {
  newInstance: newInstance56,
  extend: extend56,
  LIGHT_TYPES
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
var {
  vtkErrorMacro: vtkErrorMacro25
} = macro;
function notImplemented5(method) {
  return () => vtkErrorMacro25(`vtkViewport::${method} - NOT IMPLEMENTED`);
}
function vtkViewport(publicAPI, model) {
  model.classHierarchy.push("vtkViewport");
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = (prop) => model.props.includes(prop);
  publicAPI.addViewProp = (prop) => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props.push(prop);
    }
  };
  publicAPI.removeViewProp = (prop) => {
    const newPropList = model.props.filter((item) => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };
  function gatherProps(prop) {
    let allProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i = 0;i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = () => {
    const allPropsArray = [];
    for (let i = 0;i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = (prop) => {
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach((prop) => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = () => vtkErrorMacro25("call displayToView on your view instead");
  publicAPI.viewToDisplay = () => vtkErrorMacro25("callviewtodisplay on your view instead");
  publicAPI.getSize = () => vtkErrorMacro25("call getSize on your View instead");
  publicAPI.normalizedDisplayToProjection = (x, y, z) => {
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
    const scale8 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale8[0], (y - model.viewport[1]) / scale8[1], z];
  };
  publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2 - 1, y * 2 - 1, z * 2 - 1];
  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
    const scale8 = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale8[0] + model.viewport[0], y * scale8[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1) * 0.5, (y + 1) * 0.5, (z + 1) * 0.5];
  publicAPI.PickPropFrom = notImplemented5("PickPropFrom");
}
var DEFAULT_VALUES55 = {
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};
function extend57(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES55, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.setGetArray(publicAPI, model, ["viewport"], 4);
  macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
  vtkViewport(publicAPI, model);
}
var newInstance57 = macro.newInstance(extend57, "vtkViewport");
var vtkViewport$1 = {
  newInstance: newInstance57,
  extend: extend57
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro7,
  vtkErrorMacro: vtkErrorMacro26,
  vtkWarningMacro: vtkWarningMacro7
} = macro$1;
function notImplemented6(method) {
  return () => vtkErrorMacro26(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}
function vtkRenderer2(publicAPI, model) {
  model.classHierarchy.push("vtkRenderer");
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: "ComputeVisiblePropBoundsEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: "ResetCameraClippingRangeEvent",
    renderer: publicAPI
  };
  const RESET_CAMERA_EVENT = {
    type: "ResetCameraEvent",
    renderer: publicAPI
  };
  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro7("No cameras are on, creating one.");
      publicAPI.getActiveCameraAndResetIfCreated();
    }
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = () => {
    const camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach((light) => {
      if (light.lightTypeIsSceneLight())
        ;
      else if (light.lightTypeIsHeadLight()) {
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(exports_mat4.create()));
      } else {
        vtkErrorMacro26("light has unknown light type", light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = notImplemented6("allocateTime");
  publicAPI.updateGeometry = notImplemented6("updateGeometry");
  publicAPI.getVTKWindow = () => model._renderWindow;
  publicAPI.setLayer = (layer) => {
    vtkDebugMacro7(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = (camera) => {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: "ActiveCameraEvent",
      camera
    });
    return true;
  };
  publicAPI.makeCamera = () => {
    const camera = vtkCamera$1.newInstance();
    publicAPI.invokeEvent({
      type: "CreateCameraEvent",
      camera
    });
    return camera;
  };
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach((prop) => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = (actor) => {
    model.actors = model.actors.filter((a) => a !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    const actors = publicAPI.getActors();
    actors.forEach((actor) => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach((prop) => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = (volume) => {
    model.volumes = model.volumes.filter((v) => v !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    const volumes = publicAPI.getVolumes();
    volumes.forEach((volume) => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.hasLight = (light) => model.lights.includes(light);
  publicAPI.addLight = (light) => {
    if (light && !publicAPI.hasLight(light)) {
      model.lights.push(light);
      publicAPI.modified();
    }
  };
  publicAPI.removeLight = (light) => {
    model.lights = model.lights.filter((l) => l !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = (lights) => {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };
  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
    let vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.viewToWorld = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    exports_mat4.invert(matrix, matrix);
    exports_mat4.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    exports_vec3.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    exports_mat4.invert(matrix, matrix);
    exports_mat4.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    exports_vec3.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.worldToView = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getViewMatrix();
    exports_mat4.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    exports_vec3.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.viewToProjection = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro26("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
      return [0, 0, 0];
    }
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    exports_mat4.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    exports_vec3.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
    let nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
    for (let index2 = 0;index2 < model.props.length; ++index2) {
      const prop = model.props[index2];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && areBoundsInitialized(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      uninitializeBounds(model.allBounds);
      vtkDebugMacro7("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function() {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro7("Cannot reset camera!");
      return false;
    }
    let vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro26("Trying to reset non-existent camera");
      return false;
    }
    model.activeCamera.setViewAngle(30);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    const angle3 = radiansFromDegrees(model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance4 = radius / Math.sin(angle3 * 0.5);
    const vup = model.activeCamera.getViewUp();
    if (Math.abs(dot(vup, vn)) > 0.999) {
      vtkWarningMacro7("Resetting view-up since view plane normal is parallel");
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance4 * vn[0], center[1] + distance4 * vn[1], center[2] + distance4 * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);
    model.activeCamera.setParallelScale(parallelScale);
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function() {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro7("Cannot reset camera clipping range!");
      return false;
    }
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro26("Trying to reset clipping range of non-existent camera");
      return false;
    }
    const range = model.activeCamera.computeClippingRange(boundsToUse);
    let minGap = 0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      const angle3 = radiansFromDegrees(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle3 / 2) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2;
      range[0] -= minGap / 2;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = (renderWindow) => {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = () => model.props.filter((prop) => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    const m32 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m32 > m1) {
      m1 = m32;
    }
    return m1;
  };
  publicAPI.getTransparent = () => !!model.preserveColorBuffer;
  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}
var DEFAULT_VALUES56 = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: createUninitializedBounds(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};
function extend58(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES56, initialValues);
  vtkViewport$1.extend(publicAPI, model, initialValues);
  if (!model.background)
    model.background = [0, 0, 0, 1];
  while (model.background.length < 3)
    model.background.push(0);
  if (model.background.length === 3)
    model.background.push(1);
  get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
  setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "environmentTexture", "environmentTextureDiffuseStrength", "environmentTextureSpecularStrength", "useEnvironmentTextureAsBackground", "useShadows", "pass"]);
  getArray(publicAPI, model, ["actors", "volumes", "lights"]);
  setGetArray(publicAPI, model, ["background"], 4, 1);
  moveToProtected(publicAPI, model, ["renderWindow"]);
  vtkRenderer2(publicAPI, model);
}
var newInstance58 = newInstance(extend58, "vtkRenderer");
var vtkRenderer$1 = {
  newInstance: newInstance58,
  extend: extend58
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
var Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2
};
var Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  Thumbstick: 4,
  A: 5,
  B: 6,
  ApplicationMenu: 7
};
var Axis = {
  Unknown: 0,
  TouchpadX: 1,
  TouchpadY: 2,
  ThumbstickX: 3,
  ThumbstickY: 4
};
var Constants15 = {
  Device,
  Input,
  Axis
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js
var {
  Device: Device2,
  Input: Input2
} = Constants15;
var {
  vtkWarningMacro: vtkWarningMacro8,
  vtkErrorMacro: vtkErrorMacro27,
  normalizeWheel: normalizeWheel2,
  vtkOnceErrorMacro: vtkOnceErrorMacro2
} = macro;
var EMPTY_MOUSE_EVENT = {
  ctrlKey: false,
  altKey: false,
  shiftKey: false
};
var deviceInputMap = {
  "xr-standard": [Input2.Trigger, Input2.Grip, Input2.TrackPad, Input2.Thumbstick, Input2.A, Input2.B]
};
var handledEvents = ["StartAnimation", "Animation", "EndAnimation", "PointerEnter", "PointerLeave", "MouseEnter", "MouseLeave", "StartMouseMove", "MouseMove", "EndMouseMove", "LeftButtonPress", "LeftButtonRelease", "MiddleButtonPress", "MiddleButtonRelease", "RightButtonPress", "RightButtonRelease", "KeyPress", "KeyDown", "KeyUp", "StartMouseWheel", "MouseWheel", "EndMouseWheel", "StartPinch", "Pinch", "EndPinch", "StartPan", "Pan", "EndPan", "StartRotate", "Rotate", "EndRotate", "Button3D", "Move3D", "StartPointerLock", "EndPointerLock", "StartInteraction", "Interaction", "EndInteraction", "AnimationFrameRateUpdate"];
function preventDefault(event2) {
  if (event2.cancelable) {
    event2.preventDefault();
  }
}
function pointerCacheToPositions(cache2) {
  const positions = Object.create(null);
  cache2.forEach((_ref) => {
    let {
      pointerId,
      position
    } = _ref;
    positions[pointerId] = position;
  });
  return positions;
}
function vtkRenderWindowInteractor(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowInteractor");
  const superClass = {
    ...publicAPI
  };
  const animationRequesters = new Set;
  const pointerCache = new Map;
  let wheelCoefficient = 1;
  publicAPI.start = () => {
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    publicAPI.startEventLoop();
  };
  publicAPI.setRenderWindow = (aren) => {
    vtkErrorMacro27("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
  };
  publicAPI.setInteractorStyle = (style) => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = () => publicAPI.setEnabled(true);
  publicAPI.disable = () => publicAPI.setEnabled(false);
  publicAPI.startEventLoop = () => vtkWarningMacro8("empty event loop");
  function updateCurrentRenderer(x, y) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x, y);
    }
  }
  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function _getScreenEventPositionFor(source) {
    const canvas = model._view.getCanvas();
    const bounds = canvas.getBoundingClientRect();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0
    };
    if (pointerCache.size <= 1 || !model.currentRenderer) {
      updateCurrentRenderer(position.x, position.y);
    }
    return position;
  }
  const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
  function getModifierKeysFor(event2) {
    return {
      controlKey: event2.ctrlKey,
      altKey: event2.altKey,
      shiftKey: event2.shiftKey
    };
  }
  function getKeysFor(event2) {
    const modifierKeys = getModifierKeysFor(event2);
    const keys = {
      key: event2.key,
      keyCode: event2.charCode,
      ...modifierKeys
    };
    return keys;
  }
  function getDeviceTypeFor(event2) {
    return event2.pointerType || "";
  }
  const _bindEvents = () => {
    if (model.container === null) {
      return;
    }
    const {
      container
    } = model;
    container.addEventListener("contextmenu", preventDefault);
    container.addEventListener("wheel", publicAPI.handleWheel);
    container.addEventListener("DOMMouseScroll", publicAPI.handleWheel);
    container.addEventListener("pointerenter", publicAPI.handlePointerEnter);
    container.addEventListener("pointerleave", publicAPI.handlePointerLeave);
    container.addEventListener("pointermove", publicAPI.handlePointerMove, {
      passive: false
    });
    container.addEventListener("pointerdown", publicAPI.handlePointerDown, {
      passive: false
    });
    container.addEventListener("pointerup", publicAPI.handlePointerUp);
    container.addEventListener("pointercancel", publicAPI.handlePointerCancel);
    document.addEventListener("keypress", publicAPI.handleKeyPress);
    document.addEventListener("keydown", publicAPI.handleKeyDown);
    document.addEventListener("keyup", publicAPI.handleKeyUp);
    document.addEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    container.style.touchAction = "none";
    container.style.userSelect = "none";
    container.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
  };
  publicAPI.bindEvents = (container) => {
    if (container === null) {
      return;
    }
    const res = superClass.setContainer(container);
    if (res) {
      _bindEvents();
    }
  };
  const _unbindEvents = () => {
    clearTimeout(model.moveTimeoutID);
    clearTimeout(model.wheelTimeoutID);
    model.moveTimeoutID = 0;
    model.wheelTimeoutID = 0;
    wheelCoefficient = 1;
    const {
      container
    } = model;
    if (container) {
      container.removeEventListener("contextmenu", preventDefault);
      container.removeEventListener("wheel", publicAPI.handleWheel);
      container.removeEventListener("DOMMouseScroll", publicAPI.handleWheel);
      container.removeEventListener("pointerenter", publicAPI.handlePointerEnter);
      container.removeEventListener("pointerleave", publicAPI.handlePointerLeave);
      container.removeEventListener("pointermove", publicAPI.handlePointerMove, {
        passive: false
      });
      container.removeEventListener("pointerdown", publicAPI.handlePointerDown, {
        passive: false
      });
      container.removeEventListener("pointerup", publicAPI.handlePointerUp);
      container.removeEventListener("pointercancel", publicAPI.handlePointerCancel);
    }
    document.removeEventListener("keypress", publicAPI.handleKeyPress);
    document.removeEventListener("keydown", publicAPI.handleKeyDown);
    document.removeEventListener("keyup", publicAPI.handleKeyUp);
    document.removeEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    pointerCache.clear();
  };
  publicAPI.unbindEvents = () => {
    _unbindEvents();
    superClass.setContainer(null);
  };
  publicAPI.handleKeyPress = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = (event2) => {
    const data = getKeysFor(event2);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handlePointerEnter = (event2) => {
    const callData = {
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    publicAPI.pointerEnterEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseEnterEvent(callData);
    }
  };
  publicAPI.handlePointerLeave = (event2) => {
    const callData = {
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    publicAPI.pointerLeaveEvent(callData);
    if (callData.deviceType === "mouse") {
      publicAPI.mouseLeaveEvent(callData);
    }
  };
  publicAPI.handlePointerDown = (event2) => {
    if (event2.button > 2 || publicAPI.isPointerLocked()) {
      return;
    }
    if (model.preventDefaultOnPointerDown) {
      preventDefault(event2);
    }
    if (event2.target.hasPointerCapture(event2.pointerId)) {
      event2.target.releasePointerCapture(event2.pointerId);
    }
    model.container.setPointerCapture(event2.pointerId);
    if (pointerCache.has(event2.pointerId)) {
      vtkWarningMacro8("[RenderWindowInteractor] duplicate pointerId detected");
    }
    pointerCache.set(event2.pointerId, {
      pointerId: event2.pointerId,
      position: getScreenEventPositionFor(event2)
    });
    switch (event2.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchStart(event2);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseDown(event2);
        break;
    }
  };
  publicAPI.handlePointerUp = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      if (model.preventDefaultOnPointerUp) {
        preventDefault(event2);
      }
      pointerCache.delete(event2.pointerId);
      model.container.releasePointerCapture(event2.pointerId);
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event2);
          break;
      }
    }
  };
  publicAPI.handlePointerCancel = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      pointerCache.delete(event2.pointerId);
      switch (event2.pointerType) {
        case "pen":
        case "touch":
          publicAPI.handleTouchEnd(event2);
          break;
        case "mouse":
        default:
          publicAPI.handleMouseUp(event2);
          break;
      }
    }
  };
  publicAPI.handlePointerMove = (event2) => {
    if (pointerCache.has(event2.pointerId)) {
      const pointer = pointerCache.get(event2.pointerId);
      pointer.position = getScreenEventPositionFor(event2);
    }
    switch (event2.pointerType) {
      case "pen":
      case "touch":
        publicAPI.handleTouchMove(event2);
        break;
      case "mouse":
      default:
        publicAPI.handleMouseMove(event2);
        break;
    }
  };
  publicAPI.handleMouseDown = (event2) => {
    const callData = {
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        vtkErrorMacro27(`Unknown mouse button pressed: ${event2.button}`);
        break;
    }
  };
  publicAPI.requestPointerLock = () => {
    if (model.container) {
      model.container.requestPointerLock();
    }
  };
  publicAPI.exitPointerLock = () => document.exitPointerLock?.();
  publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = (requestor) => {
    if (requestor === undefined) {
      vtkErrorMacro27(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro8(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.extendAnimation = (duration) => {
    const newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
  publicAPI.cancelAnimation = function(requestor) {
    let skipWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro8(`${requestStr} did not request an animation`);
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = () => {
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = () => {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
    xrSession.inputSources.forEach((inputSource) => {
      const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
      const gamepad = inputSource.gamepad;
      const hand = inputSource.handedness;
      if (!gamepad) {
        return;
      }
      if (!(gamepad.index in model.lastGamepadValues)) {
        model.lastGamepadValues[gamepad.index] = {
          left: {
            buttons: {}
          },
          right: {
            buttons: {}
          },
          none: {
            buttons: {}
          }
        };
      }
      for (let buttonIdx = 0;buttonIdx < gamepad.buttons.length; ++buttonIdx) {
        if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
          publicAPI.button3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            pressed: gamepad.buttons[buttonIdx].pressed,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController,
            input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : Input2.Trigger
          });
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
          publicAPI.move3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController
          });
        }
      }
    });
  };
  publicAPI.handleMouseMove = (event2) => {
    const callData = {
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1000 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1000 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = (event2) => {
    preventDefault(event2);
    const callData = {
      ...normalizeWheel2(event2),
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    if (model.wheelTimeoutID === 0) {
      if (Math.abs(callData.spinY) >= 0.3) {
        wheelCoefficient = Math.abs(callData.spinY);
      } else {
        wheelCoefficient = 1;
      }
    }
    callData.spinY /= wheelCoefficient;
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
      publicAPI.mouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    if (model.mouseScrollDebounceByPass) {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    } else {
      model.wheelTimeoutID = setTimeout(() => {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      }, 200);
    }
  };
  publicAPI.handleMouseUp = (event2) => {
    const callData = {
      ...getModifierKeysFor(event2),
      position: getScreenEventPositionFor(event2),
      deviceType: getDeviceTypeFor(event2)
    };
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        vtkErrorMacro27(`Unknown mouse button released: ${event2.button}`);
        break;
    }
  };
  publicAPI.handleTouchStart = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      if (pointers.length === 2) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      publicAPI.recognizeGesture("TouchStart", positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: getScreenEventPositionFor(event2),
        deviceType: getDeviceTypeFor(event2)
      };
      publicAPI.leftButtonPressEvent(callData);
    }
  };
  publicAPI.handleTouchMove = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      publicAPI.recognizeGesture("TouchMove", positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event2)
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = (event2) => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures) {
      if (pointers.length === 0) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event2),
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      } else if (pointers.length === 1) {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchEnd", positions);
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event2)
        };
        publicAPI.leftButtonPressEvent(callData);
      } else {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture("TouchMove", positions);
      }
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event2)
      };
      publicAPI.leftButtonReleaseEvent(callData);
    }
  };
  publicAPI.setView = (val) => {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = () => model._view?.getRenderable()?.getRenderersByReference()?.[0];
  publicAPI.findPokedRenderer = function() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    const rc = model._view?.getRenderable()?.getRenderers();
    if (!rc || rc.length === 0) {
      return null;
    }
    rc.sort((a, b) => a.getLayer() - b.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;
    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x, y, aren)) {
        viewportren = aren;
      }
    }
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };
  publicAPI.render = () => {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };
  handledEvents.forEach((eventName) => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = (arg) => {
      if (!model.enabled) {
        return;
      }
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro2(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }
      const callData = {
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer(),
        ...arg
      };
      publicAPI[`invoke${eventName}`](callData);
    };
  });
  publicAPI.recognizeGesture = (event2, positions) => {
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }
    if (event2 === "TouchStart") {
      Object.keys(positions).forEach((key) => {
        model.startingEventPositions[key] = positions[key];
      });
      model.currentGesture = "Start";
      return;
    }
    if (event2 === "TouchEnd") {
      if (model.currentGesture === "Pinch") {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === "Rotate") {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === "Pan") {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = "Start";
      model.startingEventPositions = {};
      return;
    }
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach((key) => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });
    const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));
    let originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    let newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180 >= 360 ? newAngle - 180 : newAngle + 180;
    originalAngle = originalAngle + 180 >= 360 ? originalAngle - 180 : originalAngle + 180;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }
    const trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2;
    if (event2 === "TouchMove") {
      if (model.currentGesture === "Start") {
        let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15) {
          thresh = 15;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360;
        const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = "Pinch";
          const callData = {
            scale: 1,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = "Rotate";
          const callData = {
            rotation: 0,
            touches: positions
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = "Pan";
          const callData = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        if (model.currentGesture === "Rotate") {
          const callData = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(callData);
        }
        if (model.currentGesture === "Pinch") {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(callData);
        }
        if (model.currentGesture === "Pan") {
          const callData = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = () => {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = (r) => {
    model._forcedRenderer = !!r;
    model.currentRenderer = r;
  };
  publicAPI.setContainer = (container) => {
    _unbindEvents();
    const res = superClass.setContainer(container ?? null);
    if (res) {
      _bindEvents();
    }
    return res;
  };
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== "undefined") {
      document.removeEventListener("visibilitychange", publicAPI.handleVisibilityChange);
    }
    if (model.container) {
      publicAPI.setContainer(null);
    }
    superClass.delete();
  };
  if (typeof document.hidden !== "undefined") {
    document.addEventListener("visibilitychange", publicAPI.handleVisibilityChange, false);
  }
}
var DEFAULT_VALUES57 = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30,
  stillUpdateRate: 2,
  container: null,
  recognizeGestures: true,
  currentGesture: "Start",
  animationRequest: null,
  lastFrameTime: 0.1,
  recentAnimationFrameRate: 10,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
  preventDefaultOnPointerDown: false,
  preventDefaultOnPointerUp: false,
  mouseScrollDebounceByPass: false
};
function extend59(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES57, initialValues);
  macro.obj(publicAPI, model);
  model._animationExtendedEnd = 0;
  macro.event(publicAPI, model, "RenderEvent");
  handledEvents.forEach((eventName) => macro.event(publicAPI, model, eventName));
  macro.get(publicAPI, model, ["initialized", "interactorStyle", "lastFrameTime", "recentAnimationFrameRate", "_view"]);
  macro.setGet(publicAPI, model, ["container", "lightFollowCamera", "enabled", "enableRender", "recognizeGestures", "desiredUpdateRate", "stillUpdateRate", "picker", "preventDefaultOnPointerDown", "preventDefaultOnPointerUp", "mouseScrollDebounceByPass"]);
  macro.moveToProtected(publicAPI, model, ["view"]);
  vtkRenderWindowInteractor(publicAPI, model);
}
var newInstance59 = macro.newInstance(extend59, "vtkRenderWindowInteractor");
var vtkRenderWindowInteractor$1 = {
  newInstance: newInstance59,
  extend: extend59,
  handledEvents,
  ...Constants15
};

// ../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var {
  vtkErrorMacro: vtkErrorMacro28
} = macro;
var INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];
function vtkPoints(publicAPI, model) {
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
  publicAPI.getBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange2 = publicAPI.getRange(0);
      model.bounds[0] = xRange2[0];
      model.bounds[1] = xRange2[1];
      const yRange2 = publicAPI.getRange(1);
      model.bounds[2] = yRange2[0];
      model.bounds[3] = yRange2[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro28(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
      return INVALID_BOUNDS;
    }
    const xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    const yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };
  publicAPI.computeBounds = publicAPI.getBounds;
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
var DEFAULT_VALUES58 = {
  empty: true,
  numberOfComponents: 3,
  dataType: VtkDataTypes.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend60(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES58, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}
var newInstance60 = macro.newInstance(extend60, "vtkPoints");
var vtkPoints$1 = {
  newInstance: newInstance60,
  extend: extend60
};

// ../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index2) => {
    if (index2 === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0;cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC6 = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== undefined && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== undefined && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  publicAPI.resize = (requestedNumTuples) => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        model.numberOfCells = undefined;
        model.cellSizes = undefined;
      }
    }
  };
  publicAPI.setData = (typedArray) => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = undefined;
    model.cellSizes = undefined;
  };
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = (cellPointIds) => {
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
}
function defaultValues2(initialValues) {
  return {
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT,
    ...initialValues
  };
}
function extend61(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues2(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance61 = macro.newInstance(extend61, "vtkCellArray");
var vtkCellArray$1 = {
  newInstance: newInstance61,
  extend: extend61,
  ...STATIC6
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1;i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index2) => {
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index2;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => {
    const nbPoints = model.points.getNumberOfPoints();
    const x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];
      for (let i = 1;i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      uninitializeBounds(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = () => {
    publicAPI.getBounds();
    let length5 = 0;
    let diff = 0;
    for (let i = 0;i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length5 += diff * diff;
    }
    return length5;
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    for (let i = 0;i < 3; i++) {
      if (pcoords[i] < 0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1) {
        pDist = pcoords[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = (cell) => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {
  };
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {
  };
  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist22, weights) => {
    macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
  };
}
var DEFAULT_VALUES59 = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};
function extend62(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES59, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var newInstance62 = macro.newInstance(extend62, "vtkCell");
var vtkCell$1 = {
  newInstance: newInstance62,
  extend: extend62
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length)
    model.array.push({
      ncells: 0,
      cells: null
    });
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();
    const linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (let cellId = 0;cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0;cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } else {
      for (let cellId = 0;cellId < numCells; cellId++) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0;cellId < numCells; ++cellId) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };
  publicAPI.getLink = (ptId) => model.array[ptId];
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
  publicAPI.getCells = (ptId) => model.array[ptId].cells;
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = (n) => {
    for (let i = 0;i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES60 = {
  array: null,
  maxId: 0,
  extend: 0
};
function extend63(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES60, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance63 = macro.newInstance(extend63, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance63,
  extend: extend63
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType = {
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  VTK_CUBIC_LINE: 35,
  VTK_CONVEX_POINT_SET: 41,
  VTK_POLYHEDRON: 42,
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};
var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

// ../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}
var STATIC7 = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];
  publicAPI.deleteCell = (cellId) => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = () => model.maxId + 1;
  publicAPI.isType = (type) => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i = 0;i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);
  publicAPI.getCellType = (cellId) => model.typeArray[cellId];
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
var DEFAULT_VALUES61 = {
  size: 0,
  maxId: -1,
  extend: 1000
};
function extend64(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES61, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var newInstance64 = macro.newInstance(extend64, "vtkCellTypes");
var vtkCellTypes$1 = {
  newInstance: newInstance64,
  extend: extend64,
  ...STATIC7
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants16 = {
  IntersectionState
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/Line.js
var {
  IntersectionState: IntersectionState2
} = Constants16;
function distanceToLine(x, p1, p2) {
  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];
  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = dot(p21, p21);
  let tolerance = 0.00001 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b22, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u[0] = 0;
  v[0] = 0;
  subtract(a2, a1, a21);
  subtract(b22, b1, b21);
  subtract(b1, a1, b1a1);
  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];
  const c = [];
  c[0] = dot(a21, b1a1);
  c[1] = -dot(b21, b1a1);
  if (solveLinearSystem(A, c, 2) === 0) {
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b22];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b22, b22, a2, a2];
    v[0], v[0], u[0], u[0];
    u[0], u[0], v[0], v[0];
    let obj2;
    for (let i = 0;i < 4; i++) {
      obj2 = distanceToLine(p[i], l1[i], l2[i]);
      if (obj2.distance < minDist) {
        minDist = obj2.distance;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];
  if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
var STATIC8 = {
  distanceToLine,
  intersection
};
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t) {
    return t >= 0 && t <= 1;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    const projXYZ = [];
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    const u = [];
    const v = [];
    const intersect2 = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect2 === IntersectionState2.YES_INTERSECTION) {
      for (let i = 0;i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (let i = 0;i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      exports_quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES62 = {
  orientations: null
};
function extend65(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES62, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations"]);
  vtkLine(publicAPI, model);
}
var newInstance65 = macro.newInstance(extend65, "vtkLine");
var vtkLine$1 = {
  newInstance: newInstance65,
  extend: extend65,
  ...STATIC8,
  ...Constants16
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}
var DEFAULT_VALUES63 = {};
function extend66(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES63, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance66 = macro.newInstance(extend66, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance66,
  extend: extend66
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function computeNormalDirection(v1, v2, v32, n) {
  const ax = v32[0] - v2[0];
  const ay = v32[1] - v2[1];
  const az = v32[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v32, n) {
  computeNormalDirection(v1, v2, v32, n);
  const length5 = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length5 !== 0) {
    n[0] /= length5;
    n[1] /= length5;
    n[2] /= length5;
  }
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.000001;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n2 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  const s1 = -dot(n1, p1);
  const s22 = -dot(n2, p2);
  const dist1 = [dot(n2, p1) + s22, dot(n2, q1) + s22, dot(n2, r1) + s22];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const dist22 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];
  if (dist22[0] * dist22[1] > tolerance && dist22[0] * dist22[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n2[0]) < 0.000000001 && Math.abs(n1[1] - n2[1]) < 0.000000001 && Math.abs(n1[2] - n2[2]) < 0.000000001 && Math.abs(s1 - s22) < 0.000000001) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const pts1 = [p1, q1, r1];
  const pts2 = [p2, q2, r2];
  const n1n2 = dot(n1, n2);
  const a = (s1 - s22 * n1n2) / (n1n2 * n1n2 - 1);
  const b = (s22 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  const v = cross(n1, n2, []);
  normalize(v);
  let index1 = 0;
  let index2 = 0;
  const t1 = [];
  const t22 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i = 0;i < 3; i++) {
    const id1 = i;
    const id2 = (i + 1) % 3;
    const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = dot(val1.x, v) - dot(p, v);
    }
    const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t22[index2++] = dot(val2.x, v) - dot(p, v);
    }
  }
  if (index1 > 2) {
    index1--;
    const t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    const t222 = t22[2];
    t22[2] = t22[ts2];
    t22[ts2] = t222;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t22[0]) || Number.isNaN(t22[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    const t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t22[0] > t22[1]) {
    const t21 = t22[1];
    t22[1] = t22[0];
    t22[0] = t21;
  }
  let tt1;
  let tt2;
  if (t1[1] < t22[0] || t22[1] < t1[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] < t22[0]) {
    if (t1[1] < t22[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t22[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t22[0];
      tt2 = t22[1];
    }
  } else if (t1[1] < t22[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t22[1];
  }
  multiplyAccumulate(p, v, tt1, pt1);
  multiplyAccumulate(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
var STATIC9 = {
  computeNormalDirection,
  computeNormal,
  intersectWithTriangle
};
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    const closestPoint = [];
    const tol2 = tol * tol;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      const plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      for (let i = 0;i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);
    vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
    let maxComponent = 0;
    for (i = 0;i < 3; i++) {
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0;i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0;i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = determinant2x2(c1, c2);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c2) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0;i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0;i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0;i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1 - pcoords[0] - pcoords[1];
    for (let i = 0;i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    const pc2 = [];
    pc2[0] = pcoords[0];
    pc2[1] = pcoords[1];
    pc2[2] = 1 - pcoords[0] - pcoords[1];
    for (let i = 0;i < 3; i++) {
      if (pc2[i] < 0) {
        pDist = -pc2[i];
      } else if (pc2[i] > 1) {
        pDist = pc2[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}
var DEFAULT_VALUES64 = {};
function extend67(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES64, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var newInstance67 = macro.newInstance(extend67, "vtkTriangle");
var vtkTriangle$1 = {
  newInstance: newInstance67,
  extend: extend67,
  ...STATIC9
};

// ../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// ../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var {
  vtkWarningMacro: vtkWarningMacro9
} = macro;
var CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1
};
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str7) {
    return str7.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  POLYDATA_FIELDS.forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach((type) => {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = () => {
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro9("Building VTK_LINE ", index2, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index2] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index2] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index2] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro9("Building VTK_TRIANGLE ", index2, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.cells === undefined) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = (cellId) => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };
  publicAPI.getCell = function(cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}
var DEFAULT_VALUES65 = {};
function extend68(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES65, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance68 = macro.newInstance(extend68, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance68,
  extend: extend68
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var VTK_EPSILON = 0.000001;
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map((value, index2) => value + deltaXYZ[index2]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = exports_quat.create();
    exports_mat4.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = exports_quat.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function() {
    let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return exports_mat4.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = (val) => {
    if (val === 0) {
      return;
    }
    exports_mat4.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = (val) => {
    if (val === 0) {
      return;
    }
    exports_mat4.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = (val) => {
    if (val === 0) {
      return;
    }
    exports_mat4.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    const angle3 = radiansFromDegrees(degrees);
    const q = exports_quat.create();
    exports_quat.setAxisAngle(q, [x, y, z], angle3);
    const quatMat = new Float64Array(16);
    exports_mat4.fromQuat(quatMat, q);
    exports_mat4.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = (orientationQuaternion) => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = exports_mat4.fromQuat(new Float64Array(16), orientationQuaternion);
    exports_mat4.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    exports_mat4.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = (matrix) => {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    exports_mat4.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      exports_mat4.identity(model.matrix);
      if (model.userMatrix) {
        exports_mat4.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      exports_mat4.translate(model.matrix, model.matrix, model.origin);
      exports_mat4.translate(model.matrix, model.matrix, model.position);
      exports_mat4.multiply(model.matrix, model.matrix, model.rotation);
      exports_mat4.scale(model.matrix, model.matrix, model.scale);
      exports_mat4.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      exports_mat4.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (let i = 0;i < 4; ++i) {
        for (let j = 0;j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
  publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
  publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
  publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
  publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
var DEFAULT_VALUES66 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend69(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES66, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = exports_mat4.identity(new Float64Array(16));
  model.rotation = exports_mat4.identity(new Float64Array(16));
  model.userMatrix = exports_mat4.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance69 = macro.newInstance(extend69, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance69,
  extend: extend69
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var {
  vtkDebugMacro: vtkDebugMacro8
} = macro;
function vtkActor2(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (model.property === null) {
      publicAPI.setProperty(publicAPI.makeProperty());
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro8("Recomputing bounds...");
      model.mapperBounds = bds.concat();
      const bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      exports_mat4.transpose(tmp4, model.matrix);
      bbox.forEach((pt) => exports_vec3.transformMat4(pt, pt, tmp4));
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}
var DEFAULT_VALUES67 = {
  mapper: null,
  property: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend70(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES67, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor2(publicAPI, model);
}
var newInstance70 = macro.newInstance(extend70, "vtkActor");
var vtkActor$1 = {
  newInstance: newInstance70,
  extend: extend70
};

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkOffscreenMultiRenderWindow.js
function vtkOffscreenMultiRenderWindow(publicAPI, model) {
  const invokeResize = publicAPI.invokeResize;
  delete publicAPI.invokeResize;
  model.renderWindow = vtkRenderWindow$1.newInstance();
  model.rendererMap = {};
  model.openGLRenderWindow = vtkStreamingOpenGLRenderWindow_default.newInstance();
  model.renderWindow.addView(model.openGLRenderWindow);
  model.interactor = vtkRenderWindowInteractor$1.newInstance();
  model.interactor.setView(model.openGLRenderWindow);
  model.interactor.initialize();
  publicAPI.addRenderer = ({ viewport, id, background }) => {
    const renderer = vtkRenderer$1.newInstance({
      viewport,
      background: background || model.background
    });
    model.renderWindow.addRenderer(renderer);
    model.rendererMap[id] = renderer;
  };
  publicAPI.destroy = () => {
    const rwi = model.renderWindow.getInteractor();
    rwi.delete();
  };
  publicAPI.removeRenderer = (id) => {
    const renderer = publicAPI.getRenderer(id);
    model.renderWindow.removeRenderer(renderer);
    renderer.delete();
    delete model.rendererMap[id];
  };
  publicAPI.getRenderer = (id) => {
    return model.rendererMap[id];
  };
  publicAPI.getRenderers = () => {
    const { rendererMap } = model;
    const renderers = Object.keys(rendererMap).map((id) => {
      return { id, renderer: rendererMap[id] };
    });
    return renderers;
  };
  publicAPI.resize = () => {
    if (model.container) {
      const { width, height } = model.container;
      model.openGLRenderWindow.setSize(Math.floor(width), Math.floor(height));
      invokeResize();
      model.renderWindow.render();
    }
  };
  publicAPI.setContainer = (el) => {
    model.container = el;
    model.openGLRenderWindow.setContainer(model.container);
  };
  publicAPI.delete = macro.chain(publicAPI.setContainer, publicAPI.destroy, model.openGLRenderWindow.delete, publicAPI.delete);
  publicAPI.resize();
}
var DEFAULT_VALUES68 = {
  background: [0, 0, 0],
  container: null
};
function extend71(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES68, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, [
    "renderWindow",
    "openGLRenderWindow",
    "interactor",
    "container"
  ]);
  macro.event(publicAPI, model, "resize");
  vtkOffscreenMultiRenderWindow(publicAPI, model);
}
var newInstance71 = macro.newInstance(extend71);
var vtkOffscreenMultiRenderWindow_default = { newInstance: newInstance71, extend: extend71 };

// ../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var {
  vtkErrorMacro: vtkErrorMacro29
} = macro;
function vtkPiecewiseFunction(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunction");
  publicAPI.getSize = () => model.nodes.length;
  publicAPI.getType = () => {
    let value;
    let prevValue = 0;
    let functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (let i = 1;i < model.nodes.length; i++) {
      value = model.nodes[i].y;
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              functionType = 1;
              break;
            case 2:
            default:
              functionType = 3;
              break;
          }
        } else {
          switch (functionType) {
            case 0:
            case 2:
              functionType = 2;
              break;
            case 1:
            default:
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return "Constant";
      case 1:
        return "NonDecreasing";
      case 2:
        return "NonIncreasing";
      case 3:
      default:
        return "Varied";
    }
  };
  publicAPI.getDataPointer = () => {
    const size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (let i = 0;i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };
  publicAPI.getFirstNonZeroValue = () => {
    if (model.nodes.length === 0) {
      return 0;
    }
    let allZero = 1;
    let x = 0;
    let i = 0;
    for (;i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0) {
        allZero = 0;
        break;
      }
    }
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };
  publicAPI.getNodeValue = (index2, val) => {
    const size = model.nodes.length;
    if (index2 < 0 || index2 >= size) {
      vtkErrorMacro29("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index2].x;
    val[1] = model.nodes[index2].y;
    val[2] = model.nodes[index2].midpoint;
    val[3] = model.nodes[index2].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = (index2, val) => {
    const size = model.nodes.length;
    if (index2 < 0 || index2 >= size) {
      vtkErrorMacro29("Index out of range!");
      return -1;
    }
    const oldX = model.nodes[index2].x;
    model.nodes[index2].x = val[0];
    model.nodes[index2].y = val[1];
    model.nodes[index2].midpoint = val[2];
    model.nodes[index2].sharpness = val[3];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0);
  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro29("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro29("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    const node = {
      x,
      y,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    let i;
    for (i = 0;i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = (nodes) => {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };
  publicAPI.sortAndUpdateRange = () => {
    model.nodes.sort((a, b) => a.x - b.x);
    const modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };
  publicAPI.updateRange = () => {
    const oldRange = model.range.slice();
    const size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = (x) => {
    let i;
    for (i = 0;i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i >= model.nodes.length) {
      return -1;
    }
    const retVal = i;
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addSegment = (x1, y1, x2, y22) => {
    publicAPI.sortAndUpdateRange();
    for (let i = 0;i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addPoint(x1, y1, 0.5, 0);
    publicAPI.addPoint(x2, y22, 0.5, 0);
  };
  publicAPI.getValue = (x) => {
    const table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };
  publicAPI.adjustRange = (range) => {
    if (range.length < 2) {
      return 0;
    }
    const functionRange = publicAPI.getRange();
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }
    publicAPI.sortAndUpdateRange();
    for (let i = 0;i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = () => {
    const size = model.nodes.length;
    if (size < 2) {
      return -1;
    }
    let distance4 = model.nodes[1].x - model.nodes[0].x;
    for (let i = 0;i < size - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance4) {
        distance4 = currentDist;
      }
    }
    return distance4;
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    let i;
    let idx = 0;
    const numNodes = model.nodes.length;
    let lastValue = 0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    let x = 0;
    let x1 = 0;
    let x2 = 0;
    let y1 = 0;
    let y22 = 0;
    let midpoint = 0;
    let sharpness = 0;
    for (i = 0;i < size; i++) {
      const tidx = stride * i;
      if (size > 1) {
        x = xStart + i / (size - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y22 = model.nodes[idx].y;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0;
      } else if (idx === 0) {
        table[tidx] = model.clamping ? model.nodes[0].y : 0;
      } else {
        let s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            table[tidx] = y22;
            continue;
          }
        }
        if (sharpness < 0.01) {
          table[tidx] = (1 - s) * y1 + s * y22;
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * ((1 - s) * 2) ** (1 + 10 * sharpness);
        }
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        const slope = y22 - y1;
        const t = (1 - sharpness) * slope;
        table[tidx] = h1 * y1 + h2 * y22 + h3 * t + h4 * t;
        const min5 = y1 < y22 ? y1 : y22;
        const max5 = y1 > y22 ? y1 : y22;
        table[tidx] = table[tidx] < min5 ? min5 : table[tidx];
        table[tidx] = table[tidx] > max5 ? max5 : table[tidx];
      }
    }
  };
}
var DEFAULT_VALUES69 = {
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};
function extend72(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES69, initialValues);
  macro.obj(publicAPI, model);
  model.nodes = [];
  macro.setGet(publicAPI, model, ["allowDuplicateScalars", "clamping"]);
  macro.setArray(publicAPI, model, ["range"], 2);
  macro.getArray(publicAPI, model, ["range"]);
  vtkPiecewiseFunction(publicAPI, model);
}
var newInstance72 = macro.newInstance(extend72, "vtkPiecewiseFunction");
var vtkPiecewiseFunction$1 = {
  newInstance: newInstance72,
  extend: extend72
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js
var {
  BlendMode: BlendMode3,
  FilterMode: FilterMode2
} = Constants;
function createRadonTransferFunction(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption, maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption, outputTransferFunction) {
  let ofun = null;
  if (outputTransferFunction) {
    ofun = outputTransferFunction;
    ofun.removeAllPoints();
  } else {
    ofun = vtkPiecewiseFunction$1.newInstance();
  }
  ofun.addPointLong(-1024, 0, 1, 1);
  ofun.addPoint(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption);
  ofun.addPoint(maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption);
  return ofun;
}
var STATIC10 = {
  createRadonTransferFunction
};
function vtkVolumeMapper2(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeMapper");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = () => {
    publicAPI.setBlendMode(BlendMode3.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = () => {
    publicAPI.setBlendMode(BlendMode3.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = () => {
    publicAPI.setBlendMode(BlendMode3.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = () => {
    publicAPI.setBlendMode(BlendMode3.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = () => {
    publicAPI.setBlendMode(BlendMode3.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToRadonTransform = () => {
    publicAPI.setBlendMode(BlendMode3.RADON_TRANSFORM_BLEND);
  };
  publicAPI.getBlendModeAsString = () => macro.enumToString(BlendMode3, model.blendMode);
  publicAPI.setAverageIPScalarRange = (min5, max5) => {
    console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange");
    publicAPI.setIpScalarRange(min5, max5);
  };
  publicAPI.getFilterModeAsString = () => macro.enumToString(FilterMode2, model.filterMode);
  publicAPI.setFilterModeToOff = () => {
    publicAPI.setFilterMode(FilterMode2.OFF);
  };
  publicAPI.setFilterModeToNormalized = () => {
    publicAPI.setFilterMode(FilterMode2.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = () => {
    publicAPI.setFilterMode(FilterMode2.RAW);
  };
  publicAPI.setGlobalIlluminationReach = (gl) => superClass.setGlobalIlluminationReach(clampValue(gl, 0, 1));
  publicAPI.setVolumetricScatteringBlending = (vsb) => superClass.setVolumetricScatteringBlending(clampValue(vsb, 0, 1));
  publicAPI.setVolumeShadowSamplingDistFactor = (vsdf) => superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1 ? vsdf : 1);
  publicAPI.setAnisotropy = (at) => superClass.setAnisotropy(clampValue(at, -0.99, 0.99));
  publicAPI.setLAOKernelSize = (ks) => superClass.setLAOKernelSize(floor(clampValue(ks, 1, 32)));
  publicAPI.setLAOKernelRadius = (kr) => superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
}
var DEFAULT_VALUES70 = {
  bounds: [1, -1, 1, -1, 1, -1],
  sampleDistance: 1,
  imageSampleDistance: 1,
  maximumSamplesPerRay: 1000,
  autoAdjustSampleDistances: true,
  initialInteractionScale: 1,
  interactionSampleDistanceFactor: 1,
  blendMode: BlendMode3.COMPOSITE_BLEND,
  ipScalarRange: [-1e6, 1e6],
  filterMode: FilterMode2.OFF,
  preferSizeOverAccuracy: false,
  computeNormalFromOpacity: false,
  volumetricScatteringBlending: 0,
  globalIlluminationReach: 0,
  volumeShadowSamplingDistFactor: 5,
  anisotropy: 0,
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7
};
function extend73(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES70, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sampleDistance", "imageSampleDistance", "maximumSamplesPerRay", "autoAdjustSampleDistances", "initialInteractionScale", "interactionSampleDistanceFactor", "blendMode", "filterMode", "preferSizeOverAccuracy", "computeNormalFromOpacity", "volumetricScatteringBlending", "globalIlluminationReach", "volumeShadowSamplingDistFactor", "anisotropy", "localAmbientOcclusion", "LAOKernelSize", "LAOKernelRadius"]);
  macro.setGetArray(publicAPI, model, ["ipScalarRange"], 2);
  macro.event(publicAPI, model, "lightingActivated");
  vtkVolumeMapper2(publicAPI, model);
}
var newInstance73 = macro.newInstance(extend73, "vtkVolumeMapper");
var vtkVolumeMapper$1 = {
  newInstance: newInstance73,
  extend: extend73,
  ...STATIC10
};

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js
function vtkSharedVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkSharedVolumeMapper");
  const superDelete = publicAPI.delete;
  publicAPI.delete = () => {
    model.scalarTexture = null;
    superDelete();
  };
}
var DEFAULT_VALUES71 = {
  scalarTexture: null
};
function extend74(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES71, initialValues);
  vtkVolumeMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["scalarTexture"]);
  vtkSharedVolumeMapper(publicAPI, model);
}
var newInstance74 = macro.newInstance(extend74, "vtkSharedVolumeMapper");
var vtkSharedVolumeMapper_default = { newInstance: newInstance74, extend: extend74 };

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js
function imageIdToURI(imageId) {
  const colonIndex = imageId.indexOf(":");
  return imageId.substring(colonIndex + 1);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/fnv1aHash.js
function fnv1aHash(str7) {
  let hash = 2166136261;
  for (let i = 0;i < str7.length; i++) {
    hash ^= str7.charCodeAt(i);
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return (hash >>> 0).toString(36);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var ONE_GB = 1073741824;

class Cache {
  constructor() {
    this._imageCache = new Map;
    this._volumeCache = new Map;
    this._imageIdsToVolumeIdCache = new Map;
    this._geometryCache = new Map;
    this._imageCacheSize = 0;
    this._maxCacheSize = 3 * ONE_GB;
    this._geometryCacheSize = 0;
    this.setMaxCacheSize = (newMaxCacheSize) => {
      if (!newMaxCacheSize || typeof newMaxCacheSize !== "number") {
        const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
        throw new Error(errorMessage);
      }
      this._maxCacheSize = newMaxCacheSize;
    };
    this.isCacheable = (byteLength) => {
      const bytesAvailable = this.getBytesAvailable();
      const purgableImageBytes = Array.from(this._imageCache.values()).reduce((total, image) => {
        if (!image.sharedCacheKey) {
          return total + image.sizeInBytes;
        }
        return total;
      }, 0);
      const availableSpaceWithoutSharedCacheKey = bytesAvailable + purgableImageBytes;
      return availableSpaceWithoutSharedCacheKey >= byteLength;
    };
    this.getMaxCacheSize = () => this._maxCacheSize;
    this.getCacheSize = () => this._imageCacheSize;
    this._decacheImage = (imageId, force = false) => {
      const cachedImage = this._imageCache.get(imageId);
      if (!cachedImage) {
        return;
      }
      if (cachedImage.sharedCacheKey && !force) {
        throw new Error("Cannot decache an image with a shared cache key. You need to manually decache the volume first.");
      }
      const { imageLoadObject } = cachedImage;
      if (imageLoadObject?.cancelFn) {
        imageLoadObject.cancelFn();
      }
      if (imageLoadObject?.decache) {
        imageLoadObject.decache();
      }
      this._imageCache.delete(imageId);
    };
    this._decacheVolume = (volumeId) => {
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume) {
        return;
      }
      const { volumeLoadObject, volume } = cachedVolume;
      if (!volume) {
        return;
      }
      if (volume.cancelLoading) {
        volume.cancelLoading();
      }
      if (volume.imageData) {
        volume.imageData.delete();
      }
      if (volumeLoadObject.cancelFn) {
        volumeLoadObject.cancelFn();
      }
      if (volume.imageIds) {
        volume.imageIds.forEach((imageId) => {
          const cachedImage = this._imageCache.get(imageId);
          if (cachedImage && cachedImage.sharedCacheKey === volumeId) {
            cachedImage.sharedCacheKey = undefined;
          }
        });
      }
      this._volumeCache.delete(volumeId);
    };
    this.purgeCache = () => {
      const imageIterator = this._imageCache.keys();
      this.purgeVolumeCache();
      while (true) {
        const { value: imageId, done } = imageIterator.next();
        if (done) {
          break;
        }
        this.removeImageLoadObject(imageId, { force: true });
        triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      }
    };
    this.purgeVolumeCache = () => {
      const volumeIterator = this._volumeCache.keys();
      while (true) {
        const { value: volumeId, done } = volumeIterator.next();
        if (done) {
          break;
        }
        this.removeVolumeLoadObject(volumeId);
        triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_REMOVED, {
          volumeId
        });
      }
    };
    this.getVolumeLoadObject = (volumeId) => {
      if (volumeId === undefined) {
        throw new Error("getVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume) {
        return;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volumeLoadObject;
    };
    this.putGeometryLoadObject = (geometryId, geometryLoadObject) => {
      if (geometryId === undefined) {
        throw new Error("putGeometryLoadObject: geometryId must not be undefined");
      }
      if (geometryLoadObject.promise === undefined) {
        throw new Error("putGeometryLoadObject: geometryLoadObject.promise must not be undefined");
      }
      if (this._geometryCache.has(geometryId)) {
        throw new Error("putGeometryLoadObject: geometryId already present in geometryCache");
      }
      if (geometryLoadObject.cancelFn && typeof geometryLoadObject.cancelFn !== "function") {
        throw new Error("putGeometryLoadObject: geometryLoadObject.cancel must be a function");
      }
      const cachedGeometry = {
        loaded: false,
        geometryId,
        geometryLoadObject,
        timeStamp: Date.now(),
        sizeInBytes: 0
      };
      this._geometryCache.set(geometryId, cachedGeometry);
      return geometryLoadObject.promise.then((geometry) => {
        try {
          this._putGeometryCommon(geometryId, geometry, cachedGeometry);
        } catch (error) {
          console.debug(`Error in _putGeometryCommon for geometry ${geometryId}:`, error);
          throw error;
        }
      }).catch((error) => {
        console.debug(`Error caching geometry ${geometryId}:`, error);
        this._geometryCache.delete(geometryId);
        throw error;
      });
    };
    this.getGeometry = (geometryId) => {
      if (geometryId === undefined) {
        throw new Error("getGeometry: geometryId must not be undefined");
      }
      const cachedGeometry = this._geometryCache.get(geometryId);
      if (!cachedGeometry) {
        return;
      }
      cachedGeometry.timeStamp = Date.now();
      return cachedGeometry.geometry;
    };
    this.removeGeometryLoadObject = (geometryId) => {
      if (geometryId === undefined) {
        throw new Error("removeGeometryLoadObject: geometryId must not be undefined");
      }
      const cachedGeometry = this._geometryCache.get(geometryId);
      if (!cachedGeometry) {
        throw new Error("removeGeometryLoadObject: geometryId was not present in geometryCache");
      }
      this.decrementGeometryCacheSize(cachedGeometry.sizeInBytes);
      const eventDetails = {
        geometry: cachedGeometry,
        geometryId
      };
      triggerEvent(eventTarget_default, Events_default.GEOMETRY_CACHE_GEOMETRY_REMOVED, eventDetails);
      this._decacheGeometry(geometryId);
    };
    this._decacheGeometry = (geometryId) => {
      const cachedGeometry = this._geometryCache.get(geometryId);
      if (!cachedGeometry) {
        return;
      }
      const { geometryLoadObject } = cachedGeometry;
      if (geometryLoadObject.cancelFn) {
        geometryLoadObject.cancelFn();
      }
      if (geometryLoadObject.decache) {
        geometryLoadObject.decache();
      }
      this._geometryCache.delete(geometryId);
    };
    this.incrementGeometryCacheSize = (increment) => {
      this._geometryCacheSize += increment;
    };
    this.decrementGeometryCacheSize = (decrement) => {
      this._geometryCacheSize -= decrement;
    };
    this.getImage = (imageId, minQuality = ImageQualityStatus_default.FAR_REPLICATE) => {
      if (imageId === undefined) {
        throw new Error("getImage: imageId must not be undefined");
      }
      const cachedImage = this._imageCache.get(imageId);
      if (!cachedImage) {
        return;
      }
      cachedImage.timeStamp = Date.now();
      if (cachedImage.image?.imageQualityStatus < minQuality) {
        return;
      }
      return cachedImage.image;
    };
    this.getVolume = (volumeId, allowPartialMatch = false) => {
      if (volumeId === undefined) {
        throw new Error("getVolume: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume) {
        return allowPartialMatch ? [...this._volumeCache.values()].find((cv) => cv.volumeId.includes(volumeId))?.volume : undefined;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volume;
    };
    this.getVolumes = () => {
      const cachedVolumes = Array.from(this._volumeCache.values());
      return cachedVolumes.map((cachedVolume) => cachedVolume.volume);
    };
    this.filterVolumesByReferenceId = (volumeId) => {
      const cachedVolumes = this.getVolumes();
      return cachedVolumes.filter((volume) => {
        return volume.referencedVolumeId === volumeId;
      });
    };
    this.removeImageLoadObject = (imageId, { force = false } = {}) => {
      if (imageId === undefined) {
        throw new Error("removeImageLoadObject: imageId must not be undefined");
      }
      const cachedImage = this._imageCache.get(imageId);
      if (!cachedImage) {
        throw new Error("removeImageLoadObject: imageId was not present in imageCache");
      }
      this._decacheImage(imageId, force);
      this.incrementImageCacheSize(-cachedImage.sizeInBytes);
      const eventDetails = {
        image: cachedImage,
        imageId
      };
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);
    };
    this.removeVolumeLoadObject = (volumeId) => {
      if (volumeId === undefined) {
        throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume) {
        throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
      }
      const eventDetails = {
        volume: cachedVolume,
        volumeId
      };
      triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);
      this._decacheVolume(volumeId);
    };
    this.incrementImageCacheSize = (increment) => {
      this._imageCacheSize += increment;
    };
    this.decrementImageCacheSize = (decrement) => {
      this._imageCacheSize -= decrement;
    };
    this.getGeometryLoadObject = (geometryId) => {
      if (geometryId === undefined) {
        throw new Error("getGeometryLoadObject: geometryId must not be undefined");
      }
      const cachedGeometry = this._geometryCache.get(geometryId);
      if (!cachedGeometry) {
        return;
      }
      cachedGeometry.timeStamp = Date.now();
      return cachedGeometry.geometryLoadObject;
    };
  }
  generateVolumeId(imageIds) {
    const imageURIs = imageIds.map(imageIdToURI).sort();
    let combinedHash = 2166136261;
    for (const id of imageURIs) {
      const idHash = fnv1aHash(id);
      for (let i = 0;i < idHash.length; i++) {
        combinedHash ^= idHash.charCodeAt(i);
        combinedHash += (combinedHash << 1) + (combinedHash << 4) + (combinedHash << 7) + (combinedHash << 8) + (combinedHash << 24);
      }
    }
    return `volume-${(combinedHash >>> 0).toString(36)}`;
  }
  getImageIdsForVolumeId(volumeId) {
    return Array.from(this._imageIdsToVolumeIdCache.entries()).filter(([_, id]) => id === volumeId).map(([key]) => key);
  }
  getBytesAvailable() {
    return this.getMaxCacheSize() - this.getCacheSize();
  }
  decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {
    let bytesAvailable = this.getBytesAvailable();
    if (bytesAvailable >= numBytes) {
      return bytesAvailable;
    }
    const cachedImages = Array.from(this._imageCache.values()).filter((cachedImage) => !cachedImage.sharedCacheKey);
    function compare(a, b) {
      if (a.timeStamp > b.timeStamp) {
        return 1;
      }
      if (a.timeStamp < b.timeStamp) {
        return -1;
      }
      return 0;
    }
    cachedImages.sort(compare);
    const cachedImageIds = cachedImages.map((im2) => im2.imageId);
    let imageIdsToPurge = cachedImageIds;
    if (volumeImageIds) {
      imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));
    }
    for (const imageId of imageIdsToPurge) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
    for (const imageId of cachedImageIds) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
  }
  _putImageCommon(imageId, image, cachedImage) {
    if (!this._imageCache.has(imageId)) {
      console.warn("The image was purged from the cache before it completed loading.");
      return;
    }
    if (!image) {
      console.warn("Image is undefined");
      return;
    }
    if (image.sizeInBytes === undefined || Number.isNaN(image.sizeInBytes)) {
      throw new Error("_putImageCommon: image.sizeInBytes must not be undefined");
    }
    if (image.sizeInBytes.toFixed === undefined) {
      throw new Error("_putImageCommon: image.sizeInBytes is not a number");
    }
    if (!this.isCacheable(image.sizeInBytes)) {
      throw new Error(Events_default.CACHE_SIZE_EXCEEDED);
    }
    this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);
    cachedImage.loaded = true;
    cachedImage.image = image;
    cachedImage.sizeInBytes = image.sizeInBytes;
    this.incrementImageCacheSize(cachedImage.sizeInBytes);
    const eventDetails = {
      image: cachedImage
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_ADDED, eventDetails);
    cachedImage.sharedCacheKey = image.sharedCacheKey;
  }
  async putImageLoadObject(imageId, imageLoadObject) {
    if (imageId === undefined) {
      console.error("putImageLoadObject: imageId must not be undefined");
      throw new Error("putImageLoadObject: imageId must not be undefined");
    }
    if (imageLoadObject.promise === undefined) {
      console.error("putImageLoadObject: imageLoadObject.promise must not be undefined");
      throw new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
    }
    const alreadyCached = this._imageCache.get(imageId);
    if (alreadyCached?.imageLoadObject) {
      console.warn(`putImageLoadObject: imageId ${imageId} already in cache`);
      throw new Error("putImageLoadObject: imageId already in cache");
    }
    if (imageLoadObject.cancelFn && typeof imageLoadObject.cancelFn !== "function") {
      console.error("putImageLoadObject: imageLoadObject.cancel must be a function");
      throw new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
    }
    const cachedImage = {
      ...alreadyCached,
      loaded: false,
      imageId,
      sharedCacheKey: undefined,
      imageLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._imageCache.set(imageId, cachedImage);
    this._imageCache.set(imageId, cachedImage);
    return imageLoadObject.promise.then((image) => {
      try {
        this._putImageCommon(imageId, image, cachedImage);
      } catch (error) {
        console.debug(`Error in _putImageCommon for image ${imageId}:`, error);
        throw error;
      }
    }).catch((error) => {
      console.debug(`Error caching image ${imageId}:`, error);
      this._imageCache.delete(imageId);
      throw error;
    });
  }
  putImageSync(imageId, image) {
    if (imageId === undefined) {
      throw new Error("putImageSync: imageId must not be undefined");
    }
    if (this._imageCache.has(imageId)) {
      throw new Error("putImageSync: imageId already in cache");
    }
    const cachedImage = {
      loaded: false,
      imageId,
      sharedCacheKey: undefined,
      imageLoadObject: {
        promise: Promise.resolve(image)
      },
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._imageCache.set(imageId, cachedImage);
    try {
      this._putImageCommon(imageId, image, cachedImage);
    } catch (error) {
      this._imageCache.delete(imageId);
      throw error;
    }
  }
  getImageLoadObject(imageId) {
    if (imageId === undefined) {
      throw new Error("getImageLoadObject: imageId must not be undefined");
    }
    const cachedImage = this._imageCache.get(imageId);
    if (!cachedImage) {
      return;
    }
    cachedImage.timeStamp = Date.now();
    return cachedImage.imageLoadObject;
  }
  isLoaded(imageId) {
    const cachedImage = this._imageCache.get(imageId);
    if (!cachedImage) {
      return false;
    }
    return cachedImage.loaded;
  }
  getVolumeContainingImageId(imageId) {
    const volumeIds = Array.from(this._volumeCache.keys());
    const imageIdToUse = imageIdToURI(imageId);
    for (const volumeId of volumeIds) {
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume) {
        return;
      }
      const { volume } = cachedVolume;
      if (!volume.imageIds.length) {
        return;
      }
      const imageIdIndex = volume.getImageURIIndex(imageIdToUse);
      if (imageIdIndex > -1) {
        return { volume, imageIdIndex };
      }
    }
  }
  getCachedImageBasedOnImageURI(imageId) {
    const imageURIToUse = imageIdToURI(imageId);
    const cachedImageIds = Array.from(this._imageCache.keys());
    const foundImageId = cachedImageIds.find((imageId2) => {
      return imageIdToURI(imageId2) === imageURIToUse;
    });
    if (!foundImageId) {
      return;
    }
    return this._imageCache.get(foundImageId);
  }
  _putVolumeCommon(volumeId, volume, cachedVolume) {
    if (!this._volumeCache.get(volumeId)) {
      console.warn("The volume was purged from the cache before it completed loading.");
      return;
    }
    cachedVolume.loaded = true;
    cachedVolume.volume = volume;
    volume.imageIds?.forEach((imageId) => {
      const image = this._imageCache.get(imageId);
      if (image) {
        image.sharedCacheKey = volumeId;
      }
    });
    const eventDetails = {
      volume: cachedVolume
    };
    triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_ADDED, eventDetails);
  }
  putVolumeSync(volumeId, volume) {
    if (volumeId === undefined) {
      throw new Error("putVolumeSync: volumeId must not be undefined");
    }
    if (this._volumeCache.has(volumeId)) {
      throw new Error("putVolumeSync: volumeId already in cache");
    }
    const cachedVolume = {
      loaded: false,
      volumeId,
      volumeLoadObject: {
        promise: Promise.resolve(volume)
      },
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._volumeCache.set(volumeId, cachedVolume);
    try {
      this._putVolumeCommon(volumeId, volume, cachedVolume);
    } catch (error) {
      this._volumeCache.delete(volumeId);
      throw error;
    }
  }
  async putVolumeLoadObject(volumeId, volumeLoadObject) {
    if (volumeId === undefined) {
      throw new Error("putVolumeLoadObject: volumeId must not be undefined");
    }
    if (volumeLoadObject.promise === undefined) {
      throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
    }
    if (this._volumeCache.has(volumeId)) {
      throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);
    }
    if (volumeLoadObject.cancelFn && typeof volumeLoadObject.cancelFn !== "function") {
      throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
    }
    const cachedVolume = {
      loaded: false,
      volumeId,
      volumeLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._volumeCache.set(volumeId, cachedVolume);
    return volumeLoadObject.promise.then((volume) => {
      try {
        this._putVolumeCommon(volumeId, volume, cachedVolume);
      } catch (error) {
        console.error(`Error in _putVolumeCommon for volume ${volumeId}:`, error);
        this._volumeCache.delete(volumeId);
        throw error;
      }
    }).catch((error) => {
      this._volumeCache.delete(volumeId);
      throw error;
    });
  }
  _putGeometryCommon(geometryId, geometry, cachedGeometry) {
    if (!this._geometryCache.get(geometryId)) {
      console.warn("The geometry was purged from the cache before it completed loading.");
      return;
    }
    if (!geometry) {
      console.warn("Geometry is undefined");
      return;
    }
    if (geometry.sizeInBytes === undefined || Number.isNaN(geometry.sizeInBytes)) {
      throw new Error("_putGeometryCommon: geometry.sizeInBytes must not be undefined");
    }
    if (geometry.sizeInBytes.toFixed === undefined) {
      throw new Error("_putGeometryCommon: geometry.sizeInBytes is not a number");
    }
    if (!this.isCacheable(geometry.sizeInBytes)) {
      throw new Error(Events_default.CACHE_SIZE_EXCEEDED);
    }
    this.decacheIfNecessaryUntilBytesAvailable(geometry.sizeInBytes);
    cachedGeometry.loaded = true;
    cachedGeometry.geometry = geometry;
    cachedGeometry.sizeInBytes = geometry.sizeInBytes;
    this.incrementGeometryCacheSize(cachedGeometry.sizeInBytes);
    const eventDetails = {
      geometry: cachedGeometry
    };
    triggerEvent(eventTarget_default, Events_default.GEOMETRY_CACHE_GEOMETRY_ADDED, eventDetails);
  }
  putGeometrySync(geometryId, geometry) {
    if (geometryId === undefined) {
      throw new Error("putGeometrySync: geometryId must not be undefined");
    }
    if (this._geometryCache.has(geometryId)) {
      throw new Error("putGeometrySync: geometryId already in cache");
    }
    const cachedGeometry = {
      loaded: false,
      geometryId,
      geometryLoadObject: {
        promise: Promise.resolve(geometry)
      },
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._geometryCache.set(geometryId, cachedGeometry);
    try {
      this._putGeometryCommon(geometryId, geometry, cachedGeometry);
    } catch (error) {
      this._geometryCache.delete(geometryId);
      throw error;
    }
  }
  setPartialImage(imageId, partialImage) {
    const cachedImage = this._imageCache.get(imageId);
    if (!cachedImage) {
      if (partialImage) {
        this._imageCache.set(imageId, {
          image: partialImage,
          imageId,
          loaded: false,
          timeStamp: Date.now(),
          sizeInBytes: 0
        });
      }
      return;
    }
    if (cachedImage.loaded) {
      cachedImage.loaded = false;
      cachedImage.imageLoadObject = null;
      this.incrementImageCacheSize(-cachedImage.sizeInBytes);
      cachedImage.sizeInBytes = 0;
      cachedImage.image = partialImage || cachedImage.image;
    } else {
      cachedImage.image = partialImage || cachedImage.image;
    }
  }
  getImageQuality(imageId) {
    const image = this._imageCache.get(imageId)?.image;
    return image ? image.imageQualityStatus || ImageQualityStatus_default.FULL_RESOLUTION : undefined;
  }
}
var cache2 = new Cache;
var cache_default = cache2;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLTexture.js
function convertDataType(data, targetDataType) {
  const Constructor = getConstructorFromType(targetDataType);
  const convertedData = new Constructor(data.length);
  convertedData.set(data);
  return convertedData;
}
function vtkStreamingOpenGLTexture(publicAPI, model) {
  model.classHierarchy.push("vtkStreamingOpenGLTexture");
  model.updatedFrames = [];
  model.volumeId = null;
  const superCreate3DFilterableFromRaw = publicAPI.create3DFilterableFromRaw;
  publicAPI.create3DFilterableFromRaw = (width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy) => {
    model.inputDataType = dataType;
    model.inputNumComps = numberOfComponents;
    superCreate3DFilterableFromRaw(width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy);
  };
  const superUpdate = publicAPI.updateVolumeInfoForGL;
  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
    const isScalingApplied = superUpdate(dataType, numComps);
    model.volumeInfo.dataComputedScale = [1];
    model.volumeInfo.dataComputedOffset = [0];
    return isScalingApplied;
  };
  publicAPI.update3DFromRaw = () => {
    const { volumeId } = model;
    if (!volumeId) {
      return;
    }
    const volume = cache_default.getVolume(volumeId);
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    if (volume.isDynamicVolume()) {
      updateDynamicVolumeTexture();
      return;
    }
    return publicAPI.hasUpdatedFrames() && updateTextureImagesUsingVoxelManager();
  };
  const superModified = publicAPI.modified;
  publicAPI.setUpdatedFrame = (frameIndex) => {
    model.updatedFrames[frameIndex] = true;
    superModified();
  };
  publicAPI.modified = () => {
    superModified();
    const volume = cache_default.getVolume(model.volumeId);
    if (!volume) {
      return;
    }
    const imageIds = volume.imageIds;
    for (let i = 0;i < imageIds.length; i++) {
      model.updatedFrames[i] = true;
    }
  };
  function updateTextureImagesUsingVoxelManager() {
    const volume = cache_default.getVolume(model.volumeId);
    const imageIds = volume.imageIds;
    for (let i = 0;i < model.updatedFrames.length; i++) {
      if (model.updatedFrames[i]) {
        const image = cache_default.getImage(imageIds[i]);
        if (!image) {
          continue;
        }
        let data = image.voxelManager.getScalarData();
        const gl = model.context;
        if (volume.dataType !== data.constructor.name) {
          data = convertDataType(data, volume.dataType);
        }
        const [pixData] = publicAPI.updateArrayDataTypeForGL(volume.dataType, [
          data
        ]);
        publicAPI.bind();
        const zOffset = i;
        gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
        publicAPI.deactivate();
        model.updatedFrames[i] = null;
      }
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  }
  function updateDynamicVolumeTexture() {
    const volume = cache_default.getVolume(model.volumeId);
    const imageIds = volume.getCurrentDimensionGroupImageIds();
    if (!imageIds.length) {
      return false;
    }
    let constructor;
    for (let i = 0;i < imageIds.length; i++) {
      const imageId = imageIds[i];
      const image = cache_default.getImage(imageId);
      let data;
      if (!image) {
        constructor = getConstructorFromType(volume.dataType, true);
        data = new constructor(model.width * model.height);
      } else {
        data = image.voxelManager.getScalarData();
        constructor = data.constructor;
      }
      const gl = model.context;
      if (volume.dataType !== data.constructor.name) {
        data = convertDataType(data, volume.dataType);
      }
      const [pixData] = publicAPI.updateArrayDataTypeForGL(volume.dataType, [
        data
      ]);
      publicAPI.bind();
      let zOffset = i;
      gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
      publicAPI.deactivate();
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  }
  publicAPI.hasUpdatedFrames = () => !model.updatedFrames.length || model.updatedFrames.some((frame) => frame);
  publicAPI.getUpdatedFrames = () => model.updatedFrames;
  publicAPI.setVolumeId = (volumeId) => {
    model.volumeId = volumeId;
  };
  publicAPI.getVolumeId = () => model.volumeId;
  publicAPI.setTextureParameters = ({ width, height, depth, numberOfComponents, dataType }) => {
    model.width ??= width;
    model.height ??= height;
    model.depth ??= depth;
    model.inputNumComps ??= numberOfComponents;
    model.inputDataType ??= dataType;
  };
  publicAPI.getTextureParameters = () => ({
    width: model.width,
    height: model.height,
    depth: model.depth,
    numberOfComponents: model.inputNumComps,
    dataType: model.inputDataType
  });
}
var DEFAULT_VALUES72 = {
  updatedFrames: []
};
function extend75(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES72, initialValues);
  vtkOpenGLTexture$1.extend(publicAPI, model, initialValues);
  vtkStreamingOpenGLTexture(publicAPI, model);
}
var newInstance75 = macro.newInstance(extend75, "vtkStreamingOpenGLTexture");
var vtkStreamingOpenGLTexture_default = { newInstance: newInstance75, extend: extend75 };

// ../../node_modules/@kitware/vtk.js/Common/Core/Math.js
var import_seedrandom2 = __toESM(require_seedrandom2(), 1);
// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSlabCamera.js
var DEFAULT_VALUES73 = {
  isPerformingCoordinateTransformation: false
};
function extend76(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES73, initialValues);
  vtkCamera$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["isPerformingCoordinateTransformation"]);
  vtkSlabCamera(publicAPI, model);
}
var newInstance76 = macro.newInstance(extend76, "vtkSlabCamera");
function vtkSlabCamera(publicAPI, model) {
  model.classHierarchy.push("vtkSlabCamera");
  const tmpMatrix = exports_mat4.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = exports_mat4.create();
    if (model.projectionMatrix) {
      const scale8 = 1 / model.physicalScale;
      exports_vec3.set(tmpvec1, scale8, scale8, scale8);
      exports_mat4.copy(result, model.projectionMatrix);
      exports_mat4.scale(result, result, tmpvec1);
      exports_mat4.transpose(result, result);
      return result;
    }
    exports_mat4.identity(tmpMatrix);
    let cRange0 = model.clippingRange[0];
    let cRange1 = model.clippingRange[1];
    if (model.isPerformingCoordinateTransformation) {
      cRange0 = model.distance;
      cRange1 = model.distance + 0.1;
    }
    const cWidth = cRange1 - cRange0;
    const cRange = [
      cRange0 + (nearz + 1) * cWidth / 2,
      cRange0 + (farz + 1) * cWidth / 2
    ];
    if (model.parallelProjection) {
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      exports_mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      exports_mat4.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      const tmp = Math.tan(vtkMath.radiansFromDegrees(model.viewAngle) / 2);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = cRange0 * tmp;
        height = cRange0 * tmp / aspect;
      } else {
        width = cRange0 * tmp * aspect;
        height = cRange0 * tmp;
      }
      const xmin = (model.windowCenter[0] - 1) * width;
      const xmax = (model.windowCenter[0] + 1) * width;
      const ymin = (model.windowCenter[1] - 1) * height;
      const ymax = (model.windowCenter[1] + 1) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (xmax - xmin);
      tmpMatrix[5] = 2 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    exports_mat4.copy(result, tmpMatrix);
    return result;
  };
}
var vtkSlabCamera_default = { newInstance: newInstance76, extend: extend76 };

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
function isImageActor(actorEntry) {
  return actorIsA(actorEntry, "vtkVolume") || actorIsA(actorEntry, "vtkImageSlice");
}
function actorIsA(actorEntry, actorType) {
  const actorToCheck = "isA" in actorEntry ? actorEntry : actorEntry.actor;
  if (!actorToCheck) {
    return false;
  }
  return !!actorToCheck.isA(actorType);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var exports_metaData = {};
__export(exports_metaData, {
  removeProvider: () => removeProvider,
  removeAllProviders: () => removeAllProviders,
  get: () => getMetaData,
  addProvider: () => addProvider
});
var providers = [];
function addProvider(provider, priority = 0) {
  let i;
  for (i = 0;i < providers.length; i++) {
    if (providers[i].priority <= priority) {
      break;
    }
  }
  providers.splice(i, 0, {
    priority,
    provider
  });
}
function removeProvider(provider) {
  for (let i = 0;i < providers.length; i++) {
    if (providers[i].provider === provider) {
      providers.splice(i, 1);
      break;
    }
  }
}
function removeAllProviders() {
  while (providers.length > 0) {
    providers.pop();
  }
}
function getMetaData(type, ...queries) {
  for (let i = 0;i < providers.length; i++) {
    const result = providers[i].provider(type, ...queries);
    if (result !== undefined) {
      return result;
    }
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {
  const { direction, spacing } = imageVolume;
  const iVector = direction.slice(0, 3);
  const jVector = direction.slice(3, 6);
  const kVector = direction.slice(6, 9);
  const dotProducts = [
    exports_vec3.dot(iVector, viewPlaneNormal),
    exports_vec3.dot(jVector, viewPlaneNormal),
    exports_vec3.dot(kVector, viewPlaneNormal)
  ];
  const projectedSpacing = exports_vec3.create();
  exports_vec3.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);
  const spacingInNormalDirection = exports_vec3.length(projectedSpacing);
  return spacingInNormalDirection;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
function getClosestImageId(imageVolume, worldPos, viewPlaneNormal) {
  const { direction, spacing, imageIds } = imageVolume;
  if (!imageIds.length) {
    return;
  }
  const kVector = direction.slice(6, 9);
  const dotProducts = exports_vec3.dot(kVector, viewPlaneNormal);
  if (Math.abs(dotProducts) < 1 - epsilon_default) {
    return;
  }
  const spacingInNormalDirection = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);
  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
  let imageIdForTool;
  for (let i = 0;i < imageIds.length; i++) {
    const imageId = imageIds[i];
    const { imagePositionPatient } = getMetaData("imagePlaneModule", imageId);
    const dir = exports_vec3.create();
    exports_vec3.sub(dir, worldPos, imagePositionPatient);
    const dot6 = exports_vec3.dot(dir, viewPlaneNormal);
    if (Math.abs(dot6) < halfSpacingInNormalDirection) {
      imageIdForTool = imageId;
    }
  }
  return imageIdForTool;
}

// ../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var NoOp = (v) => v;
var EPSILON5 = 0.000001;

class Transform {
  constructor() {
    let useDegree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.matrix = exports_mat4.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? exports_common.toRadian : NoOp;
  }
  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);
    exports_vec3.set(src, originDirection[0], originDirection[1], originDirection[2]);
    exports_vec3.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    exports_vec3.normalize(src, src);
    exports_vec3.normalize(dst, dst);
    const cosAlpha = exports_vec3.dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }
    exports_vec3.cross(this.tmp, src, dst);
    if (exports_vec3.length(this.tmp) < EPSILON5) {
      exports_vec3.cross(this.tmp, [1, 0, 0], originDirection);
      if (exports_vec3.length(this.tmp) < EPSILON5) {
        exports_vec3.cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    exports_mat4.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    exports_mat4.multiply(this.matrix, this.matrix, transf);
    return this;
  }
  rotate(angle3, axis) {
    exports_vec3.set(this.tmp, ...axis);
    exports_vec3.normalize(this.tmp, this.tmp);
    exports_mat4.rotate(this.matrix, this.matrix, this.angleConv(angle3), this.tmp);
    return this;
  }
  rotateX(angle3) {
    exports_mat4.rotateX(this.matrix, this.matrix, this.angleConv(angle3));
    return this;
  }
  rotateY(angle3) {
    exports_mat4.rotateY(this.matrix, this.matrix, this.angleConv(angle3));
    return this;
  }
  rotateZ(angle3) {
    exports_mat4.rotateZ(this.matrix, this.matrix, this.angleConv(angle3));
    return this;
  }
  translate(x, y, z) {
    exports_vec3.set(this.tmp, x, y, z);
    exports_mat4.translate(this.matrix, this.matrix, this.tmp);
    return this;
  }
  scale(sx, sy, sz) {
    exports_vec3.set(this.tmp, sx, sy, sz);
    exports_mat4.scale(this.matrix, this.matrix, this.tmp);
    return this;
  }
  multiply(mat4x4) {
    exports_mat4.multiply(this.matrix, this.matrix, mat4x4);
    return this;
  }
  multiply3x3(mat3x3) {
    exports_mat4.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
    return this;
  }
  invert() {
    exports_mat4.invert(this.matrix, this.matrix);
    return this;
  }
  identity() {
    exports_mat4.identity(this.matrix);
    return this;
  }
  apply(typedArray) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let nbIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    if (areMatricesEqual(IDENTITY, this.matrix)) {
      return this;
    }
    const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
    for (let i = offset;i < size; i += 3) {
      exports_vec3.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
      exports_vec3.transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i] = this.tmp[0];
      typedArray[i + 1] = this.tmp[1];
      typedArray[i + 2] = this.tmp[2];
    }
    return this;
  }
  getMatrix() {
    return this.matrix;
  }
  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      exports_mat4.copy(this.matrix, mat4x4);
    }
    return this;
  }
}
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js
function getVolumeActorCorners(volumeActor) {
  const imageData = volumeActor.getMapper().getInputData();
  const bounds = imageData.extentToBounds(imageData.getExtent());
  return [
    [bounds[0], bounds[2], bounds[4]],
    [bounds[0], bounds[2], bounds[5]],
    [bounds[0], bounds[3], bounds[4]],
    [bounds[0], bounds[3], bounds[5]],
    [bounds[1], bounds[2], bounds[4]],
    [bounds[1], bounds[2], bounds[5]],
    [bounds[1], bounds[3], bounds[4]],
    [bounds[1], bounds[3], bounds[5]]
  ];
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js
var SMALL_EPSILON = epsilon_default * epsilon_default;
var isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;
var isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);
var isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);
function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {
  const imageData = volumeActor.getMapper().getInputData();
  let corners;
  const direction = imageData.getDirection();
  if (isOrthonormal(direction)) {
    corners = getVolumeActorCorners(volumeActor);
  } else {
    const [dx, dy2, dz] = imageData.getDimensions();
    const cornersIdx = [
      [0, 0, 0],
      [dx - 1, 0, 0],
      [0, dy2 - 1, 0],
      [dx - 1, dy2 - 1, 0],
      [0, 0, dz - 1],
      [dx - 1, 0, dz - 1],
      [0, dy2 - 1, dz - 1],
      [dx - 1, dy2 - 1, dz - 1]
    ];
    corners = cornersIdx.map((it) => imageData.indexToWorld(it));
  }
  const transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(viewPlaneNormal, [1, 0, 0]);
  corners.forEach((pt) => transform.apply(pt));
  const transformedFocalPoint = [...focalPoint];
  transform.apply(transformedFocalPoint);
  const currentSlice = transformedFocalPoint[0];
  let minX = Infinity;
  let maxX = -Infinity;
  for (let i = 0;i < 8; i++) {
    const x = corners[i][0];
    if (x > maxX) {
      maxX = x;
    }
    if (x < minX) {
      minX = x;
    }
  }
  return {
    min: minX,
    max: maxX,
    current: currentSlice,
    actor: volumeActor,
    viewPlaneNormal,
    focalPoint
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js
function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {
  const { min: min5, max: max5, current } = sliceRange;
  const posDiffFromFocalPoint = exports_vec3.create();
  exports_vec3.sub(posDiffFromFocalPoint, position, focalPoint);
  const steps = Math.round((max5 - min5) / spacingInNormalDirection);
  const fraction = (current - min5) / (max5 - min5);
  const floatingStepNumber = fraction * steps;
  let frameIndex = Math.round(floatingStepNumber);
  let newFocalPoint = [
    focalPoint[0] - viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,
    focalPoint[1] - viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,
    focalPoint[2] - viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection
  ];
  frameIndex += deltaFrames;
  if (frameIndex > steps) {
    frameIndex = steps;
  } else if (frameIndex < 0) {
    frameIndex = 0;
  }
  const newSlicePosFromMin = frameIndex * spacingInNormalDirection;
  newFocalPoint = [
    newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,
    newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,
    newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin
  ];
  const newPosition = [
    newFocalPoint[0] + posDiffFromFocalPoint[0],
    newFocalPoint[1] + posDiffFromFocalPoint[1],
    newFocalPoint[2] + posDiffFromFocalPoint[2]
  ];
  return { newFocalPoint, newPosition };
}

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
var ColorSpace = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
var Scale = {
  LINEAR: 0,
  LOG10: 1
};
var Constants17 = {
  ColorSpace,
  Scale
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
var {
  ColorSpace: ColorSpace2,
  Scale: Scale2
} = Constants17;
var {
  ScalarMappingTarget: ScalarMappingTarget3
} = vtkScalarsToColors$1;
var {
  vtkDebugMacro: vtkDebugMacro9,
  vtkErrorMacro: vtkErrorMacro30,
  vtkWarningMacro: vtkWarningMacro10
} = macro;
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  const L = lab[0];
  const a = lab[1];
  const b = lab[2];
  const M = Math.sqrt(L * L + a * a + b * b);
  const s = M > 0.001 ? Math.acos(L / M) : 0;
  const h = s > 0.001 ? Math.atan2(b, a) : 0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  const M = msh[0];
  const s = msh[1];
  const h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    return msh[2];
  }
  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  let adiff = a1 - a2;
  if (adiff < 0) {
    adiff = -adiff;
  }
  while (adiff >= 2 * Math.PI) {
    adiff -= 2 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2 * Math.PI - adiff;
  }
  return adiff;
}
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  const lab1 = [];
  const lab2 = [];
  rgb2lab(rgb1, lab1);
  rgb2lab(rgb2, lab2);
  const msh1 = [];
  const msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);
  let localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    let Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0;
      msh2[2] = 0;
      localS *= 2;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0;
      msh1[2] = 0;
      localS = 2 * localS - 1;
    }
  }
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  const mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
  const labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  lab2rgb(labTmp, result);
}
function vtkColorTransferFunction(publicAPI, model) {
  model.classHierarchy.push("vtkColorTransferFunction");
  publicAPI.getSize = () => model.nodes.length;
  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0);
  publicAPI.addRGBPointLong = function(x, r, g, b) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro30("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro30("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    const node = {
      x,
      r,
      g,
      b,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    let i = 0;
    for (;i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
  publicAPI.addHSVPointLong = function(x, h, s, v) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    const rgb = [];
    const hsv = [h, s, v];
    hsv2rgb(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };
  publicAPI.setNodes = (nodes) => {
    if (model.nodes !== nodes) {
      const before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      const after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };
  publicAPI.sortAndUpdateRange = () => {
    const before = JSON.stringify(model.nodes);
    model.nodes.sort((a, b) => a.x - b.x);
    const after = JSON.stringify(model.nodes);
    const modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };
  publicAPI.updateRange = () => {
    const oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    const size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = (x) => {
    let i = 0;
    for (;i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    const retVal = i;
    if (i >= model.nodes.length) {
      return -1;
    }
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.movePoint = (oldX, newX) => {
    if (oldX === newX) {
      return;
    }
    publicAPI.removePoint(newX);
    for (let i = 0;i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b22) => {
    publicAPI.sortAndUpdateRange();
    for (let i = 0;i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
    publicAPI.addRGBPointLong(x2, r2, g2, b22, 0.5, 0);
    publicAPI.modified();
  };
  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s22, v2) => {
    const hsv1 = [h1, s1, v1];
    const hsv2 = [h2, s22, v2];
    const rgb1 = [];
    const rgb2 = [];
    hsv2rgb(hsv1, rgb1);
    hsv2rgb(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };
  publicAPI.mapValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255 * rgb[0] + 0.5), Math.floor(255 * rgb[1] + 0.5), Math.floor(255 * rgb[2] + 0.5), 255];
  };
  publicAPI.getColor = (x, rgb) => {
    if (model.indexedLookup) {
      const numNodes = publicAPI.getSize();
      const idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        const nanColor = publicAPI.getNanColorByReference();
        rgb[0] = nanColor[0];
        rgb[1] = nanColor[1];
        rgb[2] = nanColor[2];
      } else {
        const nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        rgb[0] = nodeVal[1];
        rgb[1] = nodeVal[2];
        rgb[2] = nodeVal[3];
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };
  publicAPI.getRedValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };
  publicAPI.getGreenValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };
  publicAPI.getBlueValue = (x) => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };
  publicAPI.getTable = (xStart_, xEnd_, size, table) => {
    const xStart = Number(xStart_);
    const xEnd = Number(xEnd_);
    if (isNan(xStart) || isNan(xEnd)) {
      for (let i = 0;i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    let idx = 0;
    const numNodes = model.nodes.length;
    let lastR = 0;
    let lastG = 0;
    let lastB = 0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    let x = 0;
    let x1 = 0;
    let x2 = 0;
    const rgb1 = [0, 0, 0];
    const rgb2 = [0, 0, 0];
    let midpoint = 0;
    let sharpness = 0;
    const tmpVec = [];
    let usingLogScale = model.scale === Scale2.LOG10;
    if (usingLogScale) {
      usingLogScale = model.mappingRange[0] > 0;
    }
    let logStart = 0;
    let logEnd = 0;
    let logX = 0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }
    for (let i = 0;i < size; i++) {
      const tidx = 3 * i;
      if (size > 1) {
        if (usingLogScale) {
          logX = logStart + i / (size - 1) * (logEnd - logStart);
          x = 10 ** logX;
        } else {
          x = xStart + i / (size - 1) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = 10 ** logX;
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      if (model.discretize) {
        const range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          const numberOfValues = model.numberOfValues;
          const deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2;
          } else {
            const xn = (x - range[0]) / deltaRange;
            const discretizeIndex = floor(numberOfValues * xn);
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (x > model.mappingRange[1]) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 0.000001 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
        }
      } else {
        let s = 0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }
        if (sharpness < 0.01) {
          if (model.colorSpace === ColorSpace2.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace2.HSV) {
            const hsv1 = [];
            const hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            const hsvTmp = [];
            hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0) {
              hsvTmp[0] += 1;
            }
            hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.LAB) {
            const lab1 = [];
            const lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            const labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro30("ColorSpace set to invalid value.", model.colorSpace);
          }
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * ((1 - s) * 2) ** (1 + 10 * sharpness);
        }
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        let slope;
        let t;
        if (model.colorSpace === ColorSpace2.RGB) {
          for (let j = 0;j < 3; j++) {
            slope = rgb2[j] - rgb1[j];
            t = (1 - sharpness) * slope;
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace2.HSV) {
          const hsv1 = [];
          const hsv2 = [];
          rgb2hsv(rgb1, hsv1);
          rgb2hsv(rgb2, hsv2);
          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
            if (hsv1[0] > hsv2[0]) {
              hsv1[0] -= 1;
            } else {
              hsv2[0] -= 1;
            }
          }
          const hsvTmp = [];
          for (let j = 0;j < 3; j++) {
            slope = hsv2[j] - hsv1[j];
            t = (1 - sharpness) * slope;
            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;
            if (j === 0 && hsvTmp[j] < 0) {
              hsvTmp[j] += 1;
            }
          }
          hsv2rgb(hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.LAB) {
          const lab1 = [];
          const lab2 = [];
          rgb2lab(rgb1, lab1);
          rgb2lab(rgb2, lab2);
          const labTmp = [];
          for (let j = 0;j < 3; j++) {
            slope = lab2[j] - lab1[j];
            t = (1 - sharpness) * slope;
            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;
          }
          lab2rgb(labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.DIVERGING) {
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro30("ColorSpace set to invalid value.");
        }
        for (let j = 0;j < 3; j++) {
          table[tidx + j] = table[tidx + j] < 0 ? 0 : table[tidx + j];
          table[tidx + j] = table[tidx + j] > 1 ? 1 : table[tidx + j];
        }
      }
    }
  };
  publicAPI.getUint8Table = function(xStart, xEnd, size) {
    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro30("Attempting to lookup a value with no points in the function");
      return model.table;
    }
    const nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    const tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (let i = 0;i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromArray = (array) => {
    publicAPI.removeAllPoints();
    const numComponents = array.getNumberOfComponents();
    for (let i = 0;i < array.getNumberOfTuples(); i++) {
      switch (numComponents) {
        case 3: {
          model.nodes.push({
            x: i,
            r: array.getComponent(i, 0),
            g: array.getComponent(i, 1),
            b: array.getComponent(i, 2),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 4: {
          model.nodes.push({
            x: array.getComponent(i, 0),
            r: array.getComponent(i, 1),
            g: array.getComponent(i, 2),
            b: array.getComponent(i, 3),
            midpoint: 0.5,
            sharpness: 0
          });
          break;
        }
        case 5: {
          model.nodes.push({
            x: i,
            r: array.getComponent(i, 0),
            g: array.getComponent(i, 1),
            b: array.getComponent(i, 2),
            midpoint: array.getComponent(i, 4),
            sharpness: array.getComponent(i, 5)
          });
          break;
        }
        case 6: {
          model.nodes.push({
            x: array.getComponent(i, 0),
            r: array.getComponent(i, 1),
            g: array.getComponent(i, 2),
            b: array.getComponent(i, 3),
            midpoint: array.getComponent(i, 4),
            sharpness: array.getComponent(i, 5)
          });
          break;
        }
      }
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {
    let inc = 0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1);
    }
    for (let i = 0;i < size; i++) {
      const node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.getNodeValue = (index2, val) => {
    if (index2 < 0 || index2 >= model.nodes.length) {
      vtkErrorMacro30("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index2].x;
    val[1] = model.nodes[index2].r;
    val[2] = model.nodes[index2].g;
    val[3] = model.nodes[index2].b;
    val[4] = model.nodes[index2].midpoint;
    val[5] = model.nodes[index2].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = (index2, val) => {
    if (index2 < 0 || index2 >= model.nodes.length) {
      vtkErrorMacro30("Index out of range!");
      return -1;
    }
    const oldX = model.nodes[index2].x;
    model.nodes[index2].x = val[0];
    model.nodes[index2].r = val[1];
    model.nodes[index2].g = val[2];
    model.nodes[index2].b = val[3];
    model.nodes[index2].midpoint = val[4];
    model.nodes[index2].sharpness = val[5];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.getNumberOfAvailableColors = () => {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      return model.tableSize;
    }
    const nNodes = model.nodes?.length ?? 0;
    return Math.max(4094, nNodes);
  };
  publicAPI.getIndexedColor = (idx, rgba) => {
    const n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      const nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (let j = 0;j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1;
      return;
    }
    const nanColor = publicAPI.getNanColorByReference();
    rgba[0] = nanColor[0];
    rgba[1] = nanColor[1];
    rgba[2] = nanColor[2];
    rgba[3] = 1;
  };
  publicAPI.fillFromDataPointer = (nb, ptr) => {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (let i = 0;i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };
  publicAPI.setMappingRange = (min5, max5) => {
    const range = [min5, max5];
    const originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro30("attempt to set zero width color range");
      return;
    }
    const scale8 = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    const shift = range[0] - originalRange[0] * scale8;
    for (let i = 0;i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale8 + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };
  publicAPI.adjustRange = (range) => {
    const functionRange = publicAPI.getRange();
    const rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }
    publicAPI.sortAndUpdateRange();
    for (let i = 0;i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = () => {
    if (model.nodes.length < 2) {
      return -1;
    }
    let distance4 = Number.MAX_VALUE;
    for (let i = 0;i < model.nodes.length - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance4) {
        distance4 = currentDist;
      }
    }
    return distance4;
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro9("Transfer Function Has No Points!");
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };
  publicAPI.mapData = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro10("Transfer Function Has No Points!");
      return;
    }
    const alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
    const length5 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    const rgb = [];
    if (outFormat === ScalarMappingTarget3.RGBA) {
      for (let i = 0;i < length5; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget3.RGB) {
      for (let i = 0;i < length5; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 3] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget3.LUMINANCE) {
      for (let i = 0;i < length5; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget3.LUMINANCE_ALPHA) {
      for (let i = 0;i < length5; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[i * 2 + 1] = alpha;
      }
    }
  };
  publicAPI.applyColorMap = (colorMap) => {
    const oldColorSpace = JSON.stringify(model.colorSpace);
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace2[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === undefined) {
        vtkErrorMacro30(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);
        model.colorSpace = ColorSpace2.RGB;
      }
    }
    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);
    const oldNanColor = isModified || JSON.stringify(model.nanColor);
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1);
      }
    }
    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);
    const oldNodes = isModified || JSON.stringify(model.nodes);
    if (colorMap.RGBPoints) {
      const size = colorMap.RGBPoints.length;
      model.nodes = [];
      const midpoint = 0.5;
      const sharpness = 0;
      for (let i = 0;i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    const modifiedInvoked = publicAPI.sortAndUpdateRange();
    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));
    if (callModified)
      publicAPI.modified();
    return modifiedInvoked || callModified;
  };
}
var DEFAULT_VALUES74 = {
  clamping: true,
  colorSpace: ColorSpace2.RGB,
  hSVWrap: true,
  scale: Scale2.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};
function extend77(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES74, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0, 0, 1];
  model.belowRangeColor = [0, 0, 0, 1];
  model.aboveRangeColor = [1, 1, 1, 1];
  model.buildTime = {};
  macro.obj(model.buildTime);
  macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
  macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "discretize", "numberOfValues", {
    type: "enum",
    name: "colorSpace",
    enum: ColorSpace2
  }, {
    type: "enum",
    name: "scale",
    enum: Scale2
  }]);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkColorTransferFunction(publicAPI, model);
}
var newInstance77 = macro.newInstance(extend77, "vtkColorTransferFunction");
var vtkColorTransferFunction$1 = {
  newInstance: newInstance77,
  extend: extend77,
  ...Constants17
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.json.js
var vtkColorMaps = [
  {
    Name: "KAAMS",
    IndexedColors: [
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      0.63,
      0.63,
      1,
      0.67,
      0.5,
      0.33,
      1,
      0.5,
      0.75,
      0.53,
      0.35,
      0.7,
      1,
      0.75,
      0.5
    ],
    Annotations: [
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Cool to Warm",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.23137254902,
      0.298039215686,
      0.752941176471,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.705882352941,
      0.0156862745098,
      0.149019607843
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Cool to Warm (Extended)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0.34902,
      0.03125,
      0.039216,
      0.062745,
      0.380392,
      0.0625,
      0.062745,
      0.117647,
      0.411765,
      0.09375,
      0.090196,
      0.184314,
      0.45098,
      0.125,
      0.12549,
      0.262745,
      0.501961,
      0.15625,
      0.160784,
      0.337255,
      0.541176,
      0.1875,
      0.2,
      0.396078,
      0.568627,
      0.21875,
      0.239216,
      0.454902,
      0.6,
      0.25,
      0.286275,
      0.521569,
      0.65098,
      0.28125,
      0.337255,
      0.592157,
      0.701961,
      0.3125,
      0.388235,
      0.654902,
      0.74902,
      0.34375,
      0.466667,
      0.737255,
      0.819608,
      0.375,
      0.572549,
      0.819608,
      0.878431,
      0.40625,
      0.654902,
      0.866667,
      0.909804,
      0.4375,
      0.752941,
      0.917647,
      0.941176,
      0.46875,
      0.823529,
      0.956863,
      0.968627,
      0.5,
      0.988235,
      0.960784,
      0.901961,
      0.5,
      0.941176,
      0.984314,
      0.988235,
      0.52,
      0.988235,
      0.945098,
      0.85098,
      0.54,
      0.980392,
      0.898039,
      0.784314,
      0.5625,
      0.968627,
      0.835294,
      0.698039,
      0.59375,
      0.94902,
      0.733333,
      0.588235,
      0.625,
      0.929412,
      0.65098,
      0.509804,
      0.65625,
      0.909804,
      0.564706,
      0.435294,
      0.6875,
      0.878431,
      0.458824,
      0.352941,
      0.71875,
      0.839216,
      0.388235,
      0.286275,
      0.75,
      0.760784,
      0.294118,
      0.211765,
      0.78125,
      0.701961,
      0.211765,
      0.168627,
      0.8125,
      0.65098,
      0.156863,
      0.129412,
      0.84375,
      0.6,
      0.094118,
      0.094118,
      0.875,
      0.54902,
      0.066667,
      0.098039,
      0.90625,
      0.501961,
      0.05098,
      0.12549,
      0.9375,
      0.45098,
      0.054902,
      0.172549,
      0.96875,
      0.4,
      0.054902,
      0.192157,
      1,
      0.34902,
      0.070588,
      0.211765
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Warm to Cool",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.705882352941,
      0.0156862745098,
      0.149019607843,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.23137254902,
      0.298039215686,
      0.752941176471
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Warm to Cool (Extended)",
    NanColor: [
      0.250004,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.34902,
      0,
      0.129412,
      0.025,
      0.4,
      0.00392157,
      0.101961,
      0.05,
      0.470588,
      0.0156863,
      0.0901961,
      0.075,
      0.54902,
      0.027451,
      0.0705882,
      0.1,
      0.619608,
      0.0627451,
      0.0431373,
      0.125,
      0.690196,
      0.12549,
      0.0627451,
      0.15,
      0.741176,
      0.184314,
      0.0745098,
      0.175,
      0.788235,
      0.266667,
      0.0941176,
      0.2,
      0.811765,
      0.345098,
      0.113725,
      0.225,
      0.831373,
      0.411765,
      0.133333,
      0.25,
      0.85098,
      0.47451,
      0.145098,
      0.275,
      0.870588,
      0.54902,
      0.156863,
      0.3,
      0.878431,
      0.619608,
      0.168627,
      0.325,
      0.890196,
      0.658824,
      0.196078,
      0.35,
      0.909804,
      0.717647,
      0.235294,
      0.375,
      0.929412,
      0.776471,
      0.278431,
      0.395522,
      0.94902,
      0.823529,
      0.321569,
      0.418905,
      0.968627,
      0.87451,
      0.407843,
      0.444278,
      0.980392,
      0.917647,
      0.509804,
      0.470149,
      0.988235,
      0.956863,
      0.643137,
      0.483582,
      0.992157,
      0.964706,
      0.713725,
      0.499,
      0.988235,
      0.980392,
      0.870588,
      0.5,
      1,
      1,
      1,
      0.501,
      0.913725,
      0.988235,
      0.937255,
      0.516418,
      0.827451,
      0.980392,
      0.886275,
      0.531343,
      0.764706,
      0.980392,
      0.866667,
      0.546766,
      0.658824,
      0.980392,
      0.843137,
      0.564179,
      0.572549,
      0.964706,
      0.835294,
      0.587562,
      0.423529,
      0.941176,
      0.87451,
      0.60597,
      0.262745,
      0.901961,
      0.862745,
      0.629851,
      0.0705882,
      0.854902,
      0.870588,
      0.651741,
      0.0509804,
      0.8,
      0.85098,
      0.681592,
      0.0235294,
      0.709804,
      0.831373,
      0.712935,
      0.0313725,
      0.615686,
      0.811765,
      0.75,
      0.0313725,
      0.537255,
      0.788235,
      0.775,
      0.0392157,
      0.466667,
      0.768627,
      0.8,
      0.0509804,
      0.396078,
      0.741176,
      0.825,
      0.054902,
      0.317647,
      0.709804,
      0.85,
      0.054902,
      0.243137,
      0.678431,
      0.875,
      0.0431373,
      0.164706,
      0.639216,
      0.9,
      0.0313725,
      0.0980392,
      0.6,
      0.925,
      0.0392157,
      0.0392157,
      0.560784,
      0.95,
      0.105882,
      0.0509804,
      0.509804,
      0.975,
      0.113725,
      0.0235294,
      0.45098,
      1,
      0.12549,
      0,
      0.380392
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Desaturated",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.278431372549,
      0.278431372549,
      0.858823529412,
      0.143,
      0,
      0,
      0.360784313725,
      0.285,
      0,
      1,
      1,
      0.429,
      0,
      0.501960784314,
      0,
      0.571,
      1,
      1,
      0,
      0.714,
      1,
      0.380392156863,
      0,
      0.857,
      0.419607843137,
      0,
      0,
      1,
      0.878431372549,
      0.301960784314,
      0.301960784314
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Cold and Hot",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      1,
      1,
      0.45,
      0,
      0,
      1,
      0.5,
      0,
      0,
      0.501960784314,
      0.55,
      1,
      0,
      0,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black-Body Radiation",
    NanColor: [
      0,
      0.498039215686,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.4,
      0.901960784314,
      0,
      0,
      0.8,
      0.901960784314,
      0.901960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "X Ray",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Grayscale",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkRd",
    NanColor: [
      0,
      1,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkGn",
    NanColor: [
      1,
      0,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkBu",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkMa",
    NanColor: [
      0,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "BkCy",
    NanColor: [
      0,
      1,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Blue and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0,
      0,
      0.501960784314,
      0.666,
      0,
      0.501960784314,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Orange and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0.501960784314,
      0,
      0,
      0.666,
      1,
      0.501960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Linear YGB 1211g",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      0.988235,
      0.968627,
      0.02,
      1,
      0.952941,
      0.878431,
      0.05,
      0.968627,
      0.905882,
      0.776471,
      0.1,
      0.94902,
      0.898039,
      0.647059,
      0.15,
      0.901961,
      0.878431,
      0.556863,
      0.2,
      0.847059,
      0.858824,
      0.482353,
      0.25,
      0.690196,
      0.819608,
      0.435294,
      0.3,
      0.513725,
      0.768627,
      0.384314,
      0.35,
      0.337255,
      0.721569,
      0.337255,
      0.4,
      0.278431,
      0.658824,
      0.392157,
      0.45,
      0.231373,
      0.639216,
      0.435294,
      0.5,
      0.203922,
      0.6,
      0.486275,
      0.55,
      0.172549,
      0.568627,
      0.537255,
      0.6,
      0.141176,
      0.517647,
      0.54902,
      0.65,
      0.133333,
      0.458824,
      0.541176,
      0.7,
      0.12549,
      0.396078,
      0.529412,
      0.75,
      0.117647,
      0.321569,
      0.521569,
      0.8,
      0.121569,
      0.258824,
      0.509804,
      0.85,
      0.133333,
      0.227451,
      0.501961,
      0.9,
      0.145098,
      0.192157,
      0.490196,
      0.95,
      0.188235,
      0.164706,
      0.470588,
      1,
      0.258824,
      0.196078,
      0.439216
    ]
  },
  {
    ColorSpace: "CIELAB",
    Creator: "Francesca Samsel",
    Name: "Linear Green (Gr4L)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.054902,
      0.109804,
      0.121569,
      0.05,
      0.07451,
      0.172549,
      0.180392,
      0.1,
      0.086275,
      0.231373,
      0.219608,
      0.15,
      0.094118,
      0.278431,
      0.25098,
      0.2,
      0.109804,
      0.34902,
      0.278431,
      0.25,
      0.113725,
      0.4,
      0.278431,
      0.3,
      0.117647,
      0.45098,
      0.270588,
      0.35,
      0.117647,
      0.490196,
      0.243137,
      0.4,
      0.113725,
      0.521569,
      0.203922,
      0.45,
      0.109804,
      0.54902,
      0.152941,
      0.5,
      0.082353,
      0.588235,
      0.082353,
      0.55,
      0.109804,
      0.631373,
      0.05098,
      0.6,
      0.211765,
      0.678431,
      0.082353,
      0.65,
      0.317647,
      0.721569,
      0.113725,
      0.7,
      0.431373,
      0.760784,
      0.160784,
      0.75,
      0.556863,
      0.8,
      0.239216,
      0.8,
      0.666667,
      0.839216,
      0.294118,
      0.85,
      0.784314,
      0.878431,
      0.396078,
      0.9,
      0.886275,
      0.921569,
      0.533333,
      0.95,
      0.960784,
      0.94902,
      0.670588,
      1,
      1,
      0.984314,
      0.901961
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Linear Blue (8_31f)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.960784,
      1,
      0.980392,
      0.05,
      0.815686,
      0.960784,
      0.913725,
      0.1,
      0.670588,
      0.929412,
      0.870588,
      0.15,
      0.556863,
      0.901961,
      0.843137,
      0.2,
      0.478431,
      0.870588,
      0.823529,
      0.25,
      0.439216,
      0.831373,
      0.803922,
      0.3,
      0.4,
      0.8,
      0.788235,
      0.35,
      0.376471,
      0.768627,
      0.768627,
      0.4,
      0.34902,
      0.709804,
      0.729412,
      0.45,
      0.32549,
      0.654902,
      0.690196,
      0.5,
      0.301961,
      0.607843,
      0.658824,
      0.55,
      0.247059,
      0.545098,
      0.619608,
      0.6,
      0.239216,
      0.494118,
      0.580392,
      0.65,
      0.227451,
      0.439216,
      0.541176,
      0.7,
      0.227451,
      0.403922,
      0.521569,
      0.75,
      0.231373,
      0.368627,
      0.501961,
      0.8,
      0.227451,
      0.321569,
      0.470588,
      0.85,
      0.219608,
      0.282353,
      0.439216,
      0.9,
      0.192157,
      0.235294,
      0.4,
      0.95,
      0.160784,
      0.184314,
      0.34902,
      1,
      0.133333,
      0.12549,
      0.301961
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "Blue to Red Rainbow",
    NanColor: [
      0.498039215686,
      0.498039215686,
      0.498039215686
    ],
    RGBPoints: [
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "Red to Blue Rainbow",
    NanColor: [
      0.498039215686,
      0.498039215686,
      0.498039215686
    ],
    RGBPoints: [
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended Grey",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.317647058824,
      0.341176470588,
      0.43137254902,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Blended Black",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.17,
      0,
      0,
      1,
      0.34,
      0,
      1,
      1,
      0.5,
      0,
      1,
      0,
      0.67,
      1,
      1,
      0,
      0.84,
      1,
      0,
      0,
      1,
      0.878431372549,
      0,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Blue to Yellow",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.0392156862745,
      0.0392156862745,
      0.949019607843,
      1,
      0.949019607843,
      0.949019607843,
      0.0392156862745
    ]
  },
  {
    ColorSpace: "HSV",
    Name: "blot",
    RGBPoints: [
      0,
      0,
      0,
      1,
      0.166,
      0,
      0,
      1,
      0.167,
      1,
      0,
      1,
      0.332,
      1,
      0,
      1,
      0.333,
      0,
      1,
      1,
      0.5,
      0,
      1,
      1,
      0.501,
      0,
      1,
      0,
      0.666,
      0,
      1,
      0,
      0.667,
      1,
      1,
      0,
      0.832,
      1,
      1,
      0,
      0.833,
      1,
      0,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "CIELab Blue to Red",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0.6,
      0.749019607843,
      1,
      0.76862745098,
      0.466666666667,
      0.341176470588
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "jet",
    RGBPoints: [
      -1,
      0,
      0,
      0.5625,
      -0.777778,
      0,
      0,
      1,
      -0.269841,
      0,
      1,
      1,
      -0.015873,
      0.5,
      1,
      0.5,
      0.238095,
      1,
      1,
      0,
      0.746032,
      1,
      0,
      0,
      1,
      0.5,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "rainbow",
    RGBPoints: [
      -1,
      0,
      0,
      1,
      -0.5,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      0.5,
      1,
      1,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_bright",
    RGBPoints: [
      -1,
      0.32549,
      0.14902,
      0.960784,
      -0.866221,
      0.297047,
      0.375586,
      0.963836,
      -0.732441,
      0.180302,
      0.536818,
      0.964627,
      -0.598662,
      0.1302,
      0.649207,
      0.929647,
      -0.464883,
      0.0445143,
      0.749654,
      0.855998,
      -0.331104,
      0.0271325,
      0.830713,
      0.721527,
      -0.197324,
      0.259504,
      0.866145,
      0.543555,
      -0.0635452,
      0.428364,
      0.890725,
      0.329819,
      0.0702341,
      0.568503,
      0.898508,
      0.187623,
      0.204013,
      0.738259,
      0.890317,
      0.0825461,
      0.337793,
      0.84546,
      0.86136,
      0.0147555,
      0.471572,
      0.912191,
      0.808018,
      0,
      0.605351,
      0.962848,
      0.710445,
      0,
      0.73913,
      0.999469,
      0.600258,
      0.0176284,
      0.87291,
      0.994156,
      0.445975,
      0.193912,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_dark",
    RGBPoints: [
      -1,
      0,
      0,
      0.423499,
      -0.866221,
      0,
      0.119346,
      0.529237,
      -0.732441,
      0,
      0.238691,
      0.634976,
      -0.598662,
      0,
      0.346852,
      0.68788,
      -0.464883,
      0,
      0.45022,
      0.718141,
      -0.331104,
      0,
      0.553554,
      0.664839,
      -0.197324,
      0,
      0.651082,
      0.519303,
      -0.0635452,
      0.115841,
      0.72479,
      0.352857,
      0.0702341,
      0.326771,
      0.781195,
      0.140187,
      0.204013,
      0.522765,
      0.798524,
      0.0284624,
      0.337793,
      0.703162,
      0.788685,
      0.00885756,
      0.471572,
      0.845118,
      0.751133,
      0,
      0.605351,
      0.955734,
      0.690825,
      0,
      0.73913,
      0.995402,
      0.567916,
      0.0618524,
      0.87291,
      0.987712,
      0.403398,
      0.164851,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_CubicL",
    RGBPoints: [
      -1,
      0.479965,
      0.0118108,
      0.5307,
      -0.87451,
      0.522213,
      0.0551282,
      0.706919,
      -0.74902,
      0.50839,
      0.237278,
      0.867764,
      -0.623529,
      0.451617,
      0.373834,
      0.987255,
      -0.498039,
      0.39365,
      0.497255,
      0.97506,
      -0.372549,
      0.328631,
      0.599639,
      0.891843,
      -0.247059,
      0.250043,
      0.690286,
      0.778553,
      -0.121569,
      0.249656,
      0.764905,
      0.645857,
      0.00392157,
      0.297954,
      0.821466,
      0.50449,
      0.129412,
      0.337509,
      0.872595,
      0.358447,
      0.254902,
      0.430011,
      0.913789,
      0.297079,
      0.380392,
      0.587191,
      0.931381,
      0.333353,
      0.505882,
      0.727937,
      0.93591,
      0.353742,
      0.631373,
      0.826403,
      0.921081,
      0.365066,
      0.756863,
      0.893201,
      0.846317,
      0.372662,
      0.882353,
      0.965347,
      0.73884,
      0.378506,
      1,
      0.983235,
      0.597451,
      0.366856
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_CubicYF",
    RGBPoints: [
      -1,
      0.5151,
      0.0482,
      0.6697,
      -0.87451,
      0.520711,
      0.168955,
      0.800574,
      -0.74902,
      0.493694,
      0.278596,
      0.911824,
      -0.623529,
      0.440026,
      0.369475,
      0.984978,
      -0.498039,
      0.398932,
      0.457593,
      0.987053,
      -0.372549,
      0.350651,
      0.540644,
      0.929608,
      -0.247059,
      0.298827,
      0.615625,
      0.857729,
      -0.121569,
      0.239928,
      0.685061,
      0.769531,
      0.00392157,
      0.228832,
      0.739349,
      0.673287,
      0.129412,
      0.263297,
      0.78608,
      0.569988,
      0.254902,
      0.298107,
      0.828337,
      0.460214,
      0.380392,
      0.33092,
      0.864071,
      0.352674,
      0.505882,
      0.38306,
      0.898169,
      0.287309,
      0.631373,
      0.49023,
      0.917481,
      0.307961,
      0.756863,
      0.62372,
      0.926026,
      0.332309,
      0.882353,
      0.717458,
      0.92527,
      0.342476,
      1,
      0.8,
      0.9255,
      0.3529
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "gist_earth",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.239216,
      0.027451,
      0.415686,
      -0.74902,
      0.0901961,
      0.254902,
      0.556863,
      -0.623529,
      0.0941176,
      0.352941,
      0.54902,
      -0.498039,
      0.105882,
      0.435294,
      0.533333,
      -0.372549,
      0.12549,
      0.52549,
      0.501961,
      -0.247059,
      0.156863,
      0.596078,
      0.443137,
      -0.121569,
      0.196078,
      0.65098,
      0.380392,
      0.00392157,
      0.282353,
      0.717647,
      0.301961,
      0.129412,
      0.466667,
      0.772549,
      0.27451,
      0.254902,
      0.678431,
      0.784314,
      0.309804,
      0.380392,
      0.901961,
      0.756863,
      0.376471,
      0.505882,
      0.992157,
      0.705882,
      0.521569,
      0.631373,
      1,
      0.721569,
      0.701961,
      0.756863,
      1,
      0.784314,
      0.784314,
      0.882353,
      1,
      0.866667,
      0.866667,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "2hot",
    RGBPoints: [
      -1,
      0.0416667,
      0,
      0,
      -0.873016,
      0.208333,
      0,
      0,
      -0.746032,
      0.375,
      0,
      0,
      -0.619048,
      0.541667,
      0,
      0,
      -0.492063,
      0.708333,
      0,
      0,
      -0.365079,
      0.854137,
      0,
      0,
      -0.238095,
      0.937488,
      0.039062,
      0,
      -0.111111,
      1,
      0.208333,
      0,
      0.015873,
      1,
      0.375,
      0,
      0.142857,
      1,
      0.541667,
      0,
      0.269841,
      1,
      0.708333,
      0,
      0.396825,
      1,
      0.858805,
      0.03125,
      0.52381,
      1,
      0.947392,
      0.15625,
      0.650794,
      1,
      1,
      0.3125,
      0.777778,
      1,
      1,
      0.5625,
      0.904762,
      1,
      1,
      0.8125,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red2yellow_BW",
    RGBPoints: [
      -1,
      0.000000754296,
      0,
      0.0000109827,
      -0.87451,
      0.18285,
      0.0264094,
      0,
      -0.74902,
      0.3066,
      0,
      0,
      -0.623529,
      0.422841,
      0,
      0,
      -0.498039,
      0.522945,
      0,
      0,
      -0.372549,
      0.605721,
      0,
      0,
      -0.247059,
      0.672502,
      0.14168,
      0,
      -0.121569,
      0.728167,
      0.244025,
      0,
      0.00392157,
      0.781215,
      0.333454,
      0,
      0.129412,
      0.825,
      0.423586,
      0,
      0.254902,
      0.855893,
      0.516793,
      0,
      0.380392,
      0.880491,
      0.608846,
      0,
      0.505882,
      0.910305,
      0.695505,
      0,
      0.631373,
      0.94109,
      0.779067,
      0.223528,
      0.756863,
      0.967873,
      0.858572,
      0.473521,
      0.882353,
      0.986815,
      0.933211,
      0.751583,
      1,
      1,
      1,
      0.999997
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_marine2gold_BW",
    RGBPoints: [
      -1,
      0.000000111641,
      0,
      0.00000162551,
      -0.87451,
      0.0413146,
      0.0619808,
      0.209857,
      -0.74902,
      0.0185557,
      0.101341,
      0.350684,
      -0.623529,
      0.00486405,
      0.149847,
      0.461054,
      -0.498039,
      0.0836345,
      0.210845,
      0.517906,
      -0.372549,
      0.173222,
      0.276134,
      0.541793,
      -0.247059,
      0.259857,
      0.343877,
      0.535869,
      -0.121569,
      0.362299,
      0.408124,
      0.504293,
      0.00392157,
      0.468266,
      0.468276,
      0.468257,
      0.129412,
      0.582781,
      0.527545,
      0.374914,
      0.254902,
      0.691591,
      0.585251,
      0.274266,
      0.380392,
      0.784454,
      0.645091,
      0.247332,
      0.505882,
      0.862299,
      0.710383,
      0.27518,
      0.631373,
      0.920863,
      0.782923,
      0.351563,
      0.756863,
      0.955792,
      0.859699,
      0.533541,
      0.882353,
      0.976162,
      0.93433,
      0.780671,
      1,
      1,
      1,
      0.999983
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2gold_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0742735,
      0.0440331,
      0.230013,
      -0.74902,
      0.125276,
      0.0258685,
      0.415826,
      -0.623529,
      0.143879,
      0.0163031,
      0.591346,
      -0.498039,
      0.212261,
      0.0627855,
      0.705239,
      -0.372549,
      0.306048,
      0.141178,
      0.763636,
      -0.247059,
      0.391537,
      0.232286,
      0.773263,
      -0.121569,
      0.461734,
      0.336633,
      0.708321,
      0.00392157,
      0.54209,
      0.427581,
      0.590007,
      0.129412,
      0.61704,
      0.508623,
      0.460978,
      0.254902,
      0.702703,
      0.579586,
      0.309117,
      0.380392,
      0.790336,
      0.644811,
      0.170397,
      0.505882,
      0.870173,
      0.710733,
      0.117134,
      0.631373,
      0.93656,
      0.781991,
      0.157144,
      0.756863,
      0.965672,
      0.862068,
      0.409836,
      0.882353,
      0.985751,
      0.936296,
      0.714162,
      1,
      1,
      1,
      0.999999
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_sapphire2gold_BW",
    RGBPoints: [
      -1,
      0.107704,
      0.107708,
      0.107694,
      -0.87451,
      0.1851,
      0.112354,
      0.308554,
      -0.74902,
      0.236782,
      0.114233,
      0.48788,
      -0.623529,
      0.28296,
      0.126187,
      0.639464,
      -0.498039,
      0.344787,
      0.171643,
      0.739713,
      -0.372549,
      0.413325,
      0.242371,
      0.76913,
      -0.247059,
      0.481863,
      0.3131,
      0.719841,
      -0.121569,
      0.550402,
      0.383829,
      0.612222,
      0.00392157,
      0.61894,
      0.454558,
      0.51126,
      0.129412,
      0.687478,
      0.525287,
      0.39993,
      0.254902,
      0.756017,
      0.596016,
      0.289923,
      0.380392,
      0.824555,
      0.666745,
      0.255498,
      0.505882,
      0.892979,
      0.736822,
      0.27696,
      0.631373,
      0.938851,
      0.804966,
      0.351734,
      0.756863,
      0.966491,
      0.874853,
      0.53572,
      0.882353,
      0.982105,
      0.94153,
      0.782579,
      1,
      1,
      1,
      0.999986
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red2purple_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.167793,
      0.0166271,
      0.0431278,
      -0.74902,
      0.262608,
      0.0107595,
      0.0791181,
      -0.623529,
      0.351902,
      0.0101858,
      0.100926,
      -0.498039,
      0.441257,
      0.0160835,
      0.131919,
      -0.372549,
      0.5221,
      0.0555972,
      0.195625,
      -0.247059,
      0.593852,
      0.104294,
      0.310234,
      -0.121569,
      0.654628,
      0.158115,
      0.448486,
      0.00392157,
      0.707443,
      0.220914,
      0.570253,
      0.129412,
      0.749504,
      0.293268,
      0.67897,
      0.254902,
      0.781587,
      0.370517,
      0.779269,
      0.380392,
      0.809951,
      0.451099,
      0.855831,
      0.505882,
      0.84424,
      0.531462,
      0.900451,
      0.631373,
      0.865174,
      0.620901,
      0.91606,
      0.756863,
      0.875041,
      0.714054,
      0.910284,
      0.882353,
      0.880764,
      0.80554,
      0.896276,
      1,
      0.887572,
      0.887591,
      0.887556
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2pink_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.117562,
      0.0291202,
      0.175876,
      -0.74902,
      0.178368,
      0.0458476,
      0.285454,
      -0.623529,
      0.237731,
      0.0680173,
      0.387717,
      -0.498039,
      0.300877,
      0.0956291,
      0.484802,
      -0.372549,
      0.370929,
      0.136858,
      0.554985,
      -0.247059,
      0.449033,
      0.189273,
      0.58863,
      -0.121569,
      0.529971,
      0.245796,
      0.598587,
      0.00392157,
      0.609914,
      0.300643,
      0.610244,
      0.129412,
      0.697079,
      0.351286,
      0.616371,
      0.254902,
      0.785858,
      0.401991,
      0.617376,
      0.380392,
      0.862517,
      0.45745,
      0.64463,
      0.505882,
      0.91359,
      0.525462,
      0.705336,
      0.631373,
      0.932583,
      0.61064,
      0.767412,
      0.756863,
      0.922478,
      0.706966,
      0.817522,
      0.882353,
      0.901302,
      0.803071,
      0.856311,
      1,
      0.887571,
      0.887591,
      0.887549
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_pbj_lin",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.091821,
      0.0611476,
      0.10617,
      -0.74902,
      0.160311,
      0.0900022,
      0.192713,
      -0.623529,
      0.22484,
      0.12126,
      0.272128,
      -0.498039,
      0.291263,
      0.157469,
      0.340828,
      -0.372549,
      0.360015,
      0.200388,
      0.388903,
      -0.247059,
      0.437497,
      0.250058,
      0.387201,
      -0.121569,
      0.512636,
      0.304969,
      0.355955,
      0.00392157,
      0.582603,
      0.360874,
      0.33488,
      0.129412,
      0.655126,
      0.416374,
      0.306351,
      0.254902,
      0.725889,
      0.473329,
      0.279051,
      0.380392,
      0.778125,
      0.537928,
      0.302697,
      0.505882,
      0.815894,
      0.606931,
      0.382431,
      0.631373,
      0.839159,
      0.679308,
      0.497608,
      0.756863,
      0.854748,
      0.751666,
      0.631792,
      0.882353,
      0.869483,
      0.822508,
      0.768592,
      1,
      0.887572,
      0.887589,
      0.887565
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2green_muted",
    RGBPoints: [
      -1,
      0.107704,
      0.107708,
      0.107695,
      -0.87451,
      0.141522,
      0.13066,
      0.270741,
      -0.74902,
      0.180123,
      0.146119,
      0.42308,
      -0.623529,
      0.210161,
      0.169674,
      0.551795,
      -0.498039,
      0.239701,
      0.212939,
      0.634969,
      -0.372549,
      0.253916,
      0.282947,
      0.653641,
      -0.247059,
      0.242791,
      0.366933,
      0.608521,
      -0.121569,
      0.226302,
      0.446776,
      0.52693,
      0.00392157,
      0.236237,
      0.514689,
      0.458798,
      0.129412,
      0.274641,
      0.577589,
      0.376069,
      0.254902,
      0.349625,
      0.633993,
      0.288131,
      0.380392,
      0.4437,
      0.683677,
      0.260497,
      0.505882,
      0.536247,
      0.731214,
      0.285424,
      0.631373,
      0.628472,
      0.777128,
      0.349151,
      0.756863,
      0.718259,
      0.819287,
      0.496825,
      0.882353,
      0.804768,
      0.856164,
      0.703299,
      1,
      0.887571,
      0.887591,
      0.887548
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2green_BW",
    RGBPoints: [
      -1,
      0.000000363578,
      0,
      0.00000529374,
      -0.87451,
      0.0539915,
      0.0577948,
      0.212806,
      -0.74902,
      0.0620393,
      0.0758942,
      0.388959,
      -0.623529,
      0.0697499,
      0.102032,
      0.54177,
      -0.498039,
      0.113295,
      0.156156,
      0.64334,
      -0.372549,
      0.152047,
      0.243196,
      0.670283,
      -0.247059,
      0.158096,
      0.344084,
      0.622864,
      -0.121569,
      0.151142,
      0.43922,
      0.532767,
      0.00392157,
      0.17155,
      0.521588,
      0.457719,
      0.129412,
      0.225861,
      0.599141,
      0.363997,
      0.254902,
      0.32328,
      0.67007,
      0.259083,
      0.380392,
      0.442344,
      0.733697,
      0.223754,
      0.505882,
      0.558409,
      0.794941,
      0.257411,
      0.631373,
      0.673875,
      0.854344,
      0.340822,
      0.756863,
      0.787244,
      0.909326,
      0.524717,
      0.882353,
      0.896483,
      0.958063,
      0.775914,
      1,
      1,
      1,
      0.999982
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GREEN-WHITE_LINEAR",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.062745,
      0,
      -0.74902,
      0,
      0.12549,
      0,
      -0.623529,
      0,
      0.188235,
      0,
      -0.498039,
      0,
      0.25098,
      0,
      -0.372549,
      0,
      0.313725,
      0,
      -0.247059,
      0,
      0.376471,
      0,
      -0.121569,
      0.094118,
      0.439216,
      0,
      0.00392157,
      0.196078,
      0.501961,
      0,
      0.129412,
      0.294118,
      0.564706,
      0,
      0.254902,
      0.396078,
      0.627451,
      0,
      0.380392,
      0.498039,
      0.690196,
      0,
      0.505882,
      0.6,
      0.752941,
      0.145098,
      0.631373,
      0.701961,
      0.815686,
      0.364706,
      0.756863,
      0.8,
      0.878431,
      0.580392,
      0.882353,
      0.901961,
      0.941176,
      0.796078,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_green2yellow_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.105542,
      0.0603919,
      -0.74902,
      0,
      0.159454,
      0.104148,
      -0.623529,
      0,
      0.219502,
      0.15542,
      -0.498039,
      0,
      0.282276,
      0.203811,
      -0.372549,
      0,
      0.346331,
      0.235652,
      -0.247059,
      0,
      0.411765,
      0.235428,
      -0.121569,
      0,
      0.477177,
      0.217977,
      0.00392157,
      0.0593644,
      0.541635,
      0.21361,
      0.129412,
      0.233081,
      0.604722,
      0.210591,
      0.254902,
      0.369803,
      0.664942,
      0.226536,
      0.380392,
      0.498446,
      0.722367,
      0.288237,
      0.505882,
      0.601929,
      0.782244,
      0.380815,
      0.631373,
      0.703207,
      0.840497,
      0.512134,
      0.756863,
      0.803186,
      0.896433,
      0.674462,
      0.882353,
      0.903834,
      0.950266,
      0.846715,
      1,
      1,
      1,
      0.999981
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "blue2cyan",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0.152941,
      0.364706,
      -0.74902,
      0,
      0.254902,
      0.470588,
      -0.623529,
      0,
      0.34902,
      0.572549,
      -0.498039,
      0,
      0.443137,
      0.670588,
      -0.372549,
      0,
      0.537255,
      0.772549,
      -0.247059,
      0,
      0.627451,
      0.870588,
      -0.121569,
      0,
      0.717647,
      0.964706,
      0.00392157,
      0.0784314,
      0.772549,
      1,
      0.129412,
      0.207843,
      0.858824,
      1,
      0.254902,
      0.32549,
      0.941176,
      1,
      0.380392,
      0.45098,
      1,
      1,
      0.505882,
      0.560784,
      1,
      1,
      0.631373,
      0.662745,
      1,
      1,
      0.756863,
      0.760784,
      1,
      1,
      0.882353,
      0.870588,
      1,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2cyan_BW",
    RGBPoints: [
      -1,
      0.000000405298,
      0,
      0.0000059012,
      -0.87451,
      0.0207526,
      0.0740933,
      0.18093,
      -0.74902,
      0,
      0.121033,
      0.30343,
      -0.623529,
      0,
      0.166892,
      0.416095,
      -0.498039,
      0,
      0.216768,
      0.524796,
      -0.372549,
      0.0164769,
      0.275471,
      0.608585,
      -0.247059,
      0.0544527,
      0.344824,
      0.659267,
      -0.121569,
      0.0880643,
      0.419118,
      0.688675,
      0.00392157,
      0.127938,
      0.492556,
      0.720256,
      0.129412,
      0.149476,
      0.566946,
      0.756918,
      0.254902,
      0.188961,
      0.641333,
      0.792122,
      0.380392,
      0.245482,
      0.715336,
      0.827609,
      0.505882,
      0.329216,
      0.786235,
      0.874761,
      0.631373,
      0.453558,
      0.852803,
      0.918466,
      0.756863,
      0.626281,
      0.910493,
      0.954,
      0.882353,
      0.82257,
      0.958709,
      0.980146,
      1,
      1,
      1,
      0.999989
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0425591,
      0.0763529,
      0.150682,
      -0.74902,
      0.0569472,
      0.119154,
      0.275403,
      -0.623529,
      0.0635978,
      0.164772,
      0.395427,
      -0.498039,
      0.0774342,
      0.213851,
      0.510014,
      -0.372549,
      0.106815,
      0.267034,
      0.615102,
      -0.247059,
      0.122093,
      0.324649,
      0.720068,
      -0.121569,
      0.160851,
      0.387068,
      0.806956,
      0.00392157,
      0.213754,
      0.453516,
      0.878012,
      0.129412,
      0.26722,
      0.524656,
      0.932436,
      0.254902,
      0.326844,
      0.599279,
      0.968038,
      0.380392,
      0.403403,
      0.674712,
      0.984784,
      0.505882,
      0.499703,
      0.745519,
      1,
      0.631373,
      0.615055,
      0.813983,
      1,
      0.756863,
      0.74405,
      0.879228,
      1,
      0.882353,
      0.877909,
      0.941913,
      1,
      1,
      1,
      1,
      0.999996
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BLUE-WHITE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0,
      0,
      0.082353,
      -0.74902,
      0,
      0,
      0.168627,
      -0.623529,
      0,
      0,
      0.254902,
      -0.498039,
      0,
      0,
      0.337255,
      -0.372549,
      0,
      0,
      0.423529,
      -0.247059,
      0,
      0,
      0.509804,
      -0.121569,
      0,
      0.101961,
      0.592157,
      0.00392157,
      0,
      0.203922,
      0.678431,
      0.129412,
      0,
      0.301961,
      0.764706,
      0.254902,
      0,
      0.403922,
      0.85098,
      0.380392,
      0,
      0.505882,
      0.933333,
      0.505882,
      0,
      0.603922,
      1,
      0.631373,
      0.254902,
      0.705882,
      1,
      0.756863,
      0.509804,
      0.807843,
      1,
      0.882353,
      0.764706,
      0.905882,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple_BW",
    RGBPoints: [
      -1,
      0.00000004264,
      0,
      0.000000620844,
      -0.87451,
      0.100579,
      0.0593111,
      0.145666,
      -0.74902,
      0.167794,
      0.0889224,
      0.254953,
      -0.623529,
      0.231446,
      0.123339,
      0.360511,
      -0.498039,
      0.296699,
      0.163027,
      0.461278,
      -0.372549,
      0.363211,
      0.209286,
      0.55306,
      -0.247059,
      0.431136,
      0.260776,
      0.637195,
      -0.121569,
      0.498202,
      0.320012,
      0.705799,
      0.00392157,
      0.567456,
      0.380459,
      0.778091,
      0.129412,
      0.629381,
      0.445284,
      0.8448,
      0.254902,
      0.688373,
      0.517374,
      0.895694,
      0.380392,
      0.74891,
      0.590906,
      0.93976,
      0.505882,
      0.805017,
      0.667956,
      0.977626,
      0.631373,
      0.850914,
      0.752618,
      0.992396,
      0.756863,
      0.89724,
      0.838454,
      0.994093,
      0.882353,
      0.948461,
      0.922603,
      0.994449,
      1,
      1,
      1,
      0.999967
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_magenta_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0.0000254023,
      -0.87451,
      0.128696,
      0.0456782,
      0.11635,
      -0.74902,
      0.228133,
      0.0476299,
      0.201452,
      -0.623529,
      0.327273,
      0.0374065,
      0.282107,
      -0.498039,
      0.420953,
      0.0408166,
      0.35709,
      -0.372549,
      0.511562,
      0.0642203,
      0.430511,
      -0.247059,
      0.599552,
      0.102686,
      0.504257,
      -0.121569,
      0.684646,
      0.150536,
      0.579429,
      0.00392157,
      0.765817,
      0.205978,
      0.656062,
      0.129412,
      0.839176,
      0.27229,
      0.731807,
      0.254902,
      0.89536,
      0.357594,
      0.797309,
      0.380392,
      0.930238,
      0.457825,
      0.846984,
      0.505882,
      0.945921,
      0.564536,
      0.880571,
      0.631373,
      0.948995,
      0.670753,
      0.902279,
      0.756863,
      0.947124,
      0.772819,
      0.918171,
      0.882353,
      0.947265,
      0.869424,
      0.934352,
      1,
      0.954719,
      0.95475,
      0.954726
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "magenta",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.364706,
      0,
      0.152941,
      -0.74902,
      0.470588,
      0,
      0.254902,
      -0.623529,
      0.572549,
      0,
      0.34902,
      -0.498039,
      0.670588,
      0,
      0.443137,
      -0.372549,
      0.772549,
      0,
      0.537255,
      -0.247059,
      0.870588,
      0,
      0.627451,
      -0.121569,
      0.964706,
      0,
      0.717647,
      0.00392157,
      1,
      0.0784314,
      0.772549,
      0.129412,
      1,
      0.207843,
      0.858824,
      0.254902,
      1,
      0.32549,
      0.941176,
      0.380392,
      1,
      0.45098,
      1,
      0.505882,
      1,
      0.560784,
      1,
      0.631373,
      1,
      0.662745,
      1,
      0.756863,
      1,
      0.760784,
      1,
      0.882353,
      1,
      0.870588,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RED-PURPLE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.188235,
      0,
      0.007843,
      -0.74902,
      0.345098,
      0,
      0.035294,
      -0.623529,
      0.439216,
      0,
      0.098039,
      -0.498039,
      0.533333,
      0,
      0.152941,
      -0.372549,
      0.627451,
      0.015686,
      0.211765,
      -0.247059,
      0.721569,
      0.031373,
      0.266667,
      -0.121569,
      0.8,
      0.047059,
      0.329412,
      0.00392157,
      0.862745,
      0.047059,
      0.403922,
      0.129412,
      0.941176,
      0.062745,
      0.466667,
      0.254902,
      0.988235,
      0.078431,
      0.54902,
      0.380392,
      0.988235,
      0.141176,
      0.643137,
      0.505882,
      0.988235,
      0.25098,
      0.729412,
      0.631373,
      0.988235,
      0.376471,
      0.811765,
      0.756863,
      0.988235,
      0.54902,
      0.886275,
      0.882353,
      0.988235,
      0.752941,
      0.952941,
      1,
      0.996078,
      0.996078,
      0.996078
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_red_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.147204,
      0.0480135,
      0.0401815,
      -0.74902,
      0.253411,
      0.0617478,
      0.0301333,
      -0.623529,
      0.356059,
      0.0746331,
      0.0446897,
      -0.498039,
      0.457731,
      0.0934935,
      0.0636931,
      -0.372549,
      0.557199,
      0.122714,
      0.0860013,
      -0.247059,
      0.665179,
      0.144238,
      0.105585,
      -0.121569,
      0.763833,
      0.187056,
      0.138326,
      0.00392157,
      0.847035,
      0.254558,
      0.189407,
      0.129412,
      0.905663,
      0.345937,
      0.258215,
      0.254902,
      0.941431,
      0.447111,
      0.346277,
      0.380392,
      0.962608,
      0.546927,
      0.457571,
      0.505882,
      0.987833,
      0.637276,
      0.569944,
      0.631373,
      0.994202,
      0.732176,
      0.687958,
      0.756863,
      0.993304,
      0.826268,
      0.800567,
      0.882353,
      0.994413,
      0.917205,
      0.906393,
      1,
      1,
      1,
      0.999979
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RED_TEMPERATURE",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.090196,
      0,
      0,
      -0.74902,
      0.180392,
      0,
      0,
      -0.623529,
      0.270588,
      0,
      0,
      -0.498039,
      0.360784,
      0,
      0,
      -0.372549,
      0.45098,
      0,
      0,
      -0.247059,
      0.545098,
      0,
      0,
      -0.121569,
      0.635294,
      0,
      0,
      0.00392157,
      0.72549,
      0.058824,
      0,
      0.129412,
      0.815686,
      0.176471,
      0,
      0.254902,
      0.905882,
      0.294118,
      0,
      0.380392,
      1,
      0.411765,
      0,
      0.505882,
      1,
      0.533333,
      0.027451,
      0.631373,
      1,
      0.65098,
      0.27451,
      0.756863,
      1,
      0.768627,
      0.521569,
      0.882353,
      1,
      0.886275,
      0.768627,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_orange_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0.0000253806,
      -0.87451,
      0.135871,
      0.0593824,
      0,
      -0.74902,
      0.224328,
      0.0907216,
      0,
      -0.623529,
      0.318083,
      0.119647,
      0,
      -0.498039,
      0.414443,
      0.150246,
      0,
      -0.372549,
      0.511077,
      0.184884,
      0,
      -0.247059,
      0.605501,
      0.226033,
      0,
      -0.121569,
      0.695274,
      0.275491,
      0,
      0.00392157,
      0.777826,
      0.334445,
      0,
      0.129412,
      0.851498,
      0.402441,
      0,
      0.254902,
      0.915899,
      0.47759,
      0.000602975,
      0.380392,
      0.971984,
      0.557882,
      0.0361443,
      0.505882,
      1,
      0.641287,
      0.135967,
      0.631373,
      1,
      0.725198,
      0.27997,
      0.756863,
      1,
      0.808205,
      0.438135,
      0.882353,
      1,
      0.89306,
      0.587036,
      1,
      1,
      0.977928,
      0.721599
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "heated_object",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.34902,
      0.0862745,
      0,
      -0.74902,
      0.45098,
      0.172549,
      0,
      -0.623529,
      0.52549,
      0.231373,
      0,
      -0.498039,
      0.580392,
      0.278431,
      0,
      -0.372549,
      0.623529,
      0.313725,
      0,
      -0.247059,
      0.670588,
      0.352941,
      0,
      -0.121569,
      0.717647,
      0.392157,
      0,
      0.00392157,
      0.772549,
      0.439216,
      0,
      0.129412,
      0.839216,
      0.494118,
      0,
      0.254902,
      0.901961,
      0.541176,
      0,
      0.380392,
      0.968627,
      0.6,
      0,
      0.505882,
      1,
      0.658824,
      0,
      0.631373,
      1,
      0.721569,
      0,
      0.756863,
      1,
      0.827451,
      0.298039,
      0.882353,
      1,
      0.976471,
      0.72549,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_gold_BW",
    RGBPoints: [
      -1,
      0,
      0,
      0.0000190933,
      -0.87451,
      0.128363,
      0.0636265,
      0,
      -0.74902,
      0.193795,
      0.111057,
      0,
      -0.623529,
      0.25976,
      0.15987,
      0,
      -0.498039,
      0.328546,
      0.210589,
      0,
      -0.372549,
      0.399726,
      0.26332,
      0,
      -0.247059,
      0.472969,
      0.318261,
      0,
      -0.121569,
      0.546245,
      0.375827,
      0,
      0.00392157,
      0.61745,
      0.436719,
      0,
      0.129412,
      0.685545,
      0.501113,
      0,
      0.254902,
      0.749578,
      0.568799,
      0,
      0.380392,
      0.80962,
      0.6394,
      0,
      0.505882,
      0.865572,
      0.712699,
      0.10257,
      0.631373,
      0.917709,
      0.787569,
      0.233665,
      0.756863,
      0.966914,
      0.863138,
      0.369608,
      0.882353,
      1,
      0.939405,
      0.496104,
      1,
      0.999225,
      1,
      0.612275
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_brown_BW",
    RGBPoints: [
      -1,
      0.00000033216,
      0,
      0.00000483629,
      -0.87451,
      0.14693,
      0.0518172,
      0,
      -0.74902,
      0.225806,
      0.0814996,
      0,
      -0.623529,
      0.301681,
      0.111452,
      0,
      -0.498039,
      0.370487,
      0.150664,
      0,
      -0.372549,
      0.43108,
      0.199477,
      0,
      -0.247059,
      0.4849,
      0.255107,
      0,
      -0.121569,
      0.536798,
      0.313486,
      0,
      0.00392157,
      0.59286,
      0.371167,
      0,
      0.129412,
      0.653119,
      0.428135,
      0,
      0.254902,
      0.714589,
      0.485917,
      0.0379541,
      0.380392,
      0.774667,
      0.54565,
      0.116634,
      0.505882,
      0.831222,
      0.608047,
      0.183895,
      0.631373,
      0.880305,
      0.674199,
      0.260298,
      0.756863,
      0.922314,
      0.742472,
      0.367086,
      0.882353,
      0.959408,
      0.811222,
      0.497258,
      1,
      0.993548,
      0.875183,
      0.622093
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "copper_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0784314,
      0.0501961,
      0.0313725,
      -0.74902,
      0.156863,
      0.100392,
      0.0627451,
      -0.623529,
      0.235294,
      0.150588,
      0.0941176,
      -0.498039,
      0.313725,
      0.200784,
      0.12549,
      -0.372549,
      0.392157,
      0.25098,
      0.156863,
      -0.247059,
      0.470588,
      0.301176,
      0.188235,
      -0.121569,
      0.54902,
      0.351373,
      0.219608,
      0.00392157,
      0.627451,
      0.401569,
      0.25098,
      0.129412,
      0.705882,
      0.451765,
      0.282353,
      0.254902,
      0.784314,
      0.501961,
      0.313725,
      0.380392,
      0.862745,
      0.552157,
      0.345098,
      0.505882,
      0.941176,
      0.602353,
      0.376471,
      0.631373,
      1,
      0.652549,
      0.407843,
      0.756863,
      1,
      0.702745,
      0.439216,
      0.882353,
      1,
      0.752941,
      0.470588,
      1,
      1,
      0.8,
      0.5
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "pink_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.312416,
      0.204524,
      0.204524,
      -0.74902,
      0.441822,
      0.289241,
      0.289241,
      -0.623529,
      0.54112,
      0.354246,
      0.354246,
      -0.498039,
      0.624831,
      0.409048,
      0.409048,
      -0.372549,
      0.698582,
      0.45733,
      0.45733,
      -0.247059,
      0.764404,
      0.502282,
      0.500979,
      -0.121569,
      0.791292,
      0.591516,
      0.54112,
      0.00392157,
      0.817297,
      0.66895,
      0.578481,
      0.129412,
      0.842499,
      0.738308,
      0.613572,
      0.254902,
      0.866968,
      0.801687,
      0.646762,
      0.380392,
      0.890766,
      0.86041,
      0.678329,
      0.505882,
      0.913944,
      0.913944,
      0.711254,
      0.631373,
      0.936549,
      0.936549,
      0.79459,
      0.756863,
      0.958621,
      0.958621,
      0.869979,
      0.882353,
      0.980196,
      0.980196,
      0.939336,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "bone_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.054902,
      0.054902,
      0.075817,
      -0.74902,
      0.109804,
      0.109804,
      0.151634,
      -0.623529,
      0.164706,
      0.164706,
      0.227451,
      -0.498039,
      0.219608,
      0.219608,
      0.303268,
      -0.372549,
      0.27451,
      0.27451,
      0.379085,
      -0.247059,
      0.329412,
      0.329902,
      0.454412,
      -0.121569,
      0.384314,
      0.405719,
      0.509314,
      0.00392157,
      0.439216,
      0.481536,
      0.564216,
      0.129412,
      0.494118,
      0.557353,
      0.619118,
      0.254902,
      0.54902,
      0.63317,
      0.67402,
      0.380392,
      0.603922,
      0.708987,
      0.728922,
      0.505882,
      0.660294,
      0.783824,
      0.783824,
      0.631373,
      0.746569,
      0.838725,
      0.838725,
      0.756863,
      0.832843,
      0.893627,
      0.893627,
      0.882353,
      0.919118,
      0.948529,
      0.948529,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "gray_Matlab",
    RGBPoints: [
      -1,
      0,
      0,
      0,
      -0.87451,
      0.0627451,
      0.0627451,
      0.0627451,
      -0.74902,
      0.12549,
      0.12549,
      0.12549,
      -0.623529,
      0.188235,
      0.188235,
      0.188235,
      -0.498039,
      0.25098,
      0.25098,
      0.25098,
      -0.372549,
      0.313725,
      0.313725,
      0.313725,
      -0.247059,
      0.376471,
      0.376471,
      0.376471,
      -0.121569,
      0.439216,
      0.439216,
      0.439216,
      0.00392157,
      0.501961,
      0.501961,
      0.501961,
      0.129412,
      0.564706,
      0.564706,
      0.564706,
      0.254902,
      0.627451,
      0.627451,
      0.627451,
      0.380392,
      0.690196,
      0.690196,
      0.690196,
      0.505882,
      0.752941,
      0.752941,
      0.752941,
      0.631373,
      0.815686,
      0.815686,
      0.815686,
      0.756863,
      0.878431,
      0.878431,
      0.878431,
      0.882353,
      0.941176,
      0.941176,
      0.941176,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Purples",
    RGBPoints: [
      -1,
      0.247059,
      0,
      0.490196,
      -0.87451,
      0.288397,
      0.07677,
      0.525629,
      -0.74902,
      0.32975,
      0.153587,
      0.561092,
      -0.623529,
      0.373057,
      0.236263,
      0.600461,
      -0.498039,
      0.416363,
      0.319,
      0.639923,
      -0.372549,
      0.459669,
      0.405613,
      0.685198,
      -0.247059,
      0.503345,
      0.491534,
      0.730058,
      -0.121569,
      0.562399,
      0.54862,
      0.757616,
      0.00392157,
      0.621453,
      0.606075,
      0.785544,
      0.129412,
      0.680508,
      0.674971,
      0.824914,
      0.254902,
      0.739562,
      0.743406,
      0.863899,
      0.380392,
      0.798616,
      0.800492,
      0.893426,
      0.505882,
      0.85684,
      0.856655,
      0.922491,
      0.631373,
      0.898178,
      0.894056,
      0.942176,
      0.756863,
      0.938654,
      0.930919,
      0.961646,
      0.882353,
      0.964245,
      0.958478,
      0.977393,
      1,
      0.988235,
      0.984314,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Blues",
    RGBPoints: [
      -1,
      0.031373,
      0.188235,
      0.419608,
      -0.87451,
      0.031373,
      0.253195,
      0.516063,
      -0.74902,
      0.031757,
      0.318139,
      0.612149,
      -0.623529,
      0.080969,
      0.38113,
      0.661361,
      -0.498039,
      0.130427,
      0.444152,
      0.710327,
      -0.372549,
      0.195386,
      0.509112,
      0.743791,
      -0.247059,
      0.260715,
      0.573841,
      0.777209,
      -0.121569,
      0.341423,
      0.628958,
      0.808704,
      0.00392157,
      0.422745,
      0.684075,
      0.839892,
      0.129412,
      0.523137,
      0.739193,
      0.861546,
      0.254902,
      0.622684,
      0.793464,
      0.883429,
      0.380392,
      0.701423,
      0.826928,
      0.910988,
      0.505882,
      0.778685,
      0.8603,
      0.937993,
      0.631373,
      0.825928,
      0.891795,
      0.953741,
      0.756863,
      0.87328,
      0.923291,
      0.969489,
      0.882353,
      0.922491,
      0.954787,
      0.985236,
      1,
      0.968627,
      0.984314,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Greens",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0,
      0.347374,
      0.139346,
      -0.74902,
      0.000538,
      0.427912,
      0.172933,
      -0.623529,
      0.069435,
      0.486967,
      0.222145,
      -0.498039,
      0.138178,
      0.546082,
      0.271326,
      -0.372549,
      0.197232,
      0.609073,
      0.31857,
      -0.247059,
      0.257255,
      0.671742,
      0.365859,
      -0.121569,
      0.357647,
      0.720953,
      0.415071,
      0.00392157,
      0.45767,
      0.769919,
      0.465021,
      0.129412,
      0.546251,
      0.811257,
      0.537855,
      0.254902,
      0.634295,
      0.852211,
      0.610688,
      0.380392,
      0.709097,
      0.883706,
      0.683522,
      0.505882,
      0.78316,
      0.914833,
      0.755894,
      0.631373,
      0.842215,
      0.938454,
      0.818885,
      0.756863,
      0.899977,
      0.961538,
      0.880692,
      0.882353,
      0.935409,
      0.975317,
      0.92203,
      1,
      0.968627,
      0.988235,
      0.960784
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuBu",
    RGBPoints: [
      -1,
      0.301961,
      0,
      0.294118,
      -0.87451,
      0.404321,
      0.029527,
      0.390573,
      -0.74902,
      0.50599,
      0.059592,
      0.486782,
      -0.623529,
      0.519769,
      0.158016,
      0.551742,
      -0.498039,
      0.533456,
      0.256194,
      0.616301,
      -0.372549,
      0.54133,
      0.33887,
      0.655671,
      -0.247059,
      0.54902,
      0.421592,
      0.695087,
      -0.121569,
      0.54902,
      0.506236,
      0.736424,
      0.00392157,
      0.550127,
      0.590573,
      0.777701,
      0.129412,
      0.585559,
      0.665375,
      0.81707,
      0.254902,
      0.622145,
      0.739023,
      0.855825,
      0.380392,
      0.687105,
      0.784298,
      0.879446,
      0.505882,
      0.752065,
      0.829758,
      0.903253,
      0.631373,
      0.817024,
      0.87897,
      0.930811,
      0.756863,
      0.880907,
      0.927213,
      0.957832,
      0.882353,
      0.926182,
      0.958708,
      0.975548,
      1,
      0.968627,
      0.988235,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuPu",
    RGBPoints: [
      -1,
      0.007843,
      0.219608,
      0.345098,
      -0.87451,
      0.01178,
      0.286536,
      0.449427,
      -0.74902,
      0.015702,
      0.35328,
      0.553479,
      -0.623529,
      0.01767,
      0.396586,
      0.622376,
      -0.498039,
      0.021115,
      0.4402,
      0.690688,
      -0.372549,
      0.11757,
      0.503191,
      0.722184,
      -0.247059,
      0.214625,
      0.565859,
      0.753633,
      -0.121569,
      0.336671,
      0.615071,
      0.78316,
      0.00392157,
      0.457978,
      0.663975,
      0.812503,
      0.129412,
      0.556401,
      0.703345,
      0.836125,
      0.254902,
      0.65421,
      0.742714,
      0.859669,
      0.380392,
      0.736886,
      0.782084,
      0.881323,
      0.505882,
      0.81827,
      0.821638,
      0.903068,
      0.631373,
      0.873387,
      0.864944,
      0.92669,
      0.756863,
      0.927536,
      0.907605,
      0.949988,
      0.882353,
      0.964937,
      0.9391,
      0.967705,
      1,
      1,
      0.968627,
      0.984314
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuGn",
    RGBPoints: [
      -1,
      0.031373,
      0.25098,
      0.505882,
      -0.87451,
      0.031373,
      0.329719,
      0.590527,
      -0.74902,
      0.031911,
      0.408397,
      0.674787,
      -0.623529,
      0.100807,
      0.479262,
      0.710219,
      -0.498039,
      0.169704,
      0.550219,
      0.745744,
      -0.372549,
      0.238601,
      0.62699,
      0.787082,
      -0.247059,
      0.307958,
      0.703114,
      0.826759,
      -0.121569,
      0.39654,
      0.752326,
      0.797232,
      0.00392157,
      0.485121,
      0.801046,
      0.767705,
      0.129412,
      0.573702,
      0.83451,
      0.738178,
      0.254902,
      0.661592,
      0.867743,
      0.711034,
      0.380392,
      0.732457,
      0.895302,
      0.74253,
      0.505882,
      0.801845,
      0.922307,
      0.774579,
      0.631373,
      0.841215,
      0.938055,
      0.817885,
      0.756863,
      0.880907,
      0.95391,
      0.861084,
      0.882353,
      0.926182,
      0.971626,
      0.902422,
      1,
      0.968627,
      0.988235,
      0.941176
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnBu",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0,
      0.347374,
      0.139346,
      -0.74902,
      0.000538,
      0.427912,
      0.172933,
      -0.623529,
      0.069435,
      0.486967,
      0.222145,
      -0.498039,
      0.138178,
      0.546175,
      0.272095,
      -0.372549,
      0.197232,
      0.615071,
      0.368551,
      -0.247059,
      0.256609,
      0.683276,
      0.464867,
      -0.121569,
      0.329443,
      0.722645,
      0.555417,
      0.00392157,
      0.403137,
      0.762138,
      0.645413,
      0.129412,
      0.503529,
      0.805444,
      0.718247,
      0.254902,
      0.603922,
      0.848597,
      0.790465,
      0.380392,
      0.704314,
      0.887966,
      0.847551,
      0.505882,
      0.802307,
      0.926321,
      0.903714,
      0.631373,
      0.851519,
      0.944037,
      0.941115,
      0.756863,
      0.899977,
      0.961538,
      0.976901,
      0.882353,
      0.935409,
      0.975317,
      0.984775,
      1,
      0.968627,
      0.988235,
      0.992157
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnBuPu",
    RGBPoints: [
      -1,
      0.003922,
      0.27451,
      0.211765,
      -0.87451,
      0.003922,
      0.349312,
      0.280661,
      -0.74902,
      0.003937,
      0.423852,
      0.349773,
      -0.623529,
      0.005905,
      0.46519,
      0.446228,
      -0.498039,
      0.009443,
      0.506344,
      0.542837,
      -0.372549,
      0.111803,
      0.535871,
      0.649135,
      -0.247059,
      0.214025,
      0.565859,
      0.753633,
      -0.121569,
      0.310481,
      0.615071,
      0.78316,
      0.00392157,
      0.407797,
      0.663975,
      0.812503,
      0.129412,
      0.531811,
      0.703345,
      0.836125,
      0.254902,
      0.65421,
      0.742714,
      0.859669,
      0.380392,
      0.736886,
      0.782084,
      0.881323,
      0.505882,
      0.81827,
      0.821176,
      0.902884,
      0.631373,
      0.873387,
      0.854641,
      0.922568,
      0.756863,
      0.927536,
      0.888535,
      0.942361,
      0.882353,
      0.964937,
      0.929873,
      0.964014,
      1,
      1,
      0.968627,
      0.984314
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuGnYl",
    RGBPoints: [
      -1,
      0.031373,
      0.113725,
      0.345098,
      -0.87451,
      0.088458,
      0.159,
      0.463206,
      -0.74902,
      0.145052,
      0.204567,
      0.5807,
      -0.623529,
      0.139146,
      0.287243,
      0.620069,
      -0.498039,
      0.13318,
      0.370196,
      0.659562,
      -0.372549,
      0.123337,
      0.470588,
      0.706805,
      -0.247059,
      0.115386,
      0.570335,
      0.753126,
      -0.121569,
      0.186251,
      0.643168,
      0.761,
      0.00392157,
      0.258716,
      0.71514,
      0.768074,
      0.129412,
      0.380761,
      0.760415,
      0.750358,
      0.254902,
      0.503576,
      0.806075,
      0.732795,
      0.380392,
      0.645306,
      0.861192,
      0.719016,
      0.505882,
      0.783899,
      0.91511,
      0.705606,
      0.631373,
      0.858701,
      0.944637,
      0.6997,
      0.756863,
      0.931349,
      0.973303,
      0.698424,
      0.882353,
      0.966782,
      0.987082,
      0.777163,
      1,
      1,
      1,
      0.85098
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuRd",
    RGBPoints: [
      -1,
      0.286275,
      0,
      0.415686,
      -0.87451,
      0.38273,
      0.001968,
      0.441276,
      -0.74902,
      0.479231,
      0.003922,
      0.466774,
      -0.623529,
      0.581592,
      0.003922,
      0.480554,
      -0.498039,
      0.683799,
      0.00549,
      0.494887,
      -0.372549,
      0.776317,
      0.105882,
      0.544098,
      -0.247059,
      0.867866,
      0.206321,
      0.592618,
      -0.121569,
      0.919047,
      0.308681,
      0.612303,
      0.00392157,
      0.968812,
      0.411226,
      0.632603,
      0.129412,
      0.974717,
      0.519493,
      0.671972,
      0.254902,
      0.980546,
      0.626451,
      0.71065,
      0.380392,
      0.984483,
      0.701253,
      0.732303,
      0.505882,
      0.988328,
      0.77504,
      0.755617,
      0.631373,
      0.990296,
      0.828189,
      0.812703,
      0.756863,
      0.992372,
      0.880907,
      0.869035,
      0.882353,
      0.996309,
      0.926182,
      0.912341,
      1,
      1,
      0.968627,
      0.952941
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdPu",
    RGBPoints: [
      -1,
      0.403922,
      0,
      0.121569,
      -0.87451,
      0.500377,
      0,
      0.192434,
      -0.74902,
      0.596909,
      0.000277,
      0.263037,
      -0.623529,
      0.703206,
      0.035709,
      0.300438,
      -0.498039,
      0.808612,
      0.071296,
      0.338854,
      -0.372549,
      0.857824,
      0.116571,
      0.441215,
      -0.247059,
      0.905513,
      0.163552,
      0.54293,
      -0.121569,
      0.889765,
      0.281661,
      0.617732,
      0.00392157,
      0.873156,
      0.39897,
      0.691611,
      0.129412,
      0.82985,
      0.491488,
      0.736886,
      0.254902,
      0.789081,
      0.583237,
      0.781853,
      0.380392,
      0.810734,
      0.656071,
      0.819254,
      0.505882,
      0.833126,
      0.729181,
      0.85684,
      0.631373,
      0.870527,
      0.80792,
      0.898178,
      0.756863,
      0.907605,
      0.884398,
      0.938331,
      0.882353,
      0.9391,
      0.921799,
      0.958016,
      1,
      0.968627,
      0.956863,
      0.976471
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Oranges",
    RGBPoints: [
      -1,
      0.498039,
      0.152941,
      0.015686,
      -0.87451,
      0.57481,
      0.182468,
      0.013718,
      -0.74902,
      0.651765,
      0.212042,
      0.011734,
      -0.623529,
      0.752157,
      0.247474,
      0.007797,
      -0.498039,
      0.851719,
      0.283368,
      0.004475,
      -0.372549,
      0.898962,
      0.348328,
      0.039908,
      -0.247059,
      0.945652,
      0.413426,
      0.076401,
      -0.121569,
      0.969273,
      0.484291,
      0.157109,
      0.00392157,
      0.992157,
      0.554971,
      0.238185,
      0.129412,
      0.992157,
      0.619931,
      0.330704,
      0.254902,
      0.992157,
      0.684967,
      0.423837,
      0.380392,
      0.992157,
      0.751895,
      0.532103,
      0.505882,
      0.992249,
      0.817716,
      0.639354,
      0.631373,
      0.994218,
      0.861023,
      0.725967,
      0.756863,
      0.996186,
      0.903576,
      0.810965,
      0.882353,
      0.998155,
      0.933103,
      0.868051,
      1,
      1,
      0.960784,
      0.921569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Reds",
    RGBPoints: [
      -1,
      0.403922,
      0,
      0.05098,
      -0.87451,
      0.525967,
      0.029527,
      0.066728,
      -0.74902,
      0.647643,
      0.058962,
      0.082476,
      -0.623529,
      0.722445,
      0.076678,
      0.098224,
      -0.498039,
      0.797186,
      0.095194,
      0.114187,
      -0.372549,
      0.868051,
      0.164091,
      0.143714,
      -0.247059,
      0.937809,
      0.233541,
      0.173933,
      -0.121569,
      0.96143,
      0.326059,
      0.232987,
      0.00392157,
      0.984375,
      0.418147,
      0.292657,
      0.129412,
      0.986344,
      0.496886,
      0.371396,
      0.254902,
      0.988235,
      0.575702,
      0.450673,
      0.380392,
      0.988235,
      0.656409,
      0.543191,
      0.505882,
      0.98842,
      0.736747,
      0.635894,
      0.631373,
      0.992357,
      0.809581,
      0.732349,
      0.756863,
      0.996186,
      0.880692,
      0.826759,
      0.882353,
      0.998155,
      0.92203,
      0.885813,
      1,
      1,
      0.960784,
      0.941176
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdOr",
    RGBPoints: [
      -1,
      0.498039,
      0,
      0,
      -0.87451,
      0.6004,
      0,
      0,
      -0.74902,
      0.702514,
      0.000738,
      0.000477,
      -0.623529,
      0.773379,
      0.095225,
      0.061499,
      -0.498039,
      0.843875,
      0.189865,
      0.12283,
      -0.372549,
      0.891119,
      0.294195,
      0.203537,
      -0.247059,
      0.937855,
      0.397924,
      0.283137,
      -0.121569,
      0.963445,
      0.476663,
      0.316601,
      0.00392157,
      0.988297,
      0.555771,
      0.351665,
      0.129412,
      0.990265,
      0.646321,
      0.436309,
      0.254902,
      0.992157,
      0.735256,
      0.519646,
      0.380392,
      0.992157,
      0.784468,
      0.570827,
      0.505882,
      0.992249,
      0.833218,
      0.623483,
      0.631373,
      0.994218,
      0.872587,
      0.706159,
      0.756863,
      0.996186,
      0.911419,
      0.788189,
      0.882353,
      0.998155,
      0.940946,
      0.859054,
      1,
      1,
      0.968627,
      0.92549
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BrOrYl",
    RGBPoints: [
      -1,
      0.4,
      0.145098,
      0.023529,
      -0.87451,
      0.500392,
      0.174625,
      0.019592,
      -0.74902,
      0.600784,
      0.204291,
      0.015656,
      -0.623529,
      0.701176,
      0.251534,
      0.011719,
      -0.498039,
      0.800984,
      0.299146,
      0.008397,
      -0.372549,
      0.863975,
      0.370012,
      0.043829,
      -0.247059,
      0.926321,
      0.441107,
      0.0794,
      -0.121569,
      0.961753,
      0.521815,
      0.120738,
      0.00392157,
      0.996078,
      0.602645,
      0.163122,
      0.129412,
      0.996078,
      0.68729,
      0.237924,
      0.254902,
      0.996078,
      0.771011,
      0.314879,
      0.380392,
      0.996078,
      0.832034,
      0.444798,
      0.505882,
      0.996171,
      0.892042,
      0.572595,
      0.631373,
      0.998139,
      0.931411,
      0.65724,
      0.756863,
      1,
      0.969489,
      0.741669,
      0.882353,
      1,
      0.985236,
      0.822376,
      1,
      1,
      1,
      0.898039
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "RdOrYl",
    RGBPoints: [
      -1,
      0.501961,
      0,
      0.14902,
      -0.87451,
      0.622038,
      0,
      0.14902,
      -0.74902,
      0.741761,
      0.0004,
      0.148866,
      -0.623529,
      0.816563,
      0.05158,
      0.129181,
      -0.498039,
      0.890965,
      0.10356,
      0.110235,
      -0.372549,
      0.940177,
      0.205921,
      0.137793,
      -0.247059,
      0.988281,
      0.308789,
      0.165536,
      -0.121569,
      0.99025,
      0.432803,
      0.200969,
      0.00392157,
      0.992218,
      0.555217,
      0.236278,
      0.129412,
      0.994187,
      0.628051,
      0.267774,
      0.254902,
      0.996078,
      0.701038,
      0.301269,
      0.380392,
      0.996078,
      0.777809,
      0.383945,
      0.505882,
      0.996171,
      0.852826,
      0.466621,
      0.631373,
      0.998139,
      0.892195,
      0.549296,
      0.756863,
      1,
      0.931349,
      0.632188,
      0.882353,
      1,
      0.966782,
      0.7188,
      1,
      1,
      1,
      0.8
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "CIELab_blue2red",
    RGBPoints: [
      -1,
      0,
      0.6,
      0.74902,
      1,
      0.76863,
      0.46667,
      0.34118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "blue2yellow",
    RGBPoints: [
      -1,
      0,
      0,
      1,
      0,
      0.5,
      0.5,
      0.5,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2gold",
    RGBPoints: [
      -1,
      0.175119,
      0.0438468,
      1,
      -0.874016,
      0.22383,
      0.159771,
      0.94557,
      -0.748031,
      0.27254,
      0.233611,
      0.891216,
      -0.622047,
      0.321251,
      0.296526,
      0.836857,
      -0.496063,
      0.369962,
      0.354296,
      0.782359,
      -0.370079,
      0.418672,
      0.409139,
      0.72754,
      -0.244094,
      0.467383,
      0.462152,
      0.672148,
      -0.11811,
      0.51609,
      0.51396,
      0.615825,
      0.00787402,
      0.572863,
      0.55452,
      0.559172,
      0.133858,
      0.630269,
      0.593822,
      0.517729,
      0.259843,
      0.689588,
      0.624668,
      0.47446,
      0.385827,
      0.745394,
      0.656113,
      0.428638,
      0.511811,
      0.798624,
      0.688104,
      0.379105,
      0.637795,
      0.849926,
      0.720593,
      0.323834,
      0.76378,
      0.899765,
      0.753543,
      0.258657,
      0.889764,
      0.948487,
      0.78692,
      0.171778,
      1,
      0.990413,
      0.816451,
      0.00729848
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_blue2yellow",
    RGBPoints: [
      -1,
      0.0830122,
      0,
      0.495617,
      -0.87451,
      0.141973,
      0.0551288,
      0.57363,
      -0.74902,
      0.193048,
      0.110258,
      0.604561,
      -0.623529,
      0.234231,
      0.165386,
      0.57643,
      -0.498039,
      0.275413,
      0.220515,
      0.548299,
      -0.372549,
      0.316596,
      0.275644,
      0.520169,
      -0.247059,
      0.357778,
      0.330773,
      0.492038,
      -0.121569,
      0.398961,
      0.385901,
      0.463908,
      0.00392157,
      0.449929,
      0.438487,
      0.426815,
      0.129412,
      0.511572,
      0.488299,
      0.379944,
      0.254902,
      0.581222,
      0.53603,
      0.325741,
      0.380392,
      0.650871,
      0.583761,
      0.271538,
      0.505882,
      0.720521,
      0.631493,
      0.217335,
      0.631373,
      0.79017,
      0.679224,
      0.163132,
      0.756863,
      0.85982,
      0.726955,
      0.108929,
      0.882353,
      0.910254,
      0.774159,
      0.14112,
      1,
      0.927513,
      0.81759,
      0.306289
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_cyan2orange",
    RGBPoints: [
      -1,
      0.0471513,
      0.213874,
      0.414329,
      -0.87451,
      0.0674702,
      0.256648,
      0.439027,
      -0.74902,
      0.0959957,
      0.299331,
      0.462089,
      -0.623529,
      0.132428,
      0.341872,
      0.483212,
      -0.498039,
      0.188743,
      0.38277,
      0.500597,
      -0.372549,
      0.268511,
      0.420229,
      0.512179,
      -0.247059,
      0.352945,
      0.455602,
      0.519101,
      -0.121569,
      0.43893,
      0.489368,
      0.521538,
      0.00392157,
      0.522445,
      0.522495,
      0.522436,
      0.129412,
      0.600089,
      0.555682,
      0.53205,
      0.254902,
      0.67988,
      0.587981,
      0.539163,
      0.380392,
      0.761011,
      0.619586,
      0.544439,
      0.505882,
      0.84278,
      0.650741,
      0.548567,
      0.631373,
      0.910713,
      0.687347,
      0.557822,
      0.756863,
      0.952232,
      0.734972,
      0.577775,
      0.882353,
      0.975642,
      0.789858,
      0.604868,
      1,
      0.990752,
      0.843643,
      0.632857
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2green",
    RGBPoints: [
      -1,
      0.235006,
      0.0483128,
      0.530899,
      -0.87451,
      0.302968,
      0.108419,
      0.552391,
      -0.74902,
      0.360241,
      0.166059,
      0.569502,
      -0.623529,
      0.406746,
      0.226782,
      0.579373,
      -0.498039,
      0.444073,
      0.28964,
      0.582094,
      -0.372549,
      0.473648,
      0.353774,
      0.577947,
      -0.247059,
      0.497636,
      0.418154,
      0.567911,
      -0.121569,
      0.519086,
      0.481741,
      0.553968,
      0.00392157,
      0.542884,
      0.542914,
      0.542875,
      0.129412,
      0.566303,
      0.603989,
      0.527499,
      0.254902,
      0.595218,
      0.662965,
      0.516857,
      0.380392,
      0.628641,
      0.720701,
      0.510673,
      0.505882,
      0.665373,
      0.777849,
      0.508165,
      0.631373,
      0.704182,
      0.834921,
      0.508303,
      0.756863,
      0.743846,
      0.892328,
      0.50999,
      0.882353,
      0.783158,
      0.950422,
      0.512181,
      1,
      0.818617,
      1,
      0.513888
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_purple2green_dark",
    RGBPoints: [
      -1,
      0.107656,
      0,
      0.428682,
      -0.87451,
      0.1924,
      0,
      0.449799,
      -0.74902,
      0.255118,
      0.0648939,
      0.466726,
      -0.623529,
      0.304256,
      0.133066,
      0.476703,
      -0.498039,
      0.343202,
      0.19716,
      0.479793,
      -0.372549,
      0.373876,
      0.260353,
      0.476241,
      -0.247059,
      0.398497,
      0.322872,
      0.466953,
      -0.121569,
      0.420016,
      0.384252,
      0.453785,
      0.00392157,
      0.44319,
      0.443216,
      0.443186,
      0.129412,
      0.465553,
      0.502139,
      0.428233,
      0.254902,
      0.492959,
      0.559151,
      0.417591,
      0.380392,
      0.524654,
      0.615092,
      0.411016,
      0.505882,
      0.55959,
      0.670583,
      0.40779,
      0.631373,
      0.596614,
      0.726102,
      0.406948,
      0.756863,
      0.634544,
      0.782032,
      0.407439,
      0.882353,
      0.672183,
      0.838703,
      0.408237,
      1,
      0.706131,
      0.892759,
      0.408452
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "coolwarm",
    RGBPoints: [
      -1,
      0.229806,
      0.298718,
      0.753683,
      -0.875,
      0.303869,
      0.406535,
      0.844959,
      -0.75,
      0.383013,
      0.509419,
      0.917388,
      -0.625,
      0.466667,
      0.604563,
      0.968155,
      -0.5,
      0.552953,
      0.688929,
      0.995376,
      -0.375,
      0.639176,
      0.7596,
      0.998151,
      -0.25,
      0.722193,
      0.813953,
      0.976575,
      -0.125,
      0.798692,
      0.849786,
      0.931689,
      0,
      0.865395,
      0.86541,
      0.865396,
      0.125,
      0.924128,
      0.827385,
      0.774508,
      0.25,
      0.958853,
      0.769768,
      0.678008,
      0.375,
      0.969954,
      0.694267,
      0.579375,
      0.5,
      0.958003,
      0.602842,
      0.481776,
      0.625,
      0.923945,
      0.497309,
      0.38797,
      0.75,
      0.869187,
      0.378313,
      0.300267,
      0.875,
      0.795632,
      0.241284,
      0.220526,
      1,
      0.705673,
      0.0155562,
      0.150233
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BuRd",
    RGBPoints: [
      -1,
      0.019608,
      0.188235,
      0.380392,
      -0.87451,
      0.088504,
      0.321107,
      0.564937,
      -0.74902,
      0.163399,
      0.444983,
      0.697501,
      -0.623529,
      0.247059,
      0.555709,
      0.754095,
      -0.498039,
      0.420684,
      0.676432,
      0.818685,
      -0.372549,
      0.606459,
      0.789773,
      0.880277,
      -0.247059,
      0.761476,
      0.868512,
      0.924567,
      -0.121569,
      0.878047,
      0.925721,
      0.951942,
      0.00392157,
      0.969089,
      0.966474,
      0.964937,
      0.129412,
      0.983852,
      0.897578,
      0.846828,
      0.254902,
      0.982468,
      0.800692,
      0.706113,
      0.380392,
      0.960323,
      0.66782,
      0.536332,
      0.505882,
      0.894579,
      0.503806,
      0.399769,
      0.631373,
      0.81707,
      0.33218,
      0.281046,
      0.756863,
      0.728489,
      0.155017,
      0.197386,
      0.882353,
      0.576932,
      0.055363,
      0.14925,
      1,
      0.403922,
      0,
      0.121569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Spectral_lowBlue",
    RGBPoints: [
      -1,
      0.368627,
      0.309804,
      0.635294,
      -0.87451,
      0.260361,
      0.450058,
      0.70173,
      -0.74902,
      0.248058,
      0.591311,
      0.717186,
      -0.623529,
      0.376009,
      0.734025,
      0.658132,
      -0.498039,
      0.537947,
      0.814764,
      0.64506,
      -0.372549,
      0.702345,
      0.879585,
      0.636678,
      -0.247059,
      0.84752,
      0.938639,
      0.607151,
      -0.121569,
      0.940408,
      0.976163,
      0.656055,
      0.00392157,
      0.999923,
      0.997616,
      0.745021,
      0.129412,
      0.997463,
      0.921338,
      0.61707,
      0.254902,
      0.995002,
      0.824606,
      0.499885,
      0.380392,
      0.992541,
      0.701576,
      0.39654,
      0.505882,
      0.973472,
      0.547405,
      0.318108,
      0.631373,
      0.937793,
      0.398539,
      0.270127,
      0.756863,
      0.861515,
      0.282891,
      0.299654,
      0.882353,
      0.746482,
      0.144637,
      0.288812,
      1,
      0.619608,
      0.003922,
      0.258824
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnRP",
    RGBPoints: [
      -1,
      0,
      0.266667,
      0.105882,
      -0.87451,
      0.066436,
      0.394617,
      0.174779,
      -0.74902,
      0.168858,
      0.524567,
      0.25767,
      -0.623529,
      0.323875,
      0.657439,
      0.361015,
      -0.498039,
      0.504883,
      0.772318,
      0.506344,
      -0.372549,
      0.678431,
      0.870127,
      0.654902,
      -0.247059,
      0.803922,
      0.921799,
      0.780392,
      -0.121569,
      0.897116,
      0.951942,
      0.882814,
      0.00392157,
      0.967397,
      0.965936,
      0.967474,
      0.129412,
      0.928028,
      0.879815,
      0.930565,
      0.254902,
      0.866052,
      0.780777,
      0.882891,
      0.380392,
      0.77501,
      0.665129,
      0.821376,
      0.505882,
      0.675663,
      0.537024,
      0.737024,
      0.631373,
      0.57847,
      0.396155,
      0.645982,
      0.756863,
      0.492349,
      0.223914,
      0.547559,
      0.882353,
      0.375548,
      0.096886,
      0.423299,
      1,
      0.25098,
      0,
      0.294118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GYPi",
    RGBPoints: [
      -1,
      0.152941,
      0.392157,
      0.098039,
      -0.87451,
      0.246444,
      0.505344,
      0.117724,
      -0.74902,
      0.351942,
      0.614533,
      0.161399,
      -0.623529,
      0.474971,
      0.717878,
      0.240138,
      -0.498039,
      0.611995,
      0.811226,
      0.392849,
      -0.372549,
      0.746328,
      0.893118,
      0.565321,
      -0.247059,
      0.859516,
      0.94233,
      0.747405,
      -0.121569,
      0.928105,
      0.96386,
      0.875663,
      0.00392157,
      0.969089,
      0.966859,
      0.968012,
      0.129412,
      0.983852,
      0.910265,
      0.948328,
      0.254902,
      0.979239,
      0.833218,
      0.914648,
      0.380392,
      0.949712,
      0.729873,
      0.862976,
      0.505882,
      0.905652,
      0.58293,
      0.763552,
      0.631373,
      0.85521,
      0.410073,
      0.652211,
      0.756863,
      0.793695,
      0.183699,
      0.531642,
      0.882353,
      0.683737,
      0.063899,
      0.420761,
      1,
      0.556863,
      0.003922,
      0.321569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GnYlRd",
    RGBPoints: [
      -1,
      0,
      0.407843,
      0.215686,
      -0.87451,
      0.063975,
      0.525952,
      0.277201,
      -0.74902,
      0.177932,
      0.633064,
      0.332718,
      -0.623529,
      0.364937,
      0.724106,
      0.379469,
      -0.498039,
      0.527951,
      0.797155,
      0.40223,
      -0.372549,
      0.678431,
      0.862822,
      0.433449,
      -0.247059,
      0.803922,
      0.916955,
      0.514648,
      -0.121569,
      0.909419,
      0.961861,
      0.625067,
      0.00392157,
      0.999923,
      0.997616,
      0.745021,
      0.129412,
      0.997463,
      0.921338,
      0.61707,
      0.254902,
      0.995002,
      0.824606,
      0.499885,
      0.380392,
      0.992541,
      0.701576,
      0.39654,
      0.505882,
      0.973472,
      0.547405,
      0.318108,
      0.631373,
      0.939023,
      0.389927,
      0.245521,
      0.756863,
      0.867666,
      0.239831,
      0.176624,
      0.882353,
      0.762399,
      0.110727,
      0.151326,
      1,
      0.647059,
      0,
      0.14902
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GBBr",
    RGBPoints: [
      -1,
      0,
      0.235294,
      0.188235,
      -0.87451,
      0.002461,
      0.338639,
      0.301423,
      -0.74902,
      0.055902,
      0.448981,
      0.417609,
      -0.623529,
      0.183852,
      0.56955,
      0.538178,
      -0.498039,
      0.357785,
      0.700115,
      0.660746,
      -0.372549,
      0.540177,
      0.819531,
      0.77624,
      -0.247059,
      0.714879,
      0.890888,
      0.864821,
      -0.121569,
      0.851134,
      0.934564,
      0.922645,
      0.00392157,
      0.960861,
      0.959785,
      0.95694,
      0.129412,
      0.963322,
      0.927797,
      0.83391,
      0.254902,
      0.939946,
      0.868897,
      0.68935,
      0.380392,
      0.883353,
      0.775394,
      0.517109,
      0.505882,
      0.808074,
      0.625836,
      0.324106,
      0.631373,
      0.717647,
      0.476355,
      0.15494,
      0.756863,
      0.592157,
      0.358247,
      0.06882,
      0.882353,
      0.458593,
      0.26436,
      0.031142,
      1,
      0.329412,
      0.188235,
      0.019608
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PuOr",
    RGBPoints: [
      -1,
      0.498039,
      0.231373,
      0.031373,
      -0.87451,
      0.62599,
      0.30273,
      0.026451,
      -0.74902,
      0.746943,
      0.387082,
      0.037524,
      -0.623529,
      0.85767,
      0.490427,
      0.071972,
      -0.498039,
      0.936409,
      0.617762,
      0.236371,
      -0.372549,
      0.992695,
      0.743099,
      0.43291,
      -0.247059,
      0.995156,
      0.841523,
      0.63714,
      -0.121569,
      0.985313,
      0.913802,
      0.813687,
      0.00392157,
      0.966244,
      0.966398,
      0.967705,
      0.129412,
      0.889965,
      0.89504,
      0.938178,
      0.254902,
      0.806151,
      0.804306,
      0.894656,
      0.380392,
      0.712649,
      0.688658,
      0.833141,
      0.505882,
      0.594233,
      0.554325,
      0.744637,
      0.631373,
      0.474894,
      0.404229,
      0.652364,
      0.756863,
      0.366628,
      0.217224,
      0.563783,
      0.882353,
      0.266436,
      0.089965,
      0.434833,
      1,
      0.176471,
      0,
      0.294118
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PRGn",
    RGBPoints: [
      -1,
      0.25098,
      0,
      0.294118,
      -0.87451,
      0.383852,
      0.103345,
      0.431911,
      -0.74902,
      0.497732,
      0.234679,
      0.55371,
      -0.623529,
      0.583852,
      0.40692,
      0.652134,
      -0.498039,
      0.681968,
      0.545175,
      0.742561,
      -0.372549,
      0.7807,
      0.672357,
      0.825221,
      -0.247059,
      0.871742,
      0.788005,
      0.886736,
      -0.121569,
      0.930488,
      0.885198,
      0.932872,
      0.00392157,
      0.966321,
      0.968089,
      0.965859,
      0.129412,
      0.892503,
      0.950865,
      0.877278,
      0.254902,
      0.796078,
      0.91857,
      0.772549,
      0.380392,
      0.670588,
      0.866897,
      0.647059,
      0.505882,
      0.493195,
      0.765398,
      0.496655,
      0.631373,
      0.314187,
      0.649135,
      0.354556,
      0.756863,
      0.15917,
      0.516263,
      0.251211,
      0.882353,
      0.062284,
      0.386621,
      0.170473,
      1,
      0,
      0.266667,
      0.105882
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "PiYG",
    RGBPoints: [
      -1,
      0.556863,
      0.003922,
      0.321569,
      -0.87451,
      0.692195,
      0.067897,
      0.427374,
      -0.74902,
      0.797539,
      0.197847,
      0.539177,
      -0.623529,
      0.859054,
      0.424221,
      0.659746,
      -0.498039,
      0.908574,
      0.592618,
      0.770319,
      -0.372549,
      0.951557,
      0.736332,
      0.866205,
      -0.247059,
      0.981084,
      0.839677,
      0.917878,
      -0.121569,
      0.98293,
      0.913802,
      0.949558,
      0.00392157,
      0.96732,
      0.968474,
      0.965629,
      0.129412,
      0.92549,
      0.963552,
      0.869666,
      0.254902,
      0.852441,
      0.939254,
      0.736025,
      0.380392,
      0.739254,
      0.890042,
      0.553941,
      0.505882,
      0.60323,
      0.805536,
      0.382238,
      0.631373,
      0.467282,
      0.711419,
      0.235217,
      0.756863,
      0.344252,
      0.608074,
      0.156478,
      0.882353,
      0.2406,
      0.49827,
      0.116494,
      1,
      0.152941,
      0.392157,
      0.098039
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "OrPu",
    RGBPoints: [
      -1,
      0.176471,
      0,
      0.294118,
      -0.87451,
      0.272434,
      0.095963,
      0.444214,
      -0.74902,
      0.373395,
      0.228912,
      0.56932,
      -0.623529,
      0.481661,
      0.415917,
      0.657901,
      -0.498039,
      0.601922,
      0.562937,
      0.750481,
      -0.372549,
      0.718493,
      0.695886,
      0.836986,
      -0.247059,
      0.811995,
      0.811534,
      0.898501,
      -0.121569,
      0.894733,
      0.8995,
      0.940023,
      0.00392157,
      0.969166,
      0.966859,
      0.963629,
      0.129412,
      0.98639,
      0.910265,
      0.803691,
      0.254902,
      0.995002,
      0.835371,
      0.624375,
      0.380392,
      0.992541,
      0.736947,
      0.420146,
      0.505882,
      0.931949,
      0.609458,
      0.224221,
      0.631373,
      0.85075,
      0.483968,
      0.069819,
      0.756863,
      0.740023,
      0.380623,
      0.035371,
      0.882353,
      0.617993,
      0.29827,
      0.026759,
      1,
      0.498039,
      0.231373,
      0.031373
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "BrBG",
    RGBPoints: [
      -1,
      0.329412,
      0.188235,
      0.019608,
      -0.87451,
      0.467205,
      0.269435,
      0.031911,
      -0.74902,
      0.6,
      0.365629,
      0.074202,
      -0.623529,
      0.72549,
      0.483737,
      0.160323,
      -0.498039,
      0.812995,
      0.635832,
      0.336409,
      -0.372549,
      0.88689,
      0.781238,
      0.527874,
      -0.247059,
      0.943483,
      0.87474,
      0.700115,
      -0.121569,
      0.963168,
      0.929796,
      0.841599,
      0.00392157,
      0.957247,
      0.959938,
      0.959554,
      0.129412,
      0.84406,
      0.932872,
      0.920185,
      0.254902,
      0.70396,
      0.886428,
      0.859285,
      0.380392,
      0.529258,
      0.815071,
      0.770704,
      0.505882,
      0.346251,
      0.691811,
      0.653057,
      0.631373,
      0.175855,
      0.562015,
      0.530642,
      0.756863,
      0.047905,
      0.441446,
      0.410073,
      0.882353,
      0.002307,
      0.33218,
      0.294348,
      1,
      0,
      0.235294,
      0.188235
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "GyRd",
    RGBPoints: [
      -1,
      0.101961,
      0.101961,
      0.101961,
      -0.87451,
      0.227451,
      0.227451,
      0.227451,
      -0.74902,
      0.359939,
      0.359939,
      0.359939,
      -0.623529,
      0.502653,
      0.502653,
      0.502653,
      -0.498039,
      0.631373,
      0.631373,
      0.631373,
      -0.372549,
      0.749865,
      0.749865,
      0.749865,
      -0.247059,
      0.843368,
      0.843368,
      0.843368,
      -0.121569,
      0.926105,
      0.926105,
      0.926105,
      0.00392157,
      0.999846,
      0.997232,
      0.995694,
      0.129412,
      0.994925,
      0.908651,
      0.857901,
      0.254902,
      0.982468,
      0.800692,
      0.706113,
      0.380392,
      0.960323,
      0.66782,
      0.536332,
      0.505882,
      0.894579,
      0.503806,
      0.399769,
      0.631373,
      0.81707,
      0.33218,
      0.281046,
      0.756863,
      0.728489,
      0.155017,
      0.197386,
      0.882353,
      0.576932,
      0.055363,
      0.14925,
      1,
      0.403922,
      0,
      0.121569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divHi_purpleGreen",
    RGBPoints: [
      -1,
      0.297553,
      0,
      0.489074,
      -0.87451,
      0.40259,
      0.151146,
      0.567754,
      -0.74902,
      0.516038,
      0.284843,
      0.658231,
      -0.623529,
      0.629783,
      0.423646,
      0.750938,
      -0.498039,
      0.735198,
      0.563697,
      0.835956,
      -0.372549,
      0.82408,
      0.695541,
      0.903582,
      -0.247059,
      0.889091,
      0.807454,
      0.944862,
      -0.121569,
      0.92334,
      0.886917,
      0.951839,
      0.00392157,
      0.921045,
      0.921084,
      0.921003,
      0.129412,
      0.877324,
      0.907455,
      0.845381,
      0.254902,
      0.797649,
      0.849713,
      0.734695,
      0.380392,
      0.691646,
      0.75964,
      0.600532,
      0.505882,
      0.568981,
      0.649159,
      0.453807,
      0.631373,
      0.438945,
      0.529756,
      0.304259,
      0.756863,
      0.30973,
      0.412001,
      0.158303,
      0.882353,
      0.187078,
      0.305111,
      0.00251458,
      1,
      0.101655,
      0.220836,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divHi_purpleGreen_dim",
    RGBPoints: [
      -1,
      0.404088,
      0.131038,
      0.592767,
      -0.87451,
      0.486469,
      0.230957,
      0.651243,
      -0.74902,
      0.575165,
      0.339335,
      0.717723,
      -0.623529,
      0.662741,
      0.454332,
      0.784263,
      -0.498039,
      0.742071,
      0.570213,
      0.842918,
      -0.372549,
      0.806935,
      0.678992,
      0.886227,
      -0.247059,
      0.852219,
      0.771315,
      0.90763,
      -0.121569,
      0.873345,
      0.837327,
      0.901572,
      0.00392157,
      0.866783,
      0.86682,
      0.866745,
      0.129412,
      0.82839,
      0.858225,
      0.796812,
      0.254902,
      0.762578,
      0.814287,
      0.700202,
      0.380392,
      0.676429,
      0.744229,
      0.585735,
      0.505882,
      0.577033,
      0.65732,
      0.461526,
      0.631373,
      0.47128,
      0.562476,
      0.33476,
      0.756863,
      0.365461,
      0.467957,
      0.21076,
      0.882353,
      0.264758,
      0.381138,
      0.0878313,
      1,
      0.182591,
      0.312249,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divLow_icePeach",
    RGBPoints: [
      -1,
      0.480048,
      0.817441,
      0.998056,
      -0.87451,
      0.425898,
      0.726921,
      0.883187,
      -0.74902,
      0.366682,
      0.629445,
      0.761936,
      -0.623529,
      0.308756,
      0.531002,
      0.640217,
      -0.498039,
      0.258021,
      0.43705,
      0.523433,
      -0.372549,
      0.219244,
      0.352381,
      0.416348,
      -0.247059,
      0.195127,
      0.281032,
      0.322979,
      -0.121569,
      0.186286,
      0.22627,
      0.246525,
      0.00392157,
      0.192352,
      0.19236,
      0.192364,
      0.129412,
      0.255927,
      0.214469,
      0.191756,
      0.254902,
      0.340459,
      0.254426,
      0.206666,
      0.380392,
      0.444655,
      0.309315,
      0.234029,
      0.505882,
      0.565353,
      0.376004,
      0.270969,
      0.631373,
      0.697917,
      0.450748,
      0.314293,
      0.756863,
      0.836657,
      0.529064,
      0.360227,
      0.882353,
      0.972695,
      0.614884,
      0.413123,
      1,
      1,
      0.705904,
      0.472699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_divLow_purpleGreen",
    RGBPoints: [
      -1,
      0.956034,
      0.666487,
      0.952663,
      -0.87451,
      0.874457,
      0.572698,
      0.936352,
      -0.74902,
      0.753465,
      0.488253,
      0.909063,
      -0.623529,
      0.63309,
      0.413507,
      0.763833,
      -0.498039,
      0.514491,
      0.345878,
      0.620015,
      -0.372549,
      0.405008,
      0.288141,
      0.484376,
      -0.247059,
      0.311388,
      0.241986,
      0.363556,
      -0.121569,
      0.238722,
      0.209044,
      0.263449,
      0.00392157,
      0.192352,
      0.192366,
      0.192362,
      0.129412,
      0.200379,
      0.233201,
      0.168618,
      0.254902,
      0.230151,
      0.291737,
      0.165227,
      0.380392,
      0.279481,
      0.366076,
      0.178607,
      0.505882,
      0.344927,
      0.453267,
      0.205703,
      0.631373,
      0.421554,
      0.549449,
      0.242643,
      0.756863,
      0.503334,
      0.649999,
      0.284377,
      0.882353,
      0.583497,
      0.749672,
      0.324969,
      1,
      0.650705,
      0.837228,
      0.356264
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_green",
    RGBPoints: [
      -1,
      1,
      0.835294,
      0.886275,
      -0.87451,
      0.937255,
      0.756863,
      0.870443,
      -0.74902,
      0.875817,
      0.666376,
      0.857807,
      -0.623529,
      0.778359,
      0.583007,
      0.808134,
      -0.498039,
      0.676253,
      0.494118,
      0.745098,
      -0.372549,
      0.561365,
      0.390123,
      0.682353,
      -0.247059,
      0.438344,
      0.262745,
      0.621496,
      -0.121569,
      0.321133,
      0.141031,
      0.558751,
      0.00392157,
      0.203922,
      0.0217865,
      0.495861,
      0.129412,
      0.265505,
      0.129412,
      0.433261,
      0.254902,
      0.311692,
      0.255338,
      0.37008,
      0.380392,
      0.356282,
      0.377342,
      0.310821,
      0.505882,
      0.39971,
      0.488889,
      0.258243,
      0.631373,
      0.442556,
      0.604357,
      0.205519,
      0.756863,
      0.48671,
      0.71968,
      0.152941,
      0.882353,
      0.529847,
      0.830356,
      0.100944,
      1,
      0.572549,
      0.933333,
      0.054902
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_lime",
    RGBPoints: [
      -1,
      0.704034,
      0.784196,
      1,
      -0.87451,
      0.633111,
      0.691418,
      0.956078,
      -0.74902,
      0.564021,
      0.600606,
      0.912157,
      -0.623529,
      0.496827,
      0.51189,
      0.868235,
      -0.498039,
      0.43157,
      0.425416,
      0.824314,
      -0.372549,
      0.368248,
      0.341347,
      0.780392,
      -0.247059,
      0.306767,
      0.259855,
      0.736471,
      -0.121569,
      0.246862,
      0.181069,
      0.692549,
      0.00392157,
      0.191619,
      0.109542,
      0.648627,
      0.129412,
      0.257404,
      0.194031,
      0.604706,
      0.254902,
      0.321794,
      0.278775,
      0.560784,
      0.380392,
      0.387909,
      0.364617,
      0.516863,
      0.505882,
      0.456569,
      0.451881,
      0.472941,
      0.631373,
      0.527424,
      0.540773,
      0.42902,
      0.756863,
      0.599759,
      0.631427,
      0.385098,
      0.882353,
      0.673065,
      0.723898,
      0.341176,
      1,
      0.742751,
      0.812252,
      0.3
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Haze",
    RGBPoints: [
      -1,
      1,
      0.835294,
      0.996078,
      -0.00392157,
      0.023529,
      0.141176,
      0.498039,
      0.00392157,
      0.015686,
      0.137255,
      0.494118,
      1,
      0.984314,
      0.764706,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "Haze_cyan",
    RGBPoints: [
      -1,
      0.956863,
      1,
      0.835294,
      -0.87451,
      0.933188,
      0.921714,
      0.760784,
      -0.74902,
      0.870588,
      0.803486,
      0.671605,
      -0.623529,
      0.807843,
      0.684096,
      0.583297,
      -0.498039,
      0.745098,
      0.569208,
      0.494118,
      -0.372549,
      0.682353,
      0.437763,
      0.390123,
      -0.247059,
      0.621496,
      0.288163,
      0.262745,
      -0.121569,
      0.558751,
      0.144517,
      0.141031,
      0.00392157,
      0.495861,
      0.0217865,
      0.0413943,
      0.129412,
      0.433261,
      0.137255,
      0.129412,
      0.254902,
      0.37008,
      0.263181,
      0.255338,
      0.380392,
      0.306318,
      0.381845,
      0.372694,
      0.505882,
      0.243137,
      0.503994,
      0.494263,
      0.631373,
      0.180392,
      0.629484,
      0.619753,
      0.756863,
      0.117647,
      0.754975,
      0.747131,
      0.882353,
      0.054902,
      0.876398,
      0.866812,
      1,
      0,
      0.988235,
      0.976471
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "nic_Edge",
    RGBPoints: [
      -1,
      0.191208,
      0.191208,
      0.191208,
      -0.87451,
      0.239484,
      0.00545035,
      0.614821,
      -0.74902,
      0.220593,
      0.0617459,
      0.863547,
      -0.623529,
      0.17509,
      0.278988,
      0.97794,
      -0.498039,
      0.143526,
      0.576069,
      0.998553,
      -0.372549,
      0.166456,
      0.871883,
      0.96594,
      -0.247059,
      0.376202,
      0.993555,
      0.981833,
      -0.121569,
      0.681996,
      0.991297,
      0.999239,
      0.00392157,
      0.954172,
      0.952734,
      0.94374,
      0.129412,
      0.999735,
      0.99301,
      0.662896,
      0.254902,
      0.979399,
      0.991466,
      0.357973,
      0.380392,
      0.968771,
      0.854967,
      0.162659,
      0.505882,
      0.999245,
      0.556697,
      0.144323,
      0.631373,
      0.973959,
      0.26223,
      0.177946,
      0.756863,
      0.852358,
      0.0526707,
      0.222974,
      0.882353,
      0.593889,
      0.00912724,
      0.238855,
      1,
      0.191208,
      0.191208,
      0.191208
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_iceFire_H",
    RGBPoints: [
      -1,
      0.000000405432,
      0,
      0.00000590122,
      -0.87451,
      0,
      0.120401,
      0.302675,
      -0.74902,
      0,
      0.216583,
      0.524574,
      -0.623529,
      0.0552475,
      0.345025,
      0.6595,
      -0.498039,
      0.128047,
      0.492588,
      0.720288,
      -0.372549,
      0.188955,
      0.641309,
      0.792092,
      -0.247059,
      0.327673,
      0.784935,
      0.873434,
      -0.121569,
      0.60824,
      0.892164,
      0.935547,
      0.00392157,
      0.881371,
      0.912178,
      0.818099,
      0.129412,
      0.951407,
      0.835621,
      0.449279,
      0.254902,
      0.904481,
      0.690489,
      0,
      0.380392,
      0.85407,
      0.510864,
      0,
      0.505882,
      0.777093,
      0.33018,
      0.00088199,
      0.631373,
      0.672862,
      0.139087,
      0.00269398,
      0.756863,
      0.508815,
      0,
      0,
      0.882353,
      0.299417,
      0.000366289,
      0.000547829,
      1,
      0.0157519,
      0.00332021,
      0.0000000455569
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_iceFire_L",
    RGBPoints: [
      -1,
      0.870485,
      0.913768,
      0.832905,
      -0.87451,
      0.586919,
      0.887865,
      0.934003,
      -0.74902,
      0.31583,
      0.776442,
      0.867858,
      -0.623529,
      0.18302,
      0.632034,
      0.787722,
      -0.498039,
      0.117909,
      0.484134,
      0.713825,
      -0.372549,
      0.0507239,
      0.335979,
      0.654741,
      -0.247059,
      0,
      0.209874,
      0.511832,
      -0.121569,
      0,
      0.114689,
      0.28935,
      0.00392157,
      0.0157519,
      0.00332021,
      0.0000000455569,
      0.129412,
      0.312914,
      0,
      0,
      0.254902,
      0.520865,
      0,
      0,
      0.380392,
      0.680105,
      0.15255,
      0.0025996,
      0.505882,
      0.785109,
      0.339479,
      0.000797922,
      0.631373,
      0.857354,
      0.522494,
      0,
      0.756863,
      0.910974,
      0.699774,
      0,
      0.882353,
      0.951921,
      0.842817,
      0.478545,
      1,
      0.881371,
      0.912178,
      0.818099
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "hsv",
    RGBPoints: [
      -1,
      1,
      0,
      0,
      -0.666666,
      1,
      0,
      1,
      -0.333333,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0.33333,
      0,
      1,
      0,
      0.66666,
      1,
      1,
      0,
      1,
      1,
      0,
      0
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "hue_L60",
    RGBPoints: [
      -1,
      0.964784,
      0.400592,
      0.349549,
      -0.87451,
      0.964915,
      0.372498,
      0.53785,
      -0.74902,
      0.892353,
      0.401039,
      0.759569,
      -0.623529,
      0.79263,
      0.446956,
      0.903017,
      -0.498039,
      0.682208,
      0.49954,
      0.966673,
      -0.372549,
      0.56392,
      0.553082,
      0.968836,
      -0.247059,
      0.442031,
      0.606396,
      0.901601,
      -0.121569,
      0.305499,
      0.65701,
      0.765784,
      0.00392157,
      0.197251,
      0.687914,
      0.620914,
      0.129412,
      0.193882,
      0.701887,
      0.472654,
      0.254902,
      0.249866,
      0.706123,
      0.320005,
      0.380392,
      0.35132,
      0.697417,
      0.202919,
      0.505882,
      0.498097,
      0.669467,
      0.125232,
      0.631373,
      0.637477,
      0.626239,
      0.107431,
      0.756863,
      0.762115,
      0.56872,
      0.155812,
      0.882353,
      0.889434,
      0.481116,
      0.240445,
      1,
      0.964784,
      0.400592,
      0.349549
    ]
  },
  {
    IndexedColors: [
      0,
      0,
      0,
      0.8941176470588236,
      0.1019607843137255,
      0.1098039215686274,
      0.2156862745098039,
      0.4941176470588236,
      0.7215686274509804,
      0.3019607843137255,
      0.6862745098039216,
      0.2901960784313726,
      0.596078431372549,
      0.3058823529411765,
      0.6392156862745098,
      1,
      0.4980392156862745,
      0,
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392
    ],
    Name: "Spectrum",
    NanColor: [
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392
    ]
  },
  {
    IndexedColors: [
      0.4745098039215686,
      0.09019607843137255,
      0.09019607843137255,
      0.7098039215686275,
      0.00392156862745098,
      0.00392156862745098,
      0.9372549019607843,
      0.2784313725490196,
      0.09803921568627451,
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353,
      1,
      0.7058823529411765,
      0,
      1,
      0.8980392156862745,
      0.02352941176470588
    ],
    Name: "Warm",
    NanColor: [
      1,
      0.8980392156862745,
      0.02352941176470588
    ]
  },
  {
    IndexedColors: [
      0.4588235294117647,
      0.6941176470588235,
      0.00392156862745098,
      0.3450980392156863,
      0.5019607843137255,
      0.1607843137254902,
      0.3137254901960784,
      0.8431372549019608,
      0.7490196078431373,
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.6039215686274509,
      0.407843137254902,
      1,
      0.3725490196078431,
      0.2,
      0.5019607843137255
    ],
    Name: "Cool",
    NanColor: [
      0.3725490196078431,
      0.2,
      0.5019607843137255
    ]
  },
  {
    IndexedColors: [
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.3058823529411765,
      0.8509803921568627,
      0.9176470588235294,
      0.4509803921568628,
      0.6039215686274509,
      0.8352941176470589,
      0.2588235294117647,
      0.2392156862745098,
      0.6627450980392157,
      0.3137254901960784,
      0.3294117647058823,
      0.5294117647058824,
      0.06274509803921569,
      0.1647058823529412,
      0.3215686274509804
    ],
    Name: "Blues",
    NanColor: [
      0.06274509803921569,
      0.1647058823529412,
      0.3215686274509804
    ]
  },
  {
    IndexedColors: [
      0.1098039215686274,
      0.5843137254901961,
      0.803921568627451,
      0.2313725490196079,
      0.407843137254902,
      0.6705882352941176,
      0.4,
      0.2431372549019608,
      0.7176470588235294,
      0.6352941176470588,
      0.3294117647058823,
      0.8117647058823529,
      0.8705882352941177,
      0.3803921568627451,
      0.807843137254902,
      0.8627450980392157,
      0.3803921568627451,
      0.5843137254901961,
      0.2392156862745098,
      0.06274509803921569,
      0.3215686274509804
    ],
    Name: "Wild Flower",
    NanColor: [
      0.2392156862745098,
      0.06274509803921569,
      0.3215686274509804
    ]
  },
  {
    IndexedColors: [
      0.396078431372549,
      0.4862745098039216,
      0.2156862745098039,
      0.4588235294117647,
      0.6941176470588235,
      0.00392156862745098,
      0.6980392156862745,
      0.7294117647058823,
      0.1882352941176471,
      1,
      0.8980392156862745,
      0.02352941176470588,
      1,
      0.7058823529411765,
      0,
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353
    ],
    Name: "Citrus",
    NanColor: [
      0.9764705882352941,
      0.5137254901960784,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.2313725490196079,
      0.03137254901960784,
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333,
      0.1764705882352941,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Diverging Purple-Orange (11)",
    NanColor: [
      0.1764705882352941,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.2313725490196079,
      0.03137254901960784,
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333,
      0.1764705882352941,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Diverging Purple-Orange (10)",
    NanColor: [
      0.1764705882352941,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (9)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.8784313725490196,
      0.5098039215686274,
      0.0784313725490196,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.5019607843137255,
      0.4509803921568628,
      0.6745098039215687,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (8)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6,
      0.5568627450980392,
      0.7647058823529411,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (7)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.3450980392156863,
      0.02352941176470588,
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.996078431372549,
      0.8784313725490196,
      0.7137254901960784,
      0.8470588235294118,
      0.8549019607843137,
      0.9215686274509803,
      0.6,
      0.5568627450980392,
      0.7647058823529411,
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ],
    Name: "Brewer Diverging Purple-Orange (6)",
    NanColor: [
      0.3294117647058823,
      0.1529411764705882,
      0.5333333333333333
    ]
  },
  {
    IndexedColors: [
      0.9019607843137255,
      0.3803921568627451,
      0.00392156862745098,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ],
    Name: "Brewer Diverging Purple-Orange (5)",
    NanColor: [
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.9019607843137255,
      0.3803921568627451,
      0.00392156862745098,
      0.9921568627450981,
      0.7215686274509804,
      0.3882352941176471,
      0.6980392156862745,
      0.6705882352941176,
      0.8235294117647058,
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ],
    Name: "Brewer Diverging Purple-Orange (4)",
    NanColor: [
      0.3686274509803922,
      0.2352941176470588,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.9450980392156862,
      0.6392156862745098,
      0.2509803921568627,
      0.9686274509803922,
      0.9686274509803922,
      0.9686274509803922,
      0.6,
      0.5568627450980392,
      0.7647058823529411
    ],
    Name: "Brewer Diverging Purple-Orange (3)",
    NanColor: [
      0.6,
      0.5568627450980392,
      0.7647058823529411
    ]
  },
  {
    IndexedColors: [
      0.6196078431372549,
      0.00392156862745098,
      0.2588235294117647,
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353,
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ],
    Name: "Brewer Diverging Spectral (11)",
    NanColor: [
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ]
  },
  {
    IndexedColors: [
      0.6196078431372549,
      0.00392156862745098,
      0.2588235294117647,
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353,
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ],
    Name: "Brewer Diverging Spectral (10)",
    NanColor: [
      0.3686274509803922,
      0.3098039215686275,
      0.6352941176470588
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (9)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9568627450980393,
      0.4274509803921568,
      0.2627450980392157,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (8)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      1,
      1,
      0.7490196078431373,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6,
      0.8352941176470589,
      0.5803921568627451,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (7)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8352941176470589,
      0.2431372549019608,
      0.3098039215686275,
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      0.996078431372549,
      0.8784313725490196,
      0.5450980392156862,
      0.9019607843137255,
      0.9607843137254902,
      0.596078431372549,
      0.6,
      0.8352941176470589,
      0.5803921568627451,
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ],
    Name: "Brewer Diverging Spectral (6)",
    NanColor: [
      0.196078431372549,
      0.5333333333333333,
      0.7411764705882353
    ]
  },
  {
    IndexedColors: [
      0.8431372549019608,
      0.09803921568627451,
      0.1098039215686274,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      1,
      1,
      0.7490196078431373,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ],
    Name: "Brewer Diverging Spectral (5)",
    NanColor: [
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ]
  },
  {
    IndexedColors: [
      0.8431372549019608,
      0.09803921568627451,
      0.1098039215686274,
      0.9921568627450981,
      0.6823529411764706,
      0.3803921568627451,
      0.6705882352941176,
      0.8666666666666667,
      0.6431372549019608,
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ],
    Name: "Brewer Diverging Spectral (4)",
    NanColor: [
      0.1686274509803922,
      0.5137254901960784,
      0.7294117647058823
    ]
  },
  {
    IndexedColors: [
      0.9882352941176471,
      0.5529411764705883,
      0.3490196078431372,
      1,
      1,
      0.7490196078431373,
      0.6,
      0.8352941176470589,
      0.5803921568627451
    ],
    Name: "Brewer Diverging Spectral (3)",
    NanColor: [
      0.6,
      0.8352941176470589,
      0.5803921568627451
    ]
  },
  {
    IndexedColors: [
      0.3294117647058823,
      0.1882352941176471,
      0.0196078431372549,
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922,
      0,
      0.2352941176470588,
      0.1882352941176471
    ],
    Name: "Brewer Diverging Brown-Blue-Green (11)",
    NanColor: [
      0,
      0.2352941176470588,
      0.1882352941176471
    ]
  },
  {
    IndexedColors: [
      0.3294117647058823,
      0.1882352941176471,
      0.0196078431372549,
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922,
      0,
      0.2352941176470588,
      0.1882352941176471
    ],
    Name: "Brewer Diverging Brown-Blue-Green (10)",
    NanColor: [
      0,
      0.2352941176470588,
      0.1882352941176471
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (9)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.7490196078431373,
      0.5058823529411764,
      0.1764705882352941,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.207843137254902,
      0.592156862745098,
      0.5607843137254902,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (8)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (7)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.5490196078431373,
      0.3176470588235294,
      0.0392156862745098,
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9647058823529412,
      0.9098039215686274,
      0.7647058823529411,
      0.7803921568627451,
      0.9176470588235294,
      0.8980392156862745,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687,
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ],
    Name: "Brewer Diverging Brown-Blue-Green (6)",
    NanColor: [
      0.00392156862745098,
      0.4,
      0.3686274509803922
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.3803921568627451,
      0.1019607843137255,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ],
    Name: "Brewer Diverging Brown-Blue-Green (5)",
    NanColor: [
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.3803921568627451,
      0.1019607843137255,
      0.8745098039215686,
      0.7607843137254902,
      0.4901960784313725,
      0.5019607843137255,
      0.803921568627451,
      0.7568627450980392,
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ],
    Name: "Brewer Diverging Brown-Blue-Green (4)",
    NanColor: [
      0.00392156862745098,
      0.5215686274509804,
      0.4431372549019608
    ]
  },
  {
    IndexedColors: [
      0.8470588235294118,
      0.7019607843137254,
      0.396078431372549,
      0.9607843137254902,
      0.9607843137254902,
      0.9607843137254902,
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687
    ],
    Name: "Brewer Diverging Brown-Blue-Green (3)",
    NanColor: [
      0.3529411764705883,
      0.7058823529411765,
      0.6745098039215687
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.4274509803921568,
      0.1725490196078431,
      0,
      0.2666666666666667,
      0.1058823529411765
    ],
    Name: "Brewer Sequential Blue-Green (9)",
    NanColor: [
      0,
      0.2666666666666667,
      0.1058823529411765
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.3450980392156863,
      0.1411764705882353
    ],
    Name: "Brewer Sequential Blue-Green (8)",
    NanColor: [
      0,
      0.3450980392156863,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.2549019607843137,
      0.6823529411764706,
      0.4627450980392157,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176,
      0,
      0.3450980392156863,
      0.1411764705882353
    ],
    Name: "Brewer Sequential Blue-Green (7)",
    NanColor: [
      0,
      0.3450980392156863,
      0.1411764705882353
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.8,
      0.9254901960784314,
      0.9019607843137255,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431,
      0,
      0.4274509803921568,
      0.1725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (6)",
    NanColor: [
      0,
      0.4274509803921568,
      0.1725490196078431
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.6980392156862745,
      0.8862745098039215,
      0.8862745098039215,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431,
      0,
      0.4274509803921568,
      0.1725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (5)",
    NanColor: [
      0,
      0.4274509803921568,
      0.1725490196078431
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.6980392156862745,
      0.8862745098039215,
      0.8862745098039215,
      0.4,
      0.7607843137254902,
      0.6431372549019608,
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176
    ],
    Name: "Brewer Sequential Blue-Green (4)",
    NanColor: [
      0.1372549019607843,
      0.5450980392156862,
      0.2705882352941176
    ]
  },
  {
    IndexedColors: [
      0.8980392156862745,
      0.9607843137254902,
      0.9764705882352941,
      0.6,
      0.8470588235294118,
      0.788235294117647,
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431
    ],
    Name: "Brewer Sequential Blue-Green (3)",
    NanColor: [
      0.1725490196078431,
      0.6352941176470588,
      0.3725490196078431
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8980392156862745,
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.6,
      0.203921568627451,
      0.01568627450980392,
      0.4,
      0.1450980392156863,
      0.02352941176470588
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (9)",
    NanColor: [
      0.4,
      0.1450980392156863,
      0.02352941176470588
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8980392156862745,
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (8)",
    NanColor: [
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.9254901960784314,
      0.4392156862745098,
      0.0784313725490196,
      0.8,
      0.2980392156862745,
      0.00784313725490196,
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (7)",
    NanColor: [
      0.5490196078431373,
      0.1764705882352941,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8901960784313725,
      0.5686274509803921,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372,
      0.6,
      0.203921568627451,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (6)",
    NanColor: [
      0.6,
      0.203921568627451,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8509803921568627,
      0.5568627450980392,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372,
      0.6,
      0.203921568627451,
      0.01568627450980392
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (5)",
    NanColor: [
      0.6,
      0.203921568627451,
      0.01568627450980392
    ]
  },
  {
    IndexedColors: [
      1,
      1,
      0.8313725490196079,
      0.996078431372549,
      0.8509803921568627,
      0.5568627450980392,
      0.996078431372549,
      0.6,
      0.1607843137254902,
      0.8,
      0.2980392156862745,
      0.00784313725490196
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (4)",
    NanColor: [
      0.8,
      0.2980392156862745,
      0.00784313725490196
    ]
  },
  {
    IndexedColors: [
      1,
      0.9686274509803922,
      0.7372549019607844,
      0.996078431372549,
      0.7686274509803922,
      0.3098039215686275,
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372
    ],
    Name: "Brewer Sequential Yellow-Orange-Brown (3)",
    NanColor: [
      0.8509803921568627,
      0.3725490196078431,
      0.05490196078431372
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216,
      0.3019607843137255,
      0,
      0.2941176470588235
    ],
    Name: "Brewer Sequential Blue-Purple (9)",
    NanColor: [
      0.3019607843137255,
      0,
      0.2941176470588235
    ]
  },
  {
    IndexedColors: [
      0.9686274509803922,
      0.9882352941176471,
      0.9921568627450981,
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ],
    Name: "Brewer Sequential Blue-Purple (8)",
    NanColor: [
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5490196078431373,
      0.4196078431372549,
      0.6941176470588235,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804,
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ],
    Name: "Brewer Sequential Blue-Purple (7)",
    NanColor: [
      0.4313725490196079,
      0.00392156862745098,
      0.4196078431372549
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7490196078431373,
      0.8274509803921568,
      0.9019607843137255,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ],
    Name: "Brewer Sequential Blue-Purple (6)",
    NanColor: [
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137,
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ],
    Name: "Brewer Sequential Blue-Purple (5)",
    NanColor: [
      0.5058823529411764,
      0.05882352941176471,
      0.4862745098039216
    ]
  },
  {
    IndexedColors: [
      0.9294117647058824,
      0.9725490196078431,
      0.984313725490196,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.5490196078431373,
      0.5882352941176471,
      0.7764705882352941,
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804
    ],
    Name: "Brewer Sequential Blue-Purple (4)",
    NanColor: [
      0.5333333333333333,
      0.2549019607843137,
      0.615686274509804
    ]
  },
  {
    IndexedColors: [
      0.8784313725490196,
      0.9254901960784314,
      0.9568627450980393,
      0.6196078431372549,
      0.7372549019607844,
      0.8549019607843137,
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137
    ],
    Name: "Brewer Sequential Blue-Purple (3)",
    NanColor: [
      0.5333333333333333,
      0.3372549019607843,
      0.6549019607843137
    ]
  },
  {
    IndexedColors: [
      0.4980392156862745,
      0.788235294117647,
      0.4980392156862745,
      0.7450980392156863,
      0.6823529411764706,
      0.8313725490196079,
      0.9921568627450981,
      0.7529411764705882,
      0.5254901960784314,
      1,
      1,
      0.6,
      0.2196078431372549,
      0.4235294117647059,
      0.6901960784313725,
      0.9411764705882353,
      0.00784313725490196,
      0.4980392156862745,
      0.7490196078431373,
      0.3568627450980392,
      0.09019607843137255,
      0.4,
      0.4,
      0.4
    ],
    Name: "Brewer Qualitative Accent",
    NanColor: [
      0.4,
      0.4,
      0.4
    ]
  },
  {
    IndexedColors: [
      0.1058823529411765,
      0.6196078431372549,
      0.4666666666666667,
      0.8509803921568627,
      0.3725490196078431,
      0.00784313725490196,
      0.4588235294117647,
      0.4392156862745098,
      0.7019607843137254,
      0.9058823529411765,
      0.1607843137254902,
      0.5411764705882353,
      0.4,
      0.6509803921568628,
      0.1176470588235294,
      0.9019607843137255,
      0.6705882352941176,
      0.00784313725490196,
      0.6509803921568628,
      0.4627450980392157,
      0.1137254901960784,
      0.4,
      0.4,
      0.4
    ],
    Name: "Brewer Qualitative Dark2",
    NanColor: [
      0.4,
      0.4,
      0.4
    ]
  },
  {
    IndexedColors: [
      0.4,
      0.7607843137254902,
      0.6470588235294118,
      0.9882352941176471,
      0.5529411764705883,
      0.3843137254901961,
      0.5529411764705883,
      0.6274509803921569,
      0.796078431372549,
      0.9058823529411765,
      0.5411764705882353,
      0.7647058823529411,
      0.6509803921568628,
      0.8470588235294118,
      0.3294117647058823,
      1,
      0.8509803921568627,
      0.1843137254901961,
      0.8980392156862745,
      0.7686274509803922,
      0.5803921568627451,
      0.7019607843137254,
      0.7019607843137254,
      0.7019607843137254
    ],
    Name: "Brewer Qualitative Set2",
    NanColor: [
      0.7019607843137254,
      0.7019607843137254,
      0.7019607843137254
    ]
  },
  {
    IndexedColors: [
      0.7019607843137254,
      0.8862745098039215,
      0.803921568627451,
      0.9921568627450981,
      0.803921568627451,
      0.6745098039215687,
      0.796078431372549,
      0.8352941176470589,
      0.9098039215686274,
      0.9568627450980393,
      0.792156862745098,
      0.8941176470588236,
      0.9019607843137255,
      0.9607843137254902,
      0.788235294117647,
      1,
      0.9490196078431372,
      0.6823529411764706,
      0.9450980392156862,
      0.8862745098039215,
      0.8,
      0.8,
      0.8,
      0.8
    ],
    Name: "Brewer Qualitative Pastel2",
    NanColor: [
      0.8,
      0.8,
      0.8
    ]
  },
  {
    IndexedColors: [
      0.984313725490196,
      0.7058823529411765,
      0.6823529411764706,
      0.7019607843137254,
      0.803921568627451,
      0.8901960784313725,
      0.8,
      0.9215686274509803,
      0.7725490196078432,
      0.8705882352941177,
      0.796078431372549,
      0.8941176470588236,
      0.996078431372549,
      0.8509803921568627,
      0.6509803921568628,
      1,
      1,
      0.8,
      0.8980392156862745,
      0.8470588235294118,
      0.7411764705882353,
      0.9921568627450981,
      0.8549019607843137,
      0.9254901960784314,
      0.9490196078431372,
      0.9490196078431372,
      0.9490196078431372
    ],
    Name: "Brewer Qualitative Pastel1",
    NanColor: [
      0.9490196078431372,
      0.9490196078431372,
      0.9490196078431372
    ]
  },
  {
    IndexedColors: [
      0.8941176470588236,
      0.1019607843137255,
      0.1098039215686274,
      0.2156862745098039,
      0.4941176470588236,
      0.7215686274509804,
      0.3019607843137255,
      0.6862745098039216,
      0.2901960784313726,
      0.596078431372549,
      0.3058823529411765,
      0.6392156862745098,
      1,
      0.4980392156862745,
      0,
      1,
      1,
      0.2,
      0.6509803921568628,
      0.3372549019607843,
      0.1568627450980392,
      0.9686274509803922,
      0.5058823529411764,
      0.7490196078431373,
      0.6,
      0.6,
      0.6
    ],
    Name: "Brewer Qualitative Set1",
    NanColor: [
      0.6,
      0.6,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.6509803921568628,
      0.807843137254902,
      0.8901960784313725,
      0.1215686274509804,
      0.4705882352941176,
      0.7058823529411765,
      0.6980392156862745,
      0.8745098039215686,
      0.5411764705882353,
      0.2,
      0.6274509803921569,
      0.1725490196078431,
      0.984313725490196,
      0.6039215686274509,
      0.6,
      0.8901960784313725,
      0.1019607843137255,
      0.1098039215686274,
      0.9921568627450981,
      0.7490196078431373,
      0.4352941176470588,
      1,
      0.4980392156862745,
      0,
      0.792156862745098,
      0.6980392156862745,
      0.8392156862745098,
      0.4156862745098039,
      0.2392156862745098,
      0.6039215686274509,
      1,
      1,
      0.6
    ],
    Name: "Brewer Qualitative Paired",
    NanColor: [
      1,
      1,
      0.6
    ]
  },
  {
    IndexedColors: [
      0.5529411764705883,
      0.8274509803921568,
      0.7803921568627451,
      1,
      1,
      0.7019607843137254,
      0.7450980392156863,
      0.7294117647058823,
      0.8549019607843137,
      0.984313725490196,
      0.5019607843137255,
      0.4470588235294118,
      0.5019607843137255,
      0.6941176470588235,
      0.8274509803921568,
      0.9921568627450981,
      0.7058823529411765,
      0.3843137254901961,
      0.7019607843137254,
      0.8705882352941177,
      0.4117647058823529,
      0.9882352941176471,
      0.803921568627451,
      0.8980392156862745,
      0.8509803921568627,
      0.8509803921568627,
      0.8509803921568627,
      0.7372549019607844,
      0.5019607843137255,
      0.7411764705882353,
      0.8,
      0.9215686274509803,
      0.7725490196078432,
      1,
      0.9294117647058824,
      0.4352941176470588
    ],
    Name: "Brewer Qualitative Set3",
    NanColor: [
      1,
      0.9294117647058824,
      0.4352941176470588
    ]
  },
  {
    IndexedColors: [
      1,
      0,
      0,
      1,
      0.862745,
      0,
      0,
      0.695201,
      0
    ],
    Name: "Traffic Lights",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    IndexedColors: [
      0.908659,
      0.604013,
      0.581857,
      1,
      0.862745,
      0,
      0,
      0.695201,
      0
    ],
    Name: "Traffic Lights For Deuteranopes",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    IndexedColors: [
      0.4196078431372549,
      0,
      0.07058823529411765,
      0.9019607843137255,
      0.9411764705882353,
      0.0196078431372549,
      0.01568627450980392,
      0.6196078431372549,
      0.00784313725490196
    ],
    Name: "Traffic Lights For Deuteranopes 2",
    NanColor: [
      0.803922,
      0,
      0.803922
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Muted Blue-Green",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.109804,
      0.27451,
      0.301961,
      0.02,
      0.129412,
      0.309804,
      0.341176,
      0.05,
      0.14902,
      0.341176,
      0.380392,
      0.1,
      0.188235,
      0.403922,
      0.458824,
      0.15,
      0.227451,
      0.447059,
      0.521569,
      0.2,
      0.290196,
      0.494118,
      0.588235,
      0.25,
      0.368627,
      0.552941,
      0.670588,
      0.3,
      0.458824,
      0.619608,
      0.74902,
      0.35,
      0.588235,
      0.713725,
      0.85098,
      0.4,
      0.72549,
      0.815686,
      0.941176,
      0.45,
      0.831373,
      0.882353,
      0.980392,
      0.475,
      0.909804,
      0.933333,
      1,
      0.5,
      0.980392,
      0.984314,
      1,
      0.5,
      0.996078,
      1,
      0.94902,
      0.5,
      1,
      1,
      0.980392,
      0.5,
      0.980392,
      0.984314,
      1,
      0.525,
      0.972549,
      0.988235,
      0.890196,
      0.55,
      0.917647,
      0.960784,
      0.835294,
      0.6,
      0.835294,
      0.921569,
      0.772549,
      0.65,
      0.768627,
      0.901961,
      0.737255,
      0.7,
      0.670588,
      0.831373,
      0.654902,
      0.75,
      0.576471,
      0.760784,
      0.584314,
      0.8,
      0.498039,
      0.678431,
      0.521569,
      0.85,
      0.392157,
      0.560784,
      0.427451,
      0.9,
      0.294118,
      0.45098,
      0.333333,
      0.95,
      0.211765,
      0.34902,
      0.254902,
      1,
      0.152941,
      0.278431,
      0.196078
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Green-Blue Asymmetric Divergent (62Blbc)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.121569,
      0.2,
      0.145098,
      0.05,
      0.196078,
      0.301961,
      0.223529,
      0.1,
      0.258824,
      0.4,
      0.278431,
      0.2,
      0.341176,
      0.54902,
      0.341176,
      0.25,
      0.419608,
      0.619608,
      0.376471,
      0.3,
      0.545098,
      0.701961,
      0.392157,
      0.35,
      0.643137,
      0.780392,
      0.403922,
      0.4,
      0.729412,
      0.819608,
      0.45098,
      0.45,
      0.811765,
      0.870588,
      0.521569,
      0.5,
      0.898039,
      0.909804,
      0.564706,
      0.55,
      0.941176,
      0.92549,
      0.686275,
      0.6,
      0.960784,
      0.94902,
      0.776471,
      0.64,
      1,
      1,
      1,
      0.65,
      0.890196,
      0.988235,
      0.972549,
      0.7,
      0.721569,
      0.894118,
      0.901961,
      0.75,
      0.631373,
      0.823529,
      0.839216,
      0.8,
      0.517647,
      0.662745,
      0.701961,
      0.85,
      0.384314,
      0.494118,
      0.54902,
      0.9,
      0.298039,
      0.360784,
      0.45098,
      0.95,
      0.223529,
      0.25098,
      0.34902,
      0.99,
      0.156863,
      0.172549,
      0.25098,
      1,
      0.137255,
      0.137255,
      0.188235
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Asymmtrical Earth Tones (6_21b)",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      0.141176,
      0.14902,
      0.2,
      0.05,
      0.215686,
      0.258824,
      0.321569,
      0.1,
      0.243137,
      0.368627,
      0.380392,
      0.15,
      0.27451,
      0.439216,
      0.4,
      0.2,
      0.32549,
      0.501961,
      0.384314,
      0.25,
      0.403922,
      0.6,
      0.419608,
      0.3,
      0.486275,
      0.701961,
      0.454902,
      0.35,
      0.556863,
      0.74902,
      0.494118,
      0.4,
      0.670588,
      0.8,
      0.545098,
      0.5,
      0.854902,
      0.901961,
      0.631373,
      0.55,
      0.92549,
      0.941176,
      0.694118,
      0.6,
      0.960784,
      0.94902,
      0.776471,
      0.65,
      0.988235,
      0.968627,
      0.909804,
      0.7,
      0.839216,
      0.815686,
      0.772549,
      0.75,
      0.701961,
      0.662745,
      0.615686,
      0.8,
      0.6,
      0.529412,
      0.478431,
      0.85,
      0.501961,
      0.403922,
      0.360784,
      0.9,
      0.439216,
      0.313725,
      0.290196,
      1,
      0.301961,
      0.164706,
      0.176471
    ]
  },
  {
    ColorSpace: "Lab",
    Creator: "Francesca Samsel",
    Name: "Yellow 15",
    NanColor: [
      0.25,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      0.988235,
      0.002,
      1,
      1,
      0.988235,
      0.05,
      0.984314,
      0.988235,
      0.843137,
      0.1,
      0.988235,
      0.988235,
      0.741176,
      0.15,
      0.980392,
      0.968627,
      0.654902,
      0.2,
      0.980392,
      0.945098,
      0.576471,
      0.25,
      0.968627,
      0.905882,
      0.486275,
      0.3,
      0.968627,
      0.862745,
      0.388235,
      0.35,
      0.960784,
      0.803922,
      0.286275,
      0.4,
      0.94902,
      0.741176,
      0.219608,
      0.45,
      0.941176,
      0.678431,
      0.14902,
      0.5,
      0.929412,
      0.607843,
      0.094118,
      0.55,
      0.921569,
      0.545098,
      0.054902,
      0.6,
      0.909804,
      0.486275,
      0.035294,
      0.65,
      0.890196,
      0.411765,
      0.019608,
      0.7,
      0.8,
      0.305882,
      0,
      0.75,
      0.760784,
      0.239216,
      0,
      0.8,
      0.678431,
      0.180392,
      0.011765,
      0.85,
      0.6,
      0.121569,
      0.023529,
      0.9,
      0.501961,
      0.054902,
      0.031373,
      0.95,
      0.4,
      0.039216,
      0.058824,
      1,
      0.301961,
      0.047059,
      0.090196
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Magma (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      0.001462,
      0.000466,
      0.013866,
      0.003922,
      0.002258,
      0.001295,
      0.018331,
      0.007843,
      0.003279,
      0.002305,
      0.023708,
      0.011765,
      0.004512,
      0.00349,
      0.029965,
      0.015686,
      0.00595,
      0.004843,
      0.03713,
      0.019608,
      0.007588,
      0.006356,
      0.044973,
      0.023529,
      0.009426,
      0.008022,
      0.052844,
      0.027451,
      0.011465,
      0.009828,
      0.06075,
      0.031373,
      0.013708,
      0.011771,
      0.068667,
      0.035294,
      0.016156,
      0.01384,
      0.076603,
      0.039216,
      0.018815,
      0.016026,
      0.084584,
      0.043137,
      0.021692,
      0.01832,
      0.09261,
      0.047059,
      0.024792,
      0.020715,
      0.100676,
      0.05098,
      0.028123,
      0.023201,
      0.108787,
      0.054902,
      0.031696,
      0.025765,
      0.116965,
      0.058824,
      0.03552,
      0.028397,
      0.125209,
      0.062745,
      0.039608,
      0.03109,
      0.133515,
      0.066667,
      0.04383,
      0.03383,
      0.141886,
      0.070588,
      0.048062,
      0.036607,
      0.150327,
      0.07451,
      0.05232,
      0.039407,
      0.158841,
      0.078431,
      0.056615,
      0.04216,
      0.167446,
      0.082353,
      0.060949,
      0.044794,
      0.176129,
      0.086275,
      0.06533,
      0.047318,
      0.184892,
      0.090196,
      0.069764,
      0.049726,
      0.193735,
      0.094118,
      0.074257,
      0.052017,
      0.20266,
      0.098039,
      0.078815,
      0.054184,
      0.211667,
      0.101961,
      0.083446,
      0.056225,
      0.220755,
      0.105882,
      0.088155,
      0.058133,
      0.229922,
      0.109804,
      0.092949,
      0.059904,
      0.239164,
      0.113725,
      0.097833,
      0.061531,
      0.248477,
      0.117647,
      0.102815,
      0.06301,
      0.257854,
      0.121569,
      0.107899,
      0.064335,
      0.267289,
      0.12549,
      0.113094,
      0.065492,
      0.276784,
      0.129412,
      0.118405,
      0.066479,
      0.286321,
      0.133333,
      0.123833,
      0.067295,
      0.295879,
      0.137255,
      0.12938,
      0.067935,
      0.305443,
      0.141176,
      0.135053,
      0.068391,
      0.315,
      0.145098,
      0.140858,
      0.068654,
      0.324538,
      0.14902,
      0.146785,
      0.068738,
      0.334011,
      0.152941,
      0.152839,
      0.068637,
      0.343404,
      0.156863,
      0.159018,
      0.068354,
      0.352688,
      0.160784,
      0.165308,
      0.067911,
      0.361816,
      0.164706,
      0.171713,
      0.067305,
      0.370771,
      0.168627,
      0.178212,
      0.066576,
      0.379497,
      0.172549,
      0.184801,
      0.065732,
      0.387973,
      0.176471,
      0.19146,
      0.064818,
      0.396152,
      0.180392,
      0.198177,
      0.063862,
      0.404009,
      0.184314,
      0.204935,
      0.062907,
      0.411514,
      0.188235,
      0.211718,
      0.061992,
      0.418647,
      0.192157,
      0.218512,
      0.061158,
      0.425392,
      0.196078,
      0.225302,
      0.060445,
      0.431742,
      0.2,
      0.232077,
      0.059889,
      0.437695,
      0.203922,
      0.238826,
      0.059517,
      0.443256,
      0.207843,
      0.245543,
      0.059352,
      0.448436,
      0.211765,
      0.25222,
      0.059415,
      0.453248,
      0.215686,
      0.258857,
      0.059706,
      0.45771,
      0.219608,
      0.265447,
      0.060237,
      0.46184,
      0.223529,
      0.271994,
      0.060994,
      0.46566,
      0.227451,
      0.278493,
      0.061978,
      0.46919,
      0.231373,
      0.284951,
      0.063168,
      0.472451,
      0.235294,
      0.291366,
      0.064553,
      0.475462,
      0.239216,
      0.29774,
      0.066117,
      0.478243,
      0.243137,
      0.304081,
      0.067835,
      0.480812,
      0.247059,
      0.310382,
      0.069702,
      0.483186,
      0.25098,
      0.316654,
      0.07169,
      0.48538,
      0.254902,
      0.322899,
      0.073782,
      0.487408,
      0.258824,
      0.329114,
      0.075972,
      0.489287,
      0.262745,
      0.335308,
      0.078236,
      0.491024,
      0.266667,
      0.341482,
      0.080564,
      0.492631,
      0.270588,
      0.347636,
      0.082946,
      0.494121,
      0.27451,
      0.353773,
      0.085373,
      0.495501,
      0.278431,
      0.359898,
      0.087831,
      0.496778,
      0.282353,
      0.366012,
      0.090314,
      0.49796,
      0.286275,
      0.372116,
      0.092816,
      0.499053,
      0.290196,
      0.378211,
      0.095332,
      0.500067,
      0.294118,
      0.384299,
      0.097855,
      0.501002,
      0.298039,
      0.390384,
      0.100379,
      0.501864,
      0.301961,
      0.396467,
      0.102902,
      0.502658,
      0.305882,
      0.402548,
      0.10542,
      0.503386,
      0.309804,
      0.408629,
      0.10793,
      0.504052,
      0.313725,
      0.414709,
      0.110431,
      0.504662,
      0.317647,
      0.420791,
      0.11292,
      0.505215,
      0.321569,
      0.426877,
      0.115395,
      0.505714,
      0.32549,
      0.432967,
      0.117855,
      0.50616,
      0.329412,
      0.439062,
      0.120298,
      0.506555,
      0.333333,
      0.445163,
      0.122724,
      0.506901,
      0.337255,
      0.451271,
      0.125132,
      0.507198,
      0.341176,
      0.457386,
      0.127522,
      0.507448,
      0.345098,
      0.463508,
      0.129893,
      0.507652,
      0.34902,
      0.46964,
      0.132245,
      0.507809,
      0.352941,
      0.47578,
      0.134577,
      0.507921,
      0.356863,
      0.481929,
      0.136891,
      0.507989,
      0.360784,
      0.488088,
      0.139186,
      0.508011,
      0.364706,
      0.494258,
      0.141462,
      0.507988,
      0.368627,
      0.500438,
      0.143719,
      0.50792,
      0.372549,
      0.506629,
      0.145958,
      0.507806,
      0.376471,
      0.512831,
      0.148179,
      0.507648,
      0.380392,
      0.519045,
      0.150383,
      0.507443,
      0.384314,
      0.52527,
      0.152569,
      0.507192,
      0.388235,
      0.531507,
      0.154739,
      0.506895,
      0.392157,
      0.537755,
      0.156894,
      0.506551,
      0.396078,
      0.544015,
      0.159033,
      0.506159,
      0.4,
      0.550287,
      0.161158,
      0.505719,
      0.403922,
      0.556571,
      0.163269,
      0.50523,
      0.407843,
      0.562866,
      0.165368,
      0.504692,
      0.411765,
      0.569172,
      0.167454,
      0.504105,
      0.415686,
      0.57549,
      0.16953,
      0.503466,
      0.419608,
      0.581819,
      0.171596,
      0.502777,
      0.423529,
      0.588158,
      0.173652,
      0.502035,
      0.427451,
      0.594508,
      0.175701,
      0.501241,
      0.431373,
      0.600868,
      0.177743,
      0.500394,
      0.435294,
      0.607238,
      0.179779,
      0.499492,
      0.439216,
      0.613617,
      0.181811,
      0.498536,
      0.443137,
      0.620005,
      0.18384,
      0.497524,
      0.447059,
      0.626401,
      0.185867,
      0.496456,
      0.45098,
      0.632805,
      0.187893,
      0.495332,
      0.454902,
      0.639216,
      0.189921,
      0.49415,
      0.458824,
      0.645633,
      0.191952,
      0.49291,
      0.462745,
      0.652056,
      0.193986,
      0.491611,
      0.466667,
      0.658483,
      0.196027,
      0.490253,
      0.470588,
      0.664915,
      0.198075,
      0.488836,
      0.47451,
      0.671349,
      0.200133,
      0.487358,
      0.478431,
      0.677786,
      0.202203,
      0.485819,
      0.482353,
      0.684224,
      0.204286,
      0.484219,
      0.486275,
      0.690661,
      0.206384,
      0.482558,
      0.490196,
      0.697098,
      0.208501,
      0.480835,
      0.494118,
      0.703532,
      0.210638,
      0.479049,
      0.498039,
      0.709962,
      0.212797,
      0.477201,
      0.501961,
      0.716387,
      0.214982,
      0.47529,
      0.505882,
      0.722805,
      0.217194,
      0.473316,
      0.509804,
      0.729216,
      0.219437,
      0.471279,
      0.513725,
      0.735616,
      0.221713,
      0.46918,
      0.517647,
      0.742004,
      0.224025,
      0.467018,
      0.521569,
      0.748378,
      0.226377,
      0.464794,
      0.52549,
      0.754737,
      0.228772,
      0.462509,
      0.529412,
      0.761077,
      0.231214,
      0.460162,
      0.533333,
      0.767398,
      0.233705,
      0.457755,
      0.537255,
      0.773695,
      0.236249,
      0.455289,
      0.541176,
      0.779968,
      0.238851,
      0.452765,
      0.545098,
      0.786212,
      0.241514,
      0.450184,
      0.54902,
      0.792427,
      0.244242,
      0.447543,
      0.552941,
      0.798608,
      0.24704,
      0.444848,
      0.556863,
      0.804752,
      0.249911,
      0.442102,
      0.560784,
      0.810855,
      0.252861,
      0.439305,
      0.564706,
      0.816914,
      0.255895,
      0.436461,
      0.568627,
      0.822926,
      0.259016,
      0.433573,
      0.572549,
      0.828886,
      0.262229,
      0.430644,
      0.576471,
      0.834791,
      0.26554,
      0.427671,
      0.580392,
      0.840636,
      0.268953,
      0.424666,
      0.584314,
      0.846416,
      0.272473,
      0.421631,
      0.588235,
      0.852126,
      0.276106,
      0.418573,
      0.592157,
      0.857763,
      0.279857,
      0.415496,
      0.596078,
      0.86332,
      0.283729,
      0.412403,
      0.6,
      0.868793,
      0.287728,
      0.409303,
      0.603922,
      0.874176,
      0.291859,
      0.406205,
      0.607843,
      0.879464,
      0.296125,
      0.403118,
      0.611765,
      0.884651,
      0.30053,
      0.400047,
      0.615686,
      0.889731,
      0.305079,
      0.397002,
      0.619608,
      0.8947,
      0.309773,
      0.393995,
      0.623529,
      0.899552,
      0.314616,
      0.391037,
      0.627451,
      0.904281,
      0.31961,
      0.388137,
      0.631373,
      0.908884,
      0.324755,
      0.385308,
      0.635294,
      0.913354,
      0.330052,
      0.382563,
      0.639216,
      0.917689,
      0.3355,
      0.379915,
      0.643137,
      0.921884,
      0.341098,
      0.377376,
      0.647059,
      0.925937,
      0.346844,
      0.374959,
      0.65098,
      0.929845,
      0.352734,
      0.372677,
      0.654902,
      0.933606,
      0.358764,
      0.370541,
      0.658824,
      0.937221,
      0.364929,
      0.368567,
      0.662745,
      0.940687,
      0.371224,
      0.366762,
      0.666667,
      0.944006,
      0.377643,
      0.365136,
      0.670588,
      0.94718,
      0.384178,
      0.363701,
      0.67451,
      0.95021,
      0.39082,
      0.362468,
      0.678431,
      0.953099,
      0.397563,
      0.361438,
      0.682353,
      0.955849,
      0.4044,
      0.360619,
      0.686275,
      0.958464,
      0.411324,
      0.360014,
      0.690196,
      0.960949,
      0.418323,
      0.35963,
      0.694118,
      0.96331,
      0.42539,
      0.359469,
      0.698039,
      0.965549,
      0.432519,
      0.359529,
      0.701961,
      0.967671,
      0.439703,
      0.35981,
      0.705882,
      0.96968,
      0.446936,
      0.360311,
      0.709804,
      0.971582,
      0.45421,
      0.36103,
      0.713725,
      0.973381,
      0.46152,
      0.361965,
      0.717647,
      0.975082,
      0.468861,
      0.363111,
      0.721569,
      0.97669,
      0.476226,
      0.364466,
      0.72549,
      0.97821,
      0.483612,
      0.366025,
      0.729412,
      0.979645,
      0.491014,
      0.367783,
      0.733333,
      0.981,
      0.498428,
      0.369734,
      0.737255,
      0.982279,
      0.505851,
      0.371874,
      0.741176,
      0.983485,
      0.51328,
      0.374198,
      0.745098,
      0.984622,
      0.520713,
      0.376698,
      0.74902,
      0.985693,
      0.528148,
      0.379371,
      0.752941,
      0.9867,
      0.535582,
      0.38221,
      0.756863,
      0.987646,
      0.543015,
      0.38521,
      0.760784,
      0.988533,
      0.550446,
      0.388365,
      0.764706,
      0.989363,
      0.557873,
      0.391671,
      0.768627,
      0.990138,
      0.565296,
      0.395122,
      0.772549,
      0.990871,
      0.572706,
      0.398714,
      0.776471,
      0.991558,
      0.580107,
      0.402441,
      0.780392,
      0.992196,
      0.587502,
      0.406299,
      0.784314,
      0.992785,
      0.594891,
      0.410283,
      0.788235,
      0.993326,
      0.602275,
      0.41439,
      0.792157,
      0.993834,
      0.609644,
      0.418613,
      0.796078,
      0.994309,
      0.616999,
      0.42295,
      0.8,
      0.994738,
      0.62435,
      0.427397,
      0.803922,
      0.995122,
      0.631696,
      0.431951,
      0.807843,
      0.99548,
      0.639027,
      0.436607,
      0.811765,
      0.99581,
      0.646344,
      0.441361,
      0.815686,
      0.996096,
      0.653659,
      0.446213,
      0.819608,
      0.996341,
      0.660969,
      0.45116,
      0.823529,
      0.99658,
      0.668256,
      0.456192,
      0.827451,
      0.996775,
      0.675541,
      0.461314,
      0.831373,
      0.996925,
      0.682828,
      0.466526,
      0.835294,
      0.997077,
      0.690088,
      0.471811,
      0.839216,
      0.997186,
      0.697349,
      0.477182,
      0.843137,
      0.997254,
      0.704611,
      0.482635,
      0.847059,
      0.997325,
      0.711848,
      0.488154,
      0.85098,
      0.997351,
      0.719089,
      0.493755,
      0.854902,
      0.997351,
      0.726324,
      0.499428,
      0.858824,
      0.997341,
      0.733545,
      0.505167,
      0.862745,
      0.997285,
      0.740772,
      0.510983,
      0.866667,
      0.997228,
      0.747981,
      0.516859,
      0.870588,
      0.997138,
      0.75519,
      0.522806,
      0.87451,
      0.997019,
      0.762398,
      0.528821,
      0.878431,
      0.996898,
      0.769591,
      0.534892,
      0.882353,
      0.996727,
      0.776795,
      0.541039,
      0.886275,
      0.996571,
      0.783977,
      0.547233,
      0.890196,
      0.996369,
      0.791167,
      0.553499,
      0.894118,
      0.996162,
      0.798348,
      0.55982,
      0.898039,
      0.995932,
      0.805527,
      0.566202,
      0.901961,
      0.99568,
      0.812706,
      0.572645,
      0.905882,
      0.995424,
      0.819875,
      0.57914,
      0.909804,
      0.995131,
      0.827052,
      0.585701,
      0.913725,
      0.994851,
      0.834213,
      0.592307,
      0.917647,
      0.994524,
      0.841387,
      0.598983,
      0.921569,
      0.994222,
      0.84854,
      0.605696,
      0.92549,
      0.993866,
      0.855711,
      0.612482,
      0.929412,
      0.993545,
      0.862859,
      0.619299,
      0.933333,
      0.99317,
      0.870024,
      0.626189,
      0.937255,
      0.992831,
      0.877168,
      0.633109,
      0.941176,
      0.99244,
      0.88433,
      0.640099,
      0.945098,
      0.992089,
      0.89147,
      0.647116,
      0.94902,
      0.991688,
      0.898627,
      0.654202,
      0.952941,
      0.991332,
      0.905763,
      0.661309,
      0.956863,
      0.99093,
      0.912915,
      0.668481,
      0.960784,
      0.99057,
      0.920049,
      0.675675,
      0.964706,
      0.990175,
      0.927196,
      0.682926,
      0.968627,
      0.989815,
      0.934329,
      0.690198,
      0.972549,
      0.989434,
      0.94147,
      0.697519,
      0.976471,
      0.989077,
      0.948604,
      0.704863,
      0.980392,
      0.988717,
      0.955742,
      0.712242,
      0.984314,
      0.988367,
      0.962878,
      0.719649,
      0.988235,
      0.988033,
      0.970012,
      0.727077,
      0.992157,
      0.987691,
      0.977154,
      0.734536,
      0.996078,
      0.987387,
      0.984288,
      0.742002,
      1,
      0.987053,
      0.991438,
      0.749504
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Inferno (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      0.001462,
      0.000466,
      0.013866,
      0.003922,
      0.002267,
      0.00127,
      0.01857,
      0.007843,
      0.003299,
      0.002249,
      0.024239,
      0.011765,
      0.004547,
      0.003392,
      0.030909,
      0.015686,
      0.006006,
      0.004692,
      0.038558,
      0.019608,
      0.007676,
      0.006136,
      0.046836,
      0.023529,
      0.009561,
      0.007713,
      0.055143,
      0.027451,
      0.011663,
      0.009417,
      0.06346,
      0.031373,
      0.013995,
      0.011225,
      0.071862,
      0.035294,
      0.016561,
      0.013136,
      0.080282,
      0.039216,
      0.019373,
      0.015133,
      0.088767,
      0.043137,
      0.022447,
      0.017199,
      0.097327,
      0.047059,
      0.025793,
      0.019331,
      0.10593,
      0.05098,
      0.029432,
      0.021503,
      0.114621,
      0.054902,
      0.033385,
      0.023702,
      0.123397,
      0.058824,
      0.037668,
      0.025921,
      0.132232,
      0.062745,
      0.042253,
      0.028139,
      0.141141,
      0.066667,
      0.046915,
      0.030324,
      0.150164,
      0.070588,
      0.051644,
      0.032474,
      0.159254,
      0.07451,
      0.056449,
      0.034569,
      0.168414,
      0.078431,
      0.06134,
      0.03659,
      0.177642,
      0.082353,
      0.066331,
      0.038504,
      0.186962,
      0.086275,
      0.071429,
      0.040294,
      0.196354,
      0.090196,
      0.076637,
      0.041905,
      0.205799,
      0.094118,
      0.081962,
      0.043328,
      0.215289,
      0.098039,
      0.087411,
      0.044556,
      0.224813,
      0.101961,
      0.09299,
      0.045583,
      0.234358,
      0.105882,
      0.098702,
      0.046402,
      0.243904,
      0.109804,
      0.104551,
      0.047008,
      0.25343,
      0.113725,
      0.110536,
      0.047399,
      0.262912,
      0.117647,
      0.116656,
      0.047574,
      0.272321,
      0.121569,
      0.122908,
      0.047536,
      0.281624,
      0.12549,
      0.129285,
      0.047293,
      0.290788,
      0.129412,
      0.135778,
      0.046856,
      0.299776,
      0.133333,
      0.142378,
      0.046242,
      0.308553,
      0.137255,
      0.149073,
      0.045468,
      0.317085,
      0.141176,
      0.15585,
      0.044559,
      0.325338,
      0.145098,
      0.162689,
      0.043554,
      0.333277,
      0.14902,
      0.169575,
      0.042489,
      0.340874,
      0.152941,
      0.176493,
      0.041402,
      0.348111,
      0.156863,
      0.183429,
      0.040329,
      0.354971,
      0.160784,
      0.190367,
      0.039309,
      0.361447,
      0.164706,
      0.197297,
      0.0384,
      0.367535,
      0.168627,
      0.204209,
      0.037632,
      0.373238,
      0.172549,
      0.211095,
      0.03703,
      0.378563,
      0.176471,
      0.217949,
      0.036615,
      0.383522,
      0.180392,
      0.224763,
      0.036405,
      0.388129,
      0.184314,
      0.231538,
      0.036405,
      0.3924,
      0.188235,
      0.238273,
      0.036621,
      0.396353,
      0.192157,
      0.244967,
      0.037055,
      0.400007,
      0.196078,
      0.25162,
      0.037705,
      0.403378,
      0.2,
      0.258234,
      0.038571,
      0.406485,
      0.203922,
      0.26481,
      0.039647,
      0.409345,
      0.207843,
      0.271347,
      0.040922,
      0.411976,
      0.211765,
      0.27785,
      0.042353,
      0.414392,
      0.215686,
      0.284321,
      0.043933,
      0.416608,
      0.219608,
      0.290763,
      0.045644,
      0.418637,
      0.223529,
      0.297178,
      0.04747,
      0.420491,
      0.227451,
      0.303568,
      0.049396,
      0.422182,
      0.231373,
      0.309935,
      0.051407,
      0.423721,
      0.235294,
      0.316282,
      0.05349,
      0.425116,
      0.239216,
      0.32261,
      0.055634,
      0.426377,
      0.243137,
      0.328921,
      0.057827,
      0.427511,
      0.247059,
      0.335217,
      0.06006,
      0.428524,
      0.25098,
      0.3415,
      0.062325,
      0.429425,
      0.254902,
      0.347771,
      0.064616,
      0.430217,
      0.258824,
      0.354032,
      0.066925,
      0.430906,
      0.262745,
      0.360284,
      0.069247,
      0.431497,
      0.266667,
      0.366529,
      0.071579,
      0.431994,
      0.270588,
      0.372768,
      0.073915,
      0.4324,
      0.27451,
      0.379001,
      0.076253,
      0.432719,
      0.278431,
      0.385228,
      0.078591,
      0.432955,
      0.282353,
      0.391453,
      0.080927,
      0.433109,
      0.286275,
      0.397674,
      0.083257,
      0.433183,
      0.290196,
      0.403894,
      0.08558,
      0.433179,
      0.294118,
      0.410113,
      0.087896,
      0.433098,
      0.298039,
      0.416331,
      0.090203,
      0.432943,
      0.301961,
      0.422549,
      0.092501,
      0.432714,
      0.305882,
      0.428768,
      0.09479,
      0.432412,
      0.309804,
      0.434987,
      0.097069,
      0.432039,
      0.313725,
      0.441207,
      0.099338,
      0.431594,
      0.317647,
      0.447428,
      0.101597,
      0.43108,
      0.321569,
      0.453651,
      0.103848,
      0.430498,
      0.32549,
      0.459875,
      0.106089,
      0.429846,
      0.329412,
      0.4661,
      0.108322,
      0.429125,
      0.333333,
      0.472328,
      0.110547,
      0.428334,
      0.337255,
      0.478558,
      0.112764,
      0.427475,
      0.341176,
      0.484789,
      0.114974,
      0.426548,
      0.345098,
      0.491022,
      0.117179,
      0.425552,
      0.34902,
      0.497257,
      0.119379,
      0.424488,
      0.352941,
      0.503493,
      0.121575,
      0.423356,
      0.356863,
      0.50973,
      0.123769,
      0.422156,
      0.360784,
      0.515967,
      0.12596,
      0.420887,
      0.364706,
      0.522206,
      0.12815,
      0.419549,
      0.368627,
      0.528444,
      0.130341,
      0.418142,
      0.372549,
      0.534683,
      0.132534,
      0.416667,
      0.376471,
      0.54092,
      0.134729,
      0.415123,
      0.380392,
      0.547157,
      0.136929,
      0.413511,
      0.384314,
      0.553392,
      0.139134,
      0.411829,
      0.388235,
      0.559624,
      0.141346,
      0.410078,
      0.392157,
      0.565854,
      0.143567,
      0.408258,
      0.396078,
      0.572081,
      0.145797,
      0.406369,
      0.4,
      0.578304,
      0.148039,
      0.404411,
      0.403922,
      0.584521,
      0.150294,
      0.402385,
      0.407843,
      0.590734,
      0.152563,
      0.40029,
      0.411765,
      0.59694,
      0.154848,
      0.398125,
      0.415686,
      0.603139,
      0.157151,
      0.395891,
      0.419608,
      0.60933,
      0.159474,
      0.393589,
      0.423529,
      0.615513,
      0.161817,
      0.391219,
      0.427451,
      0.621685,
      0.164184,
      0.388781,
      0.431373,
      0.627847,
      0.166575,
      0.386276,
      0.435294,
      0.633998,
      0.168992,
      0.383704,
      0.439216,
      0.640135,
      0.171438,
      0.381065,
      0.443137,
      0.64626,
      0.173914,
      0.378359,
      0.447059,
      0.652369,
      0.176421,
      0.375586,
      0.45098,
      0.658463,
      0.178962,
      0.372748,
      0.454902,
      0.66454,
      0.181539,
      0.369846,
      0.458824,
      0.670599,
      0.184153,
      0.366879,
      0.462745,
      0.676638,
      0.186807,
      0.363849,
      0.466667,
      0.682656,
      0.189501,
      0.360757,
      0.470588,
      0.688653,
      0.192239,
      0.357603,
      0.47451,
      0.694627,
      0.195021,
      0.354388,
      0.478431,
      0.700576,
      0.197851,
      0.351113,
      0.482353,
      0.7065,
      0.200728,
      0.347777,
      0.486275,
      0.712396,
      0.203656,
      0.344383,
      0.490196,
      0.718264,
      0.206636,
      0.340931,
      0.494118,
      0.724103,
      0.20967,
      0.337424,
      0.498039,
      0.729909,
      0.212759,
      0.333861,
      0.501961,
      0.735683,
      0.215906,
      0.330245,
      0.505882,
      0.741423,
      0.219112,
      0.326576,
      0.509804,
      0.747127,
      0.222378,
      0.322856,
      0.513725,
      0.752794,
      0.225706,
      0.319085,
      0.517647,
      0.758422,
      0.229097,
      0.315266,
      0.521569,
      0.76401,
      0.232554,
      0.311399,
      0.52549,
      0.769556,
      0.236077,
      0.307485,
      0.529412,
      0.775059,
      0.239667,
      0.303526,
      0.533333,
      0.780517,
      0.243327,
      0.299523,
      0.537255,
      0.785929,
      0.247056,
      0.295477,
      0.541176,
      0.791293,
      0.250856,
      0.29139,
      0.545098,
      0.796607,
      0.254728,
      0.287264,
      0.54902,
      0.801871,
      0.258674,
      0.283099,
      0.552941,
      0.807082,
      0.262692,
      0.278898,
      0.556863,
      0.812239,
      0.266786,
      0.274661,
      0.560784,
      0.817341,
      0.270954,
      0.27039,
      0.564706,
      0.822386,
      0.275197,
      0.266085,
      0.568627,
      0.827372,
      0.279517,
      0.26175,
      0.572549,
      0.832299,
      0.283913,
      0.257383,
      0.576471,
      0.837165,
      0.288385,
      0.252988,
      0.580392,
      0.841969,
      0.292933,
      0.248564,
      0.584314,
      0.846709,
      0.297559,
      0.244113,
      0.588235,
      0.851384,
      0.30226,
      0.239636,
      0.592157,
      0.855992,
      0.307038,
      0.235133,
      0.596078,
      0.860533,
      0.311892,
      0.230606,
      0.6,
      0.865006,
      0.316822,
      0.226055,
      0.603922,
      0.869409,
      0.321827,
      0.221482,
      0.607843,
      0.873741,
      0.326906,
      0.216886,
      0.611765,
      0.878001,
      0.33206,
      0.212268,
      0.615686,
      0.882188,
      0.337287,
      0.207628,
      0.619608,
      0.886302,
      0.342586,
      0.202968,
      0.623529,
      0.890341,
      0.347957,
      0.198286,
      0.627451,
      0.894305,
      0.353399,
      0.193584,
      0.631373,
      0.898192,
      0.358911,
      0.18886,
      0.635294,
      0.902003,
      0.364492,
      0.184116,
      0.639216,
      0.905735,
      0.37014,
      0.17935,
      0.643137,
      0.90939,
      0.375856,
      0.174563,
      0.647059,
      0.912966,
      0.381636,
      0.169755,
      0.65098,
      0.916462,
      0.387481,
      0.164924,
      0.654902,
      0.919879,
      0.393389,
      0.16007,
      0.658824,
      0.923215,
      0.399359,
      0.155193,
      0.662745,
      0.92647,
      0.405389,
      0.150292,
      0.666667,
      0.929644,
      0.411479,
      0.145367,
      0.670588,
      0.932737,
      0.417627,
      0.140417,
      0.67451,
      0.935747,
      0.423831,
      0.13544,
      0.678431,
      0.938675,
      0.430091,
      0.130438,
      0.682353,
      0.941521,
      0.436405,
      0.125409,
      0.686275,
      0.944285,
      0.442772,
      0.120354,
      0.690196,
      0.946965,
      0.449191,
      0.115272,
      0.694118,
      0.949562,
      0.45566,
      0.110164,
      0.698039,
      0.952075,
      0.462178,
      0.105031,
      0.701961,
      0.954506,
      0.468744,
      0.099874,
      0.705882,
      0.956852,
      0.475356,
      0.094695,
      0.709804,
      0.959114,
      0.482014,
      0.089499,
      0.713725,
      0.961293,
      0.488716,
      0.084289,
      0.717647,
      0.963387,
      0.495462,
      0.079073,
      0.721569,
      0.965397,
      0.502249,
      0.073859,
      0.72549,
      0.967322,
      0.509078,
      0.068659,
      0.729412,
      0.969163,
      0.515946,
      0.063488,
      0.733333,
      0.970919,
      0.522853,
      0.058367,
      0.737255,
      0.97259,
      0.529798,
      0.053324,
      0.741176,
      0.974176,
      0.53678,
      0.048392,
      0.745098,
      0.975677,
      0.543798,
      0.043618,
      0.74902,
      0.977092,
      0.55085,
      0.03905,
      0.752941,
      0.978422,
      0.557937,
      0.034931,
      0.756863,
      0.979666,
      0.565057,
      0.031409,
      0.760784,
      0.980824,
      0.572209,
      0.028508,
      0.764706,
      0.981895,
      0.579392,
      0.02625,
      0.768627,
      0.982881,
      0.586606,
      0.024661,
      0.772549,
      0.983779,
      0.593849,
      0.02377,
      0.776471,
      0.984591,
      0.601122,
      0.023606,
      0.780392,
      0.985315,
      0.608422,
      0.024202,
      0.784314,
      0.985952,
      0.61575,
      0.025592,
      0.788235,
      0.986502,
      0.623105,
      0.027814,
      0.792157,
      0.986964,
      0.630485,
      0.030908,
      0.796078,
      0.987337,
      0.63789,
      0.034916,
      0.8,
      0.987622,
      0.64532,
      0.039886,
      0.803922,
      0.987819,
      0.652773,
      0.045581,
      0.807843,
      0.987926,
      0.66025,
      0.05175,
      0.811765,
      0.987945,
      0.667748,
      0.058329,
      0.815686,
      0.987874,
      0.675267,
      0.065257,
      0.819608,
      0.987714,
      0.682807,
      0.072489,
      0.823529,
      0.987464,
      0.690366,
      0.07999,
      0.827451,
      0.987124,
      0.697944,
      0.087731,
      0.831373,
      0.986694,
      0.70554,
      0.095694,
      0.835294,
      0.986175,
      0.713153,
      0.103863,
      0.839216,
      0.985566,
      0.720782,
      0.112229,
      0.843137,
      0.984865,
      0.728427,
      0.120785,
      0.847059,
      0.984075,
      0.736087,
      0.129527,
      0.85098,
      0.983196,
      0.743758,
      0.138453,
      0.854902,
      0.982228,
      0.751442,
      0.147565,
      0.858824,
      0.981173,
      0.759135,
      0.156863,
      0.862745,
      0.980032,
      0.766837,
      0.166353,
      0.866667,
      0.978806,
      0.774545,
      0.176037,
      0.870588,
      0.977497,
      0.782258,
      0.185923,
      0.87451,
      0.976108,
      0.789974,
      0.196018,
      0.878431,
      0.974638,
      0.797692,
      0.206332,
      0.882353,
      0.973088,
      0.805409,
      0.216877,
      0.886275,
      0.971468,
      0.813122,
      0.227658,
      0.890196,
      0.969783,
      0.820825,
      0.238686,
      0.894118,
      0.968041,
      0.828515,
      0.249972,
      0.898039,
      0.966243,
      0.836191,
      0.261534,
      0.901961,
      0.964394,
      0.843848,
      0.273391,
      0.905882,
      0.962517,
      0.851476,
      0.285546,
      0.909804,
      0.960626,
      0.859069,
      0.29801,
      0.913725,
      0.95872,
      0.866624,
      0.31082,
      0.917647,
      0.956834,
      0.874129,
      0.323974,
      0.921569,
      0.954997,
      0.881569,
      0.337475,
      0.92549,
      0.953215,
      0.888942,
      0.351369,
      0.929412,
      0.951546,
      0.896226,
      0.365627,
      0.933333,
      0.950018,
      0.903409,
      0.380271,
      0.937255,
      0.948683,
      0.910473,
      0.395289,
      0.941176,
      0.947594,
      0.917399,
      0.410665,
      0.945098,
      0.946809,
      0.924168,
      0.426373,
      0.94902,
      0.946392,
      0.930761,
      0.442367,
      0.952941,
      0.946403,
      0.937159,
      0.458592,
      0.956863,
      0.946903,
      0.943348,
      0.47497,
      0.960784,
      0.947937,
      0.949318,
      0.491426,
      0.964706,
      0.949545,
      0.955063,
      0.50786,
      0.968627,
      0.95174,
      0.960587,
      0.524203,
      0.972549,
      0.954529,
      0.965896,
      0.540361,
      0.976471,
      0.957896,
      0.971003,
      0.556275,
      0.980392,
      0.961812,
      0.975924,
      0.571925,
      0.984314,
      0.966249,
      0.980678,
      0.587206,
      0.988235,
      0.971162,
      0.985282,
      0.602154,
      0.992157,
      0.976511,
      0.989753,
      0.61676,
      0.996078,
      0.982257,
      0.994109,
      0.631017,
      1,
      0.988362,
      0.998364,
      0.644924
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Plasma (matplotlib)",
    NanColor: [
      0,
      1,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Nathaniel J. Smith & Stefan van der Walt",
    RGBPoints: [
      0,
      0.050383,
      0.029803,
      0.527975,
      0.003922,
      0.063536,
      0.028426,
      0.533124,
      0.007843,
      0.075353,
      0.027206,
      0.538007,
      0.011765,
      0.086222,
      0.026125,
      0.542658,
      0.015686,
      0.096379,
      0.025165,
      0.547103,
      0.019608,
      0.10598,
      0.024309,
      0.551368,
      0.023529,
      0.115124,
      0.023556,
      0.555468,
      0.027451,
      0.123903,
      0.022878,
      0.559423,
      0.031373,
      0.132381,
      0.022258,
      0.56325,
      0.035294,
      0.140603,
      0.021687,
      0.566959,
      0.039216,
      0.148607,
      0.021154,
      0.570562,
      0.043137,
      0.156421,
      0.020651,
      0.574065,
      0.047059,
      0.16407,
      0.020171,
      0.577478,
      0.05098,
      0.171574,
      0.019706,
      0.580806,
      0.054902,
      0.17895,
      0.019252,
      0.584054,
      0.058824,
      0.186213,
      0.018803,
      0.587228,
      0.062745,
      0.193374,
      0.018354,
      0.59033,
      0.066667,
      0.200445,
      0.017902,
      0.593364,
      0.070588,
      0.207435,
      0.017442,
      0.596333,
      0.07451,
      0.21435,
      0.016973,
      0.599239,
      0.078431,
      0.221197,
      0.016497,
      0.602083,
      0.082353,
      0.227983,
      0.016007,
      0.604867,
      0.086275,
      0.234715,
      0.015502,
      0.607592,
      0.090196,
      0.241396,
      0.014979,
      0.610259,
      0.094118,
      0.248032,
      0.014439,
      0.612868,
      0.098039,
      0.254627,
      0.013882,
      0.615419,
      0.101961,
      0.261183,
      0.013308,
      0.617911,
      0.105882,
      0.267703,
      0.012716,
      0.620346,
      0.109804,
      0.274191,
      0.012109,
      0.622722,
      0.113725,
      0.280648,
      0.011488,
      0.625038,
      0.117647,
      0.287076,
      0.010855,
      0.627295,
      0.121569,
      0.293478,
      0.010213,
      0.62949,
      0.12549,
      0.299855,
      0.009561,
      0.631624,
      0.129412,
      0.30621,
      0.008902,
      0.633694,
      0.133333,
      0.312543,
      0.008239,
      0.6357,
      0.137255,
      0.318856,
      0.007576,
      0.63764,
      0.141176,
      0.32515,
      0.006915,
      0.639512,
      0.145098,
      0.331426,
      0.006261,
      0.641316,
      0.14902,
      0.337683,
      0.005618,
      0.643049,
      0.152941,
      0.343925,
      0.004991,
      0.64471,
      0.156863,
      0.35015,
      0.004382,
      0.646298,
      0.160784,
      0.356359,
      0.003798,
      0.64781,
      0.164706,
      0.362553,
      0.003243,
      0.649245,
      0.168627,
      0.368733,
      0.002724,
      0.650601,
      0.172549,
      0.374897,
      0.002245,
      0.651876,
      0.176471,
      0.381047,
      0.001814,
      0.653068,
      0.180392,
      0.387183,
      0.001434,
      0.654177,
      0.184314,
      0.393304,
      0.001114,
      0.655199,
      0.188235,
      0.399411,
      0.000859,
      0.656133,
      0.192157,
      0.405503,
      0.000678,
      0.656977,
      0.196078,
      0.41158,
      0.000577,
      0.65773,
      0.2,
      0.417642,
      0.000564,
      0.65839,
      0.203922,
      0.423689,
      0.000646,
      0.658956,
      0.207843,
      0.429719,
      0.000831,
      0.659425,
      0.211765,
      0.435734,
      0.001127,
      0.659797,
      0.215686,
      0.441732,
      0.00154,
      0.660069,
      0.219608,
      0.447714,
      0.00208,
      0.66024,
      0.223529,
      0.453677,
      0.002755,
      0.66031,
      0.227451,
      0.459623,
      0.003574,
      0.660277,
      0.231373,
      0.46555,
      0.004545,
      0.660139,
      0.235294,
      0.471457,
      0.005678,
      0.659897,
      0.239216,
      0.477344,
      0.00698,
      0.659549,
      0.243137,
      0.48321,
      0.00846,
      0.659095,
      0.247059,
      0.489055,
      0.010127,
      0.658534,
      0.25098,
      0.494877,
      0.01199,
      0.657865,
      0.254902,
      0.500678,
      0.014055,
      0.657088,
      0.258824,
      0.506454,
      0.016333,
      0.656202,
      0.262745,
      0.512206,
      0.018833,
      0.655209,
      0.266667,
      0.517933,
      0.021563,
      0.654109,
      0.270588,
      0.523633,
      0.024532,
      0.652901,
      0.27451,
      0.529306,
      0.027747,
      0.651586,
      0.278431,
      0.534952,
      0.031217,
      0.650165,
      0.282353,
      0.54057,
      0.03495,
      0.64864,
      0.286275,
      0.546157,
      0.038954,
      0.64701,
      0.290196,
      0.551715,
      0.043136,
      0.645277,
      0.294118,
      0.557243,
      0.047331,
      0.643443,
      0.298039,
      0.562738,
      0.051545,
      0.641509,
      0.301961,
      0.568201,
      0.055778,
      0.639477,
      0.305882,
      0.573632,
      0.060028,
      0.637349,
      0.309804,
      0.579029,
      0.064296,
      0.635126,
      0.313725,
      0.584391,
      0.068579,
      0.632812,
      0.317647,
      0.589719,
      0.072878,
      0.630408,
      0.321569,
      0.595011,
      0.07719,
      0.627917,
      0.32549,
      0.600266,
      0.081516,
      0.625342,
      0.329412,
      0.605485,
      0.085854,
      0.622686,
      0.333333,
      0.610667,
      0.090204,
      0.619951,
      0.337255,
      0.615812,
      0.094564,
      0.61714,
      0.341176,
      0.620919,
      0.098934,
      0.614257,
      0.345098,
      0.625987,
      0.103312,
      0.611305,
      0.34902,
      0.631017,
      0.107699,
      0.608287,
      0.352941,
      0.636008,
      0.112092,
      0.605205,
      0.356863,
      0.640959,
      0.116492,
      0.602065,
      0.360784,
      0.645872,
      0.120898,
      0.598867,
      0.364706,
      0.650746,
      0.125309,
      0.595617,
      0.368627,
      0.65558,
      0.129725,
      0.592317,
      0.372549,
      0.660374,
      0.134144,
      0.588971,
      0.376471,
      0.665129,
      0.138566,
      0.585582,
      0.380392,
      0.669845,
      0.142992,
      0.582154,
      0.384314,
      0.674522,
      0.147419,
      0.578688,
      0.388235,
      0.67916,
      0.151848,
      0.575189,
      0.392157,
      0.683758,
      0.156278,
      0.57166,
      0.396078,
      0.688318,
      0.160709,
      0.568103,
      0.4,
      0.69284,
      0.165141,
      0.564522,
      0.403922,
      0.697324,
      0.169573,
      0.560919,
      0.407843,
      0.701769,
      0.174005,
      0.557296,
      0.411765,
      0.706178,
      0.178437,
      0.553657,
      0.415686,
      0.710549,
      0.182868,
      0.550004,
      0.419608,
      0.714883,
      0.187299,
      0.546338,
      0.423529,
      0.719181,
      0.191729,
      0.542663,
      0.427451,
      0.723444,
      0.196158,
      0.538981,
      0.431373,
      0.72767,
      0.200586,
      0.535293,
      0.435294,
      0.731862,
      0.205013,
      0.531601,
      0.439216,
      0.736019,
      0.209439,
      0.527908,
      0.443137,
      0.740143,
      0.213864,
      0.524216,
      0.447059,
      0.744232,
      0.218288,
      0.520524,
      0.45098,
      0.748289,
      0.222711,
      0.516834,
      0.454902,
      0.752312,
      0.227133,
      0.513149,
      0.458824,
      0.756304,
      0.231555,
      0.509468,
      0.462745,
      0.760264,
      0.235976,
      0.505794,
      0.466667,
      0.764193,
      0.240396,
      0.502126,
      0.470588,
      0.76809,
      0.244817,
      0.498465,
      0.47451,
      0.771958,
      0.249237,
      0.494813,
      0.478431,
      0.775796,
      0.253658,
      0.491171,
      0.482353,
      0.779604,
      0.258078,
      0.487539,
      0.486275,
      0.783383,
      0.2625,
      0.483918,
      0.490196,
      0.787133,
      0.266922,
      0.480307,
      0.494118,
      0.790855,
      0.271345,
      0.476706,
      0.498039,
      0.794549,
      0.27577,
      0.473117,
      0.501961,
      0.798216,
      0.280197,
      0.469538,
      0.505882,
      0.801855,
      0.284626,
      0.465971,
      0.509804,
      0.805467,
      0.289057,
      0.462415,
      0.513725,
      0.809052,
      0.293491,
      0.45887,
      0.517647,
      0.812612,
      0.297928,
      0.455338,
      0.521569,
      0.816144,
      0.302368,
      0.451816,
      0.52549,
      0.819651,
      0.306812,
      0.448306,
      0.529412,
      0.823132,
      0.311261,
      0.444806,
      0.533333,
      0.826588,
      0.315714,
      0.441316,
      0.537255,
      0.830018,
      0.320172,
      0.437836,
      0.541176,
      0.833422,
      0.324635,
      0.434366,
      0.545098,
      0.836801,
      0.329105,
      0.430905,
      0.54902,
      0.840155,
      0.33358,
      0.427455,
      0.552941,
      0.843484,
      0.338062,
      0.424013,
      0.556863,
      0.846788,
      0.342551,
      0.420579,
      0.560784,
      0.850066,
      0.347048,
      0.417153,
      0.564706,
      0.853319,
      0.351553,
      0.413734,
      0.568627,
      0.856547,
      0.356066,
      0.410322,
      0.572549,
      0.85975,
      0.360588,
      0.406917,
      0.576471,
      0.862927,
      0.365119,
      0.403519,
      0.580392,
      0.866078,
      0.36966,
      0.400126,
      0.584314,
      0.869203,
      0.374212,
      0.396738,
      0.588235,
      0.872303,
      0.378774,
      0.393355,
      0.592157,
      0.875376,
      0.383347,
      0.389976,
      0.596078,
      0.878423,
      0.387932,
      0.3866,
      0.6,
      0.881443,
      0.392529,
      0.383229,
      0.603922,
      0.884436,
      0.397139,
      0.37986,
      0.607843,
      0.887402,
      0.401762,
      0.376494,
      0.611765,
      0.89034,
      0.406398,
      0.37313,
      0.615686,
      0.89325,
      0.411048,
      0.369768,
      0.619608,
      0.896131,
      0.415712,
      0.366407,
      0.623529,
      0.898984,
      0.420392,
      0.363047,
      0.627451,
      0.901807,
      0.425087,
      0.359688,
      0.631373,
      0.904601,
      0.429797,
      0.356329,
      0.635294,
      0.907365,
      0.434524,
      0.35297,
      0.639216,
      0.910098,
      0.439268,
      0.34961,
      0.643137,
      0.9128,
      0.444029,
      0.346251,
      0.647059,
      0.915471,
      0.448807,
      0.34289,
      0.65098,
      0.918109,
      0.453603,
      0.339529,
      0.654902,
      0.920714,
      0.458417,
      0.336166,
      0.658824,
      0.923287,
      0.463251,
      0.332801,
      0.662745,
      0.925825,
      0.468103,
      0.329435,
      0.666667,
      0.928329,
      0.472975,
      0.326067,
      0.670588,
      0.930798,
      0.477867,
      0.322697,
      0.67451,
      0.933232,
      0.48278,
      0.319325,
      0.678431,
      0.93563,
      0.487712,
      0.315952,
      0.682353,
      0.93799,
      0.492667,
      0.312575,
      0.686275,
      0.940313,
      0.497642,
      0.309197,
      0.690196,
      0.942598,
      0.502639,
      0.305816,
      0.694118,
      0.944844,
      0.507658,
      0.302433,
      0.698039,
      0.947051,
      0.512699,
      0.299049,
      0.701961,
      0.949217,
      0.517763,
      0.295662,
      0.705882,
      0.951344,
      0.52285,
      0.292275,
      0.709804,
      0.953428,
      0.52796,
      0.288883,
      0.713725,
      0.95547,
      0.533093,
      0.28549,
      0.717647,
      0.957469,
      0.53825,
      0.282096,
      0.721569,
      0.959424,
      0.543431,
      0.278701,
      0.72549,
      0.961336,
      0.548636,
      0.275305,
      0.729412,
      0.963203,
      0.553865,
      0.271909,
      0.733333,
      0.965024,
      0.559118,
      0.268513,
      0.737255,
      0.966798,
      0.564396,
      0.265118,
      0.741176,
      0.968526,
      0.5697,
      0.261721,
      0.745098,
      0.970205,
      0.575028,
      0.258325,
      0.74902,
      0.971835,
      0.580382,
      0.254931,
      0.752941,
      0.973416,
      0.585761,
      0.25154,
      0.756863,
      0.974947,
      0.591165,
      0.248151,
      0.760784,
      0.976428,
      0.596595,
      0.244767,
      0.764706,
      0.977856,
      0.602051,
      0.241387,
      0.768627,
      0.979233,
      0.607532,
      0.238013,
      0.772549,
      0.980556,
      0.613039,
      0.234646,
      0.776471,
      0.981826,
      0.618572,
      0.231287,
      0.780392,
      0.983041,
      0.624131,
      0.227937,
      0.784314,
      0.984199,
      0.629718,
      0.224595,
      0.788235,
      0.985301,
      0.63533,
      0.221265,
      0.792157,
      0.986345,
      0.640969,
      0.217948,
      0.796078,
      0.987332,
      0.646633,
      0.214648,
      0.8,
      0.98826,
      0.652325,
      0.211364,
      0.803922,
      0.989128,
      0.658043,
      0.2081,
      0.807843,
      0.989935,
      0.663787,
      0.204859,
      0.811765,
      0.990681,
      0.669558,
      0.201642,
      0.815686,
      0.991365,
      0.675355,
      0.198453,
      0.819608,
      0.991985,
      0.681179,
      0.195295,
      0.823529,
      0.992541,
      0.68703,
      0.19217,
      0.827451,
      0.993032,
      0.692907,
      0.189084,
      0.831373,
      0.993456,
      0.69881,
      0.186041,
      0.835294,
      0.993814,
      0.704741,
      0.183043,
      0.839216,
      0.994103,
      0.710698,
      0.180097,
      0.843137,
      0.994324,
      0.716681,
      0.177208,
      0.847059,
      0.994474,
      0.722691,
      0.174381,
      0.85098,
      0.994553,
      0.728728,
      0.171622,
      0.854902,
      0.994561,
      0.734791,
      0.168938,
      0.858824,
      0.994495,
      0.74088,
      0.166335,
      0.862745,
      0.994355,
      0.746995,
      0.163821,
      0.866667,
      0.994141,
      0.753137,
      0.161404,
      0.870588,
      0.993851,
      0.759304,
      0.159092,
      0.87451,
      0.993482,
      0.765499,
      0.156891,
      0.878431,
      0.993033,
      0.77172,
      0.154808,
      0.882353,
      0.992505,
      0.777967,
      0.152855,
      0.886275,
      0.991897,
      0.784239,
      0.151042,
      0.890196,
      0.991209,
      0.790537,
      0.149377,
      0.894118,
      0.990439,
      0.796859,
      0.14787,
      0.898039,
      0.989587,
      0.803205,
      0.146529,
      0.901961,
      0.988648,
      0.809579,
      0.145357,
      0.905882,
      0.987621,
      0.815978,
      0.144363,
      0.909804,
      0.986509,
      0.822401,
      0.143557,
      0.913725,
      0.985314,
      0.828846,
      0.142945,
      0.917647,
      0.984031,
      0.835315,
      0.142528,
      0.921569,
      0.982653,
      0.841812,
      0.142303,
      0.92549,
      0.98119,
      0.848329,
      0.142279,
      0.929412,
      0.979644,
      0.854866,
      0.142453,
      0.933333,
      0.977995,
      0.861432,
      0.142808,
      0.937255,
      0.976265,
      0.868016,
      0.143351,
      0.941176,
      0.974443,
      0.874622,
      0.144061,
      0.945098,
      0.97253,
      0.88125,
      0.144923,
      0.94902,
      0.970533,
      0.887896,
      0.145919,
      0.952941,
      0.968443,
      0.894564,
      0.147014,
      0.956863,
      0.966271,
      0.901249,
      0.14818,
      0.960784,
      0.964021,
      0.90795,
      0.14937,
      0.964706,
      0.961681,
      0.914672,
      0.15052,
      0.968627,
      0.959276,
      0.921407,
      0.151566,
      0.972549,
      0.956808,
      0.928152,
      0.152409,
      0.976471,
      0.954287,
      0.934908,
      0.152921,
      0.980392,
      0.951726,
      0.941671,
      0.152925,
      0.984314,
      0.949151,
      0.948435,
      0.152178,
      0.988235,
      0.946602,
      0.95519,
      0.150328,
      0.992157,
      0.944152,
      0.961916,
      0.146861,
      0.996078,
      0.941896,
      0.96859,
      0.140956,
      1,
      0.940015,
      0.975158,
      0.131326
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Viridis (matplotlib)",
    NanColor: [
      1,
      0,
      0
    ],
    Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
    License: "CC0",
    Creator: "Eric Firing",
    RGBPoints: [
      0,
      0.267004,
      0.004874,
      0.329415,
      0.003922,
      0.26851,
      0.009605,
      0.335427,
      0.007843,
      0.269944,
      0.014625,
      0.341379,
      0.011765,
      0.271305,
      0.019942,
      0.347269,
      0.015686,
      0.272594,
      0.025563,
      0.353093,
      0.019608,
      0.273809,
      0.031497,
      0.358853,
      0.023529,
      0.274952,
      0.037752,
      0.364543,
      0.027451,
      0.276022,
      0.044167,
      0.370164,
      0.031373,
      0.277018,
      0.050344,
      0.375715,
      0.035294,
      0.277941,
      0.056324,
      0.381191,
      0.039216,
      0.278791,
      0.062145,
      0.386592,
      0.043137,
      0.279566,
      0.067836,
      0.391917,
      0.047059,
      0.280267,
      0.073417,
      0.397163,
      0.05098,
      0.280894,
      0.078907,
      0.402329,
      0.054902,
      0.281446,
      0.08432,
      0.407414,
      0.058824,
      0.281924,
      0.089666,
      0.412415,
      0.062745,
      0.282327,
      0.094955,
      0.417331,
      0.066667,
      0.282656,
      0.100196,
      0.42216,
      0.070588,
      0.28291,
      0.105393,
      0.426902,
      0.07451,
      0.283091,
      0.110553,
      0.431554,
      0.078431,
      0.283197,
      0.11568,
      0.436115,
      0.082353,
      0.283229,
      0.120777,
      0.440584,
      0.086275,
      0.283187,
      0.125848,
      0.44496,
      0.090196,
      0.283072,
      0.130895,
      0.449241,
      0.094118,
      0.282884,
      0.13592,
      0.453427,
      0.098039,
      0.282623,
      0.140926,
      0.457517,
      0.101961,
      0.28229,
      0.145912,
      0.46151,
      0.105882,
      0.281887,
      0.150881,
      0.465405,
      0.109804,
      0.281412,
      0.155834,
      0.469201,
      0.113725,
      0.280868,
      0.160771,
      0.472899,
      0.117647,
      0.280255,
      0.165693,
      0.476498,
      0.121569,
      0.279574,
      0.170599,
      0.479997,
      0.12549,
      0.278826,
      0.17549,
      0.483397,
      0.129412,
      0.278012,
      0.180367,
      0.486697,
      0.133333,
      0.277134,
      0.185228,
      0.489898,
      0.137255,
      0.276194,
      0.190074,
      0.493001,
      0.141176,
      0.275191,
      0.194905,
      0.496005,
      0.145098,
      0.274128,
      0.199721,
      0.498911,
      0.14902,
      0.273006,
      0.20452,
      0.501721,
      0.152941,
      0.271828,
      0.209303,
      0.504434,
      0.156863,
      0.270595,
      0.214069,
      0.507052,
      0.160784,
      0.269308,
      0.218818,
      0.509577,
      0.164706,
      0.267968,
      0.223549,
      0.512008,
      0.168627,
      0.26658,
      0.228262,
      0.514349,
      0.172549,
      0.265145,
      0.232956,
      0.516599,
      0.176471,
      0.263663,
      0.237631,
      0.518762,
      0.180392,
      0.262138,
      0.242286,
      0.520837,
      0.184314,
      0.260571,
      0.246922,
      0.522828,
      0.188235,
      0.258965,
      0.251537,
      0.524736,
      0.192157,
      0.257322,
      0.25613,
      0.526563,
      0.196078,
      0.255645,
      0.260703,
      0.528312,
      0.2,
      0.253935,
      0.265254,
      0.529983,
      0.203922,
      0.252194,
      0.269783,
      0.531579,
      0.207843,
      0.250425,
      0.27429,
      0.533103,
      0.211765,
      0.248629,
      0.278775,
      0.534556,
      0.215686,
      0.246811,
      0.283237,
      0.535941,
      0.219608,
      0.244972,
      0.287675,
      0.53726,
      0.223529,
      0.243113,
      0.292092,
      0.538516,
      0.227451,
      0.241237,
      0.296485,
      0.539709,
      0.231373,
      0.239346,
      0.300855,
      0.540844,
      0.235294,
      0.237441,
      0.305202,
      0.541921,
      0.239216,
      0.235526,
      0.309527,
      0.542944,
      0.243137,
      0.233603,
      0.313828,
      0.543914,
      0.247059,
      0.231674,
      0.318106,
      0.544834,
      0.25098,
      0.229739,
      0.322361,
      0.545706,
      0.254902,
      0.227802,
      0.326594,
      0.546532,
      0.258824,
      0.225863,
      0.330805,
      0.547314,
      0.262745,
      0.223925,
      0.334994,
      0.548053,
      0.266667,
      0.221989,
      0.339161,
      0.548752,
      0.270588,
      0.220057,
      0.343307,
      0.549413,
      0.27451,
      0.21813,
      0.347432,
      0.550038,
      0.278431,
      0.21621,
      0.351535,
      0.550627,
      0.282353,
      0.214298,
      0.355619,
      0.551184,
      0.286275,
      0.212395,
      0.359683,
      0.55171,
      0.290196,
      0.210503,
      0.363727,
      0.552206,
      0.294118,
      0.208623,
      0.367752,
      0.552675,
      0.298039,
      0.206756,
      0.371758,
      0.553117,
      0.301961,
      0.204903,
      0.375746,
      0.553533,
      0.305882,
      0.203063,
      0.379716,
      0.553925,
      0.309804,
      0.201239,
      0.38367,
      0.554294,
      0.313725,
      0.19943,
      0.387607,
      0.554642,
      0.317647,
      0.197636,
      0.391528,
      0.554969,
      0.321569,
      0.19586,
      0.395433,
      0.555276,
      0.32549,
      0.1941,
      0.399323,
      0.555565,
      0.329412,
      0.192357,
      0.403199,
      0.555836,
      0.333333,
      0.190631,
      0.407061,
      0.556089,
      0.337255,
      0.188923,
      0.41091,
      0.556326,
      0.341176,
      0.187231,
      0.414746,
      0.556547,
      0.345098,
      0.185556,
      0.41857,
      0.556753,
      0.34902,
      0.183898,
      0.422383,
      0.556944,
      0.352941,
      0.182256,
      0.426184,
      0.55712,
      0.356863,
      0.180629,
      0.429975,
      0.557282,
      0.360784,
      0.179019,
      0.433756,
      0.55743,
      0.364706,
      0.177423,
      0.437527,
      0.557565,
      0.368627,
      0.175841,
      0.44129,
      0.557685,
      0.372549,
      0.174274,
      0.445044,
      0.557792,
      0.376471,
      0.172719,
      0.448791,
      0.557885,
      0.380392,
      0.171176,
      0.45253,
      0.557965,
      0.384314,
      0.169646,
      0.456262,
      0.55803,
      0.388235,
      0.168126,
      0.459988,
      0.558082,
      0.392157,
      0.166617,
      0.463708,
      0.558119,
      0.396078,
      0.165117,
      0.467423,
      0.558141,
      0.4,
      0.163625,
      0.471133,
      0.558148,
      0.403922,
      0.162142,
      0.474838,
      0.55814,
      0.407843,
      0.160665,
      0.47854,
      0.558115,
      0.411765,
      0.159194,
      0.482237,
      0.558073,
      0.415686,
      0.157729,
      0.485932,
      0.558013,
      0.419608,
      0.15627,
      0.489624,
      0.557936,
      0.423529,
      0.154815,
      0.493313,
      0.55784,
      0.427451,
      0.153364,
      0.497,
      0.557724,
      0.431373,
      0.151918,
      0.500685,
      0.557587,
      0.435294,
      0.150476,
      0.504369,
      0.55743,
      0.439216,
      0.149039,
      0.508051,
      0.55725,
      0.443137,
      0.147607,
      0.511733,
      0.557049,
      0.447059,
      0.14618,
      0.515413,
      0.556823,
      0.45098,
      0.144759,
      0.519093,
      0.556572,
      0.454902,
      0.143343,
      0.522773,
      0.556295,
      0.458824,
      0.141935,
      0.526453,
      0.555991,
      0.462745,
      0.140536,
      0.530132,
      0.555659,
      0.466667,
      0.139147,
      0.533812,
      0.555298,
      0.470588,
      0.13777,
      0.537492,
      0.554906,
      0.47451,
      0.136408,
      0.541173,
      0.554483,
      0.478431,
      0.135066,
      0.544853,
      0.554029,
      0.482353,
      0.133743,
      0.548535,
      0.553541,
      0.486275,
      0.132444,
      0.552216,
      0.553018,
      0.490196,
      0.131172,
      0.555899,
      0.552459,
      0.494118,
      0.129933,
      0.559582,
      0.551864,
      0.498039,
      0.128729,
      0.563265,
      0.551229,
      0.501961,
      0.127568,
      0.566949,
      0.550556,
      0.505882,
      0.126453,
      0.570633,
      0.549841,
      0.509804,
      0.125394,
      0.574318,
      0.549086,
      0.513725,
      0.124395,
      0.578002,
      0.548287,
      0.517647,
      0.123463,
      0.581687,
      0.547445,
      0.521569,
      0.122606,
      0.585371,
      0.546557,
      0.52549,
      0.121831,
      0.589055,
      0.545623,
      0.529412,
      0.121148,
      0.592739,
      0.544641,
      0.533333,
      0.120565,
      0.596422,
      0.543611,
      0.537255,
      0.120092,
      0.600104,
      0.54253,
      0.541176,
      0.119738,
      0.603785,
      0.5414,
      0.545098,
      0.119512,
      0.607464,
      0.540218,
      0.54902,
      0.119423,
      0.611141,
      0.538982,
      0.552941,
      0.119483,
      0.614817,
      0.537692,
      0.556863,
      0.119699,
      0.61849,
      0.536347,
      0.560784,
      0.120081,
      0.622161,
      0.534946,
      0.564706,
      0.120638,
      0.625828,
      0.533488,
      0.568627,
      0.12138,
      0.629492,
      0.531973,
      0.572549,
      0.122312,
      0.633153,
      0.530398,
      0.576471,
      0.123444,
      0.636809,
      0.528763,
      0.580392,
      0.12478,
      0.640461,
      0.527068,
      0.584314,
      0.126326,
      0.644107,
      0.525311,
      0.588235,
      0.128087,
      0.647749,
      0.523491,
      0.592157,
      0.130067,
      0.651384,
      0.521608,
      0.596078,
      0.132268,
      0.655014,
      0.519661,
      0.6,
      0.134692,
      0.658636,
      0.517649,
      0.603922,
      0.137339,
      0.662252,
      0.515571,
      0.607843,
      0.14021,
      0.665859,
      0.513427,
      0.611765,
      0.143303,
      0.669459,
      0.511215,
      0.615686,
      0.146616,
      0.67305,
      0.508936,
      0.619608,
      0.150148,
      0.676631,
      0.506589,
      0.623529,
      0.153894,
      0.680203,
      0.504172,
      0.627451,
      0.157851,
      0.683765,
      0.501686,
      0.631373,
      0.162016,
      0.687316,
      0.499129,
      0.635294,
      0.166383,
      0.690856,
      0.496502,
      0.639216,
      0.170948,
      0.694384,
      0.493803,
      0.643137,
      0.175707,
      0.6979,
      0.491033,
      0.647059,
      0.180653,
      0.701402,
      0.488189,
      0.65098,
      0.185783,
      0.704891,
      0.485273,
      0.654902,
      0.19109,
      0.708366,
      0.482284,
      0.658824,
      0.196571,
      0.711827,
      0.479221,
      0.662745,
      0.202219,
      0.715272,
      0.476084,
      0.666667,
      0.20803,
      0.718701,
      0.472873,
      0.670588,
      0.214,
      0.722114,
      0.469588,
      0.67451,
      0.220124,
      0.725509,
      0.466226,
      0.678431,
      0.226397,
      0.728888,
      0.462789,
      0.682353,
      0.232815,
      0.732247,
      0.459277,
      0.686275,
      0.239374,
      0.735588,
      0.455688,
      0.690196,
      0.24607,
      0.73891,
      0.452024,
      0.694118,
      0.252899,
      0.742211,
      0.448284,
      0.698039,
      0.259857,
      0.745492,
      0.444467,
      0.701961,
      0.266941,
      0.748751,
      0.440573,
      0.705882,
      0.274149,
      0.751988,
      0.436601,
      0.709804,
      0.281477,
      0.755203,
      0.432552,
      0.713725,
      0.288921,
      0.758394,
      0.428426,
      0.717647,
      0.296479,
      0.761561,
      0.424223,
      0.721569,
      0.304148,
      0.764704,
      0.419943,
      0.72549,
      0.311925,
      0.767822,
      0.415586,
      0.729412,
      0.319809,
      0.770914,
      0.411152,
      0.733333,
      0.327796,
      0.77398,
      0.40664,
      0.737255,
      0.335885,
      0.777018,
      0.402049,
      0.741176,
      0.344074,
      0.780029,
      0.397381,
      0.745098,
      0.35236,
      0.783011,
      0.392636,
      0.74902,
      0.360741,
      0.785964,
      0.387814,
      0.752941,
      0.369214,
      0.788888,
      0.382914,
      0.756863,
      0.377779,
      0.791781,
      0.377939,
      0.760784,
      0.386433,
      0.794644,
      0.372886,
      0.764706,
      0.395174,
      0.797475,
      0.367757,
      0.768627,
      0.404001,
      0.800275,
      0.362552,
      0.772549,
      0.412913,
      0.803041,
      0.357269,
      0.776471,
      0.421908,
      0.805774,
      0.35191,
      0.780392,
      0.430983,
      0.808473,
      0.346476,
      0.784314,
      0.440137,
      0.811138,
      0.340967,
      0.788235,
      0.449368,
      0.813768,
      0.335384,
      0.792157,
      0.458674,
      0.816363,
      0.329727,
      0.796078,
      0.468053,
      0.818921,
      0.323998,
      0.8,
      0.477504,
      0.821444,
      0.318195,
      0.803922,
      0.487026,
      0.823929,
      0.312321,
      0.807843,
      0.496615,
      0.826376,
      0.306377,
      0.811765,
      0.506271,
      0.828786,
      0.300362,
      0.815686,
      0.515992,
      0.831158,
      0.294279,
      0.819608,
      0.525776,
      0.833491,
      0.288127,
      0.823529,
      0.535621,
      0.835785,
      0.281908,
      0.827451,
      0.545524,
      0.838039,
      0.275626,
      0.831373,
      0.555484,
      0.840254,
      0.269281,
      0.835294,
      0.565498,
      0.84243,
      0.262877,
      0.839216,
      0.575563,
      0.844566,
      0.256415,
      0.843137,
      0.585678,
      0.846661,
      0.249897,
      0.847059,
      0.595839,
      0.848717,
      0.243329,
      0.85098,
      0.606045,
      0.850733,
      0.236712,
      0.854902,
      0.616293,
      0.852709,
      0.230052,
      0.858824,
      0.626579,
      0.854645,
      0.223353,
      0.862745,
      0.636902,
      0.856542,
      0.21662,
      0.866667,
      0.647257,
      0.8584,
      0.209861,
      0.870588,
      0.657642,
      0.860219,
      0.203082,
      0.87451,
      0.668054,
      0.861999,
      0.196293,
      0.878431,
      0.678489,
      0.863742,
      0.189503,
      0.882353,
      0.688944,
      0.865448,
      0.182725,
      0.886275,
      0.699415,
      0.867117,
      0.175971,
      0.890196,
      0.709898,
      0.868751,
      0.169257,
      0.894118,
      0.720391,
      0.87035,
      0.162603,
      0.898039,
      0.730889,
      0.871916,
      0.156029,
      0.901961,
      0.741388,
      0.873449,
      0.149561,
      0.905882,
      0.751884,
      0.874951,
      0.143228,
      0.909804,
      0.762373,
      0.876424,
      0.137064,
      0.913725,
      0.772852,
      0.877868,
      0.131109,
      0.917647,
      0.783315,
      0.879285,
      0.125405,
      0.921569,
      0.79376,
      0.880678,
      0.120005,
      0.92549,
      0.804182,
      0.882046,
      0.114965,
      0.929412,
      0.814576,
      0.883393,
      0.110347,
      0.933333,
      0.82494,
      0.88472,
      0.106217,
      0.937255,
      0.83527,
      0.886029,
      0.102646,
      0.941176,
      0.845561,
      0.887322,
      0.099702,
      0.945098,
      0.85581,
      0.888601,
      0.097452,
      0.94902,
      0.866013,
      0.889868,
      0.095953,
      0.952941,
      0.876168,
      0.891125,
      0.09525,
      0.956863,
      0.886271,
      0.892374,
      0.095374,
      0.960784,
      0.89632,
      0.893616,
      0.096335,
      0.964706,
      0.906311,
      0.894855,
      0.098125,
      0.968627,
      0.916242,
      0.896091,
      0.100717,
      0.972549,
      0.926106,
      0.89733,
      0.104071,
      0.976471,
      0.935904,
      0.89857,
      0.108131,
      0.980392,
      0.945636,
      0.899815,
      0.112838,
      0.984314,
      0.9553,
      0.901065,
      0.118128,
      0.988235,
      0.964894,
      0.902323,
      0.123941,
      0.992157,
      0.974417,
      0.90359,
      0.130215,
      0.996078,
      0.983868,
      0.904867,
      0.136897,
      1,
      0.993248,
      0.906157,
      0.143936
    ]
  },
  {
    ShowIndexedColorActiveValues: 1,
    IndexedColors: [
      0.07,
      0.5,
      0.7,
      1,
      1,
      1,
      0.85,
      1,
      1,
      0.8,
      0.5,
      1,
      0.76,
      1,
      0,
      1,
      0.71,
      0.71,
      0.5,
      0.5,
      0.5,
      0.05,
      0.05,
      1,
      1,
      0.05,
      0.05,
      0.7,
      1,
      1,
      0.7,
      0.89,
      0.96,
      0.67,
      0.36,
      0.95,
      0.54,
      1,
      0,
      0.75,
      0.65,
      0.65,
      0.5,
      0.6,
      0.6,
      1,
      0.5,
      0,
      1,
      1,
      0.19,
      0.12,
      0.94,
      0.12,
      0.5,
      0.82,
      0.89,
      0.56,
      0.25,
      0.83,
      0.24,
      1,
      0,
      0.9,
      0.9,
      0.9,
      0.75,
      0.76,
      0.78,
      0.65,
      0.65,
      0.67,
      0.54,
      0.6,
      0.78,
      0.61,
      0.48,
      0.78,
      0.5,
      0.48,
      0.78,
      0.44,
      0.48,
      0.78,
      0.36,
      0.48,
      0.76,
      1,
      0.48,
      0.38,
      0.49,
      0.5,
      0.69,
      0.76,
      0.56,
      0.56,
      0.4,
      0.56,
      0.56,
      0.74,
      0.5,
      0.89,
      1,
      0.63,
      0,
      0.65,
      0.16,
      0.16,
      0.36,
      0.72,
      0.82,
      0.44,
      0.18,
      0.69,
      0,
      1,
      0,
      0.58,
      1,
      1,
      0.58,
      0.88,
      0.88,
      0.45,
      0.76,
      0.79,
      0.33,
      0.71,
      0.71,
      0.23,
      0.62,
      0.62,
      0.14,
      0.56,
      0.56,
      0.04,
      0.49,
      0.55,
      0,
      0.41,
      0.52,
      0.88,
      0.88,
      1,
      1,
      0.85,
      0.56,
      0.65,
      0.46,
      0.45,
      0.4,
      0.5,
      0.5,
      0.62,
      0.39,
      0.71,
      0.83,
      0.48,
      0,
      0.58,
      0,
      0.58,
      0.26,
      0.62,
      0.69,
      0.34,
      0.09,
      0.56,
      0,
      0.79,
      0,
      0.44,
      0.83,
      1,
      1,
      1,
      0.78,
      0.85,
      1,
      0.78,
      0.78,
      1,
      0.78,
      0.64,
      1,
      0.78,
      0.56,
      1,
      0.78,
      0.38,
      1,
      0.78,
      0.27,
      1,
      0.78,
      0.19,
      1,
      0.78,
      0.12,
      1,
      0.78,
      0,
      1,
      0.61,
      0,
      0.9,
      0.46,
      0,
      0.83,
      0.32,
      0,
      0.75,
      0.22,
      0,
      0.67,
      0.14,
      0.3,
      0.76,
      1,
      0.3,
      0.65,
      1,
      0.13,
      0.58,
      0.84,
      0.15,
      0.49,
      0.67,
      0.15,
      0.4,
      0.59,
      0.09,
      0.33,
      0.53,
      0.96,
      0.93,
      0.82,
      0.8,
      0.82,
      0.12,
      0.71,
      0.71,
      0.76,
      0.65,
      0.33,
      0.3,
      0.34,
      0.35,
      0.38,
      0.62,
      0.31,
      0.71,
      0.67,
      0.36,
      0,
      0.46,
      0.31,
      0.27,
      0.26,
      0.51,
      0.59,
      0.26,
      0,
      0.4,
      0,
      0.49,
      0,
      0.44,
      0.67,
      0.98,
      0,
      0.73,
      1,
      0,
      0.63,
      1,
      0,
      0.56,
      1,
      0,
      0.5,
      1,
      0,
      0.42,
      1,
      0.33,
      0.36,
      0.95,
      0.47,
      0.36,
      0.89,
      0.54,
      0.31,
      0.89,
      0.63,
      0.21,
      0.83,
      0.7,
      0.12,
      0.83,
      0.7,
      0.12,
      0.73,
      0.7,
      0.05,
      0.65,
      0.74,
      0.05,
      0.53,
      0.78,
      0,
      0.4,
      0.8,
      0,
      0.35,
      0.82,
      0,
      0.31,
      0.85,
      0,
      0.27,
      0.88,
      0,
      0.22,
      0.9,
      0,
      0.18,
      0.91,
      0,
      0.15,
      0.92,
      0,
      0.14,
      0.93,
      0,
      0.13,
      0.94,
      0,
      0.12,
      0.95,
      0,
      0.11,
      0.96,
      0,
      0.1,
      0.97,
      0,
      0.09,
      0.98,
      0,
      0.08,
      0.99,
      0,
      0.07,
      1,
      0,
      0.06
    ],
    Annotations: [
      0,
      "Xx",
      1,
      "H",
      2,
      "He",
      3,
      "Li",
      4,
      "Be",
      5,
      "B",
      6,
      "C",
      7,
      "N",
      8,
      "O",
      9,
      "F",
      10,
      "Ne",
      11,
      "Na",
      12,
      "Mg",
      13,
      "Al",
      14,
      "Si",
      15,
      "P",
      16,
      "S",
      17,
      "Cl",
      18,
      "Ar",
      19,
      "K",
      20,
      "Ca",
      21,
      "Sc",
      22,
      "Ti",
      23,
      "V",
      24,
      "Cr",
      25,
      "Mn",
      26,
      "Fe",
      27,
      "Co",
      28,
      "Ni",
      29,
      "Cu",
      30,
      "Zn",
      31,
      "Ga",
      32,
      "Ge",
      33,
      "As",
      34,
      "Se",
      35,
      "Br",
      36,
      "Kr",
      37,
      "Rb",
      38,
      "Sr",
      39,
      "Y",
      40,
      "Zr",
      41,
      "Nb",
      42,
      "Mo",
      43,
      "Tc",
      44,
      "Ru",
      45,
      "Rh",
      46,
      "Pd",
      47,
      "Ag",
      48,
      "Cd",
      49,
      "In",
      50,
      "Sn",
      51,
      "Sb",
      52,
      "Te",
      53,
      "I",
      54,
      "Xe",
      55,
      "Cs",
      56,
      "Ba",
      57,
      "La",
      58,
      "Ce",
      59,
      "Pr",
      60,
      "Nd",
      61,
      "Pm",
      62,
      "Sm",
      63,
      "Eu",
      64,
      "Gd",
      65,
      "Tb",
      66,
      "Dy",
      67,
      "Ho",
      68,
      "Er",
      69,
      "Tm",
      70,
      "Yb",
      71,
      "Lu",
      72,
      "Hf",
      73,
      "Ta",
      74,
      "W",
      75,
      "Re",
      76,
      "Os",
      77,
      "Ir",
      78,
      "Pt",
      79,
      "Au",
      80,
      "Hg",
      81,
      "Tl",
      82,
      "Pb",
      83,
      "Bi",
      84,
      "Po",
      85,
      "At",
      86,
      "Rn",
      87,
      "Fr",
      88,
      "Ra",
      89,
      "Ac",
      90,
      "Th",
      91,
      "Pa",
      92,
      "U",
      93,
      "Np",
      94,
      "Pu",
      95,
      "Am",
      96,
      "Cm",
      97,
      "Bk",
      98,
      "Cf",
      99,
      "Es",
      100,
      "Fm",
      101,
      "Md",
      102,
      "No",
      103,
      "Lr",
      104,
      "Rf",
      105,
      "Db",
      106,
      "Sg",
      107,
      "Bh",
      108,
      "Hs",
      109,
      "Mt",
      110,
      "Ds",
      111,
      "Rg",
      112,
      "Cn",
      113,
      "Uut",
      114,
      "Uuq",
      115,
      "Uup",
      116,
      "Uuh",
      117,
      "Uus",
      118,
      "Uuo"
    ],
    Name: "BlueObeliskElements"
  }
];

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js
var presetMap = Object.create(null);
vtkColorMaps.filter((p) => p.RGBPoints).filter((p) => p.ColorSpace !== "CIELAB").forEach((p) => {
  presetMap[p.Name] = p;
});
var rgbPresetNames = Object.keys(presetMap);
rgbPresetNames.sort();
function getPresetByName(name) {
  return presetMap[name];
}
function addPreset(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === "CIELAB") {
    return;
  }
  if (!presetMap[preset.Name]) {
    rgbPresetNames.push(preset.Name);
    rgbPresetNames.sort();
  }
  presetMap[preset.Name] = preset;
}
function removePresetByName(name) {
  const index2 = rgbPresetNames.indexOf(name);
  if (index2 > -1) {
    rgbPresetNames.splice(index2, 1);
  }
  delete presetMap[name];
}
var vtkColorMaps2 = {
  addPreset,
  removePresetByName,
  getPresetByName,
  rgbPresetNames
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js
var exports_colormap = {};
__export(exports_colormap, {
  registerColormap: () => registerColormap,
  getColormapNames: () => getColormapNames,
  getColormap: () => getColormap,
  findMatchingColormap: () => findMatchingColormap
});

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js
function areNumbersEqualWithTolerance(num1, num2, tolerance) {
  return Math.abs(num1 - num2) <= tolerance;
}
function areArraysEqual(arr1, arr2, tolerance = 0.00001) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0;i < arr1.length; i++) {
    if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {
      return false;
    }
  }
  return true;
}
function isNumberType(value) {
  return typeof value === "number";
}
function isNumberArrayLike(value) {
  return value && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length > 0 && typeof value[0] === "number";
}
function isEqual(v1, v2, tolerance = 0.00001) {
  if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {
    return false;
  }
  if (isNumberType(v1) && isNumberType(v2)) {
    return areNumbersEqualWithTolerance(v1, v2, tolerance);
  }
  if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {
    return areArraysEqual(v1, v2, tolerance);
  }
  return false;
}
var negative = (v) => typeof v === "number" ? -v : v?.map ? v.map(negative) : !v;
var abs = (v) => typeof v === "number" ? Math.abs(v) : v?.map ? v.map(abs) : v;
var isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);
var isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js
var _colormaps = new Map;
function registerColormap(colormap) {
  _colormaps.set(colormap.Name, colormap);
}
function getColormap(name) {
  return _colormaps.get(name);
}
function getColormapNames() {
  return Array.from(_colormaps.keys());
}
function findMatchingColormap(rgbPoints, actor) {
  const colormapsVTK = vtkColorMaps2.rgbPresetNames.map((presetName) => vtkColorMaps2.getPresetByName(presetName));
  const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));
  const colormaps = colormapsVTK.concat(colormapsCS3D);
  const matchedColormap = colormaps.find((colormap) => {
    const { RGBPoints: presetRGBPoints } = colormap;
    if (presetRGBPoints.length !== rgbPoints.length) {
      return false;
    }
    for (let i = 0;i < presetRGBPoints.length; i += 4) {
      if (!isEqual(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {
        return false;
      }
    }
    return true;
  });
  if (!matchedColormap) {
    return null;
  }
  const opacity = [];
  if (actorIsA(actor, "vtkVolume")) {
    const opacityPoints = actor.getProperty().getScalarOpacity(0).getDataPointer();
    if (!opacityPoints) {
      return {
        name: matchedColormap.Name
      };
    }
    for (let i = 0;i < opacityPoints.length; i += 2) {
      opacity.push({
        value: opacityPoints[i],
        opacity: opacityPoints[i + 1]
      });
    }
  }
  return {
    name: matchedColormap.Name,
    opacity
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js
function invertRgbTransferFunction(rgbTransferFunction) {
  if (!rgbTransferFunction) {
    return;
  }
  const size = rgbTransferFunction.getSize();
  for (let index2 = 0;index2 < size; index2++) {
    const nodeValue1 = [];
    rgbTransferFunction.getNodeValue(index2, nodeValue1);
    nodeValue1[1] = 1 - nodeValue1[1];
    nodeValue1[2] = 1 - nodeValue1[2];
    nodeValue1[3] = 1 - nodeValue1[3];
    rgbTransferFunction.setNodeValue(index2, nodeValue1);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js
var exports_windowLevel = {};
__export(exports_windowLevel, {
  toWindowLevel: () => toWindowLevel,
  toLowHighRange: () => toLowHighRange
});

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/logit.js
var logit = (y, wc, ww) => {
  return wc - ww / 4 * Math.log((1 - y) / y);
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js
function toWindowLevel(low, high) {
  const windowWidth = Math.abs(high - low) + 1;
  const windowCenter = (low + high + 1) / 2;
  return { windowWidth, windowCenter };
}
function toLowHighRange(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType_default.LINEAR) {
  if (voiLUTFunction === VOILUTFunctionType_default.LINEAR) {
    return {
      lower: windowCenter - 0.5 - (windowWidth - 1) / 2,
      upper: windowCenter - 0.5 + (windowWidth - 1) / 2
    };
  } else if (voiLUTFunction === VOILUTFunctionType_default.LINEAR_EXACT) {
    return {
      lower: windowCenter - windowWidth / 2,
      upper: windowCenter + windowWidth / 2
    };
  } else if (voiLUTFunction === VOILUTFunctionType_default.SAMPLED_SIGMOID) {
    const xLower = logit(0.01, windowCenter, windowWidth);
    const xUpper = logit(0.99, windowCenter, windowWidth);
    return {
      lower: xLower,
      upper: xUpper
    };
  } else {
    throw new Error("Invalid VOI LUT function");
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js
function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {
  const { windowWidth, windowCenter } = toWindowLevel(voiRange.lower, voiRange.upper);
  const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));
  const table = range.flatMap((y) => {
    const x = logit(y, windowCenter, windowWidth);
    return [x, y, y, y, 0.5, 0];
  });
  const cfun = vtkColorTransferFunction$1.newInstance();
  cfun.buildFunctionFromArray(vtkDataArray$1.newInstance({
    values: table,
    numberOfComponents: 6
  }));
  return cfun;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js
function transformWorldToIndex(imageData, worldPos) {
  const continuousIndex = imageData.worldToIndex(worldPos);
  const index2 = continuousIndex.map(Math.round);
  return index2;
}
function transformWorldToIndexContinuous(imageData, worldPos) {
  return imageData.worldToIndex(worldPos);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var exports_transferFunctionUtils = {};
__export(exports_transferFunctionUtils, {
  setTransferFunctionNodes: () => setTransferFunctionNodes,
  getTransferFunctionNodes: () => getTransferFunctionNodes
});
function getTransferFunctionNodes(transferFunction) {
  const size = transferFunction.getSize();
  const values = [];
  for (let index2 = 0;index2 < size; index2++) {
    const nodeValue1 = [];
    transferFunction.getNodeValue(index2, nodeValue1);
    values.push(nodeValue1);
  }
  return values;
}
function setTransferFunctionNodes(transferFunction, nodes) {
  if (!nodes?.length) {
    return;
  }
  transferFunction.removeAllPoints();
  nodes.forEach((node) => {
    transferFunction.addRGBPoint(...node);
  });
}

// ../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js
var {
  InterpolationType: InterpolationType4,
  OpacityMode: OpacityMode2
} = Constants14;
var {
  vtkErrorMacro: vtkErrorMacro31
} = macro;
var VTK_MAX_VRCOMP = 4;
function vtkVolumeProperty(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeProperty");
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index2 = 0;index2 < VTK_MAX_VRCOMP; index2++) {
      if (model.componentData[index2].colorChannels === 1) {
        if (model.componentData[index2].grayTransferFunction) {
          time = model.componentData[index2].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index2].colorChannels === 3) {
        if (model.componentData[index2].rGBTransferFunction) {
          time = model.componentData[index2].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
      if (model.componentData[index2].scalarOpacity) {
        time = model.componentData[index2].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index2].gradientOpacity) {
        if (!model.componentData[index2].disableGradientOpacity) {
          time = model.componentData[index2].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = (index2) => {
    if (index2 < 0 || index2 > 3) {
      vtkErrorMacro31("Bad index - must be between 0 and 3");
      return 0;
    }
    return model.componentData[index2].colorChannels;
  };
  publicAPI.setGrayTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index2].grayTransferFunction !== func) {
      model.componentData[index2].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index2].colorChannels !== 1) {
      model.componentData[index2].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getGrayTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index2].grayTransferFunction === null) {
      model.componentData[index2].grayTransferFunction = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index2].grayTransferFunction.addPoint(0, 0);
      model.componentData[index2].grayTransferFunction.addPoint(1024, 1);
      if (model.componentData[index2].colorChannels !== 1) {
        model.componentData[index2].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index2].grayTransferFunction;
  };
  publicAPI.setRGBTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index2].rGBTransferFunction !== func) {
      model.componentData[index2].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index2].colorChannels !== 3) {
      model.componentData[index2].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getRGBTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index2].rGBTransferFunction === null) {
      model.componentData[index2].rGBTransferFunction = vtkColorTransferFunction$1.newInstance();
      model.componentData[index2].rGBTransferFunction.addRGBPoint(0, 0, 0, 0);
      model.componentData[index2].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1);
      if (model.componentData[index2].colorChannels !== 3) {
        model.componentData[index2].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index2].rGBTransferFunction;
  };
  publicAPI.setScalarOpacity = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.componentData[index2].scalarOpacity !== func) {
      model.componentData[index2].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getScalarOpacity = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index2].scalarOpacity === null) {
      model.componentData[index2].scalarOpacity = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index2].scalarOpacity.addPoint(0, 1);
      model.componentData[index2].scalarOpacity.addPoint(1024, 1);
      publicAPI.modified();
    }
    return model.componentData[index2].scalarOpacity;
  };
  publicAPI.setComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro31("Invalid index");
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index2].componentWeight !== val) {
      model.componentData[index2].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP) {
      vtkErrorMacro31("Invalid index");
      return 0;
    }
    return model.componentData[index2].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType4.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType4.LINEAR);
  publicAPI.setInterpolationTypeToFastLinear = () => publicAPI.setInterpolationType(InterpolationType4.FAST_LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macro.enumToString(InterpolationType4, model.interpolationType);
  const sets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode", "forceNearestInterpolation"];
  sets.forEach((val) => {
    const cap = macro.capitalize(val);
    publicAPI[`set${cap}`] = (index2, value) => {
      if (model.componentData[index2][`${val}`] !== value) {
        model.componentData[index2][`${val}`] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  const gets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode", "forceNearestInterpolation"];
  gets.forEach((val) => {
    const cap = macro.capitalize(val);
    publicAPI[`get${cap}`] = (index2) => model.componentData[index2][`${val}`];
  });
}
var DEFAULT_VALUES75 = {
  colorMixPreset: null,
  independentComponents: true,
  interpolationType: InterpolationType4.FAST_LINEAR,
  shade: false,
  ambient: 0.1,
  diffuse: 0.7,
  specular: 0.2,
  specularPower: 10,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1
};
function extend78(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES75, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0;i < VTK_MAX_VRCOMP; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1,
        opacityMode: OpacityMode2.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0,
        gradientOpacityMaximumValue: 1,
        gradientOpacityMaximumOpacity: 1,
        useGradientOpacity: false,
        componentWeight: 1,
        forceNearestInterpolation: false
      });
    }
  }
  macro.setGet(publicAPI, model, ["colorMixPreset", "independentComponents", "interpolationType", "shade", "ambient", "diffuse", "specular", "specularPower", "useLabelOutline", "labelOutlineOpacity"]);
  macro.setGetArray(publicAPI, model, ["labelOutlineThickness"]);
  vtkVolumeProperty(publicAPI, model);
}
var newInstance78 = macro.newInstance(extend78, "vtkVolumeProperty");
var vtkVolumeProperty$1 = {
  newInstance: newInstance78,
  extend: extend78,
  ...Constants14
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js
var {
  vtkDebugMacro: vtkDebugMacro10
} = macro;
function vtkVolume2(publicAPI, model) {
  model.classHierarchy.push("vtkVolume");
  publicAPI.getVolumes = () => publicAPI;
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    const zip = (rows) => rows[0].map((_, c) => rows.map((row) => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro10("Recomputing bounds...");
      model.mapperBounds = bds.map((x) => x);
      const bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      exports_mat4.transpose(tmp4, model.matrix);
      bbox.forEach((pt) => exports_vec3.transformMat4(pt, pt, tmp4));
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}
var DEFAULT_VALUES76 = {
  mapper: null,
  property: null,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend79(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES76, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkVolume2(publicAPI, model);
}
var newInstance79 = macro.newInstance(extend79, "vtkVolume");
var vtkVolume$1 = {
  newInstance: newInstance79,
  extend: extend79
};

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js
var exports_volumeLoader = {};
__export(exports_volumeLoader, {
  registerVolumeLoader: () => registerVolumeLoader,
  registerUnknownVolumeLoader: () => registerUnknownVolumeLoader,
  loadVolume: () => loadVolume,
  getVolumeLoaderSchemes: () => getVolumeLoaderSchemes,
  getUnknownVolumeLoaderSchema: () => getUnknownVolumeLoaderSchema,
  createLocalVolume: () => createLocalVolume,
  createLocalLabelmapVolume: () => createLocalLabelmapVolume,
  createAndCacheVolumeFromImagesSync: () => createAndCacheVolumeFromImagesSync,
  createAndCacheVolumeFromImages: () => createAndCacheVolumeFromImages,
  createAndCacheVolume: () => createAndCacheVolume,
  createAndCacheDerivedVolume: () => createAndCacheDerivedVolume,
  createAndCacheDerivedLabelmapVolume: () => createAndCacheDerivedLabelmapVolume
});

// ../../node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js
var {
  vtkErrorMacro: vtkErrorMacro32
} = macro;

class SegmentAgregator {
  constructor() {
    this.segmentMapping = {};
    this.segments = [null];
    this.faces = [];
  }
  addSegment(segment) {
    const first = segment[0];
    const last = segment[segment.length - 1];
    if (first === last || segment.length < 2) {
      return;
    }
    const mappingFirst = this.segmentMapping[first];
    const mappingLast = this.segmentMapping[last];
    if (mappingFirst !== undefined && mappingLast !== undefined) {
      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {
        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;
        const seg = this.segments[idx];
        if (mappingFirst > 0) {
          for (let i = 1;i < segment.length - 1; i++) {
            seg.push(segment[i]);
          }
        } else {
          for (let i = 1;i < segment.length - 1; i++) {
            seg.unshift(segment[segment.length - 1 - i]);
          }
        }
        this.faces.push(seg);
        this.segments[idx] = null;
        this.segmentMapping[first] = undefined;
        this.segmentMapping[last] = undefined;
      } else {
        const idxHead = Math.abs(mappingFirst);
        const idxTail = Math.abs(mappingLast);
        const segHead = this.segments[idxHead];
        const segTail = this.segments[idxTail];
        this.segments[idxHead] = null;
        this.segments[idxTail] = null;
        this.segmentMapping[segHead[0]] = undefined;
        this.segmentMapping[segTail[0]] = undefined;
        this.segmentMapping[segHead[segHead.length - 1]] = undefined;
        this.segmentMapping[segTail[segTail.length - 1]] = undefined;
        this.addSegment(segment);
        this.addSegment(segHead);
        this.addSegment(segTail);
      }
    } else if (mappingFirst !== undefined) {
      if (mappingFirst > 0) {
        const seg = this.segments[mappingFirst];
        for (let i = 1;i < segment.length; i++) {
          seg.push(segment[i]);
        }
        this.segmentMapping[last] = mappingFirst;
      } else {
        const seg = this.segments[-mappingFirst];
        this.segmentMapping[last] = mappingFirst;
        for (let i = 1;i < segment.length; i++) {
          seg.unshift(segment[i]);
        }
      }
      this.segmentMapping[first] = undefined;
    } else if (mappingLast !== undefined) {
      if (mappingLast > 0) {
        const seg = this.segments[mappingLast];
        for (let i = 1;i < segment.length; i++) {
          seg.push(segment[segment.length - 1 - i]);
        }
        this.segmentMapping[first] = mappingLast;
      } else {
        const seg = this.segments[-mappingLast];
        this.segmentMapping[first] = mappingLast;
        for (let i = 1;i < segment.length; i++) {
          seg.unshift(segment[segment.length - i - 1]);
        }
      }
      this.segmentMapping[last] = undefined;
    } else {
      const id = this.segments.length;
      this.segments.push(segment);
      this.segmentMapping[first] = -id;
      this.segmentMapping[last] = id;
    }
  }
}
function vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {
  model.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter");
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro32("Invalid or missing input");
      return;
    }
    const output = vtkPolyData$1.newInstance();
    output.shallowCopy(input);
    const agregator = new SegmentAgregator;
    const lines = input.getLines().getData();
    let offset = 0;
    while (offset < lines.length) {
      const lineSize = lines[offset++];
      const lineSegment = [];
      for (let i = 0;i < lineSize; i++) {
        lineSegment.push(lines[offset + i]);
      }
      agregator.addSegment(lineSegment);
      offset += lineSize;
    }
    const {
      faces
    } = agregator;
    let cellArraySize = faces.length;
    for (let i = 0;i < faces.length; i++) {
      cellArraySize += faces[i].length;
    }
    const cellArray = new Uint16Array(cellArraySize);
    offset = 0;
    for (let i = 0;i < faces.length; i++) {
      const face = faces[i];
      cellArray[offset++] = face.length;
      for (let j = 0;j < face.length; j++) {
        cellArray[offset++] = face[j];
      }
    }
    output.setPolys(vtkCellArray$1.newInstance({
      values: cellArray,
      name: "faces"
    }));
    outData[0] = output;
  };
}
var DEFAULT_VALUES77 = {};
function extend80(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES77, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);
}
var newInstance80 = macro.newInstance(extend80, "vtkClosedPolyLineToSurfaceFilter");
var vtkClosedPolyLineToSurfaceFilter$1 = {
  newInstance: newInstance80,
  extend: extend80
};

// ../../node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var {
  vtkErrorMacro: vtkErrorMacro33
} = macro$1;
function initPolyIterator(pd) {
  const polys = pd.getPolys().getData();
  const strips = pd.getStrips().getData();
  const it = {
    cellSize: 0,
    cell: [],
    done: false,
    polyIdx: 0,
    stripIdx: 0,
    remainingStripLength: 0,
    next() {
      if (it.polyIdx < polys.length) {
        it.cellSize = polys[it.polyIdx];
        const start = it.polyIdx + 1;
        const end = start + it.cellSize;
        it.polyIdx = end;
        let p = 0;
        for (let i = start;i < end; ++i) {
          it.cell[p++] = polys[i];
        }
      } else if (it.stripIdx < strips.length) {
        it.cellSize = 3;
        if (it.remainingStripLength === 0) {
          it.remainingStripLength = strips[it.stripIdx] - 2;
          it.stripIdx += 3;
        }
        const start = it.stripIdx - 2;
        const end = it.stripIdx + 1;
        it.stripIdx++;
        it.remainingStripLength--;
        let p = 0;
        for (let i = start;i < end; ++i) {
          it.cell[p++] = strips[i];
        }
      } else if (!it.done) {
        it.done = true;
      } else {
        throw new Error("Iterator is done");
      }
    }
  };
  it.next();
  return it;
}
function vtkCutter(publicAPI, model) {
  model.classHierarchy.push("vtkCutter");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.cutFunction) {
      return mTime;
    }
    mTime = Math.max(mTime, model.cutFunction.getMTime());
    return mTime;
  };
  function dataSetCutter(input, output) {
    const points = input.getPoints();
    const pointsData = points.getData();
    const numPts = points.getNumberOfPoints();
    const newPointsData = [];
    const newLinesData = [];
    const newPolysData = [];
    if (!model.cutScalars || model.cutScalars.length < numPts) {
      model.cutScalars = new Float32Array(numPts);
    }
    let inOffset = 0;
    let outOffset = 0;
    while (inOffset < pointsData.length) {
      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);
    }
    const crossedEdges = [];
    const x1 = new Array(3);
    const x2 = new Array(3);
    const cellPointsScalars = [];
    for (const it = initPolyIterator(input);!it.done; it.next()) {
      if (it.cellSize <= 2) {
        continue;
      }
      for (let i = 0;i < it.cellSize; ) {
        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];
      }
      const sideFirstPoint = cellPointsScalars[0] > 0;
      let allPointsSameSide = true;
      for (let i = 1;i < it.cell.length; i++) {
        const sideCurrentPoint = cellPointsScalars[i] > 0;
        if (sideCurrentPoint !== sideFirstPoint) {
          allPointsSameSide = false;
          break;
        }
      }
      if (allPointsSameSide) {
        continue;
      }
      const intersectedEdgesList = [];
      for (let i = 0;i < it.cellSize; i++) {
        const idNext = i + 1 === it.cellSize ? 0 : i + 1;
        const signPoint0 = cellPointsScalars[i] > 0;
        const signPoint1 = cellPointsScalars[idNext] > 0;
        if (signPoint1 === signPoint0) {
          continue;
        }
        let e1 = i;
        let e2 = idNext;
        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];
        if (deltaScalar <= 0) {
          e1 = idNext;
          e2 = i;
          deltaScalar *= -1;
        }
        let t = 0;
        if (deltaScalar !== 0) {
          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;
        }
        const pointID1 = it.cell[e1];
        const pointID2 = it.cell[e2];
        x1[0] = pointsData[pointID1 * 3];
        x1[1] = pointsData[pointID1 * 3 + 1];
        x1[2] = pointsData[pointID1 * 3 + 2];
        x2[0] = pointsData[pointID2 * 3];
        x2[1] = pointsData[pointID2 * 3 + 1];
        x2[2] = pointsData[pointID2 * 3 + 2];
        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];
        intersectedEdgesList.push({
          pointEdge1: pointID1,
          pointEdge2: pointID2,
          intersectedPoint: computedIntersectedPoint,
          newPointID: -1
        });
      }
      for (let i = 0;i < intersectedEdgesList.length; i++) {
        const intersectedEdge = intersectedEdgesList[i];
        let alreadyAdded = false;
        for (let j = 0;j < crossedEdges.length; j++) {
          const crossedEdge = crossedEdges[j];
          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;
          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];
          if (sameEdge || samePoint) {
            alreadyAdded = true;
            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;
            break;
          }
        }
        if (!alreadyAdded) {
          newPointsData.push(intersectedEdge.intersectedPoint[0]);
          newPointsData.push(intersectedEdge.intersectedPoint[1]);
          newPointsData.push(intersectedEdge.intersectedPoint[2]);
          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;
          crossedEdges.push(intersectedEdgesList[i]);
        }
      }
      const cellSize = intersectedEdgesList.length;
      if (cellSize === 2) {
        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);
      } else if (cellSize > 2) {
        newPolysData.push(cellSize);
        intersectedEdgesList.forEach((edge) => {
          newPolysData.push(edge.newPointID);
        });
      }
    }
    const outputPoints = output.getPoints();
    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3);
    if (newLinesData.length !== 0) {
      output.getLines().setData(Uint16Array.from(newLinesData));
    }
    if (newPolysData.length !== 0) {
      output.getPolys().setData(Uint16Array.from(newPolysData));
    }
  }
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input) {
      vtkErrorMacro33("Invalid or missing input");
      return;
    }
    if (!model.cutFunction) {
      vtkErrorMacro33("Missing cut function");
      return;
    }
    const output = vtkPolyData$1.newInstance();
    dataSetCutter(input, output);
    outData[0] = output;
  };
}
var DEFAULT_VALUES78 = {
  cutFunction: null,
  cutScalars: null,
  cutValue: 0
};
function extend81(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES78, initialValues);
  obj(publicAPI, model);
  algo(publicAPI, model, 1, 1);
  setGet(publicAPI, model, ["cutFunction", "cutValue"]);
  vtkCutter(publicAPI, model);
}
var newInstance81 = newInstance(extend81, "vtkCutter");
var vtkCutter$1 = {
  newInstance: newInstance81,
  extend: extend81
};

// ../../node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js
var LINE_ARRAY = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];
var POLY_ARRAY = [4, 0, 1, 3, 2, 4, 4, 6, 7, 5, 4, 8, 10, 11, 9, 4, 12, 13, 15, 14, 4, 16, 18, 19, 17, 4, 20, 21, 23, 22];
function vtkCubeSource(publicAPI, model) {
  model.classHierarchy.push("vtkCubeSource");
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const polyData = vtkPolyData$1.newInstance();
    outData[0] = polyData;
    const numberOfPoints = 24;
    const points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    polyData.getPoints().setData(points, 3);
    const normals = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    const normalArray = vtkDataArray$1.newInstance({
      name: "Normals",
      values: normals,
      numberOfComponents: 3
    });
    polyData.getPointData().setNormals(normalArray);
    let tcdim = 2;
    if (model.generate3DTextureCoordinates === true) {
      tcdim = 3;
    }
    const textureCoords = macro.newTypedArray(model.pointType, numberOfPoints * tcdim);
    const tcoords = vtkDataArray$1.newInstance({
      name: "TextureCoordinates",
      values: textureCoords,
      numberOfComponents: tcdim
    });
    polyData.getPointData().setTCoords(tcoords);
    const x = [0, 0, 0];
    const n = [0, 0, 0];
    const tc = [0, 0];
    let pointIndex = 0;
    x[0] = -model.xLength / 2;
    n[0] = -1;
    n[1] = 0;
    n[2] = 0;
    for (let i = 0;i < 2; i++) {
      x[1] = -model.yLength / 2;
      for (let j = 0;j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[2] = -model.zLength / 2;
        for (let k = 0;k < 2; k++) {
          tc[0] = (x[2] + 0.5) * (1 - 2 * i);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[1] += model.yLength;
      }
      x[0] += model.xLength;
      n[0] += 2;
    }
    x[1] = -model.yLength / 2;
    n[1] = -1;
    n[0] = 0;
    n[2] = 0;
    for (let i = 0;i < 2; i++) {
      x[0] = -model.xLength / 2;
      for (let j = 0;j < 2; j++) {
        tc[0] = (x[0] + 0.5) * (2 * i - 1);
        x[2] = -model.zLength / 2;
        for (let k = 0;k < 2; k++) {
          tc[1] = (x[2] + 0.5) * -1;
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[0] += model.xLength;
      }
      x[1] += model.yLength;
      n[1] += 2;
    }
    x[2] = -model.zLength / 2;
    n[2] = -1;
    n[0] = 0;
    n[1] = 0;
    for (let i = 0;i < 2; i++) {
      x[1] = -model.yLength / 2;
      for (let j = 0;j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[0] = -model.xLength / 2;
        for (let k = 0;k < 2; k++) {
          tc[0] = (x[0] + 0.5) * (2 * i - 1);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * k - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * i - 1;
          }
          pointIndex++;
          x[0] += model.xLength;
        }
        x[1] += model.yLength;
      }
      x[2] += model.zLength;
      n[2] += 2;
    }
    if (model.rotations) {
      vtkMatrixBuilder.buildFromDegree().rotateX(model.rotations[0]).rotateY(model.rotations[1]).rotateZ(model.rotations[2]).apply(points).apply(normals);
    }
    if (model.center) {
      vtkMatrixBuilder.buildFromRadian().translate(...model.center).apply(points);
    }
    if (model.matrix) {
      vtkMatrixBuilder.buildFromRadian().setMatrix(model.matrix).apply(points);
      const rotMatrix = [model.matrix[0], model.matrix[1], model.matrix[2], 0, model.matrix[4], model.matrix[5], model.matrix[6], 0, model.matrix[8], model.matrix[9], model.matrix[10], 0, 0, 0, 0, 1];
      vtkMatrixBuilder.buildFromRadian().setMatrix(rotMatrix).apply(normals);
    }
    if (model.generateFaces) {
      polyData.getPolys().deepCopy(model._polys);
    } else {
      polyData.getPolys().initialize();
    }
    if (model.generateLines) {
      polyData.getLines().deepCopy(model._lineCells);
      polyData.getPointData().setNormals(null);
    } else {
      polyData.getLines().initialize();
    }
    polyData.modified();
  }
  publicAPI.setBounds = function() {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
      boundsArray = arguments.length <= 0 ? undefined : arguments[0];
    } else {
      for (let i = 0;i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    publicAPI.setXLength(boundsArray[1] - boundsArray[0]);
    publicAPI.setYLength(boundsArray[3] - boundsArray[2]);
    publicAPI.setZLength(boundsArray[5] - boundsArray[4]);
    publicAPI.setCenter([(boundsArray[0] + boundsArray[1]) / 2, (boundsArray[2] + boundsArray[3]) / 2, (boundsArray[4] + boundsArray[5]) / 2]);
  };
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES79 = {
  xLength: 1,
  yLength: 1,
  zLength: 1,
  pointType: "Float64Array",
  generate3DTextureCoordinates: false,
  generateFaces: true,
  generateLines: false
};
function extend82(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES79, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["xLength", "yLength", "zLength", "generate3DTextureCoordinates", "generateFaces", "generateLines"]);
  macro.setGetArray(publicAPI, model, ["center", "rotations"], 3);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  model._polys = vtkCellArray$1.newInstance({
    values: Uint16Array.from(POLY_ARRAY)
  });
  model._lineCells = vtkCellArray$1.newInstance({
    values: Uint16Array.from(LINE_ARRAY)
  });
  macro.moveToProtected(publicAPI, model, ["polys", "lineCells"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkCubeSource(publicAPI, model);
}
var newInstance82 = macro.newInstance(extend82, "vtkCubeSource");
var vtkCubeSource$1 = {
  newInstance: newInstance82,
  extend: extend82
};

// ../../node_modules/@kitware/vtk.js/Filters/General/ImageDataOutlineFilter.js
var {
  vtkErrorMacro: vtkErrorMacro34
} = macro;
function vtkImageDataOutlineFilter(publicAPI, model) {
  model.classHierarchy.push("vtkImageDataOutlineFilter");
  const superClass = {
    ...publicAPI
  };
  publicAPI.requestData = (inData, outData) => {
    const input = inData[0];
    if (!input || !input.isA("vtkImageData")) {
      vtkErrorMacro34("Invalid or missing input");
      return;
    }
    const spatialExt = input.getSpatialExtent();
    if (!spatialExt) {
      vtkErrorMacro34("Unable to fetch spatial extents of input image.");
      return;
    }
    model._cubeSource.setBounds(spatialExt);
    model._cubeSource.setMatrix(input.getIndexToWorld());
    outData[0] = model._cubeSource.getOutputData();
  };
  publicAPI.getMTime = () => Math.max(superClass.getMTime(), model._cubeSource.getMTime());
  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
}
var DEFAULT_VALUES80 = {};
function extend83(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES80, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 1);
  model._cubeSource = vtkCubeSource$1.newInstance();
  macro.moveToProtected(publicAPI, model, ["cubeSource", "tmpOut"]);
  vtkImageDataOutlineFilter(publicAPI, model);
}
var newInstance83 = macro.newInstance(extend83, "vtkImageDataOutlineFilter");
var vtkImageDataOutlineFilter$1 = {
  newInstance: newInstance83,
  extend: extend83
};

// ../../node_modules/@kitware/vtk.js/Common/Transform/Transform.js
var newInstance84;
function vtkTransform(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractTransform", "vtkHomogeneousTransform", "vtkTransform");
  publicAPI.transformPoint = (point, out) => {
    exports_vec3.transformMat4(out, point, model.matrix);
    return out;
  };
  publicAPI.transformPoints = (points, out) => {
    const inPoint = new Float64Array(3);
    const outPoint = new Float64Array(3);
    for (let i = 0;i < points.length; i += 3) {
      inPoint[0] = points[i];
      inPoint[1] = points[i + 1];
      inPoint[2] = points[i + 2];
      exports_vec3.transformMat4(outPoint, inPoint, model.matrix);
      out[i] = outPoint[0];
      out[i + 1] = outPoint[1];
      out[i + 2] = outPoint[2];
    }
    return out;
  };
  publicAPI.preMultiply = () => {
    publicAPI.setPreMultiplyFlag(true);
  };
  publicAPI.postMultiply = () => {
    publicAPI.setPreMultiplyFlag(false);
  };
  publicAPI.transformMatrix = (matrix, out) => {
    if (model.preMultiplyFlag) {
      exports_mat4.multiply(out, model.matrix, matrix);
    } else {
      exports_mat4.multiply(out, matrix, model.matrix);
    }
    return out;
  };
  publicAPI.transformMatrices = (matrices, out) => {
    const inMat = new Float64Array(16);
    const outMat = new Float64Array(16);
    const transform = model.preMultiplyFlag ? () => exports_mat4.multiply(outMat, model.matrix, inMat) : () => exports_mat4.multiply(outMat, inMat, model.matrix);
    for (let i = 0;i < matrices.length; i += 16) {
      for (let j = 0;j < 16; ++j) {
        inMat[j] = matrices[i + j];
      }
      transform();
      for (let j = 0;j < 16; ++j) {
        out[i + j] = outMat[j];
      }
    }
    return out;
  };
  publicAPI.getInverse = () => newInstance84({
    matrix: vtkMath.invertMatrix(Array.from(model.matrix), [], 4),
    preMultiplyFlag: model.preMultiplyFlag
  });
}
var DEFAULT_VALUES81 = {
  preMultiplyFlag: false,
  matrix: [...IDENTITY]
};
function extend84(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES81, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["preMultiplyFlag"]);
  macro.setGetArray(publicAPI, model, ["matrix"], 16);
  vtkTransform(publicAPI, model);
}
newInstance84 = macro.newInstance(extend84, "vtkTransform");
var vtkTransform$1 = {
  newInstance: newInstance84,
  extend: extend84
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperVS.glsl.js
var vtkImageResliceMapperVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model coordinates
// WC - World coordinates
// VC - View coordinates
// DC - Display coordinates
// TC - Texture coordinates

// frag position in VC
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// camera and actor matrix values
//VTK::Camera::Dec

void main()
{
  //VTK::PositionVC::Impl

  //VTK::TCoord::Impl

  //VTK::Picking::Impl
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperFS.glsl.js
var vtkImageResliceMapperFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the gpu image mapper fragment shader

// VC position of this fragment
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

// the output of this shader
//VTK::Output::Dec

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  //VTK::TCoord::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js
var {
  vtkErrorMacro: vtkErrorMacro35
} = macro$1;
function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
  matrixType.identity(tmpMat);
  return matrixArray.reduce((res, matrix, index2) => {
    if (index2 === 0) {
      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
    }
    return matrix ? matrixType.multiply(res, res, matrix) : res;
  }, tmpMat);
}
function vtkOpenGLImageResliceMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageResliceMapper");
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach((coreObject) => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model._openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      const ren = model._openGLRenderer.getRenderable();
      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const actor = model._openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    if (!model.currentInput) {
      vtkErrorMacro35("No input!");
      return;
    }
    publicAPI.updateResliceGeometry();
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType2.NEAREST) {
      model.openGLTexture.setMinificationFilter(Filter.NEAREST);
      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.openGLTexture.setMinificationFilter(Filter.LINEAR);
      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const numComp = scalars.getNumberOfComponents();
    let toString = getImageDataHash(image, scalars);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    if (reBuildTex) {
      model.openGLTexture = vtkOpenGLTexture$1.newInstance();
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const dims = image.getDimensions();
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension("EXT_texture_norm16"));
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, toString);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.openGLTexture = tex.oglObject;
    }
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    toString = getTransferFunctionHash(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = vtkOpenGLTexture$1.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0;c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (let i = 0;i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0;i < cWidth * 3; ++i) {
          cTable[i] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    const pwFunc = ppty.getPiecewiseFunction();
    toString = getTransferFunctionHash(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== toString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = vtkOpenGLTexture$1.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0;c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            if (iComps) {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0;i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, toString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;
    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: model.resliceGeom.getPoints().getData()
      });
      points.setName("points");
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: model.resliceGeom.getPolys().getData()
      });
      const options = {
        points,
        cellOffset: 0
      };
      if (model.renderable.getSlabThickness() > 0) {
        const n = model.resliceGeom.getPointData().getNormals();
        if (!n) {
          vtkErrorMacro35("Slab mode requested without normals");
        } else {
          options.normals = n;
        }
      }
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, options);
    }
    model.VBOBuildString = vboString;
    model.VBOBuildTime.modified();
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isUniformUsed("texture1")) {
        program.setUniformi("texture1", model.openGLTexture.getTextureUnit());
      }
      if (program.isAttributeUsed("vertexWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro35("Error setting vertexWC in shader VAO.");
        }
      }
      if (program.isAttributeUsed("normalWC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "normalWC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro35("Error setting normalWC in shader VAO.");
        }
      }
      if (program.isUniformUsed("slabThickness")) {
        program.setUniformf("slabThickness", model.renderable.getSlabThickness());
      }
      if (program.isUniformUsed("spacing")) {
        program.setUniform3fv("spacing", model.currentInput.getSpacing());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabType")) {
        program.setUniformi("slabType", model.renderable.getSlabType());
      }
      if (program.isUniformUsed("slabTrapezoid")) {
        program.setUniformi("slabTrapezoid", model.renderable.getSlabTrapezoidIntegration());
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      if (program.isUniformUsed("WCTCMatrix")) {
        const image = model.currentInput;
        const dim = image.getDimensions();
        exports_mat4.copy(model.tmpMat4, image.getIndexToWorld());
        exports_mat4.translate(model.tmpMat4, model.tmpMat4, [-0.5, -0.5, -0.5]);
        exports_mat4.scale(model.tmpMat4, model.tmpMat4, dim);
        exports_mat4.invert(model.tmpMat4, model.tmpMat4);
        if (inverseShiftScaleMatrix) {
          exports_mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        }
        program.setUniformMatrix("WCTCMatrix", model.tmpMat4);
      }
      if (program.isUniformUsed("vboScaling")) {
        program.setUniform3fv("vboScaling", cellBO.getCABO().getCoordScale() ?? [1, 1, 1]);
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const keyMats = model._openGLCamera.getKeyMatrices(ren);
    const actMats = model._openGLImageSlice.getKeyMatrices();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const program = cellBO.getProgram();
    if (program.isUniformUsed("MCPCMatrix")) {
      exports_mat4.identity(model.tmpMat4);
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], exports_mat4, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      exports_mat4.identity(model.tmpMat4);
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], exports_mat4, model.tmpMat4));
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
    const numComp = model.openGLTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0;i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }
    const volInfo = model.openGLTexture.getVolumeInfo();
    for (let i = 0;i < numComp; i++) {
      let cw2 = ppty.getColorWindow();
      let cl2 = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw2 = cRange[1] - cRange[0];
        cl2 = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale8 = volInfo.scale[i] / cw2;
      const shift = (volInfo.offset[i] - cl2) / cw2 + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale8);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi("colorTexture1", texColorUnit);
    for (let i = 0;i < numComp; i++) {
      let pwfScale = 1;
      let pwfShift = 0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length5 = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length5;
        pwfShift = (volInfo.offset[i] - mid) / length5 + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi("pwfTexture1", texOpacityUnit);
    program.setUniform4fv("backgroundColor", model.renderable.getBackgroundColor());
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const slabTh = model.renderable.getSlabThickness();
    const slabType = model.renderable.getSlabType();
    const slabTrap = model.renderable.getSlabTrapezoidIntegration();
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      model.lastSlabThickness = slabTh;
      model.lastSlabType = slabType;
      model.lastSlabTrapezoidIntegration = slabTrap;
      return true;
    }
    return false;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkImageResliceMapperVS;
    shaders.Fragment = vtkImageResliceMapperFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const tcoordVSDec = ["uniform mat4 WCTCMatrix;", "out vec3 fragTexCoord;"];
    const slabThickness = model.renderable.getSlabThickness();
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", tcoordVSDec).result;
    const tcoordVSImpl = ["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"];
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", tcoordVSImpl).result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
      "in vec3 fragTexCoord;",
      "uniform highp sampler3D texture1;",
      "uniform mat4 WCTCMatrix;",
      "uniform float cshift0;",
      "uniform float cscale0;",
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;",
      "uniform vec4 backgroundColor;"
    ];
    if (iComps) {
      for (let comp = 1;comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro35("Unsupported number of independent coordinates.");
      }
    }
    if (slabThickness > 0) {
      tcoordFSDec = tcoordFSDec.concat(["uniform vec3 spacing;", "uniform float slabThickness;", "uniform int slabType;", "uniform int slabTrapezoid;", "uniform vec3 vboScaling;"]);
      tcoordFSDec = tcoordFSDec.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)", "{", "  vec4 retVal = vec4(1.0);", "  if (slabType == 0) // min", "  {", "    retVal = min(currVal, valToComp);", "  }", "  else if (slabType == 1) // max", "  {", "    retVal = max(currVal, valToComp);", "  }", "  else if (slabType == 3) // sum", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  else // mean", "  {", "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ", "  }", "  return retVal;", "}"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordFSDec).result;
    let tcoordFSImpl = ["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}", "vec4 tvalue = texture(texture1, fragTexCoord);"];
    if (slabThickness > 0) {
      tcoordFSImpl = tcoordFSImpl.concat(["// Get the first and last samples", "int numSlices = 1;", "float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;", "vec3 normalxspacing = scaling * normalWCVSOutput;", "float distTraveled = length(normalxspacing);", "int trapezoid = 0;", "while (distTraveled < slabThickness * 0.5)", "{", "  distTraveled += length(normalxspacing);", "  float fnumSlices = float(numSlices);", "  if (distTraveled > slabThickness * 0.5)", "  {", "    // Before stepping outside the slab, sample at the boundaries", "    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;", "    trapezoid = slabTrapezoid;", "  }", "  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = texture(texture1, fragTCoordNeg);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;", "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))", "  {", "    vec4 newVal = texture(texture1, fragTCoordPos);", "    tvalue = compositeValue(tvalue, newVal, trapezoid);", "    numSlices += 1;", "  }", "}", "// Finally, if slab type is *mean*, divide the sum by the numSlices", "if (slabType == 2)", "{", "  tvalue = tvalue / float(numSlices);", "}"]);
    }
    if (iComps) {
      const rgba = ["r", "g", "b", "a"];
      for (let comp = 0;comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro35("Unsupported number of independent coordinates.");
      }
    } else {
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(["// Dependent components", "float intensity = tvalue.r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(["float intensity = tvalue.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(["vec4 tcolor = cscale0*tvalue + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]);
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordFSImpl).result;
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    shaders.Geometry = GSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const slabThickness = model.renderable.getSlabThickness();
    let posVCVSDec = ["attribute vec4 vertexWC;"];
    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);
    if (slabThickness > 0) {
      posVCVSDec = posVCVSDec.concat(["attribute vec3 normalWC;", "varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", posVCVSDec).result;
    let posVCVSImpl = ["gl_Position = MCPCMatrix * vertexWC;"];
    if (slabThickness > 0) {
      posVCVSImpl = posVCVSImpl.concat(["normalWCVSOutput = normalWC;", "vertexWCVSOutput = vertexWC;"]);
    }
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", posVCVSImpl).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
    let posVCFSDec = [];
    if (slabThickness > 0) {
      posVCFSDec = posVCFSDec.concat(["varying vec3 normalWCVSOutput;", "varying vec4 vertexWCVSOutput;"]);
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", posVCFSDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  function isVectorAxisAligned(n) {
    vtkMath.normalize(n);
    const tmpN = [0, 0, 0];
    for (let i = 0;i < 3; ++i) {
      exports_vec3.zero(tmpN);
      tmpN[i] = 1;
      const dotP = vtkMath.dot(n, tmpN);
      if (dotP < -0.999999 || dotP > 0.999999) {
        return [true, i];
      }
    }
    return [false, 2];
  }
  publicAPI.updateResliceGeometry = () => {
    let resGeomString = "";
    const image = model.currentInput;
    const imageBounds = image?.getBounds();
    let orthoSlicing = true;
    let orthoAxis = 2;
    const slicePD = model.renderable.getSlicePolyData();
    const slicePlane = model.renderable.getSlicePlane();
    if (slicePD) {
      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);
    } else if (slicePlane) {
      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);
      const w2io = exports_mat3.create();
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
        exports_mat3.set(w2io, ...image.getDirection());
        exports_mat3.invert(w2io, w2io);
      }
      const imageLocalNormal = [...slicePlane.getNormal()];
      exports_vec3.transformMat3(imageLocalNormal, imageLocalNormal, w2io);
      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);
    } else {
      const plane = vtkPlane$1.newInstance();
      plane.setNormal(0, 0, 1);
      let bds = [0, 1, 0, 1, 0, 1];
      if (image) {
        bds = imageBounds;
      }
      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));
      model.renderable.setSlicePlane(plane);
      resGeomString = resGeomString.concat(`Plane${slicePlane?.getMTime()}`);
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
      }
    }
    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {
      if (slicePD) {
        if (!model.resliceGeom) {
          model.resliceGeom = vtkPolyData$1.newInstance();
        }
        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);
        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);
        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());
      } else if (slicePlane) {
        if (!orthoSlicing) {
          model.outlineFilter.setInputData(image);
          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());
          model.cutter.setCutFunction(slicePlane);
          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());
          model.lineToSurfaceFilter.update();
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          const planePD = model.lineToSurfaceFilter.getOutputData();
          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);
          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);
          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());
          const n = slicePlane.getNormal();
          const npts = model.resliceGeom.getNumberOfPoints();
          vtkMath.normalize(n);
          const normalsData = new Float32Array(npts * 3);
          for (let i = 0;i < npts; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        } else {
          const ptsArray = new Float32Array(12);
          const indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);
          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();
          const ext = image.getSpatialExtent();
          let ptIdx = 0;
          for (let i = 0;i < 2; ++i) {
            for (let j = 0;j < 2; ++j) {
              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];
              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];
              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];
              ptIdx += 3;
            }
          }
          model.transform.setMatrix(image.getIndexToWorld());
          model.transform.transformPoints(ptsArray, ptsArray);
          const cellArray = new Uint16Array(8);
          cellArray[0] = 3;
          cellArray[1] = 0;
          cellArray[2] = 1;
          cellArray[3] = 3;
          cellArray[4] = 3;
          cellArray[5] = 0;
          cellArray[6] = 3;
          cellArray[7] = 2;
          const n = slicePlane.getNormal();
          vtkMath.normalize(n);
          const normalsData = new Float32Array(12);
          for (let i = 0;i < 4; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          if (!model.resliceGeom) {
            model.resliceGeom = vtkPolyData$1.newInstance();
          }
          model.resliceGeom.getPoints().setData(ptsArray, 3);
          model.resliceGeom.getPolys().setData(cellArray, 1);
          const normals = vtkDataArray$1.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: "Normals"
          });
          model.resliceGeom.getPointData().setNormals(normals);
        }
      } else {
        vtkErrorMacro35("Something went wrong.", "A default slice plane should have been created in the beginning of", "updateResliceGeometry.");
      }
      model.resliceGeomUpdateString = resGeomString;
      model.resliceGeom?.modified();
    }
  };
  publicAPI.setOpenGLTexture = (oglTex) => {
    if (oglTex) {
      model.openGLTexture = oglTex;
      model._externalOpenGLTexture = true;
    }
  };
  publicAPI.delete = chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}
var DEFAULT_VALUES82 = {
  VBOBuildTime: {},
  VBOBuildString: null,
  haveSeenDepthRequest: false,
  lastHaveSeenDepthRequest: false,
  lastIndependentComponents: false,
  lastTextureComponents: 0,
  lastSlabThickness: 0,
  lastSlabTrapezoidIntegration: 0,
  lastSlabType: -1,
  openGLTexture: null,
  colorTextureString: null,
  pwfTextureString: null,
  resliceGeom: null,
  resliceGeomUpdateString: null,
  tris: null,
  colorTexture: null,
  pwfTexture: null,
  _externalOpenGLTexture: false
};
function extend85(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES82, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.openGLTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  model.tmpMat4 = exports_mat4.identity(new Float64Array(16));
  model.outlineFilter = vtkImageDataOutlineFilter$1.newInstance();
  model.outlineFilter.setGenerateFaces(true);
  model.outlineFilter.setGenerateLines(false);
  model.cubePolyData = vtkPolyData$1.newInstance();
  model.cutter = vtkCutter$1.newInstance();
  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter$1.newInstance();
  model.transform = vtkTransform$1.newInstance();
  get(publicAPI, model, ["openGLTexture"]);
  vtkOpenGLImageResliceMapper(publicAPI, model);
}
var newInstance85 = newInstance(extend85, "vtkOpenGLImageResliceMapper");
registerOverride("vtkImageResliceMapper", newInstance85);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var CLASS_MAPPING3 = Object.create(null);
function registerOverride3(className, fn) {
  CLASS_MAPPING3[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
var DEFAULT_VALUES83 = {};
function extend86(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES83, initialValues);
  model.overrides = CLASS_MAPPING3;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
var newInstance86 = macro.newInstance(extend86, "vtkWebGPUViewNodeFactory");

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    exports_mat4.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      const xr = 1 / (xmax - xmin);
      const yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      outMat[0] = 2 * cRange[0] / (xmax - xmin);
      outMat[5] = 2 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = (val) => {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = (webGPURenderer) => {
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      exports_mat4.copy(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      exports_mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      exports_mat4.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      exports_mat4.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      exports_mat4.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      exports_mat4.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES84 = {
  keyMatrixTime: null,
  keyMatrices: null
};
function extend87(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES84, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var newInstance87 = macro.newInstance(extend87);
registerOverride3("vtkCamera", newInstance87);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = (bindables) => {
    if (model.bindables.length === bindables.length) {
      let allMatch = true;
      for (let i = 0;i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = (device) => {
    const entries = [];
    for (let i = 0;i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = (device) => {
    let mtime = publicAPI.getMTime();
    for (let i = 0;i < model.bindables.length; i++) {
      const tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    const entries = [];
    for (let i = 0;i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupEntry();
      entry.binding = i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = (pipeline) => {
    const lines = [];
    const bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (let i = 0;i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join(`
`);
  };
}
var DEFAULT_VALUES85 = {
  device: null,
  handle: null,
  label: null
};
function extend88(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES85, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var newInstance88 = macro.newInstance(extend88);
var vtkWebGPUBindGroup$1 = {
  newInstance: newInstance88,
  extend: extend88
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = (device, shaderDesc) => {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
var DEFAULT_VALUES86 = {
  device: null,
  handle: null
};
function extend89(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES86, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var newInstance89 = macro.newInstance(extend89, "vtkWebGPUShaderModule");
var vtkWebGPUShaderModule$1 = {
  newInstance: newInstance89,
  extend: extend89
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
function substitute2(source, search, replace) {
  let all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const replaceStr = Array.isArray(replace) ? replace.join(`
`) : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = "";
  if (all) {
    gflag = "g";
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = (shaderDesc) => {
    const sType = shaderDesc.getType();
    const sHash = shaderDesc.getHash();
    const keys = model._shaderModules.keys();
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    const sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
var DEFAULT_VALUES87 = {
  shaderModules: null,
  device: null,
  window: null
};
function extend90(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES87, initialValues);
  model._shaderModules = new Map;
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var newInstance90 = macro.newInstance(extend90, "vtkWebGPUShaderCache");
var vtkWebGPUShaderCache$1 = {
  newInstance: newInstance90,
  extend: extend90,
  substitute: substitute2
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
  publicAPI.initialize = (device, hash) => {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    const bindGroupLayouts = [];
    for (let i = 0;i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (let i = 0;i < model.shaderDescriptions.length; i++) {
      const sd = model.shaderDescriptions[i];
      const sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = (stype) => {
    for (let i = 0;i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype)
        return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = (bindGroup) => {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = (idx) => model.layouts[idx].layout;
  publicAPI.getBindGroupLayoutCount = (llabel) => {
    for (let i = 0;i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = (renderEncoder, vInput) => {
    vInput.bindBuffers(renderEncoder);
  };
}
var DEFAULT_VALUES88 = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};
function extend91(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES88, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var newInstance91 = newInstance(extend91, "vtkWebGPUPipeline");
var vtkWebGPUPipeline$1 = {
  newInstance: newInstance91,
  extend: extend91
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = (name) => model.outputNames.includes(name);
  publicAPI.addOutput = function(type, name) {
    let interpolation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = (type, name) => {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = (type, name) => {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
    const inputImpl = [];
    let iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      const inputStruct = [];
      inputStruct.push(`struct ${model.type}Input
{`);
      if (priorStage) {
        const inputNames = priorStage.getOutputNamesByReference();
        const inputTypes = priorStage.getOutputTypesByReference();
        const inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (let i = 0;i < inputNames.length; i++) {
          if (inputInterpolations[i] !== undefined) {
            inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
          } else {
            inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
          }
        }
      }
      for (let i = 0;i < model.builtinInputNames.length; i++) {
        inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push(`input: ${model.type}Input`);
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      const outputStruct = [`struct ${model.type}Output
{`];
      for (let i = 0;i < model.outputNames.length; i++) {
        if (model.outputInterpolations[i] !== undefined) {
          outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        } else {
          outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        }
      }
      for (let i = 0;i < model.builtinOutputNames.length; i++) {
        outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", [`-> ${model.type}Output`]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
var DEFAULT_VALUES89 = {
  type: null,
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};
function extend92(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES89, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var newInstance92 = macro.newInstance(extend92, "vtkWebGPUShaderDescription");
var vtkWebGPUShaderDescription$1 = {
  newInstance: newInstance92,
  extend: extend92
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var textureDetails = {
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "sint"
  },
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "uint"
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "sint"
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: "float"
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "uint"
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "sint"
  },
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "uint"
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "sint"
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "uint"
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "sint"
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: "float"
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "rgba8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "uint"
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "sint"
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "bgra8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: "float"
  },
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "uint"
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "sint"
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "uint"
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "sint"
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: "float"
  },
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "uint"
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "sint"
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "depth"
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: "depth"
  },
  "depth24plus-stencil8": {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "mixed"
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "depth"
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6)
    return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  vtkErrorMacro(`unknown format ${format}`);
  return null;
}
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  const num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro(`unknown format ${format}`);
    return 0;
  }
  const typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  let result;
  if (format[0] === "f") {
    result = "Float";
  } else if (format[0] === "s") {
    result = "Int";
  } else if (format[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro(`unknown format ${format}`);
    return;
  }
  const base = format.split("x")[0];
  const num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro(`unknown format ${format}`);
    return;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  let dataType;
  if (format[0] === "f" || format[1] === "n") {
    dataType = "f32";
  } else if (format[0] === "s" && format[1] === "i") {
    dataType = "i32";
  } else if (format[0] === "u" && format[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro(`unknown format ${format}`);
    return;
  }
  let numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4)
    return `vec4<${dataType}>`;
  if (numComp === 3)
    return `vec3<${dataType}>`;
  if (numComp === 2)
    return `vec2<${dataType}>`;
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format)
    return 0;
  let numComp = 1;
  if (format.substring(0, 3) === "vec") {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === "mat") {
    numComp = format[3] * format[5];
  }
  const typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format)
    return;
  if (format.includes("f32"))
    return "Float32Array";
  if (format.includes("i32"))
    return "Int32Array";
  if (format.includes("u32"))
    return "Uint32Array";
  vtkErrorMacro(`unknown format ${format}`);
  return;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
function arraysEqual(a, b) {
  if (a === b)
    return true;
  if (a == null || b == null)
    return false;
  if (a.length !== b.length)
    return false;
  for (let i = 0;i < a.length; ++i) {
    if (!b.includes(a[i]))
      return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "vertex";
    let names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (let i = 0;i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort((v1, v2) => {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = (name) => {
    for (let i = 0;i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = (name) => {
    for (let i = 0;i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = (name) => {
    for (let i = 0;i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = (name) => {
    for (let i = 0;i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = () => {
    let result = "";
    let nameCount = 0;
    for (let i = 0;i < model.inputs.length; i++) {
      for (let nm2 = 0;nm2 < model.inputs[i].names.length; nm2++) {
        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm2];
        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += `,
`;
        }
        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm2]} : ${type}`;
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = () => {
    const info = {};
    if (model.inputs.length) {
      const vertexBuffers = [];
      let nameCount = 0;
      for (let i = 0;i < model.inputs.length; i++) {
        const buf = model.inputs[i].buffer;
        const buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        const arrayInfo = buf.getArrayInformation();
        for (let nm2 = 0;nm2 < model.inputs[i].names.length; nm2++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm2].offset,
            format: arrayInfo[nm2].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = (renderEncoder) => {
    for (let i = 0;i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = () => {
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
var DEFAULT_VALUES90 = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};
function extend93(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES90, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var newInstance93 = newInstance(extend93, "vtkWebGPUVertexInput");
var vtkWebGPUVertexInput$1 = {
  newInstance: newInstance93,
  extend: extend93
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js
var vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUSimpleMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSimpleMapper");
  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
    const vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    const fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    const sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    const re = new RegExp("//VTK::[^:]*::", "g");
    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);
    const fnames = unique.map((v) => `replaceShader${v.substring(7, v.length - 2)}`);
    for (let i = 0;i < fnames.length; i++) {
      const fname = fnames[i];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
    if (!model.WebGPURenderer) {
      return;
    }
    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
    const ubocode = model.bindGroup.getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = (view) => {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.prepareToDraw = (renderEncoder) => {
    model.renderEncoder = renderEncoder;
    publicAPI.updateInput();
    publicAPI.updateBuffers();
    publicAPI.updateBindings();
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = () => {
  };
  publicAPI.updateBuffers = () => {
  };
  publicAPI.updateBindings = () => {
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = () => {
  };
  publicAPI.registerDrawCallback = (encoder) => {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = (encoder) => {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };
  publicAPI.draw = (renderEncoder) => {
    const pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    const indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = () => {
    const bindables = [...model.additionalBindables];
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (let t = 0;t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      const samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = () => {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
var DEFAULT_VALUES91 = {
  additionalBindables: undefined,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: "triangle-list",
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};
function extend94(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES91, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = new Map;
  macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUSimpleMapper(publicAPI, model);
}
var newInstance94 = macro.newInstance(extend94, "vtkWebGPUSimpleMapper");
var vtkWebGPUSimpleMapper$1 = {
  newInstance: newInstance94,
  extend: extend94
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = () => {
    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
  };
}
var DEFAULT_VALUES92 = {};
function extend95(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES92, initialValues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var newInstance95 = macro.newInstance(extend95, "vtkWebGPUFullScreenQuad");
var vtkWebGPUFullScreenQuad$1 = {
  newInstance: newInstance95,
  extend: extend95
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
var BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
var PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants18 = {
  BufferUsage,
  PrimitiveTypes
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
var forwarded = ["getMappedRange", "mapAsync", "unmap"];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  const byteCount = srcArrayBuffer.byteLength;
  const srcBuffer = device.createBuffer({
    size: byteCount,
    usage: GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  const encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  const commandBuffer = encoder.finish();
  const queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = (sizeInBytes, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = (data) => {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = (data, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  for (let i = 0;i < forwarded.length; i++) {
    publicAPI[forwarded[i]] = function() {
      return model.handle[forwarded[i]](...arguments);
    };
  }
}
var DEFAULT_VALUES93 = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};
function extend96(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES93, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var newInstance96 = macro.newInstance(extend96);
var vtkWebGPUBuffer$1 = {
  newInstance: newInstance96,
  extend: extend96,
  ...Constants18
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js
var {
  Representation: Representation6
} = vtkProperty$1;
var {
  PrimitiveTypes: PrimitiveTypes2
} = Constants18;

class _LimitedMap {
  constructor() {
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  clear() {
    this.count = 0;
  }
  has(key) {
    for (let i = 0;i < this.count; i++) {
      if (this.keys[i] === key) {
        return true;
      }
    }
    return;
  }
  get(key) {
    for (let i = 0;i < this.count; i++) {
      if (this.keys[i] === key) {
        return this.values[i];
      }
    }
    return;
  }
  set(key, value) {
    if (this.count < 9) {
      this.keys[this.count] = key;
      this.values[this.count++] = value;
    }
  }
}
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes2.Points:
      return "points";
    case PrimitiveTypes2.Lines:
      return "lines";
    case PrimitiveTypes2.Triangles:
    case PrimitiveTypes2.TriangleEdges:
      return "polys";
    case PrimitiveTypes2.TriangleStripEdges:
    case PrimitiveTypes2.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  let flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  for (let ptIdx = 0;ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId2)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId2);
      for (let ptIdx2 = ptIdx + 1;ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        const flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  for (let ptIdx = 0;ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId2]) {
      let flatId2 = _getOrAddFlatId(state, ptId2, cellId);
      state.provokedPointIds[ptId2] = 1;
      state.cellProvokedMap.set(ptId2, flatId2);
      state.flatIdToCellId[flatId2] = cellId;
      state.ibo[state.iboId++] = flatId2;
      for (let ptIdx2 = ptIdx + 1;ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  let ptId = ptIds[0];
  let flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;
  state.ibo[state.iboId++] = flatId;
  for (let ptIdx2 = 1;ptIdx2 < numPtIds; ptIdx2++) {
    ptId = ptIds[ptIdx2];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  state.iboSize += numPtIds;
  for (let ptIdx = 0;ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }
  for (let ptIdx = 0;ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, 1);
      return;
    }
  }
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
var processCell;
var _single = new Uint32Array(1);
var _double = new Uint32Array(2);
var _triple = new Uint32Array(3);
var _indexCellBuilders = {
  anythingToPoints(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0;i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0;i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (let i = 0;i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (let i = 0;i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
      for (let i = 0;i < numPoints - 2; i++) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0;i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0;i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};
function vtkWebGPUIndexBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUIndexBuffer");
  publicAPI.buildIndexBuffer = (req) => {
    const cellArray = req.cells;
    const primitiveType = req.primitiveType;
    const representation = req.representation;
    const cellOffset = req.cellOffset;
    const array = cellArray.getData();
    const cellArraySize = array.length;
    const inRepName = getPrimitiveName(primitiveType);
    const numPts = req.numberOfPoints;
    const state = {
      provokedPointIds: new Uint8Array(numPts),
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap
    };
    let func = null;
    if (representation === Representation6.POINTS || primitiveType === PrimitiveTypes2.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation6.WIREFRAME || primitiveType === PrimitiveTypes2.Lines) {
      func = _indexCellBuilders[`${inRepName}ToWireframe`];
    } else {
      func = _indexCellBuilders[`${inRepName}ToSurface`];
    }
    processCell = countCell;
    let cellId = cellOffset || 0;
    for (let cellArrayIndex = 0;cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    if (numPts <= 65535) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 36863) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 65535) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = "uint16";
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = "uint32";
    }
    if (cellId <= 65535) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (let cellArrayIndex = 0;cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}
var DEFAULT_VALUES94 = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};
function extend97(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES94, initialValues);
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
  vtkWebGPUIndexBuffer(publicAPI, model);
}
var newInstance97 = macro.newInstance(extend97);
var vtkWebGPUIndexBuffer$1 = {
  newInstance: newInstance97,
  extend: extend97,
  ...Constants18
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
var {
  BufferUsage: BufferUsage2
} = Constants18;
var {
  vtkErrorMacro: vtkErrorMacro36
} = macro$1;
var {
  VtkDataTypes: VtkDataTypes5
} = vtkDataArray$1;
var STATIC11 = {};
function _getFormatForDataArray(dataArray) {
  let format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes5.UNSIGNED_CHAR:
      format = "uint8";
      break;
    case VtkDataTypes5.FLOAT:
      format = "float32";
      break;
    case VtkDataTypes5.UNSIGNED_INT:
      format = "uint32";
      break;
    case VtkDataTypes5.INT:
      format = "sint32";
      break;
    case VtkDataTypes5.DOUBLE:
      format = "float32";
      break;
    case VtkDataTypes5.UNSIGNED_SHORT:
      format = "uint16";
      break;
    case VtkDataTypes5.SHORT:
      format = "sin16";
      break;
    default:
      format = "float32";
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += "x2";
      break;
    case 3:
      if (!format.includes("32")) {
        vtkErrorMacro36(`unsupported x3 type for ${format}`);
      }
      format += "x3";
      break;
    case 4:
      format += "x4";
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  const result = {};
  const flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }
  let shift = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  let scale8 = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale8 = options.scale;
    } else {
      scale8.fill(options.scale);
    }
  }
  const packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  let addAPoint;
  let vboidx = 0;
  const stride = numComp + (packExtra ? 1 : 0);
  const packedVBO = newTypedArray(outputType, flatSize * stride);
  let flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale8[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale8[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale8[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale8[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale8[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale8[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale8[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale8[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale8[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale8[3] * 1 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale8[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale8[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale8[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale8[3] * inArrayData[i + 3] + shift[3];
    };
  }
  for (let index2 = 0;index2 < flatSize; index2++) {
    const inArrayId = numComp * flatIdMap[index2];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i22) {
  const v1 = [pointData[i22 * 3] - pointData[i1 * 3], pointData[i22 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i22 * 3 + 2] - pointData[i1 * 3 + 2]];
  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  const result = [];
  cross(v1, v2, result);
  normalize(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  const pointData = pointArray.getData();
  const cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }
  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  const size = cellArrayData.length;
  let vboidx = 0;
  for (let index2 = 0;index2 < size; ) {
    const normal = getNormal(pointData, cellArrayData[index2 + 1], cellArrayData[index2 + 2], cellArrayData[index2 + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index2 += cellArrayData[index2] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    let buffer;
    let gpuUsage;
    if (req.usage === BufferUsage2.Index) {
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }
    if (req.usage === BufferUsage2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? "flat" : "perspective"
      }]);
    }
    if (req.usage === BufferUsage2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const normals = generateNormals(req.cells, req.dataArray);
      const result = packArray(req.indexBuffer, normals, 4, arrayType, {
        cellData: true
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: "flat"
      }]);
    }
    if (req.usage === BufferUsage2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = (hash) => model.device.hasCachedObject(hash);
  publicAPI.getBuffer = (req) => {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
    const format = _getFormatForDataArray(dataArray);
    const buffRequest = {
      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,
      usage: BufferUsage2.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = () => {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    const array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
var DEFAULT_VALUES95 = {
  device: null,
  fullScreenQuadBuffer: null
};
function extend98(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES95, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var newInstance98 = newInstance(extend98);
var vtkWebGPUBufferManager$1 = {
  newInstance: newInstance98,
  extend: extend98,
  ...STATIC11,
  ...Constants18
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
var {
  BufferUsage: BufferUsage3
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro37
} = macro;
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro37(`entry named ${name} already exists`);
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = (device) => {
    if (!model._buffer) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage3.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, instance, val) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro37(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = (name, instance, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro37(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (let i = 0;i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro37(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0;inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0;i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro37(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0;inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0;i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro37(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = 9;
    for (let inst = 0;inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let j = 0;j < 3; j++) {
        for (let i = 0;i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = () => model._sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    const lines = [`struct ${model.label}StructEntry
{`];
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
    return lines.join(`
`);
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = () => {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = new Map;
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
var DEFAULT_VALUES96 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};
function extend99(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES96, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = new Map;
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var newInstance99 = macro.newInstance(extend99, "vtkWebGPUStorageBuffer");
var vtkWebGPUStorageBuffer$1 = {
  newInstance: newInstance99,
  extend: extend99
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var {
  BufferUsage: BufferUsage4
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro38
} = macro;
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro38(`entry named ${name} already exists`);
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = () => {
    if (!model.sortDirty) {
      return;
    }
    let currOffset = 0;
    const newEntries = [];
    let maxAlignment = 4;
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes === 12) {
        for (let i22 = 0;i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        for (let i22 = i + 1;i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        let found = false;
        for (let i22 = 0;!found && i22 < model.bufferEntries.length; i22++) {
          const entry2 = model.bufferEntries[i22];
          if (!entry2.packed && entry2.sizeInBytes === 4) {
            for (let i3 = i22 + 1;i3 < model.bufferEntries.length; i3++) {
              const entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                entry.packed = true;
                entry.offset = currOffset;
                newEntries.push(entry);
                currOffset += entry.sizeInBytes;
                entry2.packed = true;
                entry2.offset = currOffset;
                newEntries.push(entry2);
                currOffset += entry2.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes > 4) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (let i = 0;i < model.bufferEntries.length; i++) {
      model._bufferEntryNames.set(model.bufferEntries[i].name, i);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = (device) => {
    if (!model.UBO) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage4.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, val) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro38(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = (name, arr) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro38(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    let changed = false;
    for (let i = 0;i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = [...arr];
    }
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = () => model.sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    publicAPI.sortBufferEntries();
    const lines = [`struct ${model.label}Struct
{`];
    for (let i = 0;i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`};
@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
    return lines.join(`
`);
  };
}
var DEFAULT_VALUES97 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};
function extend100(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES97, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = new Map;
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var newInstance100 = macro.newInstance(extend100, "vtkWebGPUUniformBuffer");
var vtkWebGPUUniformBuffer$1 = {
  newInstance: newInstance100,
  extend: extend100
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro11
} = macro$1;
var clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var _fsqClearMat4 = new Float64Array(16);
var _tNormalMat4 = new Float64Array(16);
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset = [];
    exports_vec3.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    exports_vec3.add(center, pos, offset);
    exports_vec3.sub(offset, center, model.stabilizedCenter);
    const length5 = exports_vec3.len(offset);
    if (length5 / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0;index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro11("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      model.UBO.setValue("LightCount", model.renderable.getLights().length);
      model.UBO.setValue("MaxEnvironmentMipLevel", model.renderable.getEnvironmentTexture()?.getMipLevel());
      model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i = 0;i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i = 0;i < lights.length; i++) {
        const offset = i * 4;
        const viewCoordinatePosition = lights[i].getPosition();
        exports_vec3.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;
        lightDirArray[offset] = -lights[i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[i].getDirection()[2];
        lightDirArray[offset + 3] = 0;
        lightColorArray[offset] = lights[i].getColor()[0];
        lightColorArray[offset + 1] = lights[i].getColor()[1];
        lightColorArray[offset + 2] = lights[i].getColor()[2];
        lightColorArray[offset + 3] = lights[i].getIntensity() * 5;
        lightTypeArray[offset] = getLightTypeIndex(lights[i]);
        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle()));
        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff()));
        lightTypeArray[offset + 3] = 0;
      }
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry("LightPos", "vec4<f32>");
      model.SSBO.addEntry("LightDir", "vec4<f32>");
      model.SSBO.addEntry("LightColor", "vec4<f32>");
      model.SSBO.addEntry("LightData", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
      model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
      model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
      model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = (encoder) => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = (renderEncoder) => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
        tview.addSampler(device, {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge",
          addressModeW: "repeat",
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: "linear"
        });
      }
      model.clearFSQ.setPipelineHash("clearfsqwithtexture");
    } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    exports_mat4.transpose(_tNormalMat4, keyMats.normalMatrix);
    exports_mat4.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    exports_mat4.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = (val) => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = (id) => {
    for (let i = 0;i < model.children.length; i++) {
      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
var DEFAULT_VALUES98 = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20,
  suppressClear: false,
  stabilizedCenter: [0, 0, 0]
};
function extend101(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES98, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("LightCount", "i32");
  model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
  model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
  model.UBO.addEntry("BackgroundSpecularStrength", "f32");
  model.UBO.addEntry("cameraParallel", "u32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "rendererLightSSBO"
  });
  model.lightTimeString = "";
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = exports_mat4.identity(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var newInstance101 = newInstance(extend101, "vtkWebGPURenderer");
registerOverride3("vtkRenderer", newInstance101);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
    model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
    model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = (binding, group) => {
    const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
    return result;
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: model.handle
    };
    return foo;
  };
}
var DEFAULT_VALUES99 = {
  device: null,
  handle: null,
  label: null,
  options: null
};
function extend102(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES99, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    sampler: {}
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var newInstance102 = macro.newInstance(extend102);
var vtkWebGPUSampler$1 = {
  newInstance: newInstance102,
  extend: extend102
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js
var {
  SlicingMode: SlicingMode3
} = Constants12;
var imgFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;
function computeFnToString(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return "0";
}
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
var tmp3Mat4 = new Float64Array(16);
var ptsArray1 = new Float64Array(4);
var ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      const ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = () => {
    const ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    const actor = model.WebGPUImageSlice.getRenderable();
    const volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      const image = volMapr.getInputData();
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      exports_mat4.identity(tmpMat4);
      exports_mat4.translate(tmpMat4, tmpMat4, center);
      const mcwcmat = actor.getMatrix();
      exports_mat4.transpose(tmp2Mat4, mcwcmat);
      exports_mat4.invert(tmp2Mat4, tmp2Mat4);
      exports_mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const modelToIndex = image.getWorldToIndex();
      exports_mat4.multiply(tmpMat4, modelToIndex, tmpMat4);
      exports_mat4.invert(tmp3Mat4, tmpMat4);
      exports_mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      exports_mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const dims = image.getDimensions();
      exports_mat4.identity(tmp2Mat4);
      exports_mat4.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      exports_mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      const ext = model.currentInput.getExtent();
      const {
        ijkMode
      } = model.renderable.getClosestIJKAxis();
      let nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      let axis0 = 2;
      let axis1 = 0;
      let axis2 = 1;
      if (ijkMode === SlicingMode3.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode3.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1;
      exports_vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1;
      exports_vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      exports_vec4.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1;
      exports_vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      exports_vec4.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      const cScale = [1, 1, 1, 1];
      const cShift = [0, 0, 0, 0];
      const tView = model.textureViews[0];
      const tScale = tView.getTexture().getScale();
      const numComp = tView.getTexture().getNumberOfComponents();
      for (let i = 0;i < numComp; i++) {
        let cw2 = actor.getProperty().getColorWindow();
        let cl2 = actor.getProperty().getColorLevel();
        const target = 0;
        const cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          const cRange = cfun.getRange();
          cw2 = cRange[1] - cRange[0];
          cl2 = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw2;
        cShift[i] = -cl2 / cw2 + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = () => {
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    const numIComps = 1;
    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(model.rowLength * 3);
        for (let c = 0;c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (let i = 0;i < model.rowLength; i++) {
              const idx = c * model.rowLength * 8 + i * 4;
              colorArray[idx] = 255 * tmpTable[i * 3];
              colorArray[idx + 1] = 255 * tmpTable[i * 3 + 1];
              colorArray[idx + 2] = 255 * tmpTable[i * 3 + 2];
              colorArray[idx + 3] = 255;
              for (let j = 0;j < 4; j++) {
                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];
              }
            }
          }
        }
      } else {
        for (let i = 0;i < model.rowLength; ++i) {
          const grey = 255 * i / (model.rowLength - 1);
          colorArray[i * 4] = grey;
          colorArray[i * 4 + 1] = grey;
          colorArray[i * 4 + 2] = grey;
          colorArray[i * 4 + 3] = 255;
          for (let j = 0;j < 4; j++) {
            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];
          }
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        const newTex = model.device.getTextureManager().getTexture(treq);
        const tview = newTex.createView("tfunTexture");
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    const tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      const tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const iType = actorProperty.getInterpolationType() === InterpolationType2.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  const sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    const lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;
    fDesc.setCode(code);
  };
  sr.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
var DEFAULT_VALUES100 = {
  rowLength: 1024
};
function extend103(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES100, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = exports_mat4.identity(new Float64Array(16));
  model.imagematinv = exports_mat4.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var newInstance103 = newInstance(extend103, "vtkWebGPUImageMapper");
registerOverride3("vtkImageMapper", newInstance103);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      exports_mat4.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        exports_mat4.identity(model.keyMatrices.normalMatrix);
      } else {
        exports_mat4.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        exports_mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        exports_mat4.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      exports_mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      exports_mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES101 = {
  bufferShift: undefined,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: undefined
};
function extend104(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES101, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: exports_mat4.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var newInstance104 = newInstance(extend104, "vtkWebGPUImageSlice");
registerOverride3("vtkImageSlice", newInstance104);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      const bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  const idx = new Float64Array(3);
  const vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = (result, offset) => {
    const input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    const extent = input.getExtent();
    const m = model.renderable.getMatrix();
    let count = 0;
    for (let iz = 4;iz < 6; iz++) {
      idx[2] = extent[iz];
      for (let iy = 2;iy < 4; iy++) {
        idx[1] = extent[iy];
        for (let ix = 0;ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          let poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      const center = wgpuRen.getStabilizedCenterByReference();
      exports_mat4.transpose(model.keyMatrices.bcwc, mcwc);
      exports_mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES102 = {
  propID: undefined,
  keyMatricesTime: null
};
function extend105(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES102, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var newInstance105 = macro.newInstance(extend105, "vtkWebGPUVolume");
registerOverride3("vtkVolume", newInstance105);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues())
      ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
var DEFAULT_VALUES103 = {};
function extend106(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES103, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance106 = macro.newInstance(extend106, "vtkWebGPUPixelSpaceCallbackMapper");
registerOverride3("vtkPixelSpaceCallbackMapper", newInstance106);

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js
var ADJACENT_ALL = [
  [0, -1, 0],
  [0, 1, 0],
  [0, 0, -1],
  [0, 0, 1]
];
var ADJACENT_SINGLE_PLANE = [
  [0, -1, 0],
  [0, 1, 0]
];
var ADJACENT_IN = [
  [0, -1, 0],
  [0, 1, 0],
  [0, 0, -1]
];
var ADJACENT_OUT = [
  [0, -1, 0],
  [0, 1, 0],
  [0, 0, 1]
];

class RLEVoxelMap {
  static copyMap(destination, source) {
    for (const [index2, row] of source.rows) {
      destination.rows.set(index2, structuredClone(row));
    }
  }
  constructor(width, height, depth = 1) {
    this.rows = new Map;
    this.height = 1;
    this.width = 1;
    this.depth = 1;
    this.jMultiple = 1;
    this.kMultiple = 1;
    this.numComps = 1;
    this.pixelDataConstructor = Uint8Array;
    this.updateScalarData = function(scalarData) {
      scalarData.fill(0);
      const callback = (index2, rle, row) => {
        const { start, end, value } = rle;
        for (let i = start;i < end; i++) {
          scalarData[index2 + i] = value;
        }
      };
      this.forEach(callback);
    };
    this.get = (index2) => {
      const i = index2 % this.jMultiple;
      const j = (index2 - i) / this.jMultiple;
      const rle = this.getRLE(i, j);
      return rle?.value ?? this.defaultValue;
    };
    this.getRun = (j, k) => {
      const runIndex = j + k * this.height;
      return this.rows.get(runIndex);
    };
    this.set = (index2, value) => {
      if (value === undefined) {
        return;
      }
      const i = index2 % this.width;
      const j = (index2 - i) / this.width;
      const row = this.rows.get(j);
      if (!row) {
        this.rows.set(j, [{ start: i, end: i + 1, value }]);
        return;
      }
      const rleIndex = this.findIndex(row, i);
      const rle1 = row[rleIndex];
      const rle0 = row[rleIndex - 1];
      if (!rle1) {
        if (!rle0 || rle0.value !== value || rle0.end !== i) {
          row[rleIndex] = { start: i, end: i + 1, value };
          return;
        }
        rle0.end++;
        return;
      }
      const { start, end, value: oldValue } = rle1;
      if (value === oldValue && i >= start) {
        return;
      }
      const rleInsert = { start: i, end: i + 1, value };
      const isAfter = i > start;
      const insertIndex = isAfter ? rleIndex + 1 : rleIndex;
      const rlePrev = isAfter ? rle1 : rle0;
      let rleNext = isAfter ? row[rleIndex + 1] : rle1;
      if (rlePrev?.value === value && rlePrev?.end === i) {
        rlePrev.end++;
        if (rleNext?.value === value && rleNext.start === i + 1) {
          rlePrev.end = rleNext.end;
          row.splice(rleIndex, 1);
        } else if (rleNext?.start === i) {
          rleNext.start++;
          if (rleNext.start === rleNext.end) {
            row.splice(rleIndex, 1);
            rleNext = row[rleIndex];
            if (rleNext?.start === i + 1 && rleNext.value === value) {
              rlePrev.end = rleNext.end;
              row.splice(rleIndex, 1);
            }
          }
        }
        return;
      }
      if (rleNext?.value === value && rleNext.start === i + 1) {
        rleNext.start--;
        if (rlePrev?.end > i) {
          rlePrev.end = i;
          if (rlePrev.end === rlePrev.start) {
            row.splice(rleIndex, 1);
          }
        }
        return;
      }
      if (rleNext?.start === i && rleNext.end === i + 1) {
        rleNext.value = value;
        const nextnext = row[rleIndex + 1];
        if (nextnext?.start == i + 1 && nextnext.value === value) {
          row.splice(rleIndex + 1, 1);
          rleNext.end = nextnext.end;
        }
        return;
      }
      if (i === rleNext?.start) {
        rleNext.start++;
      }
      if (isAfter && end > i + 1) {
        row.splice(insertIndex, 0, rleInsert, {
          start: i + 1,
          end: rlePrev.end,
          value: rlePrev.value
        });
      } else {
        row.splice(insertIndex, 0, rleInsert);
      }
      if (rlePrev?.end > i) {
        rlePrev.end = i;
      }
    };
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.jMultiple = width;
    this.kMultiple = this.jMultiple * height;
  }
  static {
    this.getScalarData = function(ArrayType = Uint8ClampedArray) {
      const scalarData = new ArrayType(this.frameSize);
      this.map.updateScalarData(scalarData);
      return scalarData;
    };
  }
  toIJK(index2) {
    const i = index2 % this.jMultiple;
    const j = (index2 - i) / this.jMultiple % this.height;
    const k = Math.floor(index2 / this.kMultiple);
    return [i, j, k];
  }
  toIndex([i, j, k]) {
    return i + k * this.kMultiple + j * this.jMultiple;
  }
  getRLE(i, j, k = 0) {
    const row = this.rows.get(j + k * this.height);
    if (!row) {
      return;
    }
    const index2 = this.findIndex(row, i);
    const rle = row[index2];
    return i >= rle?.start ? rle : undefined;
  }
  has(index2) {
    const i = index2 % this.jMultiple;
    const j = (index2 - i) / this.jMultiple;
    const rle = this.getRLE(i, j);
    return rle?.value !== undefined;
  }
  delete(index2) {
    const i = index2 % this.width;
    const j = (index2 - i) / this.width;
    const row = this.rows.get(j);
    if (!row) {
      return;
    }
    const rleIndex = this.findIndex(row, i);
    const rle = row[rleIndex];
    if (!rle || rle.start > i) {
      return;
    }
    if (rle.end === i + 1) {
      rle.end--;
      if (rle.start >= rle.end) {
        row.splice(rleIndex, 1);
        if (!row.length) {
          this.rows.delete(j);
        }
      }
      return;
    }
    if (rle.start === i) {
      rle.start++;
      return;
    }
    const newRle = {
      value: rle.value,
      start: i + 1,
      end: rle.end
    };
    rle.end = i;
    row.splice(rleIndex + 1, 0, newRle);
  }
  findIndex(row, i) {
    for (let index2 = 0;index2 < row.length; index2++) {
      const { end: iEnd } = row[index2];
      if (i < iEnd) {
        return index2;
      }
    }
    return row.length;
  }
  forEach(callback, options) {
    const rowModified = options?.rowModified;
    for (const [baseIndex, row] of this.rows) {
      const rowToUse = rowModified ? [...row] : row;
      for (const rle of rowToUse) {
        callback(baseIndex * this.width, rle, row);
      }
    }
  }
  forEachRow(callback) {
    for (const [baseIndex, row] of this.rows) {
      callback(baseIndex * this.width, row);
    }
  }
  clear() {
    this.rows.clear();
  }
  keys() {
    return [...this.rows.keys()];
  }
  getPixelData(k = 0, pixelData) {
    if (!pixelData) {
      pixelData = new this.pixelDataConstructor(this.width * this.height * this.numComps);
    } else {
      pixelData.fill(0);
    }
    const { width, height, numComps } = this;
    for (let j = 0;j < height; j++) {
      const row = this.getRun(j, k);
      if (!row) {
        continue;
      }
      if (numComps === 1) {
        for (const rle of row) {
          const rowOffset = j * width;
          const { start, end, value } = rle;
          for (let i = start;i < end; i++) {
            pixelData[rowOffset + i] = value;
          }
        }
      } else {
        for (const rle of row) {
          const rowOffset = j * width * numComps;
          const { start, end, value } = rle;
          for (let i = start;i < end; i += numComps) {
            for (let comp = 0;comp < numComps; comp++) {
              pixelData[rowOffset + i + comp] = value[comp];
            }
          }
        }
      }
    }
    return pixelData;
  }
  floodFill(i, j, k, value, options) {
    const rle = this.getRLE(i, j, k);
    if (!rle) {
      throw new Error(`Initial point ${i},${j},${k} isn't in the RLE`);
    }
    const stack = [[rle, j, k]];
    const replaceValue = rle.value;
    if (replaceValue === value) {
      throw new Error(`source (${replaceValue}) and destination (${value}) are identical`);
    }
    return this.flood(stack, replaceValue, value, options);
  }
  flood(stack, sourceValue, value, options) {
    let sum = 0;
    const { planar = true, diagonals = true, singlePlane = false } = options || {};
    const childOptions = { planar, diagonals, singlePlane };
    while (stack.length) {
      const top = stack.pop();
      const [current] = top;
      if (current.value !== sourceValue) {
        continue;
      }
      current.value = value;
      sum += current.end - current.start;
      const adjacents = this.findAdjacents(top, childOptions).filter((adjacent) => adjacent && adjacent[0].value === sourceValue);
      stack.push(...adjacents);
    }
    return sum;
  }
  fillFrom(getter, boundsIJK) {
    for (let k = boundsIJK[2][0];k <= boundsIJK[2][1]; k++) {
      for (let j = boundsIJK[1][0];j <= boundsIJK[1][1]; j++) {
        let rle;
        let row;
        for (let i = boundsIJK[0][0];i <= boundsIJK[0][1]; i++) {
          const value = getter(i, j, k);
          if (value === undefined) {
            rle = undefined;
            continue;
          }
          if (!row) {
            row = [];
            this.rows.set(j + k * this.height, row);
          }
          if (rle && rle.value !== value) {
            rle = undefined;
          }
          if (!rle) {
            rle = { start: i, end: i, value };
            row.push(rle);
          }
          rle.end++;
        }
      }
    }
  }
  findAdjacents(item, { diagonals = true, planar = true, singlePlane = false }) {
    const [rle, j, k, adjacentsDelta] = item;
    const { start, end } = rle;
    const leftRle = start > 0 && this.getRLE(start - 1, j, k);
    const rightRle = end < this.width && this.getRLE(end, j, k);
    const range = diagonals ? [start > 0 ? start - 1 : start, end < this.width ? end + 1 : end] : [start, end];
    const adjacents = [];
    if (leftRle) {
      adjacents.push([leftRle, j, k]);
    }
    if (rightRle) {
      adjacents.push([rightRle, j, k]);
    }
    for (const delta of adjacentsDelta || (singlePlane ? ADJACENT_SINGLE_PLANE : ADJACENT_ALL)) {
      const [, delta1, delta2] = delta;
      const testJ = delta1 + j;
      const testK = delta2 + k;
      if (testJ < 0 || testJ >= this.height) {
        continue;
      }
      if (testK < 0 || testK >= this.depth) {
        continue;
      }
      const row = this.getRun(testJ, testK);
      if (!row) {
        continue;
      }
      for (const testRle of row) {
        const newAdjacentDelta = adjacentsDelta || singlePlane && ADJACENT_SINGLE_PLANE || planar && delta2 > 0 && ADJACENT_OUT || planar && delta2 < 0 && ADJACENT_IN || ADJACENT_ALL;
        if (!(testRle.end <= range[0] || testRle.start >= range[1])) {
          adjacents.push([testRle, testJ, testK, newAdjacentDelta]);
        }
      }
    }
    return adjacents;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js
class PointsManager {
  constructor(configuration = {}) {
    this._dimensions = 3;
    this._length = 0;
    this._byteSize = 4;
    this.growSize = 128;
    const { initialSize = 1024, dimensions = 3, growSize = 128 } = configuration;
    const itemLength = initialSize * dimensions;
    this.growSize = growSize;
    this.array = new ArrayBuffer(itemLength * this._byteSize);
    this.data = new Float32Array(this.array);
    this._dimensions = dimensions;
  }
  forEach(func) {
    for (let i = 0;i < this._length; i++) {
      func(this.getPoint(i), i);
    }
  }
  get length() {
    return this._length;
  }
  get dimensions() {
    return this._dimensions;
  }
  get dimensionLength() {
    return this._length * this._dimensions;
  }
  getPoint(index2) {
    if (index2 < 0) {
      index2 += this._length;
    }
    if (index2 < 0 || index2 >= this._length) {
      return;
    }
    const offset = this._dimensions * index2;
    return this.data.subarray(offset, offset + this._dimensions);
  }
  getPointArray(index2) {
    const array = [];
    if (index2 < 0) {
      index2 += this._length;
    }
    if (index2 < 0 || index2 >= this._length) {
      return;
    }
    const offset = this._dimensions * index2;
    for (let i = 0;i < this._dimensions; i++) {
      array.push(this.data[i + offset]);
    }
    return array;
  }
  grow(additionalSize = 1, growSize = this.growSize) {
    if (this.dimensionLength + additionalSize * this._dimensions <= this.data.length) {
      return;
    }
    const newSize = this.data.length + growSize;
    const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);
    const newData = new Float32Array(newArray);
    newData.set(this.data);
    this.data = newData;
    this.array = newArray;
  }
  reverse() {
    const midLength = Math.floor(this._length / 2);
    for (let i = 0;i < midLength; i++) {
      const indexStart = i * this._dimensions;
      const indexEnd = (this._length - 1 - i) * this._dimensions;
      for (let dimension = 0;dimension < this._dimensions; dimension++) {
        const valueStart = this.data[indexStart + dimension];
        this.data[indexStart + dimension] = this.data[indexEnd + dimension];
        this.data[indexEnd + dimension] = valueStart;
      }
    }
  }
  getTypedArray() {
    return this.data;
  }
  push(point) {
    this.grow(1);
    const offset = this.length * this._dimensions;
    for (let i = 0;i < this._dimensions; i++) {
      this.data[i + offset] = point[i];
    }
    this._length++;
  }
  map(f) {
    const mapData = [];
    for (let i = 0;i < this._length; i++) {
      mapData.push(f(this.getPoint(i), i));
    }
    return mapData;
  }
  get points() {
    return this.map((p) => p);
  }
  toXYZ() {
    const xyz = { x: [], y: [] };
    if (this._dimensions >= 3) {
      xyz.z = [];
    }
    const { x, y, z } = xyz;
    this.forEach((p) => {
      x.push(p[0]);
      y.push(p[1]);
      if (z) {
        z.push(p[2]);
      }
    });
    return xyz;
  }
  static fromXYZ({ x, y, z }) {
    const array = PointsManager.create3(x.length);
    let offset = 0;
    for (let i = 0;i < x.length; i++) {
      array.data[offset++] = x[i];
      array.data[offset++] = y[i];
      array.data[offset++] = z ? z[i] : 0;
    }
    array._length = x.length;
    return array;
  }
  subselect(count = 10, offset = 0) {
    const selected = new PointsManager({
      initialSize: count,
      dimensions: this._dimensions
    });
    for (let i = 0;i < count; i++) {
      const index2 = (offset + Math.floor(this.length * i / count)) % this.length;
      selected.push(this.getPoint(index2));
    }
    return selected;
  }
  static create3(initialSize = 128, points) {
    initialSize = Math.max(initialSize, points?.length || 0);
    const newPoints = new PointsManager({ initialSize, dimensions: 3 });
    if (points) {
      points.forEach((point) => newPoints.push(point));
    }
    return newPoints;
  }
  static create2(initialSize = 128) {
    return new PointsManager({ initialSize, dimensions: 2 });
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/createPositionCallback.js
function createPositionCallback(imageData) {
  const currentPos = create3();
  const dimensions = imageData.getDimensions();
  const positionI = PointsManager.create3(dimensions[0]);
  const positionJ = PointsManager.create3(dimensions[1]);
  const positionK = PointsManager.create3(dimensions[2]);
  const direction = imageData.getDirection();
  const rowCosines = direction.slice(0, 3);
  const columnCosines = direction.slice(3, 6);
  const scanAxisNormal = direction.slice(6, 9);
  const spacing = imageData.getSpacing();
  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;
  const worldPosStart = imageData.indexToWorld([0, 0, 0]);
  const rowStep = fromValues3(rowCosines[0] * rowSpacing, rowCosines[1] * rowSpacing, rowCosines[2] * rowSpacing);
  const columnStep = fromValues3(columnCosines[0] * columnSpacing, columnCosines[1] * columnSpacing, columnCosines[2] * columnSpacing);
  const scanAxisStep = fromValues3(scanAxisNormal[0] * scanAxisSpacing, scanAxisNormal[1] * scanAxisSpacing, scanAxisNormal[2] * scanAxisSpacing);
  const scaled = create3();
  for (let i = 0;i < dimensions[0]; i++) {
    positionI.push(add4(scaled, worldPosStart, scale3(scaled, rowStep, i)));
  }
  for (let j = 0;j < dimensions[1]; j++) {
    positionJ.push(scale3(scaled, columnStep, j));
  }
  for (let k = 0;k < dimensions[2]; k++) {
    positionK.push(scale3(scaled, scanAxisStep, k));
  }
  const dataI = positionI.getTypedArray();
  const dataJ = positionJ.getTypedArray();
  const dataK = positionK.getTypedArray();
  return (ijk, destPoint = currentPos) => {
    const [i, j, k] = ijk;
    const offsetI = i * 3;
    const offsetJ = j * 3;
    const offsetK = k * 3;
    destPoint[0] = dataI[offsetI] + dataJ[offsetJ] + dataK[offsetK];
    destPoint[1] = dataI[offsetI + 1] + dataJ[offsetJ + 1] + dataK[offsetK + 1];
    destPoint[2] = dataI[offsetI + 2] + dataJ[offsetJ + 2] + dataK[offsetK + 2];
    return destPoint;
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
function pointInShapeCallback(imageData, options) {
  const { pointInShapeFn, callback, boundsIJK, returnPoints = false } = options;
  let scalarData;
  if (imageData.getScalarData) {
    scalarData = imageData.getScalarData();
  } else {
    const scalars = imageData.getPointData().getScalars();
    if (scalars) {
      scalarData = scalars.getData();
    } else {
      const { voxelManager } = imageData.get("voxelManager") || {};
      if (voxelManager) {
        scalarData = voxelManager.getCompleteScalarDataArray();
      }
    }
  }
  const dimensions = imageData.getDimensions();
  const defaultBoundsIJK = [
    [0, dimensions[0]],
    [0, dimensions[1]],
    [0, dimensions[2]]
  ];
  const bounds = boundsIJK || defaultBoundsIJK;
  const pointsInShape = iterateOverPointsInShape({
    imageData,
    bounds,
    scalarData,
    pointInShapeFn,
    callback
  });
  return returnPoints ? pointsInShape : undefined;
}
function iterateOverPointsInShape({ imageData, bounds, scalarData, pointInShapeFn, callback }) {
  const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;
  const { numComps } = imageData;
  const dimensions = imageData.getDimensions();
  const indexToWorld = createPositionCallback(imageData);
  const pointIJK = [0, 0, 0];
  const xMultiple = numComps || scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];
  const yMultiple = dimensions[0] * xMultiple;
  const zMultiple = dimensions[1] * yMultiple;
  const pointsInShape = [];
  for (let k = kMin;k <= kMax; k++) {
    pointIJK[2] = k;
    const indexK = k * zMultiple;
    for (let j = jMin;j <= jMax; j++) {
      pointIJK[1] = j;
      const indexJK = indexK + j * yMultiple;
      for (let i = iMin;i <= iMax; i++) {
        pointIJK[0] = i;
        const pointLPS = indexToWorld(pointIJK);
        if (pointInShapeFn(pointLPS, pointIJK)) {
          const index2 = indexJK + i * xMultiple;
          let value;
          if (xMultiple > 2) {
            value = [
              scalarData[index2],
              scalarData[index2 + 1],
              scalarData[index2 + 2]
            ];
          } else {
            value = scalarData[index2];
          }
          pointsInShape.push({
            value,
            index: index2,
            pointIJK,
            pointLPS: pointLPS.slice()
          });
          callback({ value, index: index2, pointIJK, pointLPS });
        }
      }
    }
  }
  return pointsInShape;
}
function iterateOverPointsInShapeVoxelManager({ voxelManager, bounds, imageData, pointInShapeFn, callback, returnPoints }) {
  const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;
  const indexToWorld = createPositionCallback(imageData);
  const pointIJK = [0, 0, 0];
  const pointsInShape = [];
  for (let k = kMin;k <= kMax; k++) {
    pointIJK[2] = k;
    for (let j = jMin;j <= jMax; j++) {
      pointIJK[1] = j;
      for (let i = iMin;i <= iMax; i++) {
        pointIJK[0] = i;
        const pointLPS = indexToWorld(pointIJK);
        if (pointInShapeFn(pointLPS, pointIJK)) {
          const index2 = voxelManager.toIndex(pointIJK);
          const value = voxelManager.getAtIndex(index2);
          if (returnPoints) {
            pointsInShape.push({
              value,
              index: index2,
              pointIJK: [...pointIJK],
              pointLPS: pointLPS.slice()
            });
          }
          callback?.({ value, index: index2, pointIJK, pointLPS });
        }
      }
    }
  }
  return pointsInShape;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/VoxelManager.js
var DEFAULT_RLE_SIZE = 5 * 1024;

class VoxelManager {
  constructor(dimensions, options) {
    this.modifiedSlices = new Set;
    this.boundsIJK = [
      [Infinity, -Infinity],
      [Infinity, -Infinity],
      [Infinity, -Infinity]
    ];
    this.scalarData = null;
    this._sliceDataCache = null;
    this.getAtIJK = (i, j, k) => {
      const index2 = this.toIndex([i, j, k]);
      return this._get(index2);
    };
    this.setAtIJK = (i, j, k, v) => {
      const index2 = this.toIndex([i, j, k]);
      const changed = this._set(index2, v);
      if (changed !== false) {
        this.modifiedSlices.add(k);
        VoxelManager.addBounds(this.boundsIJK, [i, j, k]);
      }
      return changed;
    };
    this.getAtIJKPoint = ([i, j, k]) => this.getAtIJK(i, j, k);
    this.setAtIJKPoint = ([i, j, k], v) => {
      this.setAtIJK(i, j, k, v);
    };
    this.getAtIndex = (index2) => this._get(index2);
    this.setAtIndex = (index2, v) => {
      const changed = this._set(index2, v);
      if (changed !== false) {
        const pointIJK = this.toIJK(index2);
        this.modifiedSlices.add(pointIJK[2]);
        VoxelManager.addBounds(this.boundsIJK, pointIJK);
      }
      return changed;
    };
    this.getMiddleSliceData = () => {
      const middleSliceIndex = Math.floor(this.dimensions[2] / 2);
      return this.getSliceData({
        sliceIndex: middleSliceIndex,
        slicePlane: 2
      });
    };
    this.forEach = (callback, options2 = {}) => {
      const isInObjectBoundsIJK = options2.boundsIJK || this.getBoundsIJK();
      const isInObject = options2.isInObject || this.isInObject || (() => true);
      const returnPoints = options2.returnPoints || false;
      const useLPSTransform = options2.imageData;
      const iMin = Math.min(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
      const iMax = Math.max(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
      const jMin = Math.min(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
      const jMax = Math.max(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
      const kMin = Math.min(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
      const kMax = Math.max(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
      const pointsInShape = [];
      if (useLPSTransform) {
        const pointsInShape2 = iterateOverPointsInShapeVoxelManager({
          voxelManager: this,
          imageData: options2.imageData,
          bounds: [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax]
          ],
          pointInShapeFn: isInObject,
          callback,
          returnPoints
        });
        return pointsInShape2;
      }
      if (this.map) {
        if (this.map instanceof RLEVoxelMap) {
          return this.rleForEach(callback, options2);
        }
        for (const index2 of this.map.keys()) {
          const pointIJK = this.toIJK(index2);
          if (!isInObject(null, pointIJK)) {
            continue;
          }
          const value = this._get(index2);
          if (returnPoints) {
            pointsInShape.push({
              value,
              index: index2,
              pointIJK,
              pointLPS: null
            });
          }
          callback({ value, index: index2, pointIJK, pointLPS: null });
        }
        return pointsInShape;
      } else {
        for (let k = kMin;k <= kMax; k++) {
          const kIndex = k * this.frameSize;
          for (let j = jMin;j <= jMax; j++) {
            const jIndex = kIndex + j * this.width;
            for (let i = iMin, index2 = jIndex + i;i <= iMax; i++, index2++) {
              const value = this.getAtIndex(index2);
              const pointIJK = [i, j, k];
              if (!isInObject(null, pointIJK)) {
                continue;
              }
              if (returnPoints) {
                pointsInShape.push({
                  value,
                  index: index2,
                  pointIJK,
                  pointLPS: null
                });
              }
              callback({ value, index: index2, pointIJK: [i, j, k], pointLPS: null });
            }
          }
        }
        return pointsInShape;
      }
    };
    this.getSliceData = ({ sliceIndex, slicePlane }) => {
      const [width, height, depth] = this.dimensions;
      const frameSize = width * height;
      const startIndex = sliceIndex * frameSize;
      let sliceSize;
      const SliceDataConstructor = this.getConstructor();
      function isValidConstructor(ctor) {
        return typeof ctor === "function";
      }
      if (!isValidConstructor(SliceDataConstructor)) {
        return new Uint8Array(0);
      }
      let sliceData;
      switch (slicePlane) {
        case 0:
          sliceSize = height * depth;
          sliceData = new SliceDataConstructor(sliceSize);
          for (let i = 0;i < height; i++) {
            for (let j = 0;j < depth; j++) {
              const index2 = sliceIndex + i * width + j * frameSize;
              this.setSliceDataValue(sliceData, i * depth + j, this._get(index2));
            }
          }
          break;
        case 1:
          sliceSize = width * depth;
          sliceData = new SliceDataConstructor(sliceSize);
          for (let i = 0;i < width; i++) {
            for (let j = 0;j < depth; j++) {
              const index2 = i + sliceIndex * width + j * frameSize;
              this.setSliceDataValue(sliceData, i + j * width, this._get(index2));
            }
          }
          break;
        case 2:
          sliceSize = width * height;
          sliceData = new SliceDataConstructor(sliceSize);
          for (let i = 0;i < sliceSize; i++) {
            this.setSliceDataValue(sliceData, i, this._get(startIndex + i));
          }
          break;
        default:
          throw new Error("Oblique plane - todo - implement as ortho normal vector");
      }
      return sliceData;
    };
    this.dimensions = dimensions;
    this.width = dimensions[0];
    this.frameSize = this.width * dimensions[1];
    this._get = options._get;
    this._set = options._set;
    this._id = options._id || "";
    this._getConstructor = options._getConstructor;
    this.numberOfComponents = this.numberOfComponents || 1;
    this.scalarData = options.scalarData;
    this._getScalarData = options._getScalarData;
    this._updateScalarData = options._updateScalarData;
  }
  getMinMax() {
    let min5, max5;
    const callback = ({ value: v }) => {
      const isArray = Array.isArray(v);
      if (min5 === undefined) {
        min5 = isArray ? [...v] : v;
        max5 = isArray ? [...v] : v;
      }
      if (isArray) {
        for (let i = 0;i < v.length; i++) {
          min5[i] = Math.min(min5[i], v[i]);
          max5[i] = Math.max(max5[i], v[i]);
        }
      } else {
        min5 = Math.min(min5, v);
        max5 = Math.max(max5, v);
      }
    };
    this.forEach(callback, { boundsIJK: this.getDefaultBounds() });
    return { min: min5, max: max5 };
  }
  toIJK(index2) {
    return [
      index2 % this.width,
      Math.floor(index2 % this.frameSize / this.width),
      Math.floor(index2 / this.frameSize)
    ];
  }
  toIndex(ijk) {
    return ijk[0] + ijk[1] * this.width + ijk[2] * this.frameSize;
  }
  getDefaultBounds() {
    return this.dimensions.map((dimension) => [0, dimension - 1]);
  }
  getBoundsIJK() {
    if (this.boundsIJK[0][0] < this.dimensions[0]) {
      return this.boundsIJK;
    }
    return this.getDefaultBounds();
  }
  rleForEach(callback, options) {
    const boundsIJK = options?.boundsIJK || this.getBoundsIJK();
    const { isWithinObject } = options || {};
    const map = this.map;
    map.defaultValue = undefined;
    for (let k = boundsIJK[2][0];k <= boundsIJK[2][1]; k++) {
      for (let j = boundsIJK[1][0];j <= boundsIJK[1][1]; j++) {
        const row = map.getRun(j, k);
        if (!row) {
          continue;
        }
        for (const rle of row) {
          const { start, end, value } = rle;
          const baseIndex = this.toIndex([0, j, k]);
          for (let i = start;i < end; i++) {
            const callbackArguments = {
              value,
              index: baseIndex + i,
              pointIJK: [i, j, k]
            };
            if (isWithinObject?.(callbackArguments) === false) {
              continue;
            }
            callback(callbackArguments);
          }
        }
      }
    }
  }
  getScalarData(storeScalarData = false) {
    if (this.scalarData) {
      this._updateScalarData?.(this.scalarData);
      return this.scalarData;
    }
    if (this._getScalarData) {
      const scalarData = this._getScalarData();
      if (storeScalarData) {
        console.log("Not transient, should store value", scalarData);
      }
      return scalarData;
    }
    throw new Error("No scalar data available");
  }
  setScalarData(newScalarData) {
    this.scalarData = newScalarData;
  }
  getScalarDataLength() {
    if (this.scalarData) {
      return this.scalarData.length;
    }
    if (this._getScalarDataLength) {
      return this._getScalarDataLength();
    }
    throw new Error("No scalar data available");
  }
  get sizeInBytes() {
    return this.getScalarDataLength() * this.bytePerVoxel;
  }
  get bytePerVoxel() {
    if (this.scalarData) {
      return this.scalarData.BYTES_PER_ELEMENT;
    }
    const value = this._get(0);
    return value.BYTES_PER_ELEMENT;
  }
  clear() {
    this.map?.clear();
    this.boundsIJK.map((bound) => {
      bound[0] = Infinity;
      bound[1] = -Infinity;
    });
    this.modifiedSlices.clear();
    this.points?.clear();
  }
  getConstructor() {
    if (this.scalarData) {
      return this.scalarData.constructor;
    }
    if (this._getConstructor) {
      return this._getConstructor();
    }
    console.warn("No scalar data available or can be used to get the constructor");
    return Float32Array;
  }
  getArrayOfModifiedSlices() {
    return Array.from(this.modifiedSlices);
  }
  resetModifiedSlices() {
    this.modifiedSlices.clear();
  }
  static addBounds(bounds, point) {
    if (!bounds) {
      bounds = [
        [Infinity, -Infinity],
        [Infinity, -Infinity],
        [Infinity, -Infinity]
      ];
    }
    bounds[0][0] = Math.min(point[0], bounds[0][0]);
    bounds[0][1] = Math.max(point[0], bounds[0][1]);
    bounds[1][0] = Math.min(point[1], bounds[1][0]);
    bounds[1][1] = Math.max(point[1], bounds[1][1]);
    bounds[2][0] = Math.min(point[2], bounds[2][0]);
    bounds[2][1] = Math.max(point[2], bounds[2][1]);
  }
  addPoint(point) {
    const index2 = Array.isArray(point) ? point[0] + this.width * point[1] + this.frameSize * point[2] : point;
    if (!this.points) {
      this.points = new Set;
    }
    this.points.add(index2);
  }
  getPoints() {
    return this.points ? [...this.points].map((index2) => this.toIJK(index2)) : [];
  }
  setSliceDataValue(sliceData, index2, value) {
    if (Array.isArray(value)) {
      for (let i = 0;i < value.length; i++) {
        sliceData[index2 * value.length + i] = this.toNumber(value[i]);
      }
    } else {
      sliceData[index2] = this.toNumber(value);
    }
  }
  toNumber(value) {
    if (typeof value === "number") {
      return value;
    }
    if (Array.isArray(value)) {
      return value[0] || 0;
    }
    return 0;
  }
  static _createRGBScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents = 3 }) {
    const voxels = new VoxelManager(dimensions, {
      _get: (index2) => {
        index2 *= numberOfComponents;
        return [
          scalarData[index2++],
          scalarData[index2++],
          scalarData[index2++]
        ];
      },
      _id: "_createRGBScalarVolumeVoxelManager",
      _set: (index2, v) => {
        index2 *= 3;
        const isChanged = !isEqual(scalarData[index2], v);
        scalarData[index2++] = v[0];
        scalarData[index2++] = v[1];
        scalarData[index2++] = v[2];
        return isChanged;
      },
      numberOfComponents,
      scalarData
    });
    voxels.clear = () => {
      scalarData.fill(0);
    };
    return voxels;
  }
  static createImageVolumeVoxelManager({ dimensions, imageIds, numberOfComponents = 1 }) {
    const pixelsPerSlice = dimensions[0] * dimensions[1];
    function getPixelInfo(index2) {
      const sliceIndex = Math.floor(index2 / pixelsPerSlice);
      if (sliceIndex < 0 || sliceIndex >= dimensions[2]) {
        return {};
      }
      const imageId = imageIds[sliceIndex];
      if (!imageId) {
        console.warn(`ImageId not found for sliceIndex: ${sliceIndex}`);
        return { pixelData: null, pixelIndex: null };
      }
      const image = cache_default.getImage(imageId);
      if (!image) {
        console.warn(`Image not found for imageId: ${imageId}`);
        return { pixelData: null, pixelIndex: null };
      }
      const voxelManager2 = image.voxelManager;
      const pixelIndex = index2 % pixelsPerSlice;
      return { voxelManager: voxelManager2, pixelIndex };
    }
    function getVoxelValue(index2) {
      const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(index2);
      if (!imageVoxelManager || pixelIndex === null) {
        return null;
      }
      return imageVoxelManager.getAtIndex(pixelIndex);
    }
    function setVoxelValue(index2, v) {
      const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(index2);
      if (!imageVoxelManager || pixelIndex === null) {
        return false;
      }
      const currentValue = imageVoxelManager.getAtIndex(pixelIndex);
      const isChanged = !isEqual(v, currentValue);
      if (!isChanged) {
        return isChanged;
      }
      imageVoxelManager.setAtIndex(pixelIndex, v);
      return true;
    }
    const _getConstructor = () => {
      const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(0);
      if (!imageVoxelManager || pixelIndex === null) {
        return null;
      }
      return imageVoxelManager.getConstructor();
    };
    const voxelManager = new VoxelManager(dimensions, {
      _get: getVoxelValue,
      _set: setVoxelValue,
      numberOfComponents,
      _getConstructor,
      _id: "createImageVolumeVoxelManager"
    });
    voxelManager.getMiddleSliceData = () => {
      const middleSliceIndex = Math.floor(dimensions[2] / 2);
      return voxelManager.getSliceData({
        sliceIndex: middleSliceIndex,
        slicePlane: 2
      });
    };
    voxelManager.clear = () => {
      for (const imageId of imageIds) {
        const image = cache_default.getImage(imageId);
        image.voxelManager.clear();
      }
    };
    voxelManager.getRange = () => {
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const imageId of imageIds) {
        const image = cache_default.getImage(imageId);
        if (!image) {
          continue;
        }
        if (image.minPixelValue < minValue) {
          minValue = image.minPixelValue;
        }
        if (image.maxPixelValue > maxValue) {
          maxValue = image.maxPixelValue;
        }
      }
      if (minValue === Infinity && maxValue === -Infinity) {
        return [0, 0];
      }
      return [minValue, maxValue];
    };
    voxelManager._getScalarDataLength = () => {
      const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(0);
      if (!imageVoxelManager || pixelIndex === null) {
        return 0;
      }
      return imageVoxelManager.getScalarDataLength() * dimensions[2];
    };
    voxelManager.getCompleteScalarDataArray = () => {
      const ScalarDataConstructor = voxelManager._getConstructor();
      if (!ScalarDataConstructor) {
        return new Uint8Array(0);
      }
      const dataLength = voxelManager.getScalarDataLength();
      const scalarData = new ScalarDataConstructor(dataLength);
      const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
      for (let sliceIndex = 0;sliceIndex < dimensions[2]; sliceIndex++) {
        const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(sliceIndex * sliceSize / numberOfComponents);
        if (imageVoxelManager && pixelIndex !== null) {
          const sliceStart = sliceIndex * sliceSize;
          const pixelData = imageVoxelManager.getScalarData();
          if (numberOfComponents === 1) {
            scalarData.set(pixelData, sliceStart);
          } else {
            for (let i = 0;i < pixelData.length; i += numberOfComponents) {
              for (let j = 0;j < numberOfComponents; j++) {
                scalarData[sliceStart + i + j] = pixelData[i + j];
              }
            }
          }
        }
      }
      return scalarData;
    };
    voxelManager.setCompleteScalarDataArray = (scalarData) => {
      const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
      const SliceDataConstructor = voxelManager._getConstructor();
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (let sliceIndex = 0;sliceIndex < dimensions[2]; sliceIndex++) {
        const { voxelManager: imageVoxelManager } = getPixelInfo(sliceIndex * sliceSize / numberOfComponents);
        if (imageVoxelManager && SliceDataConstructor) {
          const sliceStart = sliceIndex * sliceSize;
          const sliceEnd = sliceStart + sliceSize;
          const sliceData = new SliceDataConstructor(sliceSize);
          sliceData.set(scalarData.subarray(sliceStart, sliceEnd));
          if (imageVoxelManager.scalarData) {
            imageVoxelManager.scalarData.set(sliceData);
            imageVoxelManager.modifiedSlices.add(sliceIndex);
          } else {
            for (let i = 0;i < sliceSize; i++) {
              imageVoxelManager.setAtIndex(i, sliceData[i]);
            }
          }
          for (let i = 0;i < sliceData.length; i++) {
            const value = sliceData[i];
            minValue = Math.min(minValue, value);
            maxValue = Math.max(maxValue, value);
          }
          const imageId = imageIds[sliceIndex];
          const image = cache_default.getImage(imageId);
          if (image) {
            image.minPixelValue = minValue;
            image.maxPixelValue = maxValue;
          }
        }
      }
      for (let k = 0;k < dimensions[2]; k++) {
        voxelManager.modifiedSlices.add(k);
      }
      voxelManager.boundsIJK = [
        [0, dimensions[0] - 1],
        [0, dimensions[1] - 1],
        [0, dimensions[2] - 1]
      ];
    };
    return voxelManager;
  }
  static createScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents }) {
    if (dimensions.length !== 3) {
      throw new Error("Dimensions must be provided as [number, number, number] for [width, height, depth]");
    }
    if (!numberOfComponents) {
      numberOfComponents = scalarData.length / dimensions[0] / dimensions[1] / dimensions[2];
      if (numberOfComponents > 4 || numberOfComponents < 1 || numberOfComponents === 2) {
        throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
      }
    }
    if (numberOfComponents > 1) {
      return VoxelManager._createRGBScalarVolumeVoxelManager({
        dimensions,
        scalarData,
        numberOfComponents
      });
    }
    return VoxelManager._createNumberVolumeVoxelManager({
      dimensions,
      scalarData
    });
  }
  static createScalarDynamicVolumeVoxelManager({ imageIdGroups, dimensions, dimensionGroupNumber = 1, timePoint = 0, numberOfComponents = 1 }) {
    let activeDimensionGroup = 0;
    if (dimensionGroupNumber !== undefined) {
      activeDimensionGroup = dimensionGroupNumber - 1;
    } else if (timePoint !== undefined) {
      console.warn("Warning: timePoint parameter is deprecated. Please use dimensionGroupNumber instead. timePoint is zero-based while dimensionGroupNumber starts at 1.");
      activeDimensionGroup = timePoint;
    }
    if (!numberOfComponents) {
      const firstImage = cache_default.getImage(imageIdGroups[0][0]);
      if (!firstImage) {
        throw new Error("Unable to determine number of components: No image found");
      }
      numberOfComponents = firstImage.getPixelData().length / (dimensions[0] * dimensions[1]);
      if (numberOfComponents > 4 || numberOfComponents < 1 || numberOfComponents === 2) {
        throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
      }
    }
    const voxelGroups = imageIdGroups.map((imageIds) => {
      return VoxelManager.createImageVolumeVoxelManager({
        dimensions,
        imageIds,
        numberOfComponents
      });
    });
    const voxelManager = new VoxelManager(dimensions, {
      _get: (index2) => voxelGroups[activeDimensionGroup]._get(index2),
      _set: (index2, v) => voxelGroups[activeDimensionGroup]._set(index2, v),
      numberOfComponents,
      _id: "createScalarDynamicVolumeVoxelManager"
    });
    voxelManager.getScalarDataLength = () => {
      return voxelGroups[activeDimensionGroup].getScalarDataLength();
    };
    voxelManager.getConstructor = () => {
      return voxelGroups[activeDimensionGroup].getConstructor();
    };
    voxelManager.getRange = () => {
      return voxelGroups[activeDimensionGroup].getRange();
    };
    voxelManager.getMiddleSliceData = () => {
      return voxelGroups[activeDimensionGroup].getMiddleSliceData();
    };
    voxelManager.setTimePoint = (newTimePoint) => {
      console.warn("Warning: setTimePoint is deprecated. Please use setDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.");
      voxelManager.setDimensionGroupNumber(newTimePoint + 1);
    };
    voxelManager.setDimensionGroupNumber = (newDimensionGroupNumber) => {
      activeDimensionGroup = newDimensionGroupNumber - 1;
      voxelManager._get = (index2) => voxelGroups[activeDimensionGroup]._get(index2);
      voxelManager._set = (index2, v) => voxelGroups[activeDimensionGroup]._set(index2, v);
    };
    voxelManager.getAtIndexAndTimePoint = (index2, tp) => {
      console.warn("Warning: getAtIndexAndTimePoint is deprecated. Please use getAtIndexAndDimensionGroup instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.");
      return voxelManager.getAtIndexAndDimensionGroup(index2, tp + 1);
    };
    voxelManager.getAtIndexAndDimensionGroup = (index2, dimensionGroupNumber2) => {
      return voxelGroups[dimensionGroupNumber2 - 1]._get(index2);
    };
    voxelManager.getTimePointScalarData = (tp) => {
      console.warn("Warning: getTimePointScalarData is deprecated. Please use getDimensionGroupScalarData instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.");
      return voxelManager.getDimensionGroupScalarData(tp + 1);
    };
    voxelManager.getDimensionGroupScalarData = (dimensionGroupNumber2) => {
      return voxelGroups[dimensionGroupNumber2 - 1].getCompleteScalarDataArray();
    };
    voxelManager.getCurrentTimePointScalarData = () => {
      console.warn("Warning: getCurrentTimePointScalarData is deprecated. Please use getCurrentDimensionGroupScalarData instead.");
      return voxelManager.getCurrentDimensionGroupScalarData();
    };
    voxelManager.getCurrentDimensionGroupScalarData = () => {
      return voxelGroups[activeDimensionGroup].getCompleteScalarDataArray();
    };
    voxelManager.getCurrentTimePoint = () => {
      console.warn("Warning: getCurrentTimePoint is deprecated. Please use getCurrentDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.");
      return activeDimensionGroup;
    };
    voxelManager.getCurrentDimensionGroupNumber = () => {
      return activeDimensionGroup + 1;
    };
    return voxelManager;
  }
  static createImageVoxelManager({ width, height, scalarData, numberOfComponents = 1 }) {
    const dimensions = [width, height, 1];
    if (!numberOfComponents) {
      numberOfComponents = scalarData.length / width / height;
      if (numberOfComponents > 4 || numberOfComponents < 1 || numberOfComponents === 2) {
        throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
      }
    }
    if (numberOfComponents > 1) {
      return VoxelManager._createRGBScalarVolumeVoxelManager({
        dimensions,
        scalarData,
        numberOfComponents
      });
    }
    return VoxelManager._createNumberVolumeVoxelManager({
      dimensions,
      scalarData
    });
  }
  static _createNumberVolumeVoxelManager({ dimensions, scalarData }) {
    const voxels = new VoxelManager(dimensions, {
      _get: (index2) => scalarData[index2],
      _set: (index2, v) => {
        const isChanged = scalarData[index2] !== v;
        scalarData[index2] = v;
        return isChanged;
      },
      _getConstructor: () => scalarData.constructor,
      _id: "_createNumberVolumeVoxelManager"
    });
    voxels.scalarData = scalarData;
    voxels.clear = () => {
      voxels.scalarData.fill(0);
    };
    voxels.getMiddleSliceData = () => {
      const middleSliceIndex = Math.floor(dimensions[2] / 2);
      return voxels.getSliceData({
        sliceIndex: middleSliceIndex,
        slicePlane: 2
      });
    };
    return voxels;
  }
  static createMapVoxelManager({ dimension }) {
    const map = new Map;
    const voxelManager = new VoxelManager(dimension, {
      _get: map.get.bind(map),
      _set: (index2, v) => map.set(index2, v) && true,
      _id: "createMapVoxelManager"
    });
    voxelManager.map = map;
    return voxelManager;
  }
  static createHistoryVoxelManager({ sourceVoxelManager }) {
    const map = new Map;
    const { dimensions } = sourceVoxelManager;
    const voxelManager = new VoxelManager(dimensions, {
      _get: (index2) => map.get(index2),
      _set: function(index2, v) {
        if (!map.has(index2)) {
          const oldV = this.sourceVoxelManager.getAtIndex(index2);
          if (oldV === v) {
            return false;
          }
          map.set(index2, oldV);
        } else if (v === map.get(index2)) {
          map.delete(index2);
        }
        this.sourceVoxelManager.setAtIndex(index2, v);
      },
      _id: "createHistoryVoxelManager"
    });
    voxelManager.map = map;
    voxelManager.scalarData = sourceVoxelManager.scalarData;
    voxelManager.sourceVoxelManager = sourceVoxelManager;
    return voxelManager;
  }
  static createRLEHistoryVoxelManager(sourceVoxelManager) {
    const { dimensions } = sourceVoxelManager;
    const map = new RLEVoxelMap(dimensions[0], dimensions[1], dimensions[2]);
    const voxelManager = new VoxelManager(dimensions, {
      _get: (index2) => map.get(index2),
      _set: function(index2, v) {
        const originalV = map.get(index2);
        if (originalV === undefined) {
          const oldV = this.sourceVoxelManager.getAtIndex(index2);
          if (oldV === v || oldV === undefined && v === 0 || v === null) {
            return false;
          }
          map.set(index2, oldV ?? 0);
        } else if (v === originalV || v === null) {
          map.delete(index2);
          v = originalV;
        }
        this.sourceVoxelManager.setAtIndex(index2, v);
      },
      _getScalarData: RLEVoxelMap.getScalarData,
      _updateScalarData: (scalarData) => {
        map.updateScalarData(scalarData);
        return scalarData;
      },
      _id: "createRLEHistoryVoxelManager"
    });
    voxelManager.map = map;
    voxelManager.sourceVoxelManager = sourceVoxelManager;
    return voxelManager;
  }
  static createLazyVoxelManager({ dimensions, planeFactory }) {
    const map = new Map;
    const [width, height] = dimensions;
    const planeSize = width * height;
    const voxelManager = new VoxelManager(dimensions, {
      _get: (index2) => map.get(Math.floor(index2 / planeSize))[index2 % planeSize],
      _set: (index2, v) => {
        const k = Math.floor(index2 / planeSize);
        let layer = map.get(k);
        if (!layer) {
          layer = planeFactory(width, height);
          map.set(k, layer);
        }
        layer[index2 % planeSize] = v;
        return true;
      },
      _id: "createLazyVoxelManager"
    });
    voxelManager.map = map;
    return voxelManager;
  }
  static createRLEVolumeVoxelManager({ dimensions }) {
    const [width, height, depth] = dimensions;
    const map = new RLEVoxelMap(width, height, depth);
    const voxelManager = new VoxelManager(dimensions, {
      _get: (index2) => map.get(index2),
      _set: (index2, v) => {
        map.set(index2, v);
        return true;
      },
      _getScalarData: RLEVoxelMap.getScalarData,
      _updateScalarData: (scalarData) => {
        map.updateScalarData(scalarData);
        return scalarData;
      },
      _id: "createRLEVolumeVoxelManager"
    });
    voxelManager.map = map;
    voxelManager.getPixelData = map.getPixelData.bind(map);
    return voxelManager;
  }
  static createRLEImageVoxelManager({ dimensions }) {
    const [width, height] = dimensions;
    return VoxelManager.createRLEVolumeVoxelManager({
      dimensions: [width, height, 1]
    });
  }
  static addInstanceToImage(image) {
    const { width, height } = image;
    const scalarData = image.voxelManager.getScalarData();
    if (scalarData.length >= width * height) {
      image.voxelManager = VoxelManager.createScalarVolumeVoxelManager({
        dimensions: [width, height, 1],
        scalarData
      });
      return;
    }
    image.voxelManager = VoxelManager.createRLEVolumeVoxelManager({
      dimensions: [width, height, 1]
    });
    image.getPixelData = image.voxelManager.getPixelData;
    image.sizeInBytes = DEFAULT_RLE_SIZE;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ImageVolume.js
class ImageVolume {
  constructor(props) {
    this._imageIdsIndexMap = new Map;
    this._imageURIsIndexMap = new Map;
    this.cornerstoneImageMetaData = null;
    this.isPreScaled = false;
    this.numTimePoints = null;
    this.numFrames = null;
    const { imageIds, scaling, dimensions, spacing, origin, direction, dataType, volumeId, referencedVolumeId, metadata, referencedImageIds, additionalDetails, voxelManager, numberOfComponents } = props;
    if (!dataType) {
      throw new Error('Data type is required, please provide a data type as string such as "Uint8Array", "Float32Array", etc.');
    }
    let { imageData } = props;
    this.imageIds = imageIds;
    this.volumeId = volumeId;
    this.metadata = metadata;
    this.dimensions = dimensions;
    this.spacing = spacing;
    this.origin = origin;
    this.direction = direction;
    this.dataType = dataType;
    this.vtkOpenGLTexture = vtkStreamingOpenGLTexture_default.newInstance();
    this.vtkOpenGLTexture.setVolumeId(volumeId);
    this.voxelManager = voxelManager ?? VoxelManager.createImageVolumeVoxelManager({
      dimensions,
      imageIds,
      numberOfComponents
    });
    this.numVoxels = this.dimensions[0] * this.dimensions[1] * this.dimensions[2];
    if (!imageData) {
      imageData = vtkImageData$1.newInstance();
      imageData.setDimensions(dimensions);
      imageData.setSpacing(spacing);
      imageData.setDirection(direction);
      imageData.setOrigin(origin);
    }
    imageData.set({
      dataType,
      voxelManager: this.voxelManager,
      id: volumeId,
      numberOfComponents: numberOfComponents || 1
    });
    imageData.set({
      hasScalarVolume: false
    });
    this.imageData = imageData;
    this.numFrames = this._getNumFrames();
    this._reprocessImageIds();
    if (scaling) {
      this.scaling = scaling;
    }
    if (referencedVolumeId) {
      this.referencedVolumeId = referencedVolumeId;
    }
    if (referencedImageIds) {
      this.referencedImageIds = referencedImageIds;
    }
    if (additionalDetails) {
      this.additionalDetails = additionalDetails;
    }
  }
  get sizeInBytes() {
    return this.voxelManager.sizeInBytes;
  }
  get imageIds() {
    return this._imageIds;
  }
  set imageIds(newImageIds) {
    this._imageIds = newImageIds;
    this._reprocessImageIds();
  }
  _reprocessImageIds() {
    this._imageIdsIndexMap.clear();
    this._imageURIsIndexMap.clear();
    this._imageIds.forEach((imageId, i) => {
      const imageURI = imageIdToURI(imageId);
      this._imageIdsIndexMap.set(imageId, i);
      this._imageURIsIndexMap.set(imageURI, i);
    });
  }
  isDynamicVolume() {
    return this.numTimePoints > 1;
  }
  getImageIdIndex(imageId) {
    return this._imageIdsIndexMap.get(imageId);
  }
  getImageIdByIndex(imageIdIndex) {
    return this._imageIds[imageIdIndex];
  }
  getImageURIIndex(imageURI) {
    return this._imageURIsIndexMap.get(imageURI);
  }
  load(callback) {
  }
  destroy() {
    this.imageData.delete();
    this.imageData = null;
    this.voxelManager.clear();
    this.vtkOpenGLTexture.releaseGraphicsResources();
    this.vtkOpenGLTexture.delete();
  }
  invalidate() {
    for (let i = 0;i < this.imageIds.length; i++) {
      this.vtkOpenGLTexture.setUpdatedFrame(i);
    }
    this.imageData.modified();
  }
  modified() {
    this.imageData.modified();
    this.vtkOpenGLTexture.modified();
    this.numFrames = this._getNumFrames();
  }
  removeFromCache() {
    cache_default.removeVolumeLoadObject(this.volumeId);
  }
  getScalarDataLength() {
    return this.voxelManager.getScalarDataLength();
  }
  _getNumFrames() {
    if (!this.isDynamicVolume()) {
      return this.imageIds.length;
    }
    return this.numTimePoints;
  }
  imageIdIndexToFrameIndex(imageIdIndex) {
    return imageIdIndex % this.numFrames;
  }
  getCornerstoneImages() {
    const { imageIds } = this;
    return imageIds.map((imageId) => {
      return cache_default.getImage(imageId);
    });
  }
}
var ImageVolume_default = ImageVolume;

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var exports_imageLoader = {};
__export(exports_imageLoader, {
  unregisterAllImageLoaders: () => unregisterAllImageLoaders,
  registerUnknownImageLoader: () => registerUnknownImageLoader,
  registerImageLoader: () => registerImageLoader,
  loadImage: () => loadImage,
  loadAndCacheImages: () => loadAndCacheImages,
  loadAndCacheImage: () => loadAndCacheImage,
  createAndCacheLocalImage: () => createAndCacheLocalImage,
  createAndCacheDerivedLabelmapImages: () => createAndCacheDerivedLabelmapImages,
  createAndCacheDerivedLabelmapImage: () => createAndCacheDerivedLabelmapImage,
  createAndCacheDerivedImages: () => createAndCacheDerivedImages,
  createAndCacheDerivedImage: () => createAndCacheDerivedImage,
  cancelLoadImages: () => cancelLoadImages,
  cancelLoadImage: () => cancelLoadImage,
  cancelLoadAll: () => cancelLoadAll
});

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/genericMetadataProvider.js
var state = {};
var metadataProvider = {
  add: (imageId, payload) => {
    metadataProvider.addRaw(imageId, {
      ...payload,
      metadata: structuredClone(payload.metadata)
    });
  },
  addRaw: (imageId, payload) => {
    const type = payload.type;
    if (!state[imageId]) {
      state[imageId] = {};
    }
    state[imageId][type] = payload.metadata;
  },
  get: (type, imageId) => {
    return state[imageId]?.[type];
  },
  clear: () => {
    state = {};
  }
};
addProvider(metadataProvider.get);
var genericMetadataProvider_default = metadataProvider;

// ../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = new RequestPoolManager("imageLoadPool");
imageLoadPoolManager.grabDelay = 0;
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType_default.Interaction, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType_default.Thumbnail, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(RequestType_default.Prefetch, 1000);
var imageLoadPoolManager_default = imageLoadPoolManager;

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoaders = {};
var unknownImageLoader;
function loadImageFromImageLoader(imageId, options) {
  const cachedImageLoadObject = cache_default.getImageLoadObject(imageId);
  if (cachedImageLoadObject) {
    handleImageLoadPromise(cachedImageLoadObject.promise, imageId);
    return cachedImageLoadObject;
  }
  const scheme = imageId.split(":")[0];
  const loader = imageLoaders[scheme] || unknownImageLoader;
  if (!loader) {
    throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);
  }
  const imageLoadObject = loader(imageId, options);
  handleImageLoadPromise(imageLoadObject.promise, imageId);
  return imageLoadObject;
}
function handleImageLoadPromise(imagePromise, imageId) {
  Promise.resolve(imagePromise).then((image) => {
    ensureVoxelManager(image);
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOADED, { image });
  }).catch((error) => {
    const errorDetails = {
      imageId,
      error
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOAD_FAILED, errorDetails);
  });
}
function ensureVoxelManager(image) {
  if (!image.voxelManager) {
    const { width, height, numberOfComponents } = image;
    const voxelManager = VoxelManager.createImageVoxelManager({
      scalarData: image.getPixelData(),
      width,
      height,
      numberOfComponents
    });
    image.voxelManager = voxelManager;
    image.getPixelData = () => voxelManager.getScalarData();
    delete image.imageFrame.pixelData;
  }
}
function loadImage(imageId, options = { priority: 0, requestType: "prefetch" }) {
  if (imageId === undefined) {
    throw new Error("loadImage: parameter imageId must not be undefined");
  }
  return loadImageFromImageLoader(imageId, options).promise;
}
function loadAndCacheImage(imageId, options = { priority: 0, requestType: "prefetch" }) {
  if (imageId === undefined) {
    throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
  }
  const imageLoadObject = loadImageFromImageLoader(imageId, options);
  if (!cache_default.getImageLoadObject(imageId)) {
    cache_default.putImageLoadObject(imageId, imageLoadObject);
  }
  return imageLoadObject.promise;
}
function loadAndCacheImages(imageIds, options = { priority: 0, requestType: "prefetch" }) {
  if (!imageIds || imageIds.length === 0) {
    throw new Error("loadAndCacheImages: parameter imageIds must be list of image Ids");
  }
  const allPromises = imageIds.map((imageId) => {
    return loadAndCacheImage(imageId, options);
  });
  return allPromises;
}
function createAndCacheDerivedImage(referencedImageId, options = {}) {
  if (referencedImageId === undefined) {
    throw new Error("createAndCacheDerivedImage: parameter imageId must not be undefined");
  }
  if (options.imageId === undefined) {
    options.imageId = `derived:${uuidv4()}`;
  }
  const { imageId, skipCreateBuffer, onCacheAdd, voxelRepresentation } = options;
  const imagePlaneModule = getMetaData("imagePlaneModule", referencedImageId);
  const length5 = imagePlaneModule.rows * imagePlaneModule.columns;
  const { TypedArrayConstructor } = getBufferConfiguration(options.targetBuffer?.type, length5);
  const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length5);
  const derivedImageId = imageId;
  const referencedImagePlaneMetadata = getMetaData("imagePlaneModule", referencedImageId);
  genericMetadataProvider_default.add(derivedImageId, {
    type: "imagePlaneModule",
    metadata: referencedImagePlaneMetadata
  });
  const referencedImageGeneralSeriesMetadata = getMetaData("generalSeriesModule", referencedImageId);
  genericMetadataProvider_default.add(derivedImageId, {
    type: "generalSeriesModule",
    metadata: referencedImageGeneralSeriesMetadata
  });
  genericMetadataProvider_default.add(derivedImageId, {
    type: "generalImageModule",
    metadata: {
      instanceNumber: options.instanceNumber
    }
  });
  const imagePixelModule = getMetaData("imagePixelModule", referencedImageId);
  genericMetadataProvider_default.add(derivedImageId, {
    type: "imagePixelModule",
    metadata: {
      ...imagePixelModule,
      bitsAllocated: 8,
      bitsStored: 8,
      highBit: 7,
      samplesPerPixel: 1,
      pixelRepresentation: 0
    }
  });
  const localImage = createAndCacheLocalImage(imageId, {
    scalarData: imageScalarData,
    onCacheAdd,
    skipCreateBuffer,
    targetBuffer: {
      type: imageScalarData.constructor.name
    },
    voxelRepresentation,
    dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],
    spacing: [
      imagePlaneModule.columnPixelSpacing,
      imagePlaneModule.rowPixelSpacing
    ],
    origin: imagePlaneModule.imagePositionPatient,
    direction: imagePlaneModule.imageOrientationPatient,
    frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID
  });
  localImage.referencedImageId = referencedImageId;
  if (!cache_default.getImageLoadObject(imageId)) {
    cache_default.putImageSync(imageId, localImage);
  }
  return localImage;
}
function createAndCacheDerivedImages(referencedImageIds, options = {}) {
  if (referencedImageIds.length === 0) {
    throw new Error("createAndCacheDerivedImages: parameter imageIds must be list of image Ids");
  }
  const derivedImageIds = [];
  const images = referencedImageIds.map((referencedImageId, index2) => {
    const newOptions = {
      imageId: options?.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,
      ...options
    };
    derivedImageIds.push(newOptions.imageId);
    return createAndCacheDerivedImage(referencedImageId, {
      ...newOptions,
      instanceNumber: index2 + 1
    });
  });
  return images;
}
function createAndCacheLocalImage(imageId, options) {
  const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, voxelRepresentation } = options;
  const dimensions = options.dimensions;
  const spacing = options.spacing;
  if (!dimensions || !spacing) {
    throw new Error("createAndCacheLocalImage: dimensions and spacing are required");
  }
  const width = dimensions[0];
  const height = dimensions[1];
  const columnPixelSpacing = spacing[0];
  const rowPixelSpacing = spacing[1];
  const imagePlaneModule = {
    frameOfReferenceUID,
    rows: height,
    columns: width,
    imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],
    rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],
    columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],
    imagePositionPatient: origin ?? [0, 0, 0],
    pixelSpacing: [rowPixelSpacing, columnPixelSpacing],
    rowPixelSpacing,
    columnPixelSpacing
  };
  const length5 = width * height;
  const numberOfComponents = scalarData.length / length5;
  let scalarDataToUse;
  if (scalarData) {
    if (!(scalarData instanceof Uint8Array || scalarData instanceof Float32Array || scalarData instanceof Uint16Array || scalarData instanceof Int16Array)) {
      throw new Error("createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array");
    }
    scalarDataToUse = scalarData;
  } else if (!skipCreateBuffer) {
    const { TypedArrayConstructor } = getBufferConfiguration(targetBuffer?.type, length5);
    const imageScalarData = new TypedArrayConstructor(length5);
    scalarDataToUse = imageScalarData;
  }
  let bitsAllocated, bitsStored, highBit;
  if (scalarDataToUse instanceof Uint8Array) {
    bitsAllocated = 8;
    bitsStored = 8;
    highBit = 7;
  } else if (scalarDataToUse instanceof Uint16Array) {
    bitsAllocated = 16;
    bitsStored = 16;
    highBit = 15;
  } else if (scalarDataToUse instanceof Int16Array) {
    bitsAllocated = 16;
    bitsStored = 16;
    highBit = 15;
  } else if (scalarDataToUse instanceof Float32Array) {
    bitsAllocated = 32;
    bitsStored = 32;
    highBit = 31;
  } else {
    throw new Error("Unsupported scalarData type");
  }
  const imagePixelModule = {
    samplesPerPixel: 1,
    photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1] ? "RGB" : "MONOCHROME2",
    rows: height,
    columns: width,
    bitsAllocated,
    bitsStored,
    highBit
  };
  const metadata = {
    imagePlaneModule,
    imagePixelModule
  };
  ["imagePlaneModule", "imagePixelModule"].forEach((type) => {
    genericMetadataProvider_default.add(imageId, {
      type,
      metadata: metadata[type] || {}
    });
  });
  const voxelManager = voxelRepresentation === VoxelManagerEnum_default.RLE && VoxelManager.createRLEImageVoxelManager({ dimensions }) || VoxelManager.createImageVoxelManager({
    height,
    width,
    numberOfComponents,
    scalarData: scalarDataToUse
  });
  let minPixelValue = scalarDataToUse[0];
  let maxPixelValue = scalarDataToUse[0];
  for (let i = 1;i < scalarDataToUse.length; i++) {
    if (scalarDataToUse[i] < minPixelValue) {
      minPixelValue = scalarDataToUse[i];
    }
    if (scalarDataToUse[i] > maxPixelValue) {
      maxPixelValue = scalarDataToUse[i];
    }
  }
  const image = {
    imageId,
    intercept: 0,
    windowCenter: 0,
    windowWidth: 0,
    color: imagePixelModule.photometricInterpretation === "RGB",
    numberOfComponents: imagePixelModule.samplesPerPixel,
    dataType: targetBuffer?.type,
    slope: 1,
    minPixelValue,
    maxPixelValue,
    rows: imagePixelModule.rows,
    columns: imagePixelModule.columns,
    getCanvas: undefined,
    height: imagePixelModule.rows,
    width: imagePixelModule.columns,
    rgba: undefined,
    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,
    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,
    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,
    invert: false,
    getPixelData: () => voxelManager.getScalarData(),
    voxelManager,
    sizeInBytes: scalarData.byteLength
  };
  onCacheAdd?.(image);
  cache_default.putImageSync(image.imageId, image);
  return image;
}
function cancelLoadImage(imageId) {
  const filterFunction = ({ additionalDetails }) => {
    if (additionalDetails.imageId) {
      return additionalDetails.imageId !== imageId;
    }
    return true;
  };
  imageLoadPoolManager_default.filterRequests(filterFunction);
  const imageLoadObject = cache_default.getImageLoadObject(imageId);
  if (imageLoadObject) {
    imageLoadObject.cancelFn();
  }
}
function cancelLoadImages(imageIds) {
  imageIds.forEach((imageId) => {
    cancelLoadImage(imageId);
  });
}
function cancelLoadAll() {
  const requestPool = imageLoadPoolManager_default.getRequestPool();
  Object.keys(requestPool).forEach((type) => {
    const requests = requestPool[type];
    Object.keys(requests).forEach((priority) => {
      const requestDetails = requests[priority].pop();
      if (!requestDetails) {
        return;
      }
      const additionalDetails = requestDetails.additionalDetails;
      const { imageId, volumeId } = additionalDetails;
      let loadObject;
      if (imageId) {
        loadObject = cache_default.getImageLoadObject(imageId);
      } else if (volumeId) {
        loadObject = cache_default.getVolumeLoadObject(volumeId);
      }
      if (loadObject) {
        loadObject.cancel();
      }
    });
    imageLoadPoolManager_default.clearRequestStack(type);
  });
}
function registerImageLoader(scheme, imageLoader) {
  imageLoaders[scheme] = imageLoader;
}
function registerUnknownImageLoader(imageLoader) {
  const oldImageLoader = unknownImageLoader;
  unknownImageLoader = imageLoader;
  return oldImageLoader;
}
function unregisterAllImageLoaders() {
  Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);
  unknownImageLoader = undefined;
}
function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {
  return createAndCacheDerivedImages(referencedImageIds, {
    ...options,
    targetBuffer: { type: "Uint8Array" }
  });
}
function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {
  return createAndCacheDerivedImage(referencedImageId, {
    ...options,
    targetBuffer: { type: "Uint8Array" }
  });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js
function makeVolumeMetadata(imageIds) {
  const imageId0 = imageIds[0];
  const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel } = getMetaData("imagePixelModule", imageId0);
  const voiLut = [];
  const voiLutModule = getMetaData("voiLutModule", imageId0);
  let voiLUTFunction;
  if (voiLutModule) {
    const { windowWidth, windowCenter } = voiLutModule;
    voiLUTFunction = voiLutModule?.voiLUTFunction;
    if (Array.isArray(windowWidth)) {
      for (let i = 0;i < windowWidth.length; i++) {
        voiLut.push({
          windowWidth: windowWidth[i],
          windowCenter: windowCenter[i]
        });
      }
    } else {
      voiLut.push({
        windowWidth,
        windowCenter
      });
    }
  } else {
    voiLut.push({
      windowWidth: undefined,
      windowCenter: undefined
    });
  }
  const { modality, seriesInstanceUID } = getMetaData("generalSeriesModule", imageId0);
  const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows } = getMetaData("imagePlaneModule", imageId0);
  return {
    BitsAllocated: bitsAllocated,
    BitsStored: bitsStored,
    SamplesPerPixel: samplesPerPixel,
    HighBit: highBit,
    PhotometricInterpretation: photometricInterpretation,
    PixelRepresentation: pixelRepresentation,
    Modality: modality,
    ImageOrientationPatient: imageOrientationPatient,
    PixelSpacing: pixelSpacing,
    FrameOfReferenceUID: frameOfReferenceUID,
    Columns: columns,
    Rows: rows,
    voiLut,
    VOILUTFunction: voiLUTFunction,
    SeriesInstanceUID: seriesInstanceUID
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateSpacingBetweenImageIds.js
function calculateSpacingBetweenImageIds(imageIds) {
  const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient } = getMetaData("imagePlaneModule", imageIds[0]);
  const rowCosineVec = exports_vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
  const colCosineVec = exports_vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
  const scanAxisNormal = exports_vec3.create();
  exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
  const refIppVec = exports_vec3.fromValues(referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);
  const usingWadoUri = imageIds[0].split(":")[0] === "wadouri";
  let spacing;
  function getDistance(imageId) {
    const { imagePositionPatient } = getMetaData("imagePlaneModule", imageId);
    const positionVector = exports_vec3.create();
    const ippVec = exports_vec3.fromValues(imagePositionPatient[0], imagePositionPatient[1], imagePositionPatient[2]);
    exports_vec3.sub(positionVector, refIppVec, ippVec);
    return exports_vec3.dot(positionVector, scanAxisNormal);
  }
  if (!usingWadoUri) {
    const distanceImagePairs = imageIds.map((imageId) => {
      const distance4 = getDistance(imageId);
      return {
        distance: distance4,
        imageId
      };
    });
    distanceImagePairs.sort((a, b) => b.distance - a.distance);
    const numImages = distanceImagePairs.length;
    spacing = Math.abs(distanceImagePairs[numImages - 1].distance - distanceImagePairs[0].distance) / (numImages - 1);
  } else {
    const prefetchedImageIds = [
      imageIds[0],
      imageIds[Math.floor(imageIds.length / 2)]
    ];
    const firstImageDistance = getDistance(prefetchedImageIds[0]);
    const middleImageDistance = getDistance(prefetchedImageIds[1]);
    const metadataForMiddleImage = getMetaData("imagePlaneModule", prefetchedImageIds[1]);
    if (!metadataForMiddleImage) {
      throw new Error("Incomplete metadata required for volume construction.");
    }
    const positionVector = exports_vec3.create();
    const middleIppVec = exports_vec3.fromValues(metadataForMiddleImage.imagePositionPatient[0], metadataForMiddleImage.imagePositionPatient[1], metadataForMiddleImage.imagePositionPatient[2]);
    exports_vec3.sub(positionVector, refIppVec, middleIppVec);
    const distanceBetweenFirstAndMiddleImages = exports_vec3.dot(positionVector, scanAxisNormal);
    spacing = Math.abs(distanceBetweenFirstAndMiddleImages) / Math.floor(imageIds.length / 2);
  }
  const { sliceThickness, spacingBetweenSlices } = getMetaData("imagePlaneModule", imageIds[0]);
  const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;
  if (spacing === 0 && !strictZSpacingForVolumeViewport) {
    if (spacingBetweenSlices) {
      console.debug("Could not calculate spacing. Using spacingBetweenSlices");
      spacing = spacingBetweenSlices;
    } else if (sliceThickness) {
      console.debug("Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness");
      spacing = sliceThickness;
    } else {
      console.debug("Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render");
      spacing = 1;
    }
  }
  return spacing;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js
function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {
  const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient } = getMetaData("imagePlaneModule", imageIds[0]);
  if (!scanAxisNormal) {
    const rowCosineVec = exports_vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
    const colCosineVec = exports_vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
    scanAxisNormal = exports_vec3.create();
    exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
  }
  const usingWadoUri = imageIds[0].split(":")[0] === "wadouri";
  const zSpacing = calculateSpacingBetweenImageIds(imageIds);
  let sortedImageIds;
  function getDistance(imageId) {
    const { imagePositionPatient } = getMetaData("imagePlaneModule", imageId);
    const positionVector = exports_vec3.create();
    exports_vec3.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);
    return exports_vec3.dot(positionVector, scanAxisNormal);
  }
  if (!usingWadoUri) {
    const distanceImagePairs = imageIds.map((imageId) => {
      const distance4 = getDistance(imageId);
      return {
        distance: distance4,
        imageId
      };
    });
    distanceImagePairs.sort((a, b) => b.distance - a.distance);
    sortedImageIds = distanceImagePairs.map((a) => a.imageId);
  } else {
    const prefetchedImageIds = [
      imageIds[0],
      imageIds[Math.floor(imageIds.length / 2)]
    ];
    sortedImageIds = imageIds;
    const firstImageDistance = getDistance(prefetchedImageIds[0]);
    const middleImageDistance = getDistance(prefetchedImageIds[1]);
    if (firstImageDistance - middleImageDistance < 0) {
      sortedImageIds.reverse();
    }
  }
  const { imagePositionPatient: origin } = getMetaData("imagePlaneModule", sortedImageIds[0]);
  const result = {
    zSpacing,
    origin,
    sortedImageIds
  };
  return result;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js
function getScalingParameters(imageId) {
  const modalityLutModule = getMetaData("modalityLutModule", imageId) || {};
  const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
  const { modality } = generalSeriesModule;
  const scalingParameters = {
    rescaleSlope: modalityLutModule.rescaleSlope || 1,
    rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,
    modality
  };
  const suvFactor = getMetaData("scalingModule", imageId) || {};
  return {
    ...scalingParameters,
    ...modality === "PT" && {
      suvbw: suvFactor.suvbw,
      suvbsa: suvFactor.suvbsa,
      suvlbm: suvFactor.suvlbm
    }
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js
var hasFloatScalingParameters = (scalingParameters) => {
  const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === "number" && !Number.isInteger(value));
  return hasFloatRescale;
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/generateVolumePropsFromImageIds.js
var constructorToTypedArray = {
  Uint8Array: "Uint8Array",
  Int16Array: "Int16Array",
  Uint16Array: "Uint16Array",
  Float32Array: "Float32Array"
};
function generateVolumePropsFromImageIds(imageIds, volumeId) {
  const volumeMetadata = makeVolumeMetadata(imageIds);
  const { ImageOrientationPatient, PixelSpacing, Columns, Rows } = volumeMetadata;
  const rowCosineVec = exports_vec3.fromValues(ImageOrientationPatient[0], ImageOrientationPatient[1], ImageOrientationPatient[2]);
  const colCosineVec = exports_vec3.fromValues(ImageOrientationPatient[3], ImageOrientationPatient[4], ImageOrientationPatient[5]);
  const scanAxisNormal = exports_vec3.create();
  exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
  const { zSpacing, origin, sortedImageIds } = sortImageIdsAndGetSpacing(imageIds, scanAxisNormal);
  const numFrames = imageIds.length;
  const spacing = [PixelSpacing[1], PixelSpacing[0], zSpacing];
  const dimensions = [Columns, Rows, numFrames].map((it) => Math.floor(it));
  const direction = [
    ...rowCosineVec,
    ...colCosineVec,
    ...scanAxisNormal
  ];
  return {
    dimensions,
    spacing,
    origin,
    dataType: _determineDataType(sortedImageIds, volumeMetadata),
    direction,
    metadata: volumeMetadata,
    imageIds: sortedImageIds,
    volumeId,
    voxelManager: null,
    numberOfComponents: volumeMetadata.PhotometricInterpretation === "RGB" ? 3 : 1
  };
}
function _determineDataType(imageIds, volumeMetadata) {
  const { BitsAllocated, PixelRepresentation } = volumeMetadata;
  const signed = PixelRepresentation === 1;
  const cachedDataType = _getDataTypeFromCache(imageIds);
  if (cachedDataType) {
    return cachedDataType;
  }
  const [firstIndex, middleIndex, lastIndex] = [
    0,
    Math.floor(imageIds.length / 2),
    imageIds.length - 1
  ];
  const scalingParameters = [firstIndex, middleIndex, lastIndex].map((index2) => getScalingParameters(imageIds[index2]));
  const hasNegativeRescale = scalingParameters.some((params) => params.rescaleIntercept < 0 || params.rescaleSlope < 0);
  const floatAfterScale = scalingParameters.some((params) => hasFloatScalingParameters(params));
  const canRenderFloat = canRenderFloatTextures();
  switch (BitsAllocated) {
    case 8:
      return "Uint8Array";
    case 16:
      if (canRenderFloat && floatAfterScale) {
        return "Float32Array";
      }
      if (signed || hasNegativeRescale) {
        return "Int16Array";
      }
      if (!signed && !hasNegativeRescale) {
        return "Uint16Array";
      }
      return "Float32Array";
    case 24:
      return "Uint8Array";
    case 32:
      return "Float32Array";
    default:
      throw new Error(`Bits allocated of ${BitsAllocated} is not defined to generate scalarData for the volume.`);
  }
}
function _getDataTypeFromCache(imageIds) {
  const indices = [0, Math.floor(imageIds.length / 2), imageIds.length - 1];
  const images = indices.map((i) => cache_default.getImage(imageIds[i]));
  if (!images.every(Boolean)) {
    return null;
  }
  const constructorName = images[0].getPixelData().constructor.name;
  if (images.every((img) => img.getPixelData().constructor.name === constructorName) && constructorName in constructorToTypedArray) {
    return constructorToTypedArray[constructorName];
  }
  return null;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js
class ProgressiveIterator {
  constructor(name) {
    this.name = name || "unknown";
  }
  static as(promise) {
    if (promise.iterator) {
      return promise.iterator;
    }
    const iterator = new ProgressiveIterator("as iterator");
    promise.then((v) => {
      try {
        iterator.add(v, true);
      } catch (e) {
        iterator.reject(e);
      }
    }, (reason) => {
      iterator.reject(reason);
    });
    return iterator;
  }
  add(x, done = false) {
    this.nextValue = x;
    this.done ||= done;
    if (this.waiting) {
      this.waiting.resolve(x);
      this.waiting = undefined;
    }
  }
  resolve() {
    this.done = true;
    if (this.waiting) {
      this.waiting.resolve(this.nextValue);
      this.waiting = undefined;
    }
  }
  reject(reason) {
    this.rejectReason = reason;
    this.waiting?.reject(reason);
  }
  getRecent() {
    if (this.rejectReason) {
      throw this.rejectReason;
    }
    return this.nextValue;
  }
  async* [Symbol.asyncIterator]() {
    while (!this.done) {
      if (this.rejectReason) {
        throw this.rejectReason;
      }
      if (this.nextValue !== undefined) {
        yield this.nextValue;
        if (this.done) {
          break;
        }
      }
      if (!this.waiting) {
        this.waiting = {};
        this.waiting.promise = new Promise((resolve, reject) => {
          this.waiting.resolve = resolve;
          this.waiting.reject = reject;
        });
      }
      await this.waiting.promise;
    }
    yield this.nextValue;
  }
  async forEach(callback, errorCallback) {
    let index2 = 0;
    try {
      for await (const value of this) {
        const { done } = this;
        try {
          await callback(value, done, index2);
          index2++;
        } catch (e) {
          if (!done) {
            console.warn("Caught exception in intermediate value", e);
            continue;
          }
          if (errorCallback) {
            errorCallback(e, done);
          } else {
            throw e;
          }
        }
      }
    } catch (e) {
      if (errorCallback) {
        errorCallback(e, true);
      } else {
        throw e;
      }
    }
  }
  generate(processFunction, errorCallback) {
    return processFunction(this, this.reject.bind(this)).then(() => {
      if (!this.done) {
        this.resolve();
      }
    }, (reason) => {
      this.reject(reason);
      if (errorCallback) {
        errorCallback(reason);
      } else {
        console.warn("Couldn't process because", reason);
      }
    });
  }
  async nextPromise() {
    for await (const i of this) {
      if (i) {
        return i;
      }
    }
    return this.nextValue;
  }
  async donePromise() {
    for await (const i of this) {
    }
    return this.nextValue;
  }
  getNextPromise() {
    const promise = this.nextPromise();
    promise.iterator = this;
    return promise;
  }
  getDonePromise() {
    const promise = this.donePromise();
    promise.iterator = this;
    return promise;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js
var retrieveConfigurationState = new Map;
var IMAGE_RETRIEVE_CONFIGURATION = "imageRetrieveConfiguration";
var imageRetrieveMetadataProvider = {
  IMAGE_RETRIEVE_CONFIGURATION,
  clear: () => {
    retrieveConfigurationState.clear();
  },
  add: (key, payload) => {
    retrieveConfigurationState.set(key, payload);
  },
  clone: () => {
    return new Map(retrieveConfigurationState);
  },
  restore: (state2) => {
    retrieveConfigurationState.clear();
    state2.forEach((value, key) => {
      retrieveConfigurationState.set(key, value);
    });
  },
  get: (type, ...queries) => {
    if (type === IMAGE_RETRIEVE_CONFIGURATION) {
      return queries.map((query) => retrieveConfigurationState.get(query)).find((it) => it !== undefined);
    }
  }
};
addProvider(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));
var imageRetrieveMetadataProvider_default = imageRetrieveMetadataProvider;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js
function getViewportsWithVolumeId(volumeId) {
  const renderingEngines = getRenderingEngines();
  const targetViewports = [];
  renderingEngines.forEach((renderingEngine) => {
    const viewports = renderingEngine.getVolumeViewports();
    const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));
    targetViewports.push(...filteredViewports);
  });
  return targetViewports;
}
var getViewportsWithVolumeId_default = getViewportsWithVolumeId;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js
var autoLoad = (volumeId) => {
  const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);
  if (!renderingEngineAndViewportIds?.length) {
    return;
  }
  renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {
    if (!renderingEngine.hasBeenDestroyed) {
      renderingEngine.renderViewports(viewportIds);
    }
  });
};
function getRenderingEngineAndViewportsContainingVolume(volumeId) {
  const renderingEnginesArray = getRenderingEngines();
  const renderingEngineAndViewportIds = [];
  renderingEnginesArray.forEach((renderingEngine) => {
    const viewports = getViewportsWithVolumeId_default(volumeId);
    if (viewports.length) {
      renderingEngineAndViewportIds.push({
        renderingEngine,
        viewportIds: viewports.map((viewport) => viewport.id)
      });
    }
  });
  return renderingEngineAndViewportIds;
}
var autoLoad_default = autoLoad;

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/singleRetrieve.js
var singleRetrieveStages = [
  {
    id: "initialImages",
    retrieveType: "single"
  }
];
var singleRetrieve_default = singleRetrieveStages;

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/sequentialRetrieve.js
var sequentialRetrieveStages = [
  {
    id: "lossySequential",
    retrieveType: "singleFast"
  },
  {
    id: "finalSequential",
    retrieveType: "singleFinal"
  }
];
var sequentialRetrieve_default = sequentialRetrieveStages;

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/interleavedRetrieve.js
var nearbyFrames = [
  {
    offset: -1,
    imageQualityStatus: ImageQualityStatus_default.ADJACENT_REPLICATE
  },
  {
    offset: 1,
    imageQualityStatus: ImageQualityStatus_default.ADJACENT_REPLICATE
  },
  { offset: 2, imageQualityStatus: ImageQualityStatus_default.FAR_REPLICATE }
];
var interleavedRetrieveConfiguration = [
  {
    id: "initialImages",
    positions: [0.5, 0, -1],
    retrieveType: "default",
    requestType: RequestType_default.Thumbnail,
    priority: 5,
    nearbyFrames
  },
  {
    id: "quarterThumb",
    decimate: 4,
    offset: 3,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFast",
    priority: 6,
    nearbyFrames
  },
  {
    id: "halfThumb",
    decimate: 4,
    offset: 1,
    priority: 7,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFast",
    nearbyFrames
  },
  {
    id: "quarterFull",
    decimate: 4,
    offset: 2,
    priority: 8,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFinal"
  },
  {
    id: "halfFull",
    decimate: 4,
    offset: 0,
    priority: 9,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFinal"
  },
  {
    id: "threeQuarterFull",
    decimate: 4,
    offset: 1,
    priority: 10,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFinal"
  },
  {
    id: "finalFull",
    decimate: 4,
    offset: 3,
    priority: 11,
    requestType: RequestType_default.Thumbnail,
    retrieveType: "multipleFinal"
  },
  {
    id: "errorRetrieve"
  }
];
var interleavedRetrieve_default = interleavedRetrieveConfiguration;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js
function decimate(list, interleave, offset = 0) {
  const interleaveIndices = [];
  for (let i = offset;i < list.length; i += interleave) {
    interleaveIndices.push(i);
  }
  return interleaveIndices;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/fillNearbyFrames.js
function fillNearbyFrames(listener, request, image) {
  if (!request?.nearbyRequests?.length) {
    return;
  }
  for (const nearbyItem of request.nearbyRequests) {
    try {
      const { itemId: targetId, imageQualityStatus } = nearbyItem;
      const currentStatus = cache_default.getImageQuality(targetId);
      if (currentStatus !== undefined && currentStatus >= imageQualityStatus) {
        continue;
      }
      const nearbyImage = {
        ...image,
        imageId: targetId,
        imageQualityStatus
      };
      cache_default.setPartialImage(targetId, nearbyImage);
      listener.successCallback(targetId, nearbyImage);
    } catch (e) {
      console.warn("Couldn't fill nearby item ", nearbyItem.itemId, e);
    }
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js
class ProgressiveRetrieveImages {
  static {
    this.createProgressive = createProgressive;
  }
  static {
    this.interleavedRetrieveStages = {
      stages: interleavedRetrieve_default
    };
  }
  static {
    this.singleRetrieveStages = {
      stages: singleRetrieve_default
    };
  }
  static {
    this.sequentialRetrieveStages = {
      stages: sequentialRetrieve_default
    };
  }
  constructor(imageRetrieveConfiguration) {
    this.stages = imageRetrieveConfiguration.stages || singleRetrieve_default;
    this.retrieveOptions = imageRetrieveConfiguration.retrieveOptions || {};
  }
  loadImages(imageIds, listener) {
    const instance = new ProgressiveRetrieveImagesInstance(this, imageIds, listener);
    return instance.loadImages();
  }
}

class ProgressiveRetrieveImagesInstance {
  constructor(configuration, imageIds, listener) {
    this.outstandingRequests = 0;
    this.stageStatusMap = new Map;
    this.displayedIterator = new ProgressiveIterator("displayed");
    this.stages = configuration.stages;
    this.retrieveOptions = configuration.retrieveOptions;
    this.imageIds = imageIds;
    this.listener = listener;
  }
  async loadImages() {
    const interleaved = this.createStageRequests();
    this.outstandingRequests = interleaved.length;
    for (const request of interleaved) {
      this.addRequest(request);
    }
    if (this.outstandingRequests === 0) {
      return Promise.resolve(null);
    }
    return this.displayedIterator.getDonePromise();
  }
  sendRequest(request, options) {
    const { imageId, next } = request;
    const errorCallback = (reason, done) => {
      this.listener.errorCallback(imageId, complete || !next, reason);
      if (done) {
        this.updateStageStatus(request.stage, reason);
      }
    };
    const loadedPromise = (options.loader || loadAndCacheImage)(imageId, options);
    const uncompressedIterator = ProgressiveIterator.as(loadedPromise);
    let complete = false;
    uncompressedIterator.forEach(async (image, done) => {
      const oldStatus = cache_default.getImageQuality(imageId);
      if (!image) {
        console.warn("No image retrieved", imageId);
        return;
      }
      const { imageQualityStatus } = image;
      complete ||= imageQualityStatus === ImageQualityStatus_default.FULL_RESOLUTION;
      if (oldStatus !== undefined && oldStatus > imageQualityStatus) {
        this.updateStageStatus(request.stage, null, true);
        return;
      }
      this.listener.successCallback(imageId, image);
      this.displayedIterator.add(image);
      if (done) {
        this.updateStageStatus(request.stage);
      }
      fillNearbyFrames(this.listener, request, image);
    }, errorCallback).finally(() => {
      if (!complete && next) {
        cache_default.setPartialImage(imageId);
        this.addRequest(next, options.streamingData);
      } else {
        if (!complete) {
          this.listener.errorCallback(imageId, true, "Couldn't decode");
        }
        this.outstandingRequests--;
        for (let skip = next;skip; skip = skip.next) {
          this.updateStageStatus(skip.stage, null, true);
        }
      }
      if (this.outstandingRequests <= 0) {
        this.displayedIterator.resolve();
      }
    });
    const doneLoad = uncompressedIterator.getDonePromise();
    return doneLoad.catch((e) => null);
  }
  addRequest(request, streamingData = {}) {
    const { imageId, stage } = request;
    const baseOptions = this.listener.getLoaderImageOptions(imageId);
    if (!baseOptions) {
      return;
    }
    const { retrieveType = "default" } = stage;
    const { retrieveOptions: keyedRetrieveOptions } = this;
    const retrieveOptions = keyedRetrieveOptions[retrieveType] || keyedRetrieveOptions.default;
    const options = {
      ...baseOptions,
      retrieveType,
      retrieveOptions,
      streamingData
    };
    const priority = stage.priority ?? -5;
    const requestType = stage.requestType || RequestType_default.Interaction;
    const additionalDetails = { imageId };
    imageLoadPoolManager_default.addRequest(this.sendRequest.bind(this, request, options), requestType, additionalDetails, priority);
  }
  updateStageStatus(stage, failure, skipped = false) {
    const { id } = stage;
    const stageStatus = this.stageStatusMap.get(id);
    if (!stageStatus) {
      return;
    }
    stageStatus.imageLoadPendingCount--;
    if (failure) {
      stageStatus.imageLoadFailedCount++;
    } else if (!skipped) {
      stageStatus.totalImageCount++;
    }
    if (!skipped && !stageStatus.stageStartTime) {
      stageStatus.stageStartTime = Date.now();
    }
    if (!stageStatus.imageLoadPendingCount) {
      const { imageLoadFailedCount: numberOfFailures, totalImageCount: numberOfImages, stageStartTime = Date.now(), startTime } = stageStatus;
      const detail = {
        stageId: id,
        numberOfFailures,
        numberOfImages,
        stageDurationInMS: stageStartTime ? Date.now() - stageStartTime : null,
        startDurationInMS: Date.now() - startTime
      };
      triggerEvent(eventTarget_default, Events_default.IMAGE_RETRIEVAL_STAGE, detail);
      this.stageStatusMap.delete(id);
    }
  }
  createStageRequests() {
    const interleaved = new Array;
    const imageRequests = new Map;
    const addStageInstance = (stage, position) => {
      const index2 = position < 0 ? this.imageIds.length + position : position < 1 ? Math.floor((this.imageIds.length - 1) * position) : position;
      const imageId = this.imageIds[index2];
      if (!imageId) {
        throw new Error(`No value found to add to requests at ${position}`);
      }
      const request = {
        imageId,
        stage,
        index: index2,
        nearbyRequests: this.findNearbyRequests(index2, stage)
      };
      this.addStageStatus(stage);
      const existingRequest = imageRequests.get(imageId);
      if (existingRequest) {
        existingRequest.next = request;
      } else {
        interleaved.push(request);
      }
      imageRequests.set(imageId, request);
    };
    for (const stage of this.stages) {
      const indices = stage.positions || decimate(this.imageIds, stage.decimate || 1, stage.offset ?? 0);
      indices.forEach((index2) => {
        addStageInstance(stage, index2);
      });
    }
    return interleaved;
  }
  findNearbyRequests(index2, stage) {
    const nearby = new Array;
    if (!stage.nearbyFrames) {
      return nearby;
    }
    for (const nearbyItem of stage.nearbyFrames) {
      const nearbyIndex = index2 + nearbyItem.offset;
      if (nearbyIndex < 0 || nearbyIndex >= this.imageIds.length) {
        continue;
      }
      nearby.push({
        itemId: this.imageIds[nearbyIndex],
        imageQualityStatus: nearbyItem.imageQualityStatus,
        index: nearbyIndex
      });
    }
    return nearby;
  }
  addStageStatus(stage) {
    const { id } = stage;
    const stageStatus = this.stageStatusMap.get(id) || {
      stageId: id,
      startTime: Date.now(),
      stageStartTime: null,
      totalImageCount: 0,
      imageLoadFailedCount: 0,
      imageLoadPendingCount: 0
    };
    stageStatus.imageLoadPendingCount++;
    this.stageStatusMap.set(id, stageStatus);
    return stageStatus;
  }
}
function createProgressive(configuration) {
  return new ProgressiveRetrieveImages(configuration);
}
var ProgressiveRetrieveImages_default = ProgressiveRetrieveImages;

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/BaseStreamingImageVolume.js
var requestTypeDefault = RequestType_default.Prefetch;

class BaseStreamingImageVolume extends ImageVolume_default {
  constructor(imageVolumeProperties, streamingProperties) {
    super(imageVolumeProperties);
    this.framesLoaded = 0;
    this.framesProcessed = 0;
    this.framesUpdated = 0;
    this.autoRenderOnLoad = true;
    this.cachedFrames = [];
    this.reRenderTarget = 0;
    this.reRenderFraction = 2;
    this.imagesLoader = this;
    this.cancelLoading = () => {
      const { loadStatus } = this;
      if (!loadStatus || !loadStatus.loading) {
        return;
      }
      loadStatus.loading = false;
      loadStatus.cancelled = true;
      this.clearLoadCallbacks();
      const filterFunction = ({ additionalDetails }) => {
        return additionalDetails.volumeId !== this.volumeId;
      };
      imageLoadPoolManager_default.filterRequests(filterFunction);
    };
    this.loadStatus = streamingProperties.loadStatus;
  }
  invalidateVolume(immediate) {
    const { vtkOpenGLTexture: vtkOpenGLTexture2 } = this;
    const { numFrames } = this;
    for (let i = 0;i < numFrames; i++) {
      vtkOpenGLTexture2.setUpdatedFrame(i);
    }
    this.modified();
    if (immediate) {
      autoLoad_default(this.volumeId);
    }
  }
  clearLoadCallbacks() {
    this.loadStatus.callbacks = [];
  }
  callLoadStatusCallback(evt) {
    const { framesUpdated, framesProcessed, totalNumFrames } = evt;
    const { volumeId, reRenderFraction, loadStatus, metadata } = this;
    const { FrameOfReferenceUID } = metadata;
    if (this.autoRenderOnLoad) {
      if (framesUpdated > this.reRenderTarget || framesProcessed === totalNumFrames) {
        this.reRenderTarget += reRenderFraction;
        autoLoad_default(volumeId);
      }
    }
    if (framesProcessed === totalNumFrames) {
      loadStatus.callbacks.forEach((callback) => callback(evt));
      const eventDetail = {
        FrameOfReferenceUID,
        volumeId
      };
      triggerEvent(eventTarget_default, Events_default.IMAGE_VOLUME_LOADING_COMPLETED, eventDetail);
    }
  }
  updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus = ImageQualityStatus_default.FULL_RESOLUTION) {
    const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
    const { cachedFrames, numFrames, totalNumFrames } = this;
    const { FrameOfReferenceUID } = this.metadata;
    const currentStatus = cachedFrames[frameIndex];
    if (currentStatus > imageQualityStatus) {
      return;
    }
    if (cachedFrames[frameIndex] === ImageQualityStatus_default.FULL_RESOLUTION) {
      return;
    }
    const complete = imageQualityStatus === ImageQualityStatus_default.FULL_RESOLUTION;
    cachedFrames[imageIdIndex] = imageQualityStatus;
    this.framesUpdated++;
    if (complete) {
      this.framesLoaded++;
      this.framesProcessed++;
    }
    const eventDetail = {
      FrameOfReferenceUID,
      volumeId: this.volumeId,
      numberOfFrames: numFrames,
      framesProcessed: this.framesProcessed
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_VOLUME_MODIFIED, eventDetail);
    if (complete && this.framesProcessed === this.totalNumFrames) {
      this.loadStatus.loaded = true;
      this.loadStatus.loading = false;
    }
    this.callLoadStatusCallback({
      success: true,
      imageIdIndex,
      imageId,
      framesLoaded: this.framesLoaded,
      framesProcessed: this.framesProcessed,
      framesUpdated: this.framesUpdated,
      numFrames,
      totalNumFrames,
      complete,
      imageQualityStatus
    });
    this.vtkOpenGLTexture.setUpdatedFrame(frameIndex);
    if (this.loadStatus.loaded) {
      this.loadStatus.callbacks = [];
    }
  }
  successCallback(imageId, image) {
    const imageIdIndex = this.getImageIdIndex(imageId);
    const { imageQualityStatus } = image;
    if (this.loadStatus.cancelled) {
      console.warn("volume load cancelled, returning for imageIdIndex: ", imageIdIndex);
      return;
    }
    this.updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus);
    if (this.isDynamicVolume()) {
      this.checkDimensionGroupCompletion(imageIdIndex);
    }
  }
  errorCallback(imageId, permanent, error) {
    if (!permanent) {
      return;
    }
    const { totalNumFrames, numFrames } = this;
    const imageIdIndex = this.getImageIdIndex(imageId);
    this.framesProcessed++;
    if (this.framesProcessed === totalNumFrames) {
      this.loadStatus.loaded = true;
      this.loadStatus.loading = false;
    }
    this.callLoadStatusCallback({
      success: false,
      imageId,
      imageIdIndex,
      error,
      framesLoaded: this.framesLoaded,
      framesProcessed: this.framesProcessed,
      framesUpdated: this.framesUpdated,
      numFrames,
      totalNumFrames
    });
    if (this.loadStatus.loaded) {
      this.loadStatus.callbacks = [];
    }
    const eventDetail = {
      error,
      imageIdIndex,
      imageId
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOAD_ERROR, eventDetail);
  }
  load(callback) {
    const { imageIds, loadStatus, numFrames } = this;
    const { transferSyntaxUID } = getMetaData("transferSyntax", imageIds[0]) || {};
    const imageRetrieveConfiguration = getMetaData(imageRetrieveMetadataProvider_default.IMAGE_RETRIEVE_CONFIGURATION, this.volumeId, transferSyntaxUID, "volume");
    this.imagesLoader = this.isDynamicVolume() ? this : imageRetrieveConfiguration ? (imageRetrieveConfiguration.create || ProgressiveRetrieveImages_default.createProgressive)(imageRetrieveConfiguration) : this;
    if (loadStatus.loading === true) {
      return;
    }
    const { loaded } = this.loadStatus;
    const totalNumFrames = imageIds.length;
    if (loaded) {
      if (callback) {
        callback({
          success: true,
          framesLoaded: totalNumFrames,
          framesProcessed: totalNumFrames,
          numFrames,
          totalNumFrames
        });
      }
      return;
    }
    if (callback) {
      this.loadStatus.callbacks.push(callback);
    }
    this._prefetchImageIds();
  }
  getLoaderImageOptions(imageId) {
    const { transferSyntaxUID } = getMetaData("transferSyntax", imageId) || {};
    const imagePlaneModule = getMetaData("imagePlaneModule", imageId) || {};
    const { rows, columns } = imagePlaneModule;
    const imageIdIndex = this.getImageIdIndex(imageId);
    const modalityLutModule = getMetaData("modalityLutModule", imageId) || {};
    const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
    const scalingParameters = {
      rescaleSlope: modalityLutModule.rescaleSlope,
      rescaleIntercept: modalityLutModule.rescaleIntercept,
      modality: generalSeriesModule.modality
    };
    if (scalingParameters.modality === "PT") {
      const suvFactor = getMetaData("scalingModule", imageId);
      if (suvFactor) {
        this._addScalingToVolume(suvFactor);
        scalingParameters.suvbw = suvFactor.suvbw;
      }
    }
    const floatAfterScale = hasFloatScalingParameters(scalingParameters);
    const allowFloatRendering = canRenderFloatTextures();
    this.isPreScaled = true;
    if (scalingParameters && scalingParameters.rescaleSlope !== undefined && scalingParameters.rescaleIntercept !== undefined) {
      const { rescaleSlope, rescaleIntercept } = scalingParameters;
      this.isPreScaled = typeof rescaleSlope === "number" && typeof rescaleIntercept === "number";
    }
    if (!allowFloatRendering && floatAfterScale) {
      this.isPreScaled = false;
    }
    const targetBuffer = {
      type: this.dataType,
      rows,
      columns
    };
    return {
      targetBuffer,
      allowFloatRendering,
      preScale: {
        enabled: this.isPreScaled,
        scalingParameters
      },
      transferPixelData: true,
      requestType: requestTypeDefault,
      transferSyntaxUID,
      additionalDetails: {
        imageId,
        imageIdIndex,
        volumeId: this.volumeId
      }
    };
  }
  callLoadImage(imageId, imageIdIndex, options) {
    const { cachedFrames } = this;
    if (cachedFrames[imageIdIndex] === ImageQualityStatus_default.FULL_RESOLUTION) {
      return;
    }
    const handleImageCacheAdded = (event2) => {
      const { image } = event2.detail;
      if (image.imageId === imageId) {
        this.vtkOpenGLTexture.setUpdatedFrame(imageIdIndex);
        eventTarget_default.removeEventListener(Events_default.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
      }
    };
    eventTarget_default.addEventListener(Events_default.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
    const uncompressedIterator = ProgressiveIterator.as(loadAndCacheImage(imageId, options));
    return uncompressedIterator.forEach((image) => {
      this.successCallback(imageId, image);
    }, this.errorCallback.bind(this, imageIdIndex, imageId));
  }
  getImageIdsRequests(imageIds, priorityDefault) {
    this.totalNumFrames = this.imageIds.length;
    const autoRenderPercentage = 2;
    if (this.autoRenderOnLoad) {
      this.reRenderFraction = this.totalNumFrames * (autoRenderPercentage / 100);
      this.reRenderTarget = this.reRenderFraction;
    }
    const requests = imageIds.map((imageId) => {
      const imageIdIndex = this.getImageIdIndex(imageId);
      const requestType = requestTypeDefault;
      const priority = priorityDefault;
      const options = this.getLoaderImageOptions(imageId);
      return {
        callLoadImage: this.callLoadImage.bind(this),
        imageId,
        imageIdIndex,
        options,
        priority,
        requestType,
        additionalDetails: {
          volumeId: this.volumeId
        }
      };
    });
    return requests;
  }
  getImageLoadRequests(priority) {
    throw new Error("Abstract method");
  }
  getImageIdsToLoad() {
    throw new Error("Abstract method");
  }
  loadImages() {
    this.loadStatus.loading = true;
    const requests = this.getImageLoadRequests(5);
    requests.reverse().forEach((request) => {
      if (!request) {
        return;
      }
      const { callLoadImage, imageId, imageIdIndex, options, priority, requestType, additionalDetails } = request;
      imageLoadPoolManager_default.addRequest(callLoadImage.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
    });
    return Promise.resolve(true);
  }
  _prefetchImageIds() {
    this.loadStatus.loading = true;
    const imageIds = [...this.getImageIdsToLoad()];
    this.totalNumFrames = this.imageIds.length;
    const autoRenderPercentage = 2;
    if (this.autoRenderOnLoad) {
      this.reRenderFraction = this.totalNumFrames * (autoRenderPercentage / 100);
      this.reRenderTarget = this.reRenderFraction;
    }
    return this.imagesLoader.loadImages(imageIds, this).catch((e) => {
      console.debug("progressive loading failed to complete", e);
    });
  }
  _addScalingToVolume(suvFactor) {
    if (this.scaling) {
      return;
    }
    const { suvbw, suvlbm, suvbsa } = suvFactor;
    const petScaling = {};
    if (suvlbm) {
      petScaling.suvbwToSuvlbm = suvlbm / suvbw;
    }
    if (suvbsa) {
      petScaling.suvbwToSuvbsa = suvbsa / suvbw;
    }
    if (suvbw) {
      petScaling.suvbw = suvbw;
    }
    this.scaling = { PT: petScaling };
  }
  checkDimensionGroupCompletion(imageIdIndex) {
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/StreamingImageVolume.js
class StreamingImageVolume extends BaseStreamingImageVolume {
  constructor(imageVolumeProperties, streamingProperties) {
    if (!imageVolumeProperties.imageIds) {
      imageVolumeProperties.imageIds = streamingProperties.imageIds;
    }
    super(imageVolumeProperties, streamingProperties);
    this.getImageIdsToLoad = () => {
      const { imageIds } = this;
      this.numFrames = imageIds.length;
      return imageIds;
    };
  }
  getScalarData() {
    return this.voxelManager.getScalarData();
  }
  getImageLoadRequests(priority) {
    const { imageIds } = this;
    return this.getImageIdsRequests(imageIds, priority);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneStreamingImageVolumeLoader.js
function cornerstoneStreamingImageVolumeLoader(volumeId, options) {
  if (!options || !options.imageIds || !options.imageIds.length) {
    throw new Error("ImageIds must be provided to create a streaming image volume");
  }
  async function getStreamingImageVolume() {
    if (options.imageIds[0].split(":")[0] === "wadouri") {
      const [middleImageIndex, lastImageIndex] = [
        Math.floor(options.imageIds.length / 2),
        options.imageIds.length - 1
      ];
      const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];
      await Promise.all(indexesToPrefetch.map((index2) => {
        if (cache_default.isLoaded(options.imageIds[index2])) {
          return Promise.resolve(true);
        }
        return new Promise((resolve, reject) => {
          const imageId = options.imageIds[index2];
          imageLoadPoolManager_default.addRequest(async () => {
            loadImage(imageId).then(() => {
              console.log(`Prefetched imageId: ${imageId}`);
              resolve(true);
            }).catch((err) => {
              reject(err);
            });
          }, RequestType_default.Prefetch, { volumeId }, 1);
        });
      })).catch(console.error);
    }
    const volumeProps = generateVolumePropsFromImageIds(options.imageIds, volumeId);
    const { dimensions, spacing, origin, direction, metadata, imageIds, dataType, numberOfComponents } = volumeProps;
    const streamingImageVolume = new StreamingImageVolume({
      volumeId,
      metadata,
      dimensions,
      spacing,
      origin,
      direction,
      imageIds,
      dataType,
      numberOfComponents
    }, {
      imageIds,
      loadStatus: {
        loaded: false,
        loading: false,
        cancelled: false,
        cachedFrames: [],
        callbacks: []
      }
    });
    return streamingImageVolume;
  }
  const streamingImageVolumePromise = getStreamingImageVolume();
  return {
    promise: streamingImageVolumePromise,
    decache: () => {
      streamingImageVolumePromise.then((streamingImageVolume) => {
        streamingImageVolume.destroy();
        streamingImageVolume = null;
      });
    },
    cancel: () => {
      streamingImageVolumePromise.then((streamingImageVolume) => {
        streamingImageVolume.cancelLoading();
      });
    }
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js
var volumeLoaders = {};
var unknownVolumeLoader = cornerstoneStreamingImageVolumeLoader;
function loadVolumeFromVolumeLoader(volumeId, options) {
  const colonIndex = volumeId.indexOf(":");
  const scheme = volumeId.substring(0, colonIndex);
  let loader = volumeLoaders[scheme];
  if (loader === undefined || loader === null) {
    if (unknownVolumeLoader == null || typeof unknownVolumeLoader !== "function") {
      throw new Error(`No volume loader for scheme ${scheme} has been registered`);
    }
    loader = unknownVolumeLoader;
  }
  const volumeLoadObject = loader(volumeId, options);
  volumeLoadObject.promise.then(function(volume) {
    triggerEvent(eventTarget_default, Events_default.VOLUME_LOADED, { volume });
  }, function(error) {
    const errorObject = {
      volumeId,
      error
    };
    triggerEvent(eventTarget_default, Events_default.VOLUME_LOADED_FAILED, errorObject);
  });
  return volumeLoadObject;
}
function loadVolume(volumeId, options = { imageIds: [] }) {
  if (volumeId === undefined) {
    throw new Error("loadVolume: parameter volumeId must not be undefined");
  }
  let volumeLoadObject = cache_default.getVolumeLoadObject(volumeId);
  if (volumeLoadObject !== undefined) {
    return volumeLoadObject.promise;
  }
  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);
  return volumeLoadObject.promise.then((volume) => {
    return volume;
  });
}
async function createAndCacheVolume(volumeId, options) {
  if (volumeId === undefined) {
    throw new Error("createAndCacheVolume: parameter volumeId must not be undefined");
  }
  let volumeLoadObject = cache_default.getVolumeLoadObject(volumeId);
  if (volumeLoadObject !== undefined) {
    return volumeLoadObject.promise;
  }
  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);
  cache_default.putVolumeLoadObject(volumeId, volumeLoadObject);
  return volumeLoadObject.promise;
}
function createAndCacheDerivedVolume(referencedVolumeId, options) {
  const referencedVolume = cache_default.getVolume(referencedVolumeId);
  if (!referencedVolume) {
    throw new Error(`Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`);
  }
  let { volumeId } = options;
  const { voxelRepresentation } = options;
  if (volumeId === undefined) {
    volumeId = uuidv4();
  }
  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;
  const referencedImageIds = referencedVolume.isDynamicVolume() ? referencedVolume.getCurrentDimensionGroupImageIds() : referencedVolume.imageIds ?? [];
  const derivedImages = createAndCacheDerivedImages(referencedImageIds, {
    targetBuffer: options.targetBuffer,
    voxelRepresentation
  });
  const dataType = derivedImages[0].dataType;
  const derivedVolumeImageIds = derivedImages.map((image) => image.imageId);
  const derivedVolume = new ImageVolume({
    volumeId,
    dataType,
    metadata: structuredClone(metadata),
    dimensions: [dimensions[0], dimensions[1], dimensions[2]],
    spacing,
    origin,
    direction,
    referencedVolumeId,
    imageIds: derivedVolumeImageIds,
    referencedImageIds: referencedVolume.imageIds ?? []
  });
  cache_default.putVolumeSync(volumeId, derivedVolume);
  return derivedVolume;
}
async function createAndCacheVolumeFromImages(volumeId, imageIds) {
  if (imageIds === undefined) {
    throw new Error("createAndCacheVolumeFromImages: parameter imageIds must not be undefined");
  }
  if (volumeId === undefined) {
    throw new Error("createAndCacheVolumeFromImages: parameter volumeId must not be undefined");
  }
  const cachedVolume = cache_default.getVolume(volumeId);
  if (cachedVolume) {
    return cachedVolume;
  }
  const imageIdsToLoad = imageIds.filter((imageId) => !cache_default.getImage(imageId));
  if (imageIdsToLoad.length === 0) {
    return createAndCacheVolumeFromImagesSync(volumeId, imageIds);
  }
  const volume = await createAndCacheVolume(volumeId, {
    imageIds
  });
  return volume;
}
function createAndCacheVolumeFromImagesSync(volumeId, imageIds) {
  if (imageIds === undefined) {
    throw new Error("createAndCacheVolumeFromImagesSync: parameter imageIds must not be undefined");
  }
  if (volumeId === undefined) {
    throw new Error("createAndCacheVolumeFromImagesSync: parameter volumeId must not be undefined");
  }
  const cachedVolume = cache_default.getVolume(volumeId);
  if (cachedVolume) {
    return cachedVolume;
  }
  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);
  const derivedVolume = new ImageVolume({
    volumeId,
    dataType: volumeProps.dataType,
    metadata: structuredClone(volumeProps.metadata),
    dimensions: volumeProps.dimensions,
    spacing: volumeProps.spacing,
    origin: volumeProps.origin,
    direction: volumeProps.direction,
    referencedVolumeId: volumeProps.referencedVolumeId,
    imageIds: volumeProps.imageIds,
    referencedImageIds: volumeProps.referencedImageIds
  });
  cache_default.putVolumeSync(volumeId, derivedVolume);
  return derivedVolume;
}
function createLocalVolume(volumeId, options = {}) {
  const { metadata, dimensions, spacing, origin, direction, scalarData, targetBuffer, preventCache = false } = options;
  const cachedVolume = cache_default.getVolume(volumeId);
  if (cachedVolume) {
    return cachedVolume;
  }
  const sliceLength = dimensions[0] * dimensions[1];
  const dataType = scalarData ? scalarData.constructor.name : targetBuffer?.type ?? "Float32Array";
  const totalNumberOfVoxels = sliceLength * dimensions[2];
  let byteLength;
  switch (dataType) {
    case "Uint8Array":
    case "Int8Array":
      byteLength = totalNumberOfVoxels;
      break;
    case "Uint16Array":
    case "Int16Array":
      byteLength = totalNumberOfVoxels * 2;
      break;
    case "Float32Array":
      byteLength = totalNumberOfVoxels * 4;
      break;
  }
  const isCacheable = cache_default.isCacheable(byteLength);
  if (!isCacheable) {
    throw new Error(`Cannot created derived volume: Volume with id ${volumeId} is not cacheable.`);
  }
  const imageIds = [];
  const derivedImages = [];
  for (let i = 0;i < dimensions[2]; i++) {
    const imageId = `${volumeId}_slice_${i}`;
    imageIds.push(imageId);
    const sliceData = scalarData.subarray(i * sliceLength, (i + 1) * sliceLength);
    const derivedImage = createAndCacheLocalImage(imageId, {
      scalarData: sliceData,
      dimensions: [dimensions[0], dimensions[1]],
      spacing: [spacing[0], spacing[1]],
      origin,
      direction,
      targetBuffer: { type: dataType }
    });
    derivedImages.push(derivedImage);
  }
  const imageVolume = new ImageVolume({
    volumeId,
    metadata: structuredClone(metadata),
    dimensions: [dimensions[0], dimensions[1], dimensions[2]],
    spacing,
    origin,
    direction,
    imageIds,
    dataType
  });
  const voxelManager = VoxelManager.createImageVolumeVoxelManager({
    imageIds,
    dimensions,
    numberOfComponents: 1
  });
  imageVolume.voxelManager = voxelManager;
  if (!preventCache) {
    cache_default.putVolumeSync(volumeId, imageVolume);
  }
  return imageVolume;
}
function registerVolumeLoader(scheme, volumeLoader) {
  volumeLoaders[scheme] = volumeLoader;
}
function getVolumeLoaderSchemes() {
  return Object.keys(volumeLoaders);
}
function registerUnknownVolumeLoader(volumeLoader) {
  const oldVolumeLoader = unknownVolumeLoader;
  unknownVolumeLoader = volumeLoader;
  return oldVolumeLoader;
}
function getUnknownVolumeLoaderSchema() {
  return unknownVolumeLoader.name;
}
function createAndCacheDerivedLabelmapVolume(referencedVolumeId, options = {}) {
  return createAndCacheDerivedVolume(referencedVolumeId, {
    ...options,
    targetBuffer: {
      type: "Uint8Array",
      ...options?.targetBuffer
    }
  });
}
function createLocalLabelmapVolume(options, volumeId, preventCache = false) {
  if (!options.scalarData) {
    options.scalarData = new Uint8Array(options.dimensions[0] * options.dimensions[1] * options.dimensions[2]);
  }
  return createLocalVolume(volumeId, { ...options, preventCache });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeMapper.js
function createVolumeMapper(imageData, vtkOpenGLTexture2) {
  const volumeMapper = vtkSharedVolumeMapper_default.newInstance();
  if (getConfiguration().rendering.preferSizeOverAccuracy) {
    volumeMapper.setPreferSizeOverAccuracy(true);
  }
  volumeMapper.setInputData(imageData);
  const spacing = imageData.getSpacing();
  const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;
  volumeMapper.setMaximumSamplesPerRay(4000);
  volumeMapper.setSampleDistance(sampleDistance);
  volumeMapper.setScalarTexture(vtkOpenGLTexture2);
  return volumeMapper;
}
function convertMapperToNotSharedMapper(sharedMapper) {
  const volumeMapper = vtkVolumeMapper$1.newInstance();
  volumeMapper.setBlendMode(sharedMapper.getBlendMode());
  const imageData = sharedMapper.getInputData();
  const { voxelManager } = imageData.get("voxelManager");
  const values = voxelManager.getCompleteScalarDataArray();
  const scalarArray = vtkDataArray$1.newInstance({
    name: `Pixels`,
    values
  });
  imageData.getPointData().setScalars(scalarArray);
  volumeMapper.setInputData(imageData);
  volumeMapper.setMaximumSamplesPerRay(sharedMapper.getMaximumSamplesPerRay());
  volumeMapper.setSampleDistance(sharedMapper.getSampleDistance());
  return volumeMapper;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setDefaultVolumeVOI.js
var PRIORITY = 0;
var REQUEST_TYPE = RequestType_default.Prefetch;
async function setDefaultVolumeVOI(volumeActor, imageVolume) {
  let voi = getVOIFromMetadata(imageVolume);
  if (!voi && imageVolume.imageIds.length) {
    voi = await getVOIFromMiddleSliceMinMax(imageVolume);
    voi = handlePreScaledVolume(imageVolume, voi);
  }
  if (voi.lower === 0 && voi.upper === 0 || voi.lower === undefined || voi.upper === undefined) {
    return;
  }
  volumeActor.getProperty().getRGBTransferFunction(0).setMappingRange(voi.lower, voi.upper);
}
function handlePreScaledVolume(imageVolume, voi) {
  const imageIds = imageVolume.imageIds;
  const imageIdIndex = Math.floor(imageIds.length / 2);
  const imageId = imageIds[imageIdIndex];
  const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
  if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {
    return {
      lower: 0,
      upper: 5
    };
  }
  return voi;
}
function getVOIFromMetadata(imageVolume) {
  const { imageIds, metadata } = imageVolume;
  let voi;
  if (imageIds?.length) {
    const imageIdIndex = Math.floor(imageIds.length / 2);
    const imageId = imageIds[imageIdIndex];
    const voiLutModule = getMetaData("voiLutModule", imageId);
    if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {
      if (voiLutModule?.voiLUTFunction) {
        voi = {};
        voi.voiLUTFunction = voiLutModule?.voiLUTFunction;
      }
      const { windowWidth, windowCenter } = voiLutModule;
      const width = Array.isArray(windowWidth) ? windowWidth[0] : windowWidth;
      const center = Array.isArray(windowCenter) ? windowCenter[0] : windowCenter;
      if (width !== 0) {
        voi = { windowWidth: width, windowCenter: center };
      }
    }
  } else {
    voi = metadata.voiLut[0];
  }
  if (voi && (voi.windowWidth !== 0 || voi.windowCenter !== 0)) {
    const { lower, upper } = toLowHighRange(Number(voi.windowWidth), Number(voi.windowCenter), voi.voiLUTFunction);
    return { lower, upper };
  }
  return;
}
async function getVOIFromMiddleSliceMinMax(imageVolume) {
  const { imageIds } = imageVolume;
  const imageIdIndex = Math.floor(imageIds.length / 2);
  const imageId = imageVolume.imageIds[imageIdIndex];
  const generalSeriesModule = getMetaData("generalSeriesModule", imageId) || {};
  const { modality } = generalSeriesModule;
  const modalityLutModule = getMetaData("modalityLutModule", imageId) || {};
  const scalingParameters = {
    rescaleSlope: modalityLutModule.rescaleSlope,
    rescaleIntercept: modalityLutModule.rescaleIntercept,
    modality
  };
  let scalingParametersToUse;
  if (modality === "PT") {
    const suvFactor = getMetaData("scalingModule", imageId);
    if (suvFactor) {
      scalingParametersToUse = {
        ...scalingParameters,
        suvbw: suvFactor.suvbw
      };
    }
  }
  const options = {
    priority: PRIORITY,
    requestType: REQUEST_TYPE,
    preScale: {
      scalingParameters: scalingParametersToUse
    }
  };
  let image = cache_default.getImage(imageId);
  if (!imageVolume.referencedImageIds?.length) {
    image = await loadAndCacheImage(imageId, { ...options, ignoreCache: true });
  }
  let { min: min5, max: max5 } = image.voxelManager.getMinMax();
  if (min5?.length > 1) {
    min5 = Math.min(...min5);
    max5 = Math.max(...max5);
  }
  return {
    lower: min5,
    upper: max5
  };
}
function _isCurrentImagePTPrescaled(modality, imageVolume) {
  if (modality !== "PT" || !imageVolume.isPreScaled) {
    return false;
  }
  if (!imageVolume.scaling?.PT.suvbw) {
    return false;
  }
  return true;
}
var setDefaultVolumeVOI_default = setDefaultVolumeVOI;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeActor.js
async function createVolumeActor(props, element, viewportId, suppressEvents = false) {
  const { volumeId, callback, blendMode } = props;
  const imageVolume = await loadVolume(volumeId);
  if (!imageVolume) {
    throw new Error(`imageVolume with id: ${imageVolume.volumeId} does not exist`);
  }
  const { imageData, vtkOpenGLTexture: vtkOpenGLTexture2 } = imageVolume;
  const volumeMapper = createVolumeMapper(imageData, vtkOpenGLTexture2);
  if (blendMode) {
    volumeMapper.setBlendMode(blendMode);
  }
  const volumeActor = vtkVolume$1.newInstance();
  volumeActor.setMapper(volumeMapper);
  const { numberOfComponents } = imageData.get("numberOfComponents");
  const volumeProperty = volumeActor.getProperty();
  volumeProperty.set({ viewportId });
  if (numberOfComponents === 3) {
    volumeActor.getProperty().setIndependentComponents(false);
  }
  await setDefaultVolumeVOI_default(volumeActor, imageVolume);
  if (callback) {
    callback({ volumeActor, volumeId });
  }
  if (!suppressEvents) {
    triggerVOIModified(element, viewportId, volumeActor, volumeId);
  }
  return volumeActor;
}
function triggerVOIModified(element, viewportId, volumeActor, volumeId) {
  const voiRange = volumeActor.getProperty().getRGBTransferFunction(0).getRange();
  const voiModifiedEventDetail = {
    viewportId,
    range: {
      lower: voiRange[0],
      upper: voiRange[1]
    },
    volumeId
  };
  triggerEvent(element, Events_default.VOI_MODIFIED, voiModifiedEventDetail);
}
var createVolumeActor_default = createVolumeActor;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js
var getVolumeId = (targetId) => {
  const prefix = "volumeId:";
  const str7 = targetId.includes(prefix) ? targetId.substring(prefix.length) : targetId;
  const index2 = str7.indexOf("sliceIndex=");
  return index2 === -1 ? str7 : str7.substring(0, index2 - 1);
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js
var EPSILON_PART = 1 + epsilon_default;
var startsWith = (str7, starts) => starts === str7.substring(0, Math.min(str7.length, starts.length));
var isPrimaryVolume = (volume) => !!getVolumeLoaderSchemes().find((scheme) => startsWith(volume.volumeId, scheme));
function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {
  const { viewPlaneNormal } = camera;
  const volumeActors = viewport.getActors();
  if (!volumeActors.length) {
    return {
      spacingInNormalDirection: null,
      imageVolume: null,
      actorUID: null
    };
  }
  const imageVolumes = volumeActors.map((va) => {
    const actorUID = va.referencedId ?? va.uid;
    return cache_default.getVolume(actorUID);
  }).filter((iv) => !!iv);
  if (targetId) {
    const targetVolumeId = getVolumeId(targetId);
    const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));
    const imageVolume = imageVolumes[imageVolumeIndex];
    const { uid: actorUID } = volumeActors[imageVolumeIndex];
    const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);
    return { imageVolume, spacingInNormalDirection, actorUID };
  }
  if (!imageVolumes.length) {
    return {
      spacingInNormalDirection: null,
      imageVolume: null,
      actorUID: null
    };
  }
  const smallest = {
    spacingInNormalDirection: Infinity,
    imageVolume: null,
    actorUID: null
  };
  const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);
  for (let i = 0;i < imageVolumes.length; i++) {
    const imageVolume = imageVolumes[i];
    if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {
      continue;
    }
    const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);
    if (spacingInNormalDirection * EPSILON_PART < smallest.spacingInNormalDirection) {
      smallest.spacingInNormalDirection = spacingInNormalDirection;
      smallest.imageVolume = imageVolume;
      smallest.actorUID = volumeActors[i].uid;
    }
  }
  return smallest;
}
function getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {
  const { slabThickness } = viewport.getProperties();
  let spacingInNormalDirection = slabThickness;
  if (!slabThickness || !useSlabThickness) {
    spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
  }
  return spacingInNormalDirection;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js
function getImageSliceDataForVolumeViewport(viewport) {
  const camera = viewport.getCamera();
  const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);
  if (!imageVolume) {
    return;
  }
  const { viewPlaneNormal, focalPoint } = camera;
  const actorEntry = viewport.getActors().find((a) => a.referencedId === imageVolume.volumeId || a.uid === imageVolume.volumeId);
  if (!actorEntry) {
    console.warn("No actor found for with actorUID of", imageVolume.volumeId);
  }
  const volumeActor = actorEntry.actor;
  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);
  const { min: min5, max: max5, current } = sliceRange;
  const numberOfSlices = Math.round((max5 - min5) / spacingInNormalDirection) + 1;
  let imageIndex = (current - min5) / (max5 - min5) * numberOfSlices;
  imageIndex = Math.floor(imageIndex);
  if (imageIndex > numberOfSlices - 1) {
    imageIndex = numberOfSlices - 1;
  } else if (imageIndex < 0) {
    imageIndex = 0;
  }
  return {
    numberOfSlices,
    imageIndex
  };
}
var getImageSliceDataForVolumeViewport_default = getImageSliceDataForVolumeViewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/volumeNewImageEventDispatcher.js
var state2 = {};
function resetVolumeNewImageState(viewportId) {
  if (state2[viewportId] !== undefined) {
    delete state2[viewportId];
  }
}
function volumeNewImageEventDispatcher(cameraEvent) {
  const { renderingEngineId, viewportId } = cameraEvent.detail;
  const renderingEngine = getRenderingEngine(renderingEngineId);
  const viewport = renderingEngine.getViewport(viewportId);
  if (!("setVolumes" in viewport)) {
    throw new Error(`volumeNewImageEventDispatcher: viewport does not have setVolumes method`);
  }
  if (state2[viewport.id] === undefined) {
    state2[viewport.id] = 0;
  }
  const sliceData = getImageSliceDataForVolumeViewport_default(viewport);
  if (!sliceData) {
    console.warn(`volumeNewImageEventDispatcher: sliceData is undefined for viewport ${viewport.id}`);
    return;
  }
  const { numberOfSlices, imageIndex } = sliceData;
  if (state2[viewport.id] === imageIndex) {
    return;
  }
  state2[viewport.id] = imageIndex;
  const eventDetail = {
    imageIndex,
    viewportId,
    renderingEngineId,
    numberOfSlices
  };
  triggerEvent(viewport.element, Events_default.VOLUME_NEW_IMAGE, eventDetail);
}
var volumeNewImageEventDispatcher_default = volumeNewImageEventDispatcher;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js
var exports_planar = {};
__export(exports_planar, {
  threePlaneIntersection: () => threePlaneIntersection,
  planeEquation: () => planeEquation,
  planeDistanceToPoint: () => planeDistanceToPoint,
  linePlaneIntersection: () => linePlaneIntersection
});
function linePlaneIntersection(p0, p1, plane) {
  const [x02, y0, z0] = p0;
  const [x1, y1, z1] = p1;
  const [A, B, C, D] = plane;
  const a = x1 - x02;
  const b = y1 - y0;
  const c = z1 - z0;
  const t = -1 * (A * x02 + B * y0 + C * z0 - D) / (A * a + B * b + C * c);
  const X = a * t + x02;
  const Y = b * t + y0;
  const Z = c * t + z0;
  return [X, Y, Z];
}
function planeEquation(normal, point, normalized = false) {
  const [A, B, C] = normal;
  const D = A * point[0] + B * point[1] + C * point[2];
  if (normalized) {
    const length5 = Math.sqrt(A * A + B * B + C * C);
    return [A / length5, B / length5, C / length5, D / length5];
  }
  return [A, B, C, D];
}
function threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {
  const [A1, B1, C1, D1] = firstPlane;
  const [A2, B2, C2, D2] = secondPlane;
  const [A32, B3, C3, D3] = thirdPlane;
  const m0 = exports_mat3.fromValues(A1, A2, A32, B1, B2, B3, C1, C2, C3);
  const m1 = exports_mat3.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);
  const m2 = exports_mat3.fromValues(A1, A2, A32, D1, D2, D3, C1, C2, C3);
  const m32 = exports_mat3.fromValues(A1, A2, A32, B1, B2, B3, D1, D2, D3);
  const x = exports_mat3.determinant(m1) / exports_mat3.determinant(m0);
  const y = exports_mat3.determinant(m2) / exports_mat3.determinant(m0);
  const z = exports_mat3.determinant(m32) / exports_mat3.determinant(m0);
  return [x, y, z];
}
function planeDistanceToPoint(plane, point, signed = false) {
  const [A, B, C, D] = plane;
  const [x, y, z] = point;
  const numerator = A * x + B * y + C * z - D;
  const distance4 = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);
  const sign = signed ? Math.sign(numerator) : 1;
  return sign * distance4;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js
function hasNaNValues(input) {
  if (Array.isArray(input)) {
    return input.some((value) => Number.isNaN(value));
  }
  return Number.isNaN(input);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js
function deepClone(obj2) {
  if (obj2 === null || typeof obj2 !== "object") {
    return obj2;
  }
  if (typeof obj2 === "function") {
    return obj2;
  }
  if (typeof structuredClone === "function") {
    return obj2;
  }
  if (Array.isArray(obj2)) {
    return obj2.map(deepClone);
  } else {
    const clonedObj = {};
    for (const key in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, key)) {
        clonedObj[key] = deepClone(obj2[key]);
      }
    }
    return clonedObj;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
class Viewport {
  static {
    this.CameraViewPresentation = {
      rotation: true,
      pan: true,
      zoom: true,
      displayArea: true
    };
  }
  static {
    this.TransferViewPresentation = {
      windowLevel: true,
      paletteLut: true
    };
  }
  constructor(props) {
    this.insetImageMultiplier = 1.1;
    this.flipHorizontal = false;
    this.flipVertical = false;
    this.viewportStatus = ViewportStatus_default.NO_DATA;
    this._suppressCameraModifiedEvents = false;
    this.hasPixelSpacing = true;
    this.getProperties = () => ({});
    this.setRotation = (_rotation) => {
    };
    this.viewportWidgets = new Map;
    this.addWidget = (widgetId, widget) => {
      this.viewportWidgets.set(widgetId, widget);
    };
    this.getWidget = (id) => {
      return this.viewportWidgets.get(id);
    };
    this.getWidgets = () => {
      return Array.from(this.viewportWidgets.values());
    };
    this.removeWidgets = () => {
      const widgets = this.getWidgets();
      widgets.forEach((widget) => {
        if (widget.getEnabled()) {
          widget.setEnabled(false);
        }
        if (widget.getActor && widget.getRenderer) {
          const actor = widget.getActor();
          const renderer = widget.getRenderer();
          if (renderer && actor) {
            renderer.removeActor(actor);
          }
        }
      });
    };
    this.id = props.id;
    this.renderingEngineId = props.renderingEngineId;
    this.type = props.type;
    this.element = props.element;
    this.canvas = props.canvas;
    this.sx = props.sx;
    this.sy = props.sy;
    this.sWidth = props.sWidth;
    this.sHeight = props.sHeight;
    this._actors = new Map;
    this.element.setAttribute("data-viewport-uid", this.id);
    this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId);
    this.defaultOptions = deepClone(props.defaultOptions);
    this.suppressEvents = props.defaultOptions.suppressEvents ? props.defaultOptions.suppressEvents : false;
    this.options = deepClone(props.defaultOptions);
    this.isDisabled = false;
  }
  static get useCustomRenderingPipeline() {
    return false;
  }
  setRendered() {
    if (this.viewportStatus === ViewportStatus_default.NO_DATA || this.viewportStatus === ViewportStatus_default.LOADING) {
      return;
    }
    this.viewportStatus = ViewportStatus_default.RENDERED;
  }
  getRenderingEngine() {
    return renderingEngineCache_default.get(this.renderingEngineId);
  }
  getRenderer() {
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      throw new Error("Rendering engine has been destroyed");
    }
    return renderingEngine.offscreenMultiRenderWindow?.getRenderer(this.id);
  }
  render() {
    const renderingEngine = this.getRenderingEngine();
    renderingEngine.renderViewport(this.id);
  }
  setOptions(options, immediate = false) {
    this.options = structuredClone(options);
    if (this.options?.displayArea) {
      this.setDisplayArea(this.options?.displayArea);
    }
    if (immediate) {
      this.render();
    }
  }
  reset(immediate = false) {
    this.options = structuredClone(this.defaultOptions);
    if (immediate) {
      this.render();
    }
  }
  getSliceViewInfo() {
    throw new Error("Method not implemented.");
  }
  flip({ flipHorizontal, flipVertical }) {
    const imageData = this.getDefaultImageData();
    if (!imageData) {
      return;
    }
    const camera = this.getCamera();
    const { viewPlaneNormal, viewUp, focalPoint, position } = camera;
    const viewRight = exports_vec3.cross(exports_vec3.create(), viewPlaneNormal, viewUp);
    let viewUpToSet = exports_vec3.copy(exports_vec3.create(), viewUp);
    const viewPlaneNormalToSet = exports_vec3.negate(exports_vec3.create(), viewPlaneNormal);
    const distance4 = exports_vec3.distance(position, focalPoint);
    const dimensions = imageData.getDimensions();
    const middleIJK = dimensions.map((d) => Math.floor(d / 2));
    const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
    const centeredFocalPoint = imageData.indexToWorld(idx, exports_vec3.create());
    const resetFocalPoint = this._getFocalPointForResetCamera(centeredFocalPoint, camera, { resetPan: true, resetToCenter: false });
    const panDir = exports_vec3.subtract(exports_vec3.create(), focalPoint, resetFocalPoint);
    const panValue = exports_vec3.length(panDir);
    const getPanDir = (mirrorVec) => {
      const panDirMirror = exports_vec3.scale(exports_vec3.create(), mirrorVec, 2 * exports_vec3.dot(panDir, mirrorVec));
      exports_vec3.subtract(panDirMirror, panDirMirror, panDir);
      exports_vec3.normalize(panDirMirror, panDirMirror);
      return panDirMirror;
    };
    if (flipHorizontal) {
      const panDirMirror = getPanDir(viewUpToSet);
      const newFocalPoint = exports_vec3.scaleAndAdd(exports_vec3.create(), resetFocalPoint, panDirMirror, panValue);
      const newPosition = exports_vec3.scaleAndAdd(exports_vec3.create(), newFocalPoint, viewPlaneNormalToSet, distance4);
      this.setCamera({
        viewPlaneNormal: viewPlaneNormalToSet,
        position: newPosition,
        focalPoint: newFocalPoint
      });
      this.flipHorizontal = !this.flipHorizontal;
    }
    if (flipVertical) {
      viewUpToSet = exports_vec3.negate(viewUpToSet, viewUp);
      const panDirMirror = getPanDir(viewRight);
      const newFocalPoint = exports_vec3.scaleAndAdd(exports_vec3.create(), resetFocalPoint, panDirMirror, panValue);
      const newPosition = exports_vec3.scaleAndAdd(exports_vec3.create(), newFocalPoint, viewPlaneNormalToSet, distance4);
      this.setCamera({
        focalPoint: newFocalPoint,
        viewPlaneNormal: viewPlaneNormalToSet,
        viewUp: viewUpToSet,
        position: newPosition
      });
      this.flipVertical = !this.flipVertical;
    }
    this.render();
  }
  getDefaultImageData() {
    const actorEntry = this.getDefaultActor();
    if (actorEntry && isImageActor(actorEntry)) {
      return actorEntry.actor.getMapper().getInputData();
    }
  }
  getDefaultActor() {
    return this.getActors()[0];
  }
  getActors() {
    return Array.from(this._actors.values());
  }
  getActorUIDs() {
    return Array.from(this._actors.keys());
  }
  getActor(actorUID) {
    return this._actors.get(actorUID);
  }
  getImageActor(volumeId) {
    const actorEntries = this.getActors();
    let actorEntry = actorEntries[0];
    if (volumeId) {
      actorEntry = actorEntries.find((a) => a.referencedId === volumeId);
    }
    if (!actorEntry || !isImageActor(actorEntry)) {
      return null;
    }
    const actor = actorEntry.actor;
    return actor;
  }
  getActorUIDByIndex(index2) {
    const actor = this.getActors()[index2];
    if (actor) {
      return actor.uid;
    }
  }
  getActorByIndex(index2) {
    return this.getActors()[index2];
  }
  setActors(actors) {
    this.removeAllActors();
    this.addActors(actors, { resetCamera: true });
  }
  _removeActor(actorUID) {
    const actorEntry = this.getActor(actorUID);
    if (!actorEntry) {
      console.warn(`Actor ${actorUID} does not exist for this viewport`);
      return;
    }
    const renderer = this.getRenderer();
    renderer.removeViewProp(actorEntry.actor);
    this._actors.delete(actorUID);
  }
  removeActors(actorUIDs) {
    actorUIDs.forEach((actorUID) => {
      this._removeActor(actorUID);
    });
  }
  addActors(actors, options = {}) {
    const { resetCamera = false } = options;
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      console.warn("Viewport::addActors::Rendering engine has not been initialized or has been destroyed");
      return;
    }
    actors.forEach((actor) => {
      this.addActor(actor);
    });
    const prevViewPresentation = this.getViewPresentation();
    const prevViewRef = this.getViewReference();
    this.resetCamera();
    if (!resetCamera) {
      this.setViewReference(prevViewRef);
      this.setViewPresentation(prevViewPresentation);
    }
  }
  addActor(actorEntry) {
    const { uid: actorUID, actor } = actorEntry;
    const renderingEngine = this.getRenderingEngine();
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
      console.warn(`Cannot add actor UID of ${actorUID} Rendering Engine has been destroyed`);
      return;
    }
    if (!actorUID || !actor) {
      throw new Error("Actors should have uid and vtk Actor properties");
    }
    if (this.getActor(actorUID)) {
      console.warn(`Actor ${actorUID} already exists for this viewport`);
      return;
    }
    const renderer = this.getRenderer();
    renderer?.addActor(actor);
    this._actors.set(actorUID, Object.assign({}, actorEntry));
    this.updateCameraClippingPlanesAndRange();
  }
  removeAllActors() {
    this.getRenderer()?.removeAllViewProps();
    this._actors = new Map;
    return;
  }
  resetCameraNoEvent() {
    this._suppressCameraModifiedEvents = true;
    this.resetCamera();
    this._suppressCameraModifiedEvents = false;
  }
  setCameraNoEvent(camera) {
    this._suppressCameraModifiedEvents = true;
    this.setCamera(camera);
    this._suppressCameraModifiedEvents = false;
  }
  _getViewImageDataIntersections(imageData, focalPoint, normal) {
    const A = normal[0];
    const B = normal[1];
    const C = normal[2];
    const D = A * focalPoint[0] + B * focalPoint[1] + C * focalPoint[2];
    const bounds = imageData.getBounds();
    const edges = this._getEdges(bounds);
    const intersections = [];
    for (const edge of edges) {
      const [[x02, y0, z0], [x1, y1, z1]] = edge;
      if (A * (x1 - x02) + B * (y1 - y0) + C * (z1 - z0) === 0) {
        continue;
      }
      const intersectionPoint = linePlaneIntersection([x02, y0, z0], [x1, y1, z1], [A, B, C, D]);
      if (this._isInBounds(intersectionPoint, bounds)) {
        intersections.push(intersectionPoint);
      }
    }
    return intersections;
  }
  setInterpolationType(_interpolationType, _arg) {
  }
  setDisplayArea(displayArea, suppressEvents = false) {
    if (!displayArea) {
      return;
    }
    const { storeAsInitialCamera, type: areaType } = displayArea;
    if (storeAsInitialCamera) {
      this.options.displayArea = displayArea;
    }
    const { _suppressCameraModifiedEvents } = this;
    this._suppressCameraModifiedEvents = true;
    this.setCamera(this.fitToCanvasCamera);
    if (areaType === "SCALE") {
      this.setDisplayAreaScale(displayArea);
    } else {
      this.setInterpolationType(this.getProperties()?.interpolationType ?? InterpolationType_default.LINEAR);
      this.setDisplayAreaFit(displayArea);
    }
    if (storeAsInitialCamera) {
      this.initialCamera = this.getCamera();
    }
    this._suppressCameraModifiedEvents = _suppressCameraModifiedEvents;
    if (!suppressEvents && !_suppressCameraModifiedEvents) {
      const eventDetail = {
        viewportId: this.id,
        displayArea,
        storeAsInitialCamera
      };
      triggerEvent(this.element, Events_default.DISPLAY_AREA_MODIFIED, eventDetail);
      this.setCamera(this.getCamera());
    }
  }
  setDisplayAreaScale(displayArea) {
    const { scale: scale8 = 1 } = displayArea;
    const canvas = this.canvas;
    const height = canvas.height;
    const width = canvas.width;
    if (height < 8 || width < 8) {
      return;
    }
    const imageData = this.getDefaultImageData();
    const spacingWorld = imageData.getSpacing();
    const spacing = spacingWorld[1];
    this.setInterpolationType(InterpolationType_default.NEAREST);
    this.setCamera({ parallelScale: height * spacing / (2 * scale8) });
    delete displayArea.imageArea;
    this.setDisplayAreaFit(displayArea);
    const { focalPoint, position, viewUp, viewPlaneNormal } = this.getCamera();
    const focalChange = exports_vec3.create();
    if (canvas.height % 2) {
      exports_vec3.scaleAndAdd(focalChange, focalChange, viewUp, scale8 * 0.5 * spacing);
    }
    if (canvas.width % 2) {
      const viewRight = exports_vec3.cross(exports_vec3.create(), viewUp, viewPlaneNormal);
      exports_vec3.scaleAndAdd(focalChange, focalChange, viewRight, scale8 * 0.5 * spacing);
    }
    if (!focalChange[0] && !focalChange[1] && !focalChange[2]) {
      return;
    }
    this.setCamera({
      focalPoint: exports_vec3.add(exports_vec3.create(), focalPoint, focalChange),
      position: exports_vec3.add(exports_vec3.create(), position, focalChange)
    });
  }
  setDisplayAreaFit(displayArea) {
    const { imageArea, imageCanvasPoint } = displayArea;
    const devicePixelRatio2 = window?.devicePixelRatio || 1;
    const imageData = this.getDefaultImageData();
    if (!imageData) {
      return;
    }
    const canvasWidth = this.sWidth / devicePixelRatio2;
    const canvasHeight = this.sHeight / devicePixelRatio2;
    const dimensions = imageData.getDimensions();
    const canvasZero = this.worldToCanvas(imageData.indexToWorld([0, 0, 0]));
    const canvasEdge = this.worldToCanvas(imageData.indexToWorld([
      dimensions[0],
      dimensions[1],
      dimensions[2]
    ]));
    const canvasImage = [
      Math.abs(canvasEdge[0] - canvasZero[0]),
      Math.abs(canvasEdge[1] - canvasZero[1])
    ];
    const [imgWidth, imgHeight] = canvasImage;
    let zoom = this.getZoom() / this.insetImageMultiplier;
    if (imageArea) {
      const [areaX, areaY] = imageArea;
      const currentScale = Math.max(Math.abs(imgWidth / canvasWidth), Math.abs(imgHeight / canvasHeight));
      const requireX = Math.abs(areaX * imgWidth / canvasWidth);
      const requireY = Math.abs(areaY * imgHeight / canvasHeight);
      const initZoom = this.getZoom();
      const fitZoom = this.getZoom(this.fitToCanvasCamera);
      const absZoom = requireX > requireY ? currentScale / requireX : currentScale / requireY;
      const applyZoom = absZoom * initZoom / fitZoom;
      zoom = applyZoom;
      this.setZoom(this.insetImageMultiplier * zoom, false);
    }
    if (imageCanvasPoint) {
      console.log("Starting pan update zoom=", zoom);
      const { imagePoint, canvasPoint = imagePoint || [0.5, 0.5] } = imageCanvasPoint;
      const [canvasX, canvasY] = canvasPoint;
      const canvasPanX = canvasWidth * (canvasX - 0.5);
      const canvasPanY = canvasHeight * (canvasY - 0.5);
      const [imageX, imageY] = imagePoint || canvasPoint;
      const useZoom = zoom;
      const imagePanX = this.insetImageMultiplier * useZoom * imgWidth * (0.5 - imageX);
      const imagePanY = this.insetImageMultiplier * useZoom * imgHeight * (0.5 - imageY);
      const newPositionX = imagePanX + canvasPanX;
      const newPositionY = imagePanY + canvasPanY;
      const deltaPoint2 = [newPositionX, newPositionY];
      console.log("delta point", newPositionX, this.getPan()[0], imagePanX, canvasPanX);
      exports_vec2.add(deltaPoint2, deltaPoint2, this.getPan());
      this.setPan(deltaPoint2, false);
    }
  }
  getDisplayArea() {
    return this.options?.displayArea;
  }
  resetCamera(options) {
    const { resetPan = true, resetZoom = true, resetToCenter = true, storeAsInitialCamera = true } = options || {};
    const renderer = this.getRenderer();
    this.setCameraNoEvent({
      flipHorizontal: false,
      flipVertical: false
    });
    const previousCamera = this.getCamera();
    const bounds = renderer.computeVisiblePropBounds();
    const focalPoint = [0, 0, 0];
    const imageData = this.getDefaultImageData();
    if (imageData) {
      const spc = imageData.getSpacing();
      bounds[0] = bounds[0] + spc[0] / 2;
      bounds[1] = bounds[1] - spc[0] / 2;
      bounds[2] = bounds[2] + spc[1] / 2;
      bounds[3] = bounds[3] - spc[1] / 2;
      bounds[4] = bounds[4] + spc[2] / 2;
      bounds[5] = bounds[5] - spc[2] / 2;
    }
    const activeCamera = this.getVtkActiveCamera();
    const viewPlaneNormal = activeCamera.getViewPlaneNormal();
    const viewUp = activeCamera.getViewUp();
    focalPoint[0] = (bounds[0] + bounds[1]) / 2;
    focalPoint[1] = (bounds[2] + bounds[3]) / 2;
    focalPoint[2] = (bounds[4] + bounds[5]) / 2;
    if (imageData) {
      const dimensions = imageData.getDimensions();
      const middleIJK = dimensions.map((d) => Math.floor(d / 2));
      const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
      imageData.indexToWorld(idx, focalPoint);
    }
    const { widthWorld, heightWorld } = this._getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal);
    const canvasSize2 = [this.sWidth, this.sHeight];
    const boundsAspectRatio = widthWorld / heightWorld;
    const canvasAspectRatio = canvasSize2[0] / canvasSize2[1];
    const scaleFactor = boundsAspectRatio / canvasAspectRatio;
    const parallelScale = scaleFactor < 1 ? this.insetImageMultiplier * heightWorld / 2 : this.insetImageMultiplier * heightWorld * scaleFactor / 2;
    const radius = Viewport.boundsRadius(bounds) * (this.type === ViewportType_default.VOLUME_3D ? 10 : 1);
    const distance4 = this.insetImageMultiplier * radius;
    const viewUpToSet = Math.abs(vtkMath.dot(viewUp, viewPlaneNormal)) > 0.999 ? [-viewUp[2], viewUp[0], viewUp[1]] : viewUp;
    const focalPointToSet = this._getFocalPointForResetCamera(focalPoint, previousCamera, { resetPan, resetToCenter });
    const positionToSet = [
      focalPointToSet[0] + distance4 * viewPlaneNormal[0],
      focalPointToSet[1] + distance4 * viewPlaneNormal[1],
      focalPointToSet[2] + distance4 * viewPlaneNormal[2]
    ];
    renderer.resetCameraClippingRange(bounds);
    const clippingRangeToUse = [
      -rendering_default.MAXIMUM_RAY_DISTANCE,
      rendering_default.MAXIMUM_RAY_DISTANCE
    ];
    activeCamera.setPhysicalScale(radius);
    activeCamera.setPhysicalTranslation(-focalPointToSet[0], -focalPointToSet[1], -focalPointToSet[2]);
    this.setCamera({
      parallelScale: resetZoom ? parallelScale : previousCamera.parallelScale,
      focalPoint: focalPointToSet,
      position: positionToSet,
      viewAngle: 90,
      viewUp: viewUpToSet,
      clippingRange: clippingRangeToUse
    });
    const modifiedCamera = this.getCamera();
    this.setFitToCanvasCamera(this.getCamera());
    if (storeAsInitialCamera) {
      this.setInitialCamera(modifiedCamera);
    }
    if (resetZoom) {
      this.setZoom(1, storeAsInitialCamera);
    }
    const RESET_CAMERA_EVENT = {
      type: "ResetCameraEvent",
      renderer
    };
    renderer.invokeEvent(RESET_CAMERA_EVENT);
    this.triggerCameraModifiedEventIfNecessary(previousCamera, modifiedCamera);
    if (imageData && this.options.displayArea && resetZoom && resetPan && resetToCenter) {
      this.setDisplayArea(this.options.displayArea);
    }
    return true;
  }
  setInitialCamera(camera) {
    this.initialCamera = camera;
  }
  setFitToCanvasCamera(camera) {
    this.fitToCanvasCamera = camera;
  }
  getPan(initialCamera = this.initialCamera) {
    if (!initialCamera) {
      return [0, 0];
    }
    const activeCamera = this.getVtkActiveCamera();
    const focalPoint = activeCamera.getFocalPoint();
    const zero32 = this.canvasToWorld([0, 0]);
    const initialCanvasFocal = this.worldToCanvas(exports_vec3.subtract([0, 0, 0], initialCamera.focalPoint, zero32));
    const currentCanvasFocal = this.worldToCanvas(exports_vec3.subtract([0, 0, 0], focalPoint, zero32));
    const result = exports_vec2.subtract([0, 0], initialCanvasFocal, currentCanvasFocal);
    return result;
  }
  getCurrentImageIdIndex() {
    throw new Error("Not implemented");
  }
  getSliceIndex() {
    throw new Error("Not implemented");
  }
  getImageData() {
    throw new Error("Not implemented");
  }
  getViewReferenceId(_specifier) {
    return null;
  }
  setPan(pan, storeAsInitialCamera = false) {
    const previousCamera = this.getCamera();
    const { focalPoint, position } = previousCamera;
    const zero32 = this.canvasToWorld([0, 0]);
    const delta2 = exports_vec2.subtract([0, 0], pan, this.getPan());
    if (Math.abs(delta2[0]) < 1 && Math.abs(delta2[1]) < 1 && !storeAsInitialCamera) {
      return;
    }
    const delta = exports_vec3.subtract(exports_vec3.create(), this.canvasToWorld(delta2), zero32);
    const newFocal = exports_vec3.subtract(exports_vec3.create(), focalPoint, delta);
    const newPosition = exports_vec3.subtract(exports_vec3.create(), position, delta);
    this.setCamera({
      ...previousCamera,
      focalPoint: newFocal,
      position: newPosition
    }, storeAsInitialCamera);
  }
  getZoom(compareCamera = this.initialCamera) {
    if (!compareCamera) {
      return 1;
    }
    const activeCamera = this.getVtkActiveCamera();
    const { parallelScale: initialParallelScale } = compareCamera;
    return initialParallelScale / activeCamera.getParallelScale();
  }
  setZoom(value, storeAsInitialCamera = false) {
    const camera = this.getCamera();
    const { parallelScale: initialParallelScale } = this.initialCamera;
    const parallelScale = initialParallelScale / value;
    if (camera.parallelScale === parallelScale && !storeAsInitialCamera) {
      return;
    }
    this.setCamera({
      ...camera,
      parallelScale
    }, storeAsInitialCamera);
  }
  _getFocalPointForViewPlaneReset(imageData) {
    const { focalPoint, viewPlaneNormal: normal } = this.getCamera();
    const intersections = this._getViewImageDataIntersections(imageData, focalPoint, normal);
    let x = 0;
    let y = 0;
    let z = 0;
    intersections.forEach(([point_x, point_y, point_z]) => {
      x += point_x;
      y += point_y;
      z += point_z;
    });
    const newFocalPoint = [
      x / intersections.length,
      y / intersections.length,
      z / intersections.length
    ];
    return newFocalPoint;
  }
  getCanvas() {
    return this.canvas;
  }
  getVtkActiveCamera() {
    const renderer = this.getRenderer();
    if (!renderer) {
      console.warn("No renderer found for the viewport");
      return null;
    }
    return renderer.getActiveCamera();
  }
  getCameraNoRotation() {
    const vtkCamera3 = this.getVtkActiveCamera();
    const sanitizeVector = (vector, defaultValue) => {
      return vector.some((v) => isNaN(v)) ? defaultValue : vector;
    };
    const viewUp = sanitizeVector([...vtkCamera3.getViewUp()], [0, 1, 0]);
    const viewPlaneNormal = sanitizeVector([...vtkCamera3.getViewPlaneNormal()], [0, 0, -1]);
    const position = sanitizeVector([...vtkCamera3.getPosition()], [0, 0, 1]);
    const focalPoint = sanitizeVector([...vtkCamera3.getFocalPoint()], [0, 0, 0]);
    return {
      viewUp,
      viewPlaneNormal,
      position,
      focalPoint,
      parallelProjection: vtkCamera3.getParallelProjection(),
      parallelScale: vtkCamera3.getParallelScale(),
      viewAngle: vtkCamera3.getViewAngle(),
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical
    };
  }
  getCamera() {
    const camera = this.getCameraNoRotation();
    return {
      ...camera,
      rotation: this.getRotation()
    };
  }
  setCamera(cameraInterface, storeAsInitialCamera = false) {
    const vtkCamera3 = this.getVtkActiveCamera();
    const previousCamera = this.getCamera();
    const updatedCamera = Object.assign({}, previousCamera, cameraInterface);
    const { viewUp, viewPlaneNormal, position, focalPoint, parallelScale, viewAngle, flipHorizontal, flipVertical, clippingRange } = cameraInterface;
    if (flipHorizontal !== undefined) {
      const flipH = flipHorizontal && !this.flipHorizontal || !flipHorizontal && this.flipHorizontal;
      if (flipH) {
        this.flip({ flipHorizontal: flipH });
      }
    }
    if (flipVertical !== undefined) {
      const flipV = flipVertical && !this.flipVertical || !flipVertical && this.flipVertical;
      if (flipV) {
        this.flip({ flipVertical: flipV });
      }
    }
    if (viewUp !== undefined) {
      vtkCamera3.setViewUp(viewUp);
    }
    if (viewPlaneNormal !== undefined) {
      vtkCamera3.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    }
    if (position !== undefined) {
      vtkCamera3.setPosition(...position);
    }
    if (focalPoint !== undefined) {
      vtkCamera3.setFocalPoint(...focalPoint);
    }
    if (parallelScale !== undefined) {
      vtkCamera3.setParallelScale(parallelScale);
    }
    if (viewAngle !== undefined) {
      vtkCamera3.setViewAngle(viewAngle);
    }
    if (clippingRange !== undefined) {
      vtkCamera3.setClippingRange(clippingRange);
    }
    const prevFocalPoint = previousCamera.focalPoint;
    const prevViewUp = previousCamera.viewUp;
    if (prevFocalPoint && focalPoint || prevViewUp && viewUp) {
      const currentViewPlaneNormal = vtkCamera3.getViewPlaneNormal();
      const currentViewUp = vtkCamera3.getViewUp();
      let cameraModifiedOutOfPlane = false;
      let viewUpHasChanged = false;
      if (focalPoint) {
        const deltaCamera = [
          focalPoint[0] - prevFocalPoint[0],
          focalPoint[1] - prevFocalPoint[1],
          focalPoint[2] - prevFocalPoint[2]
        ];
        cameraModifiedOutOfPlane = Math.abs(vtkMath.dot(deltaCamera, currentViewPlaneNormal)) > 0;
      }
      if (viewUp) {
        viewUpHasChanged = !isEqual(currentViewUp, prevViewUp);
      }
      if (cameraModifiedOutOfPlane || viewUpHasChanged) {
        const actorEntry = this.getDefaultActor();
        if (!actorEntry?.actor) {
          return;
        }
        if (!actorIsA(actorEntry, "vtkActor")) {
          this.updateClippingPlanesForActors(updatedCamera);
        }
        if (actorIsA(actorEntry, "vtkImageSlice") || this.type === ViewportType_default.VOLUME_3D) {
          const renderer = this.getRenderer();
          renderer.resetCameraClippingRange();
        }
      }
    }
    if (storeAsInitialCamera) {
      this.setInitialCamera(updatedCamera);
    }
    this.triggerCameraModifiedEventIfNecessary(previousCamera, this.getCamera());
  }
  triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera) {
    if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
      const eventDetail = {
        previousCamera,
        camera: updatedCamera,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      triggerEvent(this.element, Events_default.CAMERA_MODIFIED, eventDetail);
    }
  }
  updateCameraClippingPlanesAndRange() {
    const currentCamera = this.getCamera();
    this.updateClippingPlanesForActors(currentCamera);
    this.getRenderer().resetCameraClippingRange();
  }
  async updateClippingPlanesForActors(updatedCamera) {
    const actorEntries = this.getActors();
    actorEntries.map((actorEntry) => {
      if (!actorEntry.actor) {
        return;
      }
      const mapper = actorEntry.actor.getMapper();
      let vtkPlanes = actorEntry?.clippingFilter ? actorEntry?.clippingFilter.getClippingPlanes() : mapper.getClippingPlanes();
      if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
        vtkPlanes = [vtkPlane$1.newInstance(), vtkPlane$1.newInstance()];
      }
      let slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
      if (actorEntry.slabThickness) {
        slabThickness = actorEntry.slabThickness;
      }
      const { viewPlaneNormal, focalPoint } = updatedCamera;
      this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
      triggerEvent(this.element, Events_default.CLIPPING_PLANES_UPDATED, {
        actorEntry,
        focalPoint,
        vtkPlanes,
        viewport: this
      });
    });
  }
  setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint) {
    if (vtkPlanes.length < 2) {
      return;
    }
    const scaledDistance = [
      viewPlaneNormal[0],
      viewPlaneNormal[1],
      viewPlaneNormal[2]
    ];
    vtkMath.multiplyScalar(scaledDistance, slabThickness);
    vtkPlanes[0].setNormal(viewPlaneNormal);
    const newOrigin1 = [0, 0, 0];
    vtkMath.subtract(focalPoint, scaledDistance, newOrigin1);
    vtkPlanes[0].setOrigin(newOrigin1);
    vtkPlanes[1].setNormal(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    const newOrigin2 = [0, 0, 0];
    vtkMath.add(focalPoint, scaledDistance, newOrigin2);
    vtkPlanes[1].setOrigin(newOrigin2);
  }
  getClippingPlanesForActor(actorEntry) {
    if (!actorEntry) {
      actorEntry = this.getDefaultActor();
    }
    if (!actorEntry.actor) {
      throw new Error("Invalid actor entry: Actor is undefined");
    }
    const mapper = actorEntry.actor.getMapper();
    let vtkPlanes = actorEntry?.clippingFilter ? actorEntry?.clippingFilter.getClippingPlanes() : mapper.getClippingPlanes();
    if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
      vtkPlanes = [vtkPlane$1.newInstance(), vtkPlane$1.newInstance()];
    }
    return vtkPlanes;
  }
  _getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal) {
    const viewUpCorners = this._getCorners(bounds);
    const viewRightCorners = this._getCorners(bounds);
    const viewRight = exports_vec3.cross(exports_vec3.create(), viewUp, viewPlaneNormal);
    let transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections(viewUp, [1, 0, 0]);
    viewUpCorners.forEach((pt) => transform.apply(pt));
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i = 0;i < 8; i++) {
      const y = viewUpCorners[i][0];
      if (y > maxY) {
        maxY = y;
      }
      if (y < minY) {
        minY = y;
      }
    }
    transform = vtkMatrixBuilder.buildFromDegree().identity().rotateFromDirections([viewRight[0], viewRight[1], viewRight[2]], [1, 0, 0]);
    viewRightCorners.forEach((pt) => transform.apply(pt));
    let minX = Infinity;
    let maxX = -Infinity;
    for (let i = 0;i < 8; i++) {
      const x = viewRightCorners[i][0];
      if (x > maxX) {
        maxX = x;
      }
      if (x < minX) {
        minX = x;
      }
    }
    return { widthWorld: maxX - minX, heightWorld: maxY - minY };
  }
  getViewReference(viewRefSpecifier) {
    const { focalPoint: cameraFocalPoint, viewPlaneNormal, viewUp } = this.getCamera();
    const target = {
      FrameOfReferenceUID: this.getFrameOfReferenceUID(),
      cameraFocalPoint,
      viewPlaneNormal,
      viewUp,
      sliceIndex: viewRefSpecifier?.sliceIndex ?? this.getSliceIndex()
    };
    return target;
  }
  isReferenceViewable(viewRef, options) {
    if (viewRef.FrameOfReferenceUID && viewRef.FrameOfReferenceUID !== this.getFrameOfReferenceUID()) {
      return false;
    }
    const { viewPlaneNormal } = viewRef;
    const camera = this.getCamera();
    if (viewPlaneNormal && !isEqual(viewPlaneNormal, camera.viewPlaneNormal) && !isEqual(exports_vec3.negate(camera.viewPlaneNormal, camera.viewPlaneNormal), viewPlaneNormal)) {
      return options?.withOrientation;
    }
    return true;
  }
  getViewPresentation(viewPresSel = {
    rotation: true,
    displayArea: true,
    zoom: true,
    pan: true,
    flipHorizontal: true,
    flipVertical: true
  }) {
    const target = {};
    const { rotation, displayArea, zoom, pan, flipHorizontal, flipVertical } = viewPresSel;
    if (rotation) {
      target.rotation = this.getRotation();
    }
    if (displayArea) {
      target.displayArea = this.getDisplayArea();
    }
    const initZoom = this.getZoom();
    if (zoom) {
      target.zoom = initZoom;
    }
    if (pan) {
      target.pan = this.getPan();
      exports_vec2.scale(target.pan, target.pan, 1 / initZoom);
    }
    if (flipHorizontal) {
      target.flipHorizontal = this.flipHorizontal;
    }
    if (flipVertical) {
      target.flipVertical = this.flipVertical;
    }
    return target;
  }
  setViewReference(viewRef) {
  }
  setViewPresentation(viewPres) {
    if (!viewPres) {
      return;
    }
    const { displayArea, zoom = this.getZoom(), pan, rotation, flipHorizontal = this.flipHorizontal, flipVertical = this.flipVertical } = viewPres;
    if (displayArea !== this.getDisplayArea()) {
      this.setDisplayArea(displayArea);
    }
    this.setZoom(zoom);
    if (pan) {
      this.setPan(exports_vec2.scale([0, 0], pan, zoom));
    }
    if (rotation >= 0) {
      this.setRotation(rotation);
    }
    if (flipHorizontal || flipVertical) {
      this.flip({ flipHorizontal, flipVertical });
    }
  }
  _getCorners(bounds) {
    return [
      [bounds[0], bounds[2], bounds[4]],
      [bounds[0], bounds[2], bounds[5]],
      [bounds[0], bounds[3], bounds[4]],
      [bounds[0], bounds[3], bounds[5]],
      [bounds[1], bounds[2], bounds[4]],
      [bounds[1], bounds[2], bounds[5]],
      [bounds[1], bounds[3], bounds[4]],
      [bounds[1], bounds[3], bounds[5]]
    ];
  }
  _getFocalPointForResetCamera(centeredFocalPoint, previousCamera, { resetPan = true, resetToCenter = true }) {
    if (resetToCenter && resetPan) {
      return centeredFocalPoint;
    }
    if (resetToCenter && !resetPan) {
      return hasNaNValues(previousCamera.focalPoint) ? centeredFocalPoint : previousCamera.focalPoint;
    }
    if (!resetToCenter && resetPan) {
      const oldCamera = previousCamera;
      const oldFocalPoint = oldCamera.focalPoint;
      const oldViewPlaneNormal = oldCamera.viewPlaneNormal;
      const vectorFromOldFocalPointToCenteredFocalPoint = exports_vec3.subtract(exports_vec3.create(), centeredFocalPoint, oldFocalPoint);
      const distanceFromOldFocalPointToCenteredFocalPoint = exports_vec3.dot(vectorFromOldFocalPointToCenteredFocalPoint, oldViewPlaneNormal);
      const newFocalPoint = exports_vec3.scaleAndAdd(exports_vec3.create(), centeredFocalPoint, oldViewPlaneNormal, -1 * distanceFromOldFocalPointToCenteredFocalPoint);
      return [newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]];
    }
    if (!resetPan && !resetToCenter) {
      return hasNaNValues(previousCamera.focalPoint) ? centeredFocalPoint : previousCamera.focalPoint;
    }
  }
  _isInBounds(point, bounds) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    const [x, y, z] = point;
    if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
      return false;
    }
    return true;
  }
  _getEdges(bounds) {
    const [p1, p2, p32, p4, p5, p6, p7, p8] = this._getCorners(bounds);
    return [
      [p1, p2],
      [p1, p5],
      [p1, p32],
      [p2, p4],
      [p2, p6],
      [p32, p4],
      [p32, p7],
      [p4, p8],
      [p5, p7],
      [p5, p6],
      [p6, p8],
      [p7, p8]
    ];
  }
  static boundsRadius(bounds) {
    const w1 = (bounds[1] - bounds[0]) ** 2;
    const w2 = (bounds[3] - bounds[2]) ** 2;
    const w3 = (bounds[5] - bounds[4]) ** 2;
    const radius = Math.sqrt(w1 + w2 + w3 || 1) * 0.5;
    return radius;
  }
  setDataIds(_imageIds, _options) {
    throw new Error("Unsupported operatoin setDataIds");
  }
}
var Viewport_default = Viewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js
function getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {
  const camera = viewport.getCamera();
  const { focalPoint, viewPlaneNormal } = camera;
  const { spacingInNormalDirection, actorUID } = getTargetVolumeAndSpacingInNormalDir(viewport, camera, volumeId, useSlabThickness);
  if (!actorUID) {
    throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);
  }
  const actorEntry = viewport.getActor(actorUID);
  if (!actorEntry) {
    console.warn("No actor found for with actorUID of", actorUID);
    return null;
  }
  const volumeActor = actorEntry.actor;
  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);
  return {
    sliceRange,
    spacingInNormalDirection,
    camera
  };
}
var getVolumeSliceRangeInfo_default = getVolumeSliceRangeInfo;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js
function getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {
  const { sliceRange, spacingInNormalDirection, camera } = getVolumeSliceRangeInfo_default(viewport, volumeId, useSlabThickness);
  const { min: min5, max: max5, current } = sliceRange;
  const numScrollSteps = Math.round((max5 - min5) / spacingInNormalDirection);
  const fraction = (current - min5) / (max5 - min5);
  const floatingStepNumber = fraction * numScrollSteps;
  const currentStepIndex = Math.round(floatingStepNumber);
  return {
    numScrollSteps,
    currentStepIndex,
    sliceRangeInfo: {
      sliceRange,
      spacingInNormalDirection,
      camera
    }
  };
}
var getVolumeViewportScrollInfo_default = getVolumeViewportScrollInfo;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js
function getVoiFromSigmoidRGBTransferFunction(cfun) {
  let cfunRange = [];
  const [lower, upper] = cfun.getRange();
  cfun.getTable(lower, upper, 1024, cfunRange);
  cfunRange = cfunRange.filter((v, k) => k % 3 === 0);
  const cfunDomain = [...Array(1024).keys()].map((v, k) => {
    return lower + (upper - lower) / (1024 - 1) * k;
  });
  const y1 = cfunRange[256];
  const logy1 = Math.log((1 - y1) / y1);
  const x1 = cfunDomain[256];
  const y22 = cfunRange[256 * 3];
  const logy2 = Math.log((1 - y22) / y22);
  const x2 = cfunDomain[256 * 3];
  const ww = Math.round(4 * (x2 - x1) / (logy1 - logy2));
  const wc = Math.round(x1 + ww * logy1 / 4);
  return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js
function applyPreset(actor, preset) {
  const colorTransferArray = preset.colorTransfer.split(" ").splice(1).map(parseFloat);
  const { shiftRange } = getShiftRange(colorTransferArray);
  const min5 = shiftRange[0];
  const width = shiftRange[1] - shiftRange[0];
  const cfun = vtkColorTransferFunction$1.newInstance();
  const normColorTransferValuePoints = [];
  for (let i = 0;i < colorTransferArray.length; i += 4) {
    let value = colorTransferArray[i];
    const r = colorTransferArray[i + 1];
    const g = colorTransferArray[i + 2];
    const b = colorTransferArray[i + 3];
    value = (value - min5) / width;
    normColorTransferValuePoints.push([value, r, g, b]);
  }
  applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);
  actor.getProperty().setRGBTransferFunction(0, cfun);
  const scalarOpacityArray = preset.scalarOpacity.split(" ").splice(1).map(parseFloat);
  const ofun = vtkPiecewiseFunction$1.newInstance();
  const normPoints = [];
  for (let i = 0;i < scalarOpacityArray.length; i += 2) {
    let value = scalarOpacityArray[i];
    const opacity = scalarOpacityArray[i + 1];
    value = (value - min5) / width;
    normPoints.push([value, opacity]);
  }
  applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);
  const property = actor.getProperty();
  property.setScalarOpacity(0, ofun);
  const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity] = preset.gradientOpacity.split(" ").splice(1).map(parseFloat);
  property.setUseGradientOpacity(0, true);
  property.setGradientOpacityMinimumValue(0, gradientMinValue);
  property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);
  property.setGradientOpacityMaximumValue(0, gradientMaxValue);
  property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);
  if (preset.interpolation === "1") {
    property.setInterpolationTypeToFastLinear();
  }
  property.setShade(preset.shade === "1");
  const ambient = parseFloat(preset.ambient);
  const diffuse = parseFloat(preset.diffuse);
  const specular = parseFloat(preset.specular);
  const specularPower = parseFloat(preset.specularPower);
  property.setAmbient(ambient);
  property.setDiffuse(diffuse);
  property.setSpecular(specular);
  property.setSpecularPower(specularPower);
}
function getShiftRange(colorTransferArray) {
  let min5 = Infinity;
  let max5 = -Infinity;
  for (let i = 0;i < colorTransferArray.length; i += 4) {
    min5 = Math.min(min5, colorTransferArray[i]);
    max5 = Math.max(max5, colorTransferArray[i]);
  }
  const center = (max5 - min5) / 2;
  return {
    shiftRange: [-center, center],
    min: min5,
    max: max5
  };
}
function applyPointsToRGBFunction(points, range, cfun) {
  const width = range[1] - range[0];
  const rescaled = points.map(([x, r, g, b]) => [
    x * width + range[0],
    r,
    g,
    b
  ]);
  cfun.removeAllPoints();
  rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));
  return rescaled;
}
function applyPointsToPiecewiseFunction(points, range, pwf) {
  const width = range[1] - range[0];
  const rescaled = points.map(([x, y]) => [x * width + range[0], y]);
  pwf.removeAllPoints();
  rescaled.forEach(([x, y]) => pwf.addPoint(x, y));
  return rescaled;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
class BaseVolumeViewport extends Viewport_default {
  constructor(props) {
    super(props);
    this.useCPURendering = false;
    this.perVolumeIdDefaultProperties = new Map;
    this.viewportProperties = {};
    this.volumeIds = new Set;
    this.setRotation = (rotation) => {
      const panFit = this.getPan(this.fitToCanvasCamera);
      const pan = this.getPan();
      const previousCamera = this.getCamera();
      const panSub = exports_vec2.sub([0, 0], panFit, pan);
      this.setPan(panSub, false);
      const { flipVertical } = this.getCamera();
      const initialViewUp = flipVertical ? exports_vec3.negate([0, 0, 0], this.initialViewUp) : this.initialViewUp;
      this.setCameraNoEvent({
        viewUp: initialViewUp
      });
      this.rotateCamera(rotation);
      const afterPan = this.getPan();
      const afterPanFit = this.getPan(this.fitToCanvasCamera);
      const newCenter = exports_vec2.sub([0, 0], afterPan, afterPanFit);
      const newOffset = exports_vec2.add([0, 0], panFit, newCenter);
      this.setPan(newOffset, false);
      if (this._suppressCameraModifiedEvents) {
        return;
      }
      const camera2 = this.getCamera();
      const eventDetail = {
        previousCamera,
        camera: camera2,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      triggerEvent(this.element, Events_default.CAMERA_MODIFIED, eventDetail);
    };
    this.getDefaultProperties = (volumeId) => {
      let volumeProperties;
      if (volumeId !== undefined) {
        volumeProperties = this.perVolumeIdDefaultProperties.get(volumeId);
      }
      if (volumeProperties !== undefined) {
        return volumeProperties;
      }
      return {
        ...this.globalDefaultProperties
      };
    };
    this.getProperties = (volumeId) => {
      const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
      if (!applicableVolumeActorInfo) {
        return;
      }
      const { colormap: latestColormap, VOILUTFunction, interpolationType, invert: invert4, slabThickness, preset } = this.viewportProperties;
      volumeId ||= this.getVolumeId();
      const volume = cache_default.getVolume(volumeId);
      if (!volume) {
        return null;
      }
      const volumeActorEntry = this.getActors().find((actorEntry) => {
        return actorEntry.referencedId === volumeId;
      });
      if (!volumeActorEntry) {
        return;
      }
      const volumeActor = volumeActorEntry.actor;
      const cfun = volumeActor.getProperty().getRGBTransferFunction(0);
      const [lower, upper] = this.viewportProperties?.VOILUTFunction === "SIGMOID" ? getVoiFromSigmoidRGBTransferFunction(cfun) : cfun.getRange();
      const voiRange = { lower, upper };
      const volumeColormap = this.getColormap(volumeId);
      const colormap = volumeId && volumeColormap ? volumeColormap : latestColormap;
      return {
        colormap,
        voiRange,
        VOILUTFunction,
        interpolationType,
        invert: invert4,
        slabThickness,
        preset
      };
    };
    this.getColormap = (volumeId) => {
      const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
      if (!applicableVolumeActorInfo) {
        return;
      }
      const { volumeActor } = applicableVolumeActorInfo;
      const cfun = this._getOrCreateColorTransferFunction(volumeId);
      const { nodes } = cfun.getState();
      const RGBPoints = nodes.reduce((acc, node) => {
        acc.push(node.x, node.r, node.g, node.b);
        return acc;
      }, []);
      const matchedColormap = findMatchingColormap(RGBPoints, volumeActor);
      return matchedColormap;
    };
    this.getRotation = () => {
      const { viewUp: currentViewUp, viewPlaneNormal, flipVertical } = this.getCameraNoRotation();
      const initialViewUp = flipVertical ? exports_vec3.negate([0, 0, 0], this.initialViewUp) : this.initialViewUp;
      if (!initialViewUp) {
        return 0;
      }
      const initialToCurrentViewUpAngle = exports_vec3.angle(initialViewUp, currentViewUp) * 180 / Math.PI;
      const initialToCurrentViewUpCross = exports_vec3.cross([0, 0, 0], initialViewUp, currentViewUp);
      const normalDot = exports_vec3.dot(initialToCurrentViewUpCross, viewPlaneNormal);
      const value = normalDot >= 0 ? initialToCurrentViewUpAngle : (360 - initialToCurrentViewUpAngle) % 360;
      return value;
    };
    this.getFrameOfReferenceUID = () => {
      return this._FrameOfReferenceUID;
    };
    this.canvasToWorld = (canvasPos) => {
      const vtkCamera3 = this.getVtkActiveCamera();
      vtkCamera3.setIsPerformingCoordinateTransformation?.(true);
      const renderer2 = this.getRenderer();
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size = openGLRenderWindow.getSize();
      const devicePixelRatio2 = window.devicePixelRatio || 1;
      const canvasPosWithDPR = [
        canvasPos[0] * devicePixelRatio2,
        canvasPos[1] * devicePixelRatio2
      ];
      const displayCoord = [
        canvasPosWithDPR[0] + this.sx,
        canvasPosWithDPR[1] + this.sy
      ];
      displayCoord[1] = size[1] - displayCoord[1];
      const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer2);
      vtkCamera3.setIsPerformingCoordinateTransformation?.(false);
      return [worldCoord[0], worldCoord[1], worldCoord[2]];
    };
    this.worldToCanvas = (worldPos) => {
      const vtkCamera3 = this.getVtkActiveCamera();
      vtkCamera3.setIsPerformingCoordinateTransformation?.(true);
      const renderer2 = this.getRenderer();
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size = openGLRenderWindow.getSize();
      const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer2);
      displayCoord[1] = size[1] - displayCoord[1];
      const canvasCoord = [
        displayCoord[0] - this.sx,
        displayCoord[1] - this.sy
      ];
      const devicePixelRatio2 = window.devicePixelRatio || 1;
      const canvasCoordWithDPR = [
        canvasCoord[0] / devicePixelRatio2,
        canvasCoord[1] / devicePixelRatio2
      ];
      vtkCamera3.setIsPerformingCoordinateTransformation(false);
      return canvasCoordWithDPR;
    };
    this.hasImageURI = (imageURI) => {
      const volumeActors = this.getActors().filter((actorEntry) => actorIsA(actorEntry, "vtkVolume"));
      return volumeActors.some(({ uid, referencedId }) => {
        const volume = cache_default.getVolume(referencedId || uid);
        if (!volume?.imageIds) {
          return false;
        }
        const volumeImageURIs = volume.imageIds.map(imageIdToURI);
        return volumeImageURIs.includes(imageURI);
      });
    };
    this.getImageIds = (volumeId) => {
      const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
      if (!applicableVolumeActorInfo) {
        throw new Error(`No actor found for the given volumeId: ${volumeId}`);
      }
      const volumeIdToUse = applicableVolumeActorInfo.volumeId;
      const imageVolume = cache_default.getVolume(volumeIdToUse);
      if (!imageVolume) {
        throw new Error(`imageVolume with id: ${volumeIdToUse} does not exist in cache`);
      }
      return imageVolume.imageIds;
    };
    this.useCPURendering = getShouldUseCPURendering();
    if (this.useCPURendering) {
      throw new Error("VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.");
    }
    const renderer = this.getRenderer();
    const camera = vtkSlabCamera_default.newInstance();
    renderer.setActiveCamera(camera);
    switch (this.type) {
      case ViewportType_default.ORTHOGRAPHIC:
        camera.setParallelProjection(true);
        break;
      case ViewportType_default.VOLUME_3D:
        camera.setParallelProjection(true);
        break;
      case ViewportType_default.PERSPECTIVE:
        camera.setParallelProjection(false);
        break;
      default:
        throw new Error(`Unrecognized viewport type: ${this.type}`);
    }
    this.initializeVolumeNewImageEventDispatcher();
  }
  static get useCustomRenderingPipeline() {
    return false;
  }
  getSliceViewInfo() {
    throw new Error("Method not implemented.");
  }
  applyViewOrientation(orientation, resetCamera = true) {
    const { viewPlaneNormal, viewUp } = this._getOrientationVectors(orientation);
    const camera = this.getVtkActiveCamera();
    camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    camera.setViewUpFrom(viewUp);
    this.initialViewUp = viewUp;
    if (resetCamera) {
      const t = this;
      t.resetCamera({ resetOrientation: false, resetRotation: false });
    }
  }
  initializeVolumeNewImageEventDispatcher() {
    const volumeNewImageHandlerBound = volumeNewImageHandler.bind(this);
    const volumeNewImageCleanUpBound = volumeNewImageCleanUp.bind(this);
    function volumeNewImageHandler(cameraEvent) {
      const { viewportId } = cameraEvent.detail;
      if (viewportId !== this.id || this.isDisabled) {
        return;
      }
      const viewportImageData = this.getImageData();
      if (!viewportImageData) {
        return;
      }
      volumeNewImageEventDispatcher_default(cameraEvent);
    }
    function volumeNewImageCleanUp(evt) {
      const { viewportId } = evt.detail;
      if (viewportId !== this.id) {
        return;
      }
      this.element.removeEventListener(Events_default.CAMERA_MODIFIED, volumeNewImageHandlerBound);
      eventTarget_default.removeEventListener(Events_default.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
      resetVolumeNewImageState(viewportId);
    }
    this.element.removeEventListener(Events_default.CAMERA_MODIFIED, volumeNewImageHandlerBound);
    this.element.addEventListener(Events_default.CAMERA_MODIFIED, volumeNewImageHandlerBound);
    eventTarget_default.addEventListener(Events_default.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
  }
  setVOILUTFunction(voiLUTFunction, volumeId, suppressEvents) {
    if (!Object.values(VOILUTFunctionType_default).includes(voiLUTFunction)) {
      voiLUTFunction = VOILUTFunctionType_default.LINEAR;
    }
    const { voiRange } = this.getProperties();
    this.setVOI(voiRange, volumeId, suppressEvents);
    this.viewportProperties.VOILUTFunction = voiLUTFunction;
  }
  setColormap(colormap, volumeId, suppressEvents) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    const cfun = vtkColorTransferFunction$1.newInstance();
    let colormapObj = getColormap(colormap.name);
    const { name } = colormap;
    if (!colormapObj) {
      colormapObj = vtkColorMaps2.getPresetByName(name);
    }
    if (!colormapObj) {
      throw new Error(`Colormap ${colormap} not found`);
    }
    const range = volumeActor.getProperty().getRGBTransferFunction(0).getRange();
    cfun.applyColorMap(colormapObj);
    cfun.setMappingRange(range[0], range[1]);
    volumeActor.getProperty().setRGBTransferFunction(0, cfun);
    this.viewportProperties.colormap = colormap;
    if (!suppressEvents) {
      const eventDetail = {
        viewportId: this.id,
        colormap,
        volumeId
      };
      triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetail);
      triggerEvent(this.element, Events_default.COLORMAP_MODIFIED, eventDetail);
    }
  }
  setOpacity(colormap, volumeId) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    const ofun = vtkPiecewiseFunction$1.newInstance();
    if (typeof colormap.opacity === "number") {
      const range = volumeActor.getProperty().getRGBTransferFunction(0).getRange();
      ofun.addPoint(range[0], colormap.opacity);
      ofun.addPoint(range[1], colormap.opacity);
    } else {
      colormap.opacity.forEach(({ opacity, value }) => {
        ofun.addPoint(value, opacity);
      });
    }
    volumeActor.getProperty().setScalarOpacity(0, ofun);
    if (!this.viewportProperties.colormap) {
      this.viewportProperties.colormap = {};
    }
    this.viewportProperties.colormap.opacity = colormap.opacity;
  }
  setInvert(inverted, volumeId, suppressEvents) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const volumeIdToUse = applicableVolumeActorInfo.volumeId;
    const cfun = this._getOrCreateColorTransferFunction(volumeIdToUse);
    invertRgbTransferFunction(cfun);
    this.viewportProperties.invert = inverted;
    if (!suppressEvents) {
      const eventDetail = {
        ...this.getVOIModifiedEventDetail(volumeIdToUse),
        invertStateChanged: true
      };
      triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetail);
    }
  }
  getVOIModifiedEventDetail(volumeId) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      throw new Error(`No actor found for the given volumeId: ${volumeId}`);
    }
    const volumeActor = applicableVolumeActorInfo.volumeActor;
    const transferFunction = volumeActor.getProperty().getRGBTransferFunction(0);
    const range = transferFunction.getMappingRange();
    const matchedColormap = this.getColormap(volumeId);
    const { VOILUTFunction, invert: invert4 } = this.getProperties(volumeId);
    return {
      viewportId: this.id,
      range: {
        lower: range[0],
        upper: range[1]
      },
      volumeId: applicableVolumeActorInfo.volumeId,
      VOILUTFunction,
      colormap: matchedColormap,
      invert: invert4
    };
  }
  _getOrCreateColorTransferFunction(volumeId) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return null;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    const rgbTransferFunction = volumeActor.getProperty().getRGBTransferFunction(0);
    if (rgbTransferFunction) {
      return rgbTransferFunction;
    }
    const newRGBTransferFunction = vtkColorTransferFunction$1.newInstance();
    volumeActor.getProperty().setRGBTransferFunction(0, newRGBTransferFunction);
    return newRGBTransferFunction;
  }
  setInterpolationType(interpolationType, volumeId) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    const volumeProperty = volumeActor.getProperty();
    volumeProperty.setInterpolationType(interpolationType);
    this.viewportProperties.interpolationType = interpolationType;
  }
  setVOI(voiRange, volumeId, suppressEvents = false) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    const volumeIdToUse = applicableVolumeActorInfo.volumeId;
    const voiRangeToUse = voiRange;
    if (typeof voiRangeToUse === "undefined") {
      throw new Error("voiRangeToUse is undefined, need to implement this in the new volume model");
    }
    const { VOILUTFunction } = this.getProperties(volumeIdToUse);
    if (VOILUTFunction === VOILUTFunctionType_default.SAMPLED_SIGMOID) {
      const cfun = createSigmoidRGBTransferFunction(voiRangeToUse);
      volumeActor.getProperty().setRGBTransferFunction(0, cfun);
    } else {
      const { lower, upper } = voiRangeToUse;
      volumeActor.getProperty().getRGBTransferFunction(0).setRange(lower, upper);
    }
    if (!suppressEvents) {
      const eventDetail = {
        ...this.getVOIModifiedEventDetail(volumeIdToUse)
      };
      triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetail);
    }
    this.viewportProperties.voiRange = voiRangeToUse;
  }
  rotateCamera(rotation) {
    const rotationToApply = rotation - this.getRotation();
    this.getVtkActiveCamera().roll(-rotationToApply);
  }
  setDefaultProperties(ViewportProperties, volumeId) {
    if (volumeId == null) {
      this.globalDefaultProperties = ViewportProperties;
    } else {
      this.perVolumeIdDefaultProperties.set(volumeId, ViewportProperties);
    }
  }
  clearDefaultProperties(volumeId) {
    if (volumeId == null) {
      this.globalDefaultProperties = {};
      this.resetProperties();
    } else {
      this.perVolumeIdDefaultProperties.delete(volumeId);
      this.resetToDefaultProperties(volumeId);
    }
  }
  getViewReference(viewRefSpecifier = {}) {
    const target = super.getViewReference(viewRefSpecifier);
    const volumeId = this.getVolumeId(viewRefSpecifier);
    if (viewRefSpecifier?.forFrameOfReference !== false) {
      target.volumeId = volumeId;
    }
    if (typeof viewRefSpecifier?.sliceIndex !== "number") {
      return target;
    }
    const { viewPlaneNormal } = target;
    const delta = viewRefSpecifier?.sliceIndex - this.getSliceIndex();
    const { sliceRangeInfo } = getVolumeViewportScrollInfo_default(this, volumeId, true);
    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
    const { focalPoint, position } = camera;
    const { newFocalPoint } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
    target.cameraFocalPoint = newFocalPoint;
    return target;
  }
  isReferenceViewable(viewRef, options) {
    if (!viewRef.FrameOfReferenceUID) {
      return false;
    }
    if (!super.isReferenceViewable(viewRef, options)) {
      return false;
    }
    if (options?.withNavigation) {
      return true;
    }
    const currentSliceIndex = this.getSliceIndex();
    const { sliceIndex } = viewRef;
    if (Array.isArray(sliceIndex)) {
      return sliceIndex[0] <= currentSliceIndex && currentSliceIndex <= sliceIndex[1];
    }
    return sliceIndex === undefined || sliceIndex === currentSliceIndex;
  }
  scroll(delta = 1) {
    const volumeId = this.getVolumeId();
    const { sliceRangeInfo } = getVolumeViewportScrollInfo_default(this, volumeId, true);
    if (!sliceRangeInfo) {
      return;
    }
    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
    const { focalPoint, viewPlaneNormal, position } = camera;
    const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
    this.setCamera({
      focalPoint: newFocalPoint,
      position: newPosition
    });
  }
  setViewReference(viewRef) {
    if (!viewRef) {
      return;
    }
    const volumeId = this.getVolumeId();
    const { viewPlaneNormal: refViewPlaneNormal, FrameOfReferenceUID: refFrameOfReference, cameraFocalPoint, viewUp } = viewRef;
    let { sliceIndex } = viewRef;
    const { focalPoint, viewPlaneNormal, position } = this.getCamera();
    const isNegativeNormal = isEqualNegative(viewPlaneNormal, refViewPlaneNormal);
    const isSameNormal = isEqual(viewPlaneNormal, refViewPlaneNormal);
    if (typeof sliceIndex === "number" && viewRef.volumeId === volumeId && (isNegativeNormal || isSameNormal)) {
      const { currentStepIndex, sliceRangeInfo, numScrollSteps } = getVolumeViewportScrollInfo_default(this, volumeId, true);
      const { sliceRange, spacingInNormalDirection } = sliceRangeInfo;
      if (isNegativeNormal) {
        sliceIndex = numScrollSteps - sliceIndex - 1;
      }
      const delta = sliceIndex - currentStepIndex;
      const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
      this.setCamera({ focalPoint: newFocalPoint, position: newPosition });
    } else if (refFrameOfReference === this.getFrameOfReferenceUID()) {
      if (refViewPlaneNormal && !isNegativeNormal && !isSameNormal) {
        this.setOrientation({ viewPlaneNormal: refViewPlaneNormal, viewUp });
        this.setViewReference(viewRef);
        return;
      }
      if (cameraFocalPoint) {
        const focalDelta = exports_vec3.subtract([0, 0, 0], cameraFocalPoint, focalPoint);
        const useNormal = refViewPlaneNormal ?? viewPlaneNormal;
        const normalDot = exports_vec3.dot(focalDelta, useNormal);
        if (!isEqual(normalDot, 0)) {
          exports_vec3.scale(focalDelta, useNormal, normalDot);
        }
        const newFocal = exports_vec3.add([0, 0, 0], focalPoint, focalDelta);
        const newPosition = exports_vec3.add([0, 0, 0], position, focalDelta);
        this.setCamera({ focalPoint: newFocal, position: newPosition });
      }
    } else {
      throw new Error(`Incompatible view refs: ${refFrameOfReference}!==${this.getFrameOfReferenceUID()}`);
    }
  }
  setProperties({ voiRange, VOILUTFunction, invert: invert4, colormap, preset, interpolationType, slabThickness } = {}, volumeId, suppressEvents = false) {
    if (this.globalDefaultProperties == null) {
      this.setDefaultProperties({
        voiRange,
        VOILUTFunction,
        invert: invert4,
        colormap,
        preset,
        slabThickness
      });
    }
    if (invert4 !== undefined && this.viewportProperties.invert !== invert4) {
      this.setInvert(invert4, volumeId, suppressEvents);
    }
    if (colormap?.name) {
      this.setColormap(colormap, volumeId, suppressEvents);
    }
    if (colormap?.opacity != null) {
      this.setOpacity(colormap, volumeId);
    }
    if (voiRange !== undefined) {
      this.setVOI(voiRange, volumeId, suppressEvents);
    }
    if (typeof interpolationType !== "undefined") {
      this.setInterpolationType(interpolationType);
    }
    if (VOILUTFunction !== undefined) {
      this.setVOILUTFunction(VOILUTFunction, volumeId, suppressEvents);
    }
    if (preset !== undefined) {
      this.setPreset(preset, volumeId, suppressEvents);
    }
    if (slabThickness !== undefined) {
      this.setSlabThickness(slabThickness);
    }
  }
  resetToDefaultProperties(volumeId) {
    const properties = this.globalDefaultProperties;
    if (properties.colormap?.name) {
      this.setColormap(properties.colormap, volumeId);
    }
    if (properties.colormap?.opacity != null) {
      this.setOpacity(properties.colormap, volumeId);
    }
    if (properties.voiRange !== undefined) {
      this.setVOI(properties.voiRange, volumeId);
    }
    if (properties.VOILUTFunction !== undefined) {
      this.setVOILUTFunction(properties.VOILUTFunction, volumeId);
    }
    if (properties.invert !== undefined) {
      this.setInvert(properties.invert, volumeId);
    }
    if (properties.slabThickness !== undefined) {
      this.setSlabThickness(properties.slabThickness);
      this.viewportProperties.slabThickness = properties.slabThickness;
    }
    if (properties.preset !== undefined) {
      this.setPreset(properties.preset, volumeId, false);
    }
    if (properties.preset !== undefined) {
      this.setPreset(properties.preset, volumeId, false);
    }
    this.render();
  }
  setPreset(presetNameOrObj, volumeId, suppressEvents) {
    const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
    if (!applicableVolumeActorInfo) {
      return;
    }
    const { volumeActor } = applicableVolumeActorInfo;
    let preset = presetNameOrObj;
    if (typeof preset === "string") {
      preset = viewportPresets_default.find((preset2) => {
        return preset2.name === presetNameOrObj;
      });
    }
    if (!preset) {
      return;
    }
    applyPreset(volumeActor, preset);
    this.viewportProperties.preset = preset;
    this.render();
    if (!suppressEvents) {
      triggerEvent(this.element, Events_default.PRESET_MODIFIED, {
        viewportId: this.id,
        volumeId: applicableVolumeActorInfo.volumeId,
        actor: volumeActor,
        presetName: preset.name
      });
    }
  }
  async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache_default.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist, you need to create/allocate the volume first`);
    }
    const FrameOfReferenceUID = firstImageVolume.metadata.FrameOfReferenceUID;
    this._isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID);
    this._FrameOfReferenceUID = FrameOfReferenceUID;
    volumeInputArray.forEach((volumeInput) => {
      this._addVolumeId(volumeInput.volumeId);
    });
    const volumeActors = [];
    for (let i = 0;i < volumeInputArray.length; i++) {
      const { volumeId, actorUID, slabThickness, ...rest } = volumeInputArray[i];
      const actor = await createVolumeActor_default(volumeInputArray[i], this.element, this.id, suppressEvents);
      const uid = actorUID || uuidv4();
      volumeActors.push({
        uid,
        actor,
        slabThickness,
        referencedId: volumeId,
        ...rest
      });
    }
    this._setVolumeActors(volumeActors);
    this.viewportStatus = ViewportStatus_default.PRE_RENDER;
    this.initializeColorTransferFunction(volumeInputArray);
    triggerEvent(this.element, Events_default.VOLUME_VIEWPORT_NEW_VOLUME, {
      viewportId: this.id,
      volumeActors
    });
    if (immediate) {
      this.render();
    }
  }
  async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache_default.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    const volumeActors = [];
    this._isValidVolumeInputArray(volumeInputArray, this._FrameOfReferenceUID);
    volumeInputArray.forEach((volumeInput) => {
      this._addVolumeId(volumeInput.volumeId);
    });
    for (let i = 0;i < volumeInputArray.length; i++) {
      const { volumeId, visibility, actorUID, slabThickness, ...rest } = volumeInputArray[i];
      const actor = await createVolumeActor_default(volumeInputArray[i], this.element, this.id, suppressEvents);
      if (!visibility) {
        actor.setVisibility(false);
      }
      const uid = actorUID || uuidv4();
      volumeActors.push({
        uid,
        actor,
        slabThickness,
        referencedId: volumeId,
        ...rest
      });
    }
    this.addActors(volumeActors);
    this.initializeColorTransferFunction(volumeInputArray);
    if (immediate) {
      this.render();
    }
  }
  removeVolumeActors(actorUIDs, immediate = false) {
    this.removeActors(actorUIDs);
    if (immediate) {
      this.render();
    }
  }
  setOrientation(_orientation, _immediate = true) {
    console.warn('Method "setOrientation" needs implementation');
  }
  initializeColorTransferFunction(volumeInputArray) {
    const selectedVolumeId = volumeInputArray[0].volumeId;
    const colorTransferFunction = this._getOrCreateColorTransferFunction(selectedVolumeId);
    if (!this.initialTransferFunctionNodes && colorTransferFunction) {
      this.initialTransferFunctionNodes = getTransferFunctionNodes(colorTransferFunction);
    }
  }
  _getApplicableVolumeActor(volumeId) {
    const actorEntries = this.getActors();
    if (!actorEntries?.length) {
      return;
    }
    if (volumeId) {
      const actorEntry = actorEntries.find((actor) => actor.referencedId === volumeId);
      if (!actorEntry) {
        return;
      }
      return {
        volumeActor: actorEntry.actor,
        volumeId,
        actorUID: actorEntry.uid
      };
    }
    const defaultActorEntry = actorEntries[0];
    return {
      volumeActor: defaultActorEntry.actor,
      volumeId: defaultActorEntry.referencedId,
      actorUID: defaultActorEntry.uid
    };
  }
  async _isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID) {
    const numVolumes = volumeInputArray.length;
    for (let i = 1;i < numVolumes; i++) {
      const imageVolume = cache_default.getVolume(volumeInputArray[i].volumeId);
      if (FrameOfReferenceUID !== imageVolume.metadata.FrameOfReferenceUID) {
        throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
      }
    }
    return true;
  }
  getBounds() {
    const renderer = this.getRenderer();
    const bounds = renderer.computeVisiblePropBounds();
    return bounds;
  }
  flip(flipDirection) {
    super.flip(flipDirection);
  }
  hasVolumeId(volumeId) {
    return this.volumeIds.has(volumeId);
  }
  hasVolumeURI(volumeURI) {
    for (const volumeId of this.volumeIds) {
      if (volumeId.includes(volumeURI)) {
        return true;
      }
    }
    return false;
  }
  getImageData(volumeId) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    volumeId ||= this.getVolumeId();
    const actorEntry = this.getActors()?.find((actor2) => actor2.referencedId === volumeId);
    if (!actorIsA(actorEntry, "vtkVolume")) {
      return;
    }
    const actor = actorEntry.actor;
    const volume = cache_default.getVolume(volumeId);
    const vtkImageData2 = actor.getMapper().getInputData();
    return {
      dimensions: vtkImageData2.getDimensions(),
      spacing: vtkImageData2.getSpacing(),
      origin: vtkImageData2.getOrigin(),
      direction: vtkImageData2.getDirection(),
      imageData: actor.getMapper().getInputData(),
      metadata: {
        Modality: volume?.metadata?.Modality,
        FrameOfReferenceUID: volume?.metadata?.FrameOfReferenceUID
      },
      get scalarData() {
        return volume?.voxelManager?.getScalarData();
      },
      scaling: volume?.scaling,
      hasPixelSpacing: true,
      voxelManager: volume?.voxelManager
    };
  }
  setCameraClippingRange() {
    throw new Error("Method not implemented.");
  }
  getSliceIndex() {
    throw new Error("Method not implemented.");
  }
  setCamera(cameraInterface, storeAsInitialCamera) {
    super.setCamera(cameraInterface, storeAsInitialCamera);
    this.setCameraClippingRange();
  }
  _setVolumeActors(volumeActorEntries) {
    for (let i = 0;i < volumeActorEntries.length; i++) {
      this.viewportProperties.invert = false;
    }
    this.setActors(volumeActorEntries);
  }
  _getOrientationVectors(orientation) {
    if (typeof orientation === "object") {
      if (orientation.viewPlaneNormal && orientation.viewUp) {
        return orientation;
      } else {
        throw new Error("Invalid orientation object. It must contain viewPlaneNormal and viewUp");
      }
    } else if (typeof orientation === "string" && mprCameraValues_default[orientation]) {
      this.viewportProperties.orientation = orientation;
      return mprCameraValues_default[orientation];
    } else {
      throw new Error(`Invalid orientation: ${orientation}. Valid orientations are: ${Object.keys(mprCameraValues_default).join(", ")}`);
    }
  }
  getSlabThickness() {
    const actors = this.getActors();
    let slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
    actors.forEach((actor) => {
      if (actor.slabThickness > slabThickness) {
        slabThickness = actor.slabThickness;
      }
    });
    return slabThickness;
  }
  getIntensityFromWorld(point) {
    const actorEntry = this.getDefaultActor();
    if (!actorIsA(actorEntry, "vtkVolume")) {
      return;
    }
    const { actor } = actorEntry;
    const imageData = actor.getMapper().getInputData();
    const volume = cache_default.getVolume(this.getVolumeId());
    const index2 = transformWorldToIndex(imageData, point);
    return volume.voxelManager.getAtIJKPoint(index2);
  }
  getVolumeId(specifier) {
    const actorEntries = this.getActors();
    if (!actorEntries) {
      return;
    }
    if (!specifier?.volumeId) {
      const found2 = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === "vtkVolume");
      return found2?.referencedId || found2?.uid;
    }
    const found = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === "vtkVolume" && actorEntry.referencedId === specifier?.volumeId);
    return found?.referencedId || found?.uid;
  }
  getViewReferenceId(specifier = {}) {
    let { volumeId, sliceIndex } = specifier;
    if (!volumeId) {
      const actorEntries = this.getActors();
      if (!actorEntries) {
        return;
      }
      volumeId = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === "vtkVolume")?.referencedId;
    }
    const currentIndex = this.getSliceIndex();
    sliceIndex ??= currentIndex;
    const { viewPlaneNormal, focalPoint } = this.getCamera();
    const querySeparator = volumeId.includes("?") ? "&" : "?";
    return `volumeId:${volumeId}${querySeparator}sliceIndex=${sliceIndex}&viewPlaneNormal=${viewPlaneNormal.join(",")}`;
  }
  _addVolumeId(volumeId) {
    this.volumeIds.add(volumeId);
  }
  getAllVolumeIds() {
    return Array.from(this.volumeIds);
  }
}
var BaseVolumeViewport_default = BaseVolumeViewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js
function transformCanvasToIJK(viewport, canvasPoint) {
  const { imageData: vtkImageData2 } = viewport.getImageData();
  const worldPoint = viewport.canvasToWorld(canvasPoint);
  return transformWorldToIndex(vtkImageData2, worldPoint);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js
function transformIndexToWorld(imageData, voxelPos) {
  return imageData.indexToWorld(voxelPos);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIJKToCanvas.js
function transformIJKToCanvas(viewport, ijkPoint) {
  const { imageData: vtkImageData2 } = viewport.getImageData();
  const worldPoint = transformIndexToWorld(vtkImageData2, ijkPoint);
  return viewport.worldToCanvas(worldPoint);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js
class VolumeViewport extends BaseVolumeViewport_default {
  constructor(props) {
    super(props);
    this._useAcquisitionPlaneForViewPlane = false;
    this.getNumberOfSlices = () => {
      const { numberOfSlices } = getImageSliceDataForVolumeViewport_default(this) || {};
      return numberOfSlices;
    };
    this.resetCameraForResize = () => {
      return this.resetCamera({
        resetPan: true,
        resetZoom: true,
        resetToCenter: true,
        resetRotation: false,
        suppressEvents: true
      });
    };
    this.getCurrentImageIdIndex = (volumeId, useSlabThickness = true) => {
      const { currentStepIndex } = getVolumeViewportScrollInfo_default(this, volumeId || this.getVolumeId(), useSlabThickness);
      return currentStepIndex;
    };
    this.getSliceIndex = () => {
      const { imageIndex } = getImageSliceDataForVolumeViewport_default(this) || {};
      return imageIndex;
    };
    this.getCurrentImageId = () => {
      const actorEntry = this.getDefaultActor();
      if (!actorEntry || !actorIsA(actorEntry, "vtkVolume")) {
        return;
      }
      const volume = cache_default.getVolume(this.getVolumeId());
      if (!volume) {
        return;
      }
      const { viewPlaneNormal, focalPoint } = this.getCamera();
      return getClosestImageId(volume, focalPoint, viewPlaneNormal);
    };
    this.getSlicePlaneCoordinates = () => {
      const actorEntry = this.getDefaultActor();
      if (!actorEntry?.actor) {
        console.warn("No image data found for calculating vtkPlanes.");
        return [];
      }
      const volumeId = this.getVolumeId();
      const imageVolume = cache_default.getVolume(volumeId);
      const camera = this.getCamera();
      const { focalPoint, position, viewPlaneNormal } = camera;
      const spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
      const sliceRange = getSliceRange(actorEntry.actor, viewPlaneNormal, focalPoint);
      const numSlicesBackward = Math.round((sliceRange.current - sliceRange.min) / spacingInNormalDirection);
      const numSlicesForward = Math.round((sliceRange.max - sliceRange.current) / spacingInNormalDirection);
      const currentSliceIndex = this.getSliceIndex();
      const focalPoints = [];
      for (let i = -numSlicesBackward;i <= numSlicesForward; i++) {
        const { newFocalPoint: point } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, i);
        focalPoints.push({ sliceIndex: currentSliceIndex + i, point });
      }
      return focalPoints;
    };
    const { orientation } = this.options;
    if (orientation && orientation !== OrientationAxis_default.ACQUISITION) {
      this.applyViewOrientation(orientation);
      return;
    }
    this._useAcquisitionPlaneForViewPlane = true;
  }
  async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache_default.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    if (this._useAcquisitionPlaneForViewPlane) {
      this._setViewPlaneToAcquisitionPlane(firstImageVolume);
      this._useAcquisitionPlaneForViewPlane = false;
    }
    return super.setVolumes(volumeInputArray, immediate, suppressEvents);
  }
  async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
    const firstImageVolume = cache_default.getVolume(volumeInputArray[0].volumeId);
    if (!firstImageVolume) {
      throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
    }
    if (this._useAcquisitionPlaneForViewPlane) {
      this._setViewPlaneToAcquisitionPlane(firstImageVolume);
      this._useAcquisitionPlaneForViewPlane = false;
    }
    return super.addVolumes(volumeInputArray, immediate, suppressEvents);
  }
  jumpToWorld(worldPos) {
    const { focalPoint } = this.getCamera();
    const delta = [0, 0, 0];
    exports_vec3.sub(delta, worldPos, focalPoint);
    const camera = this.getCamera();
    const normal = camera.viewPlaneNormal;
    const dotProd = exports_vec3.dot(delta, normal);
    const projectedDelta = exports_vec3.fromValues(normal[0], normal[1], normal[2]);
    exports_vec3.scale(projectedDelta, projectedDelta, dotProd);
    if (Math.abs(projectedDelta[0]) > 0.001 || Math.abs(projectedDelta[1]) > 0.001 || Math.abs(projectedDelta[2]) > 0.001) {
      const newFocalPoint = [0, 0, 0];
      const newPosition = [0, 0, 0];
      exports_vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);
      exports_vec3.add(newPosition, camera.position, projectedDelta);
      this.setCamera({
        focalPoint: newFocalPoint,
        position: newPosition
      });
      this.render();
    }
    return true;
  }
  setOrientation(orientation, immediate = true) {
    let viewPlaneNormal, viewUp;
    if (typeof orientation === "string") {
      if (mprCameraValues_default[orientation]) {
        ({ viewPlaneNormal, viewUp } = mprCameraValues_default[orientation]);
      } else if (orientation === "acquisition") {
        ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
      } else {
        throw new Error(`Invalid orientation: ${orientation}. Use Enums.OrientationAxis instead.`);
      }
      this.setCamera({
        viewPlaneNormal,
        viewUp
      });
      this.viewportProperties.orientation = orientation;
      this.resetCamera();
    } else {
      ({ viewPlaneNormal, viewUp } = orientation);
      this.applyViewOrientation(orientation);
    }
    if (immediate) {
      this.render();
    }
  }
  setCameraClippingRange() {
    const activeCamera = this.getVtkActiveCamera();
    if (!activeCamera) {
      console.warn("No active camera found");
      return;
    }
    if (activeCamera.getParallelProjection()) {
      activeCamera.setClippingRange(-rendering_default.MAXIMUM_RAY_DISTANCE, rendering_default.MAXIMUM_RAY_DISTANCE);
    } else {
      activeCamera.setClippingRange(rendering_default.MINIMUM_SLAB_THICKNESS, rendering_default.MAXIMUM_RAY_DISTANCE);
    }
  }
  _getAcquisitionPlaneOrientation() {
    const actorEntry = this.getDefaultActor();
    if (!actorEntry) {
      return;
    }
    const volumeId = this.getVolumeId();
    const imageVolume = cache_default.getVolume(volumeId);
    if (!imageVolume) {
      throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
    }
    const { direction } = imageVolume;
    const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
    const viewUp = direction.slice(3, 6).map((x) => -x);
    return {
      viewPlaneNormal,
      viewUp
    };
  }
  _setViewPlaneToAcquisitionPlane(imageVolume) {
    let viewPlaneNormal, viewUp;
    if (imageVolume) {
      const { direction } = imageVolume;
      viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
      viewUp = direction.slice(3, 6).map((x) => -x);
    } else {
      ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
    }
    this.setCamera({
      viewPlaneNormal,
      viewUp
    });
    this.initialViewUp = viewUp;
    this.resetCamera();
  }
  getBlendMode(filterActorUIDs) {
    const actorEntries = this.getActors();
    const actorForBlend = filterActorUIDs?.length > 0 ? actorEntries.find((actorEntry) => filterActorUIDs.includes(actorEntry.uid)) : actorEntries[0];
    return actorForBlend?.blendMode || actorForBlend?.actor.getMapper().getBlendMode();
  }
  setBlendMode(blendMode, filterActorUIDs = [], immediate = false) {
    let actorEntries = this.getActors();
    if (filterActorUIDs?.length > 0) {
      actorEntries = actorEntries.filter((actorEntry) => {
        return filterActorUIDs.includes(actorEntry.uid);
      });
    }
    actorEntries.forEach((actorEntry) => {
      const { actor } = actorEntry;
      const mapper = actor.getMapper();
      mapper.setBlendMode?.(blendMode);
      actorEntry.blendMode = blendMode;
    });
    if (immediate) {
      this.render();
    }
  }
  resetCamera(options) {
    const { resetPan = true, resetZoom = true, resetRotation = true, resetToCenter = true, suppressEvents = false, resetOrientation = true } = options || {};
    const { orientation } = this.viewportProperties;
    if (orientation && resetOrientation) {
      this.applyViewOrientation(orientation, false);
    }
    super.resetCamera({ resetPan, resetZoom, resetToCenter });
    const activeCamera = this.getVtkActiveCamera();
    const viewPlaneNormal = activeCamera.getViewPlaneNormal();
    const focalPoint = activeCamera.getFocalPoint();
    const actorEntries = this.getActors();
    actorEntries.forEach((actorEntry) => {
      if (!actorEntry.actor) {
        return;
      }
      const mapper = actorEntry.actor.getMapper();
      const vtkPlanes = mapper.getClippingPlanes();
      if (vtkPlanes.length === 0 && !actorEntry?.clippingFilter) {
        const clipPlane1 = vtkPlane$1.newInstance();
        const clipPlane2 = vtkPlane$1.newInstance();
        const newVtkPlanes = [clipPlane1, clipPlane2];
        let slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
        if (actorEntry.slabThickness) {
          slabThickness = actorEntry.slabThickness;
        }
        this.setOrientationOfClippingPlanes(newVtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
        mapper.addClippingPlane(clipPlane1);
        mapper.addClippingPlane(clipPlane2);
      }
    });
    if (resetRotation && mprCameraValues_default[this.viewportProperties.orientation] !== undefined) {
      const viewToReset = mprCameraValues_default[this.viewportProperties.orientation];
      this.setCameraNoEvent({
        viewUp: viewToReset.viewUp,
        viewPlaneNormal: viewToReset.viewPlaneNormal
      });
    }
    if (!suppressEvents) {
      const eventDetail = {
        viewportId: this.id,
        camera: this.getCamera(),
        renderingEngineId: this.renderingEngineId,
        element: this.element
      };
      triggerEvent(this.element, Events_default.CAMERA_RESET, eventDetail);
    }
    return true;
  }
  setSlabThickness(slabThickness, filterActorUIDs = []) {
    if (slabThickness < 0.1) {
      slabThickness = 0.1;
    }
    let actorEntries = this.getActors();
    if (filterActorUIDs?.length > 0) {
      actorEntries = actorEntries.filter((actorEntry) => {
        return filterActorUIDs.includes(actorEntry.uid);
      });
    }
    actorEntries.forEach((actorEntry) => {
      if (actorIsA(actorEntry, "vtkVolume")) {
        actorEntry.slabThickness = slabThickness;
      }
    });
    const currentCamera = this.getCamera();
    this.updateClippingPlanesForActors(currentCamera);
    this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
    this.viewportProperties.slabThickness = slabThickness;
  }
  resetSlabThickness() {
    const actorEntries = this.getActors();
    actorEntries.forEach((actorEntry) => {
      if (actorIsA(actorEntry, "vtkVolume")) {
        actorEntry.slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
      }
    });
    const currentCamera = this.getCamera();
    this.updateClippingPlanesForActors(currentCamera);
    this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
    this.viewportProperties.slabThickness = undefined;
  }
  getSliceViewInfo() {
    const { width: canvasWidth, height: canvasHeight } = this.getCanvas();
    const ijkOriginPoint = transformCanvasToIJK(this, [0, 0]);
    const ijkRowPoint = transformCanvasToIJK(this, [canvasWidth - 1, 0]);
    const ijkColPoint = transformCanvasToIJK(this, [0, canvasHeight - 1]);
    const ijkRowVec = exports_vec3.sub(exports_vec3.create(), ijkRowPoint, ijkOriginPoint);
    const ijkColVec = exports_vec3.sub(exports_vec3.create(), ijkColPoint, ijkOriginPoint);
    const ijkSliceVec = exports_vec3.cross(exports_vec3.create(), ijkRowVec, ijkColVec);
    exports_vec3.normalize(ijkRowVec, ijkRowVec);
    exports_vec3.normalize(ijkColVec, ijkColVec);
    exports_vec3.normalize(ijkSliceVec, ijkSliceVec);
    const { dimensions } = this.getImageData();
    const [sx, sy, sz] = dimensions;
    const ijkCorners = [
      [0, 0, 0],
      [sx - 1, 0, 0],
      [0, sy - 1, 0],
      [sx - 1, sy - 1, 0],
      [0, 0, sz - 1],
      [sx - 1, 0, sz - 1],
      [0, sy - 1, sz - 1],
      [sx - 1, sy - 1, sz - 1]
    ];
    const canvasCorners = ijkCorners.map((ijkCorner) => transformIJKToCanvas(this, ijkCorner));
    const canvasAABB = canvasCorners.reduce((aabb, canvasPoint) => {
      aabb.minX = Math.min(aabb.minX, canvasPoint[0]);
      aabb.minY = Math.min(aabb.minY, canvasPoint[1]);
      aabb.maxX = Math.max(aabb.maxX, canvasPoint[0]);
      aabb.maxY = Math.max(aabb.maxY, canvasPoint[1]);
      return aabb;
    }, { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
    const ijkTopLeft = transformCanvasToIJK(this, [
      canvasAABB.minX,
      canvasAABB.minY
    ]);
    const sliceToIndexMatrix = exports_mat4.fromValues(ijkRowVec[0], ijkRowVec[1], ijkRowVec[2], 0, ijkColVec[0], ijkColVec[1], ijkColVec[2], 0, ijkSliceVec[0], ijkSliceVec[1], ijkSliceVec[2], 0, ijkTopLeft[0], ijkTopLeft[1], ijkTopLeft[2], 1);
    const ijkBottomRight = transformCanvasToIJK(this, [
      canvasAABB.maxX,
      canvasAABB.maxY
    ]);
    const ijkDiagonal = exports_vec3.sub(exports_vec3.create(), ijkBottomRight, ijkTopLeft);
    const indexToSliceMatrix = exports_mat4.invert(exports_mat4.create(), sliceToIndexMatrix);
    const { viewPlaneNormal } = this.getCamera();
    const isOblique = viewPlaneNormal.filter((component) => Math.abs(component) > epsilon_default).length > 1;
    if (isOblique) {
      throw new Error("getSliceInfo is not supported for oblique views");
    }
    const sliceAxis = viewPlaneNormal.findIndex((component) => Math.abs(component) > 1 - epsilon_default);
    if (sliceAxis === -1) {
      throw new Error("Unable to determine slice axis");
    }
    const sliceWidth = exports_vec3.dot(ijkRowVec, ijkDiagonal) + 1;
    const sliceHeight = exports_vec3.dot(ijkColVec, ijkDiagonal) + 1;
    return {
      sliceIndex: this.getSliceIndex(),
      width: sliceWidth,
      height: sliceHeight,
      slicePlane: sliceAxis,
      sliceToIndexMatrix,
      indexToSliceMatrix
    };
  }
  getCurrentSlicePixelData() {
    const { voxelManager } = this.getImageData();
    const sliceData = voxelManager.getSliceData(this.getSliceViewInfo());
    return sliceData;
  }
  getViewReference(viewRefSpecifier = {}) {
    const viewRef = super.getViewReference(viewRefSpecifier);
    if (!viewRef?.volumeId) {
      return;
    }
    const volume = cache_default.getVolume(viewRef.volumeId);
    viewRef.referencedImageId = getClosestImageId(volume, viewRef.cameraFocalPoint, viewRef.viewPlaneNormal);
    return viewRef;
  }
  resetProperties(volumeId) {
    this._resetProperties(volumeId);
  }
  _resetProperties(volumeId) {
    const volumeActor = volumeId ? this.getActor(volumeId) : this.getDefaultActor();
    if (!volumeActor) {
      throw new Error(`No actor found for the given volumeId: ${volumeId}`);
    }
    if (volumeActor.slabThickness) {
      volumeActor.slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
      this.viewportProperties.slabThickness = undefined;
      this.updateClippingPlanesForActors(this.getCamera());
    }
    volumeId ||= this.getVolumeId();
    const imageVolume = cache_default.getVolume(volumeId);
    if (!imageVolume) {
      throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
    }
    setDefaultVolumeVOI_default(volumeActor.actor, imageVolume);
    if (isImageActor(volumeActor)) {
      const transferFunction = volumeActor.actor.getProperty().getRGBTransferFunction(0);
      setTransferFunctionNodes(transferFunction, this.initialTransferFunctionNodes);
    }
    const eventDetails = {
      ...super.getVOIModifiedEventDetail(volumeId)
    };
    const resetPan = true;
    const resetZoom = true;
    const resetToCenter = true;
    const resetCameraRotation = true;
    this.resetCamera({
      resetPan,
      resetZoom,
      resetToCenter,
      resetCameraRotation
    });
    triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetails);
  }
  getSlicesClippingPlanes() {
    const focalPoints = this.getSlicePlaneCoordinates();
    const { viewPlaneNormal } = this.getCamera();
    const slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
    return focalPoints.map(({ point, sliceIndex }) => {
      const vtkPlanes = [vtkPlane$1.newInstance(), vtkPlane$1.newInstance()];
      this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, point);
      return {
        sliceIndex,
        planes: vtkPlanes.map((plane) => ({
          normal: plane.getNormal(),
          origin: plane.getOrigin()
        }))
      };
    });
  }
}
var VolumeViewport_default = VolumeViewport;

// ../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper.js
function vtkAbstractImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractImageMapper");
  publicAPI.getIsOpaque = () => true;
  publicAPI.getCurrentImage = () => null;
  publicAPI.getBoundsForSlice = () => {
    macro.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED");
    return createUninitializedBounds();
  };
}
var DEFAULT_VALUES104 = {
  slice: 0,
  customDisplayExtent: [0, 0, 0, 0, 0, 0],
  useCustomExtents: false,
  backgroundColor: [0, 0, 0, 1]
};
function extend107(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES104, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["slice", "useCustomExtents"]);
  macro.setGetArray(publicAPI, model, ["customDisplayExtent"], 6);
  macro.setGetArray(publicAPI, model, ["backgroundColor"], 4);
  vtkAbstractImageMapper(publicAPI, model);
}
var vtkAbstractImageMapper$1 = {
  extend: extend107
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js
function doPicking(p1, p2, mapper) {
  const imageData = mapper.getCurrentImage();
  const extent = imageData.getExtent();
  const ijk = [extent[0], extent[2], extent[4]];
  const {
    ijkMode
  } = mapper.getClosestIJKAxis();
  let nSlice = mapper.isA("vtkImageArrayMapper") ? mapper.getSubSlice() : mapper.getSlice();
  if (ijkMode !== mapper.getSlicingMode()) {
    nSlice = mapper.getSliceAtPosition(nSlice);
  }
  ijk[ijkMode] += nSlice;
  const worldOrigin = [0, 0, 0];
  imageData.indexToWorld(ijk, worldOrigin);
  ijk[ijkMode] += 1;
  const worldNormal = [0, 0, 0];
  imageData.indexToWorld(ijk, worldNormal);
  worldNormal[0] -= worldOrigin[0];
  worldNormal[1] -= worldOrigin[1];
  worldNormal[2] -= worldOrigin[2];
  exports_vec3.normalize(worldNormal, worldNormal);
  const intersect2 = vtkPlane$1.intersectWithLine(p1, p2, worldOrigin, worldNormal);
  if (intersect2.intersection) {
    const point = intersect2.x;
    const absoluteIJK = [0, 0, 0];
    imageData.worldToIndex(point, absoluteIJK);
    return {
      t: intersect2.t,
      absoluteIJK
    };
  }
  return null;
}
function intersectWithLineForPointPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
      return null;
    }
    return {
      t: pickingData.t,
      ijk
    };
  }
  return null;
}
function intersectWithLineForCellPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const absIJK = pickingData.absoluteIJK;
    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];
    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] || ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {
      return null;
    }
    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
    return {
      t: pickingData.t,
      ijk,
      pCoords
    };
  }
  return null;
}

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js
var {
  staticOffsetAPI: staticOffsetAPI3,
  otherStaticMethods: otherStaticMethods3
} = CoincidentTopologyHelper;
var {
  SlicingMode: SlicingMode4
} = Constants12;
function vtkImageMapper2(publicAPI, model) {
  model.classHierarchy.push("vtkImageMapper");
  publicAPI.getSliceAtPosition = (pos) => {
    const image = publicAPI.getCurrentImage();
    let pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      const bds = image.getBounds();
      switch (model.slicingMode) {
        case SlicingMode4.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode4.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode4.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    const ijk = [0, 0, 0];
    image.worldToIndex(pos3, ijk);
    const ex = image.getExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let slice = 0;
    switch (ijkMode) {
      case SlicingMode4.I:
        slice = clampValue(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode4.J:
        slice = clampValue(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode4.K:
        slice = clampValue(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice;
  };
  publicAPI.setSliceFromCamera = (cam) => {
    const fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode4.I:
      case SlicingMode4.J:
      case SlicingMode4.K:
        {
          const slice = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice);
        }
        break;
      case SlicingMode4.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode4.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode4.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = (id) => {
    publicAPI.setSlicingMode(SlicingMode4.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = () => {
    const out = [0, 0, 0];
    const mat3 = publicAPI.getCurrentImage().getDirection();
    switch (model.slicingMode) {
      case SlicingMode4.X:
        out[0] = 1;
        break;
      case SlicingMode4.Y:
        out[1] = 1;
        break;
      case SlicingMode4.Z:
        out[2] = 1;
        break;
      case SlicingMode4.I:
        multiply3x3_vect3(mat3, [1, 0, 0], out);
        break;
      case SlicingMode4.J:
        multiply3x3_vect3(mat3, [0, 1, 0], out);
        break;
      case SlicingMode4.K:
        multiply3x3_vect3(mat3, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    let xyzMode;
    switch (model.slicingMode) {
      case SlicingMode4.X:
        xyzMode = 0;
        break;
      case SlicingMode4.Y:
        xyzMode = 1;
        break;
      case SlicingMode4.Z:
        xyzMode = 2;
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }
    const direction = publicAPI.getCurrentImage().getDirection();
    const newMatrix = getSparseOrthogonalMatrix(direction);
    let ijkMode = 0;
    for (;ijkMode < 3; ++ijkMode) {
      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {
        break;
      }
    }
    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;
    model.closestIJKAxis = {
      ijkMode,
      flip
    };
  }
  publicAPI.setSlicingMode = (mode) => {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = () => {
    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode4.NONE) && publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = () => {
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return createUninitializedBounds();
    }
    if (!model.useCustomExtents) {
      return image.getBounds();
    }
    const ex = model.customDisplayExtent.slice();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode4.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode4.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode4.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function() {
    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;
    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return createUninitializedBounds();
    }
    const extent = image.getSpatialExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = slice;
    if (ijkMode !== model.slicingMode) {
      nSlice = publicAPI.getSliceAtPosition(slice);
    }
    switch (ijkMode) {
      case SlicingMode4.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode4.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode4.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image.extentToBounds(extent);
  };
  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);
  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);
  publicAPI.getCurrentImage = () => publicAPI.getInputData();
}
var DEFAULT_VALUES105 = {
  slicingMode: SlicingMode4.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode4.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false,
  preferSizeOverAccuracy: false
};
function extend108(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES105, initialValues);
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["slicingMode"]);
  macro.setGet(publicAPI, model, ["closestIJKAxis", "renderToRectangle", "sliceAtFocalPoint", "preferSizeOverAccuracy"]);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkImageMapper2(publicAPI, model);
}
var newInstance107 = macro.newInstance(extend108, "vtkImageMapper");
var vtkImageMapper$1 = {
  newInstance: newInstance107,
  extend: extend108,
  ...staticOffsetAPI3,
  ...otherStaticMethods3,
  ...Constants12
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty.js
var {
  InterpolationType: InterpolationType5
} = Constants13;
var {
  vtkErrorMacro: vtkErrorMacro39
} = macro;
var VTK_MAX_VRCOMP2 = 4;
function vtkImageProperty(publicAPI, model) {
  model.classHierarchy.push("vtkImageProperty");
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index2 = 0;index2 < VTK_MAX_VRCOMP2; index2++) {
      if (model.componentData[index2].rGBTransferFunction) {
        time = model.componentData[index2].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index2].piecewiseFunction) {
        time = model.componentData[index2].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };
  publicAPI.setRGBTransferFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getRGBTransferFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };
  publicAPI.setPiecewiseFunction = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getPiecewiseFunction = function() {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };
  publicAPI.setScalarOpacity = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let idx = index2;
    let transferFunc = func;
    if (!Number.isInteger(index2)) {
      transferFunc = index2;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };
  publicAPI.getScalarOpacity = function() {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP2) {
      vtkErrorMacro39("Invalid index");
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index2].componentWeight !== val) {
      model.componentData[index2].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function() {
    let index2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index2 < 0 || index2 >= VTK_MAX_VRCOMP2) {
      vtkErrorMacro39("Invalid index");
      return 0;
    }
    return model.componentData[index2].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType5.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType5.LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macro.enumToString(InterpolationType5, model.interpolationType);
}
var DEFAULT_VALUES106 = {
  independentComponents: false,
  interpolationType: InterpolationType5.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1,
  diffuse: 0,
  opacity: 1,
  useLookupTableScalarRange: false,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1
};
function extend109(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES106, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0;i < VTK_MAX_VRCOMP2; i++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "colorWindow", "colorLevel", "ambient", "diffuse", "opacity", "useLookupTableScalarRange", "useLabelOutline", "labelOutlineOpacity"]);
  macro.setGetArray(publicAPI, model, ["labelOutlineThickness"]);
  vtkImageProperty(publicAPI, model);
}
var newInstance108 = macro.newInstance(extend109, "vtkImageProperty");
var vtkImageProperty$1 = {
  newInstance: newInstance108,
  extend: extend109
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js
var {
  vtkDebugMacro: vtkDebugMacro12
} = macro;
function vtkImageSlice2(publicAPI, model) {
  model.classHierarchy.push("vtkImageSlice");
  publicAPI.getActors = () => publicAPI;
  publicAPI.getImages = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    const zip = (rows) => rows[0].map((_, c) => rows.map((row) => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro12("Recomputing bounds...");
      model.mapperBounds = bds.map((x) => x);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      exports_mat4.transpose(tmp4, model.matrix);
      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBoundsForSlice = (slice, thickness) => {
    const bds = model.mapper.getBoundsForSlice(slice, thickness);
    if (!vtkBoundingBox.isValid(bds)) {
      return bds;
    }
    publicAPI.computeMatrix();
    const tmp4 = new Float64Array(16);
    exports_mat4.transpose(tmp4, model.matrix);
    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);
    return newBounds;
  };
  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];
  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];
  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];
  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];
  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];
  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    if (model.property !== null) {
      let time = model.property.getMTime();
      mt = time > mt ? time : mt;
      if (model.property.getRGBTransferFunction() !== null) {
        time = model.property.getRGBTransferFunction().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
}
var DEFAULT_VALUES107 = {
  mapper: null,
  property: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [...vtkBoundingBox.INIT_BOUNDS]
};
function extend110(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES107, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper", "forceOpaque", "forceTranslucent"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkImageSlice2(publicAPI, model);
}
var newInstance109 = macro.newInstance(extend110, "vtkImageSlice");
var vtkImageSlice$1 = {
  newInstance: newInstance109,
  extend: extend110
};

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js
function createLinearRGBTransferFunction(voiRange) {
  const cfun = vtkColorTransferFunction$1.newInstance();
  let lower = 0;
  let upper = 1024;
  if (voiRange.lower !== undefined && voiRange.upper !== undefined) {
    lower = voiRange.lower;
    upper = voiRange.upper;
  }
  cfun.addRGBPoint(lower, 0, 0, 0);
  cfun.addRGBPoint(upper, 1, 1, 1);
  return cfun;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js
function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {
  const pixelData = image.voxelManager.getScalarData();
  if (!sourceImageData.getPointData) {
    return;
  }
  const scalarData = sourceImageData.getPointData().getScalars().getData();
  if (image.color && image.rgba) {
    const newPixelData = new Uint8Array(image.columns * image.rows * 3);
    for (let i = 0;i < image.columns * image.rows; i++) {
      newPixelData[i * 3] = pixelData[i * 4];
      newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];
      newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];
    }
    image.rgba = false;
    image.getPixelData = () => newPixelData;
    scalarData.set(newPixelData);
  } else {
    scalarData.set(pixelData);
  }
  sourceImageData.modified();
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
function now_default() {
  if (window.performance) {
    return performance.now();
  }
  return Date.now();
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.js
function generateLinearVOILUT(windowWidth, windowCenter) {
  return function(modalityLutValue) {
    const value = ((modalityLutValue - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) * 255;
    return Math.min(Math.max(value, 0), 255);
  };
}
function generateNonLinearVOILUT(voiLUT) {
  const bitsPerEntry = Math.max(...voiLUT.lut).toString(2).length;
  const shift = bitsPerEntry - 8;
  const minValue = voiLUT.lut[0] >> shift;
  const maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;
  const maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;
  return function(modalityLutValue) {
    if (modalityLutValue < voiLUT.firstValueMapped) {
      return minValue;
    } else if (modalityLutValue >= maxValueMapped) {
      return maxValue;
    }
    return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;
  };
}
function getVOILut_default(windowWidth, windowCenter, voiLUT) {
  if (voiLUT) {
    return generateNonLinearVOILUT(voiLUT);
  }
  return generateLinearVOILUT(windowWidth, windowCenter);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateColorLUT.js
function generateColorLUT(image, windowWidth, windowCenter, invert4, voiLUT) {
  const maxPixelValue = image.maxPixelValue;
  const minPixelValue = image.minPixelValue;
  const offset = Math.min(minPixelValue, 0);
  if (image.cachedLut === undefined) {
    const length5 = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length5);
  }
  const lut = image.cachedLut.lutArray;
  const vlutfn = getVOILut_default(Array.isArray(windowWidth) ? windowWidth[0] : windowWidth, Array.isArray(windowCenter) ? windowCenter[0] : windowCenter, voiLUT);
  if (invert4) {
    for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = 255 - vlutfn(storedValue);
    }
  } else {
    for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
      lut[storedValue + -offset] = vlutfn(storedValue);
    }
  }
  return lut;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedColorPixelDataToCanvasImageData.js
function storedColorPixelDataToCanvasImageData_default(image, lut, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  const numPixels = pixelData.length;
  start = now_default();
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex] + -minPixelValue];
      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex]];
      storedPixelDataIndex += 2;
      canvasImageDataIndex += 2;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedRGBAPixelDataToCanvasImageData.js
function storedRGBAPixelDataToCanvasImageData_default(image, lut, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.getPixelData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  const numPixels = pixelData.length;
  start = now_default();
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelData[storedPixelDataIndex++];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
class Transform2 {
  constructor() {
    this.reset();
  }
  getMatrix() {
    return this.m;
  }
  reset() {
    this.m = [1, 0, 0, 1, 0, 0];
  }
  clone() {
    const transform = new Transform2;
    transform.m[0] = this.m[0];
    transform.m[1] = this.m[1];
    transform.m[2] = this.m[2];
    transform.m[3] = this.m[3];
    transform.m[4] = this.m[4];
    transform.m[5] = this.m[5];
    return transform;
  }
  multiply(matrix) {
    const m11 = this.m[0] * matrix[0] + this.m[2] * matrix[1];
    const m12 = this.m[1] * matrix[0] + this.m[3] * matrix[1];
    const m21 = this.m[0] * matrix[2] + this.m[2] * matrix[3];
    const m22 = this.m[1] * matrix[2] + this.m[3] * matrix[3];
    const dx = this.m[0] * matrix[4] + this.m[2] * matrix[5] + this.m[4];
    const dy2 = this.m[1] * matrix[4] + this.m[3] * matrix[5] + this.m[5];
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy2;
  }
  invert() {
    const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
    const m0 = this.m[3] * d;
    const m1 = -this.m[1] * d;
    const m2 = -this.m[2] * d;
    const m32 = this.m[0] * d;
    const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
    const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m32;
    this.m[4] = m4;
    this.m[5] = m5;
  }
  rotate(rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const m11 = this.m[0] * c + this.m[2] * s;
    const m12 = this.m[1] * c + this.m[3] * s;
    const m21 = this.m[0] * -s + this.m[2] * c;
    const m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
  }
  translate(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
  }
  scale(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
  }
  transformPoint(point) {
    const x = point[0];
    const y = point[1];
    return [
      x * this.m[0] + y * this.m[2] + this.m[4],
      x * this.m[1] + y * this.m[3] + this.m[5]
    ];
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js
function calculateTransform_default(enabledElement, scale8) {
  const transform = new Transform2;
  if (!enabledElement.viewport.displayedArea) {
    return transform;
  }
  transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);
  const angle3 = enabledElement.viewport.rotation;
  if (angle3 !== 0) {
    transform.rotate(angle3 * Math.PI / 180);
  }
  let widthScale = enabledElement.viewport.scale;
  let heightScale = enabledElement.viewport.scale;
  const width = enabledElement.viewport.displayedArea.brhc.x - (enabledElement.viewport.displayedArea.tlhc.x - 1);
  const height = enabledElement.viewport.displayedArea.brhc.y - (enabledElement.viewport.displayedArea.tlhc.y - 1);
  if (enabledElement.viewport.displayedArea.presentationSizeMode === "NONE") {
    if (enabledElement.image.rowPixelSpacing < enabledElement.image.columnPixelSpacing) {
      widthScale *= enabledElement.image.columnPixelSpacing / enabledElement.image.rowPixelSpacing;
    } else if (enabledElement.image.columnPixelSpacing < enabledElement.image.rowPixelSpacing) {
      heightScale *= enabledElement.image.rowPixelSpacing / enabledElement.image.columnPixelSpacing;
    }
  } else {
    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;
    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;
    if (enabledElement.viewport.displayedArea.presentationSizeMode === "SCALE TO FIT") {
      const verticalScale = enabledElement.canvas.height / (height * heightScale);
      const horizontalScale = enabledElement.canvas.width / (width * widthScale);
      widthScale = heightScale = Math.min(horizontalScale, verticalScale);
      if (enabledElement.viewport.displayedArea.rowPixelSpacing < enabledElement.viewport.displayedArea.columnPixelSpacing) {
        widthScale *= enabledElement.viewport.displayedArea.columnPixelSpacing / enabledElement.viewport.displayedArea.rowPixelSpacing;
      } else if (enabledElement.viewport.displayedArea.columnPixelSpacing < enabledElement.viewport.displayedArea.rowPixelSpacing) {
        heightScale *= enabledElement.viewport.displayedArea.rowPixelSpacing / enabledElement.viewport.displayedArea.columnPixelSpacing;
      }
    }
  }
  transform.scale(widthScale, heightScale);
  if (angle3 !== 0) {
    transform.rotate(-angle3 * Math.PI / 180);
  }
  transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);
  if (angle3 !== 0) {
    transform.rotate(angle3 * Math.PI / 180);
  }
  if (scale8 !== undefined) {
    transform.scale(scale8, scale8);
  }
  if (enabledElement.viewport.hflip) {
    transform.scale(-1, 1);
  }
  if (enabledElement.viewport.vflip) {
    transform.scale(1, -1);
  }
  transform.translate(-width / 2, -height / 2);
  return transform;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
function setToPixelCoordinateSystem_default(enabledElement, context, scale8) {
  if (enabledElement === undefined) {
    throw new Error("setToPixelCoordinateSystem: parameter enabledElement must not be undefined");
  }
  if (context === undefined) {
    throw new Error("setToPixelCoordinateSystem: parameter context must not be undefined");
  }
  const transform = calculateTransform_default(enabledElement, scale8);
  const m = transform.getMatrix();
  context.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
function doesImageNeedToBeRendered(enabledElement, image) {
  const lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;
  const lastRenderedViewport = enabledElement.renderingTools.lastRenderedViewport;
  return image.imageId !== lastRenderedImageId || !lastRenderedViewport || lastRenderedViewport.windowCenter !== enabledElement.viewport.voi.windowCenter || lastRenderedViewport.windowWidth !== enabledElement.viewport.voi.windowWidth || lastRenderedViewport.invert !== enabledElement.viewport.invert || lastRenderedViewport.rotation !== enabledElement.viewport.rotation || lastRenderedViewport.hflip !== enabledElement.viewport.hflip || lastRenderedViewport.vflip !== enabledElement.viewport.vflip || lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT || lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT || lastRenderedViewport.colormap !== enabledElement.viewport.colormap;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
function initializeRenderCanvas_default(enabledElement, image) {
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  renderCanvas.width = image.width;
  renderCanvas.height = image.height;
  const canvasContext = renderCanvas.getContext("2d");
  canvasContext.fillStyle = "white";
  canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
  const renderCanvasData = canvasContext.getImageData(0, 0, image.width, image.height);
  enabledElement.renderingTools.renderCanvasContext = canvasContext;
  enabledElement.renderingTools.renderCanvasData = renderCanvasData;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
function saveLastRendered_default(enabledElement) {
  const imageId = enabledElement.image.imageId;
  const viewport = enabledElement.viewport;
  const isColor = enabledElement.image.color;
  enabledElement.renderingTools.lastRenderedImageId = imageId;
  enabledElement.renderingTools.lastRenderedIsColor = isColor;
  enabledElement.renderingTools.lastRenderedViewport = {
    windowCenter: viewport.voi.windowCenter,
    windowWidth: viewport.voi.windowWidth,
    invert: viewport.invert,
    rotation: viewport.rotation,
    hflip: viewport.hflip,
    vflip: viewport.vflip,
    modalityLUT: viewport.modalityLUT,
    voiLUT: viewport.voiLUT,
    colormap: viewport.colormap
  };
  return enabledElement.renderingTools;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderColorImage.js
function getLut(image, viewport) {
  if (image.cachedLut !== undefined && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && image.cachedLut.invert === viewport.invert) {
    return image.cachedLut.lutArray;
  }
  generateColorLUT(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  return image.cachedLut.lutArray;
}
function getRenderCanvas(enabledElement, image, invalidated) {
  const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
  if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  const { windowWidth, windowCenter } = enabledElement.viewport.voi;
  if ((windowWidth === 256 || windowWidth === 255) && (windowCenter === 128 || windowCenter === 127) && !enabledElement.viewport.invert && image.getCanvas && image.getCanvas()) {
    return image.getCanvas();
  }
  if (!doesImageNeedToBeRendered(enabledElement, image) && !invalidated) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas_default(enabledElement, image);
  }
  let start = now_default();
  const colorLUT = getLut(image, enabledElement.viewport);
  image.stats = image.stats || {};
  image.stats.lastLutGenerateTime = now_default() - start;
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  if (image.rgba) {
    storedRGBAPixelDataToCanvasImageData_default(image, colorLUT, renderCanvasData.data);
  } else {
    storedColorPixelDataToCanvasImageData_default(image, colorLUT, renderCanvasData.data);
  }
  start = now_default();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now_default() - start;
  return renderCanvas;
}
function renderColorImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error("renderColorImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === undefined) {
    throw new Error("renderColorImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem_default(enabledElement, context);
  const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered_default(enabledElement);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageData.js
function storedPixelDataToCanvasImageData_default(image, lut, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 3;
  let storedPixelDataIndex = 0;
  start = now_default();
  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
        canvasImageDataIndex += 4;
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
        canvasImageDataIndex += 4;
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataIndex += 4;
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataIndex += 4;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      canvasImageDataData[canvasImageDataIndex] = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataIndex += 4;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPET.js
function storedPixelDataToCanvasImageDataPET_default(image, lutFunction, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const numPixels = pixelData.length;
  let canvasImageDataIndex = 3;
  let storedPixelDataIndex = 0;
  start = now_default();
  while (storedPixelDataIndex < numPixels) {
    canvasImageDataData[canvasImageDataIndex] = lutFunction(pixelData[storedPixelDataIndex++]);
    canvasImageDataIndex += 4;
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataRGBA.js
function storedPixelDataToCanvasImageDataRGBA_default(image, lut, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let pixelValue;
  start = now_default();
  if (pixelData instanceof Int16Array) {
    if (minPixelValue < 0) {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255;
      }
    } else {
      while (storedPixelDataIndex < numPixels) {
        pixelValue = lut[pixelData[storedPixelDataIndex++]];
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = pixelValue;
        canvasImageDataData[canvasImageDataIndex++] = 255;
      }
    }
  } else if (pixelData instanceof Uint16Array) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  } else if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      pixelValue = lut[pixelData[storedPixelDataIndex++]];
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = pixelValue;
      canvasImageDataData[canvasImageDataIndex++] = 255;
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/computeAutoVoi.js
function computeAutoVoi(viewport, image) {
  if (hasVoi(viewport)) {
    return;
  }
  const maxVoi = image.maxPixelValue * image.slope + image.intercept;
  const minVoi = image.minPixelValue * image.slope + image.intercept;
  const ww = maxVoi - minVoi;
  const wc = (maxVoi + minVoi) / 2;
  if (viewport.voi === undefined) {
    viewport.voi = {
      windowWidth: ww,
      windowCenter: wc,
      voiLUTFunction: image.voiLUTFunction
    };
  } else {
    viewport.voi.windowWidth = ww;
    viewport.voi.windowCenter = wc;
  }
}
function hasVoi(viewport) {
  const hasLut = viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;
  return hasLut || viewport.voi.windowWidth !== undefined && viewport.voi.windowCenter !== undefined;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/lutMatches.js
function lutMatches(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.id === b.id;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getModalityLut.js
function generateLinearModalityLUT(slope, intercept) {
  return (storedPixelValue) => storedPixelValue * slope + intercept;
}
function generateNonLinearModalityLUT(modalityLUT) {
  const minValue = modalityLUT.lut[0];
  const maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];
  const maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;
  return (storedPixelValue) => {
    if (storedPixelValue < modalityLUT.firstValueMapped) {
      return minValue;
    } else if (storedPixelValue >= maxValueMapped) {
      return maxValue;
    }
    return modalityLUT.lut[storedPixelValue];
  };
}
function getModalityLut_default(slope, intercept, modalityLUT) {
  if (modalityLUT) {
    return generateNonLinearModalityLUT(modalityLUT);
  }
  return generateLinearModalityLUT(slope, intercept);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateLut.js
function generateLut_default(image, windowWidth, windowCenter, invert4, modalityLUT, voiLUT) {
  const maxPixelValue = image.maxPixelValue;
  const minPixelValue = image.minPixelValue;
  const offset = Math.min(minPixelValue, 0);
  if (image.cachedLut === undefined) {
    const length5 = maxPixelValue - offset + 1;
    image.cachedLut = {};
    image.cachedLut.lutArray = new Uint8ClampedArray(length5);
  }
  const lut = image.cachedLut.lutArray;
  const mlutfn = getModalityLut_default(image.slope, image.intercept, modalityLUT);
  const vlutfn = getVOILut_default(windowWidth, windowCenter, voiLUT);
  if (image.isPreScaled) {
    if (invert4) {
      for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = 255 - vlutfn(storedValue);
      }
    } else {
      for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = vlutfn(storedValue);
      }
    }
  } else {
    if (invert4) {
      for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));
      }
    } else {
      for (let storedValue = minPixelValue;storedValue <= maxPixelValue; storedValue++) {
        lut[storedValue + -offset] = vlutfn(mlutfn(storedValue));
      }
    }
  }
  return lut;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js
function getLut_default(image, viewport, invalidated) {
  if (image.cachedLut !== undefined && image.cachedLut.windowCenter === viewport.voi.windowCenter && image.cachedLut.windowWidth === viewport.voi.windowWidth && lutMatches(image.cachedLut.modalityLUT, viewport.modalityLUT) && lutMatches(image.cachedLut.voiLUT, viewport.voiLUT) && image.cachedLut.invert === viewport.invert && !invalidated) {
    return image.cachedLut.lutArray;
  }
  computeAutoVoi(viewport, image);
  generateLut_default(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);
  image.cachedLut.windowWidth = viewport.voi.windowWidth;
  image.cachedLut.windowCenter = viewport.voi.windowCenter;
  image.cachedLut.invert = viewport.invert;
  image.cachedLut.voiLUT = viewport.voiLUT;
  image.cachedLut.modalityLUT = viewport.modalityLUT;
  return image.cachedLut.lutArray;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderGrayscaleImage.js
function getRenderCanvas2(enabledElement, image, invalidated, useAlphaChannel = true) {
  const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
  if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
    initializeRenderCanvas_default(enabledElement, image);
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  if (!doesImageNeedToBeRendered(enabledElement, image) && !invalidated) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas_default(enabledElement, image);
  }
  image.stats = image.stats || {};
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  let start = now_default();
  image.stats.lastLutGenerateTime = now_default() - start;
  const { viewport } = enabledElement;
  if (viewport.modality === "PT" && image.isPreScaled) {
    const { windowWidth, windowCenter } = viewport.voi;
    const minimum = windowCenter - windowWidth / 2;
    const maximum = windowCenter + windowWidth / 2;
    const range = maximum - minimum;
    const collectedMultiplierTerms = 255 / range;
    let petVOILutFunction;
    if (viewport.invert) {
      petVOILutFunction = (value) => 255 - (value - minimum) * collectedMultiplierTerms;
    } else {
      petVOILutFunction = (value) => (value - minimum) * collectedMultiplierTerms;
    }
    storedPixelDataToCanvasImageDataPET_default(image, petVOILutFunction, renderCanvasData.data);
  } else {
    const lut = getLut_default(image, viewport, invalidated);
    if (useAlphaChannel) {
      storedPixelDataToCanvasImageData_default(image, lut, renderCanvasData.data);
    } else {
      storedPixelDataToCanvasImageDataRGBA_default(image, lut, renderCanvasData.data);
    }
  }
  start = now_default();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now_default() - start;
  return renderCanvas;
}
function renderGrayscaleImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error("drawImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === undefined) {
    throw new Error("drawImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem_default(enabledElement, context);
  const renderCanvas = getRenderCanvas2(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered_default(enabledElement);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/lookupTable.js
var BELOW_RANGE_COLOR_INDEX2 = 0;
var ABOVE_RANGE_COLOR_INDEX2 = 1;
var NAN_COLOR_INDEX2 = 2;
function HSVToRGB(hue, sat, val) {
  if (hue > 1) {
    throw new Error("HSVToRGB expects hue < 1");
  }
  const rgb = [];
  if (sat === 0) {
    rgb[0] = val;
    rgb[1] = val;
    rgb[2] = val;
    return rgb;
  }
  const hueCase = Math.floor(hue * 6);
  const frac = 6 * hue - hueCase;
  const lx = val * (1 - sat);
  const ly = val * (1 - sat * frac);
  const lz = val * (1 - sat * (1 - frac));
  switch (hueCase) {
    case 0:
    case 6:
      rgb[0] = val;
      rgb[1] = lz;
      rgb[2] = lx;
      break;
    case 1:
      rgb[0] = ly;
      rgb[1] = val;
      rgb[2] = lx;
      break;
    case 2:
      rgb[0] = lx;
      rgb[1] = val;
      rgb[2] = lz;
      break;
    case 3:
      rgb[0] = lx;
      rgb[1] = ly;
      rgb[2] = val;
      break;
    case 4:
      rgb[0] = lz;
      rgb[1] = lx;
      rgb[2] = val;
      break;
    case 5:
      rgb[0] = val;
      rgb[1] = lx;
      rgb[2] = ly;
      break;
  }
  return rgb;
}
function linearIndexLookupMain(v, p) {
  let dIndex;
  if (v < p.Range[0]) {
    dIndex = p.MaxIndex + BELOW_RANGE_COLOR_INDEX2 + 1.5;
  } else if (v > p.Range[1]) {
    dIndex = p.MaxIndex + ABOVE_RANGE_COLOR_INDEX2 + 1.5;
  } else {
    dIndex = (v + p.Shift) * p.Scale;
  }
  return Math.floor(dIndex);
}

class LookupTable {
  constructor() {
    this.NumberOfColors = 256;
    this.Ramp = "linear";
    this.TableRange = [0, 255];
    this.HueRange = [0, 0.66667];
    this.SaturationRange = [1, 1];
    this.ValueRange = [1, 1];
    this.AlphaRange = [1, 1];
    this.NaNColor = [128, 0, 0, 255];
    this.BelowRangeColor = [0, 0, 0, 255];
    this.UseBelowRangeColor = true;
    this.AboveRangeColor = [255, 255, 255, 255];
    this.UseAboveRangeColor = true;
    this.InputRange = [0, 255];
    this.Table = [];
  }
  setNumberOfTableValues(number) {
    this.NumberOfColors = number;
  }
  setRamp(ramp) {
    this.Ramp = ramp;
  }
  setTableRange(start, end) {
    this.TableRange[0] = start;
    this.TableRange[1] = end;
  }
  setHueRange(start, end) {
    this.HueRange[0] = start;
    this.HueRange[1] = end;
  }
  setSaturationRange(start, end) {
    this.SaturationRange[0] = start;
    this.SaturationRange[1] = end;
  }
  setValueRange(start, end) {
    this.ValueRange[0] = start;
    this.ValueRange[1] = end;
  }
  setRange(start, end) {
    this.InputRange[0] = start;
    this.InputRange[1] = end;
  }
  setAlphaRange(start, end) {
    this.AlphaRange[0] = start;
    this.AlphaRange[1] = end;
  }
  getColor(scalar) {
    return this.mapValue(scalar);
  }
  build(force) {
    if (this.Table.length > 1 && !force) {
      return;
    }
    this.Table = [];
    const maxIndex = this.NumberOfColors - 1;
    let hinc, sinc, vinc, ainc;
    if (maxIndex) {
      hinc = (this.HueRange[1] - this.HueRange[0]) / maxIndex;
      sinc = (this.SaturationRange[1] - this.SaturationRange[0]) / maxIndex;
      vinc = (this.ValueRange[1] - this.ValueRange[0]) / maxIndex;
      ainc = (this.AlphaRange[1] - this.AlphaRange[0]) / maxIndex;
    } else {
      hinc = sinc = vinc = ainc = 0;
    }
    for (let i = 0;i <= maxIndex; i++) {
      const hue = this.HueRange[0] + i * hinc;
      const sat = this.SaturationRange[0] + i * sinc;
      const val = this.ValueRange[0] + i * vinc;
      const alpha = this.AlphaRange[0] + i * ainc;
      const rgb = HSVToRGB(hue, sat, val);
      const c_rgba = [0, 0, 0, 0];
      switch (this.Ramp) {
        case "scurve":
          c_rgba[0] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[0]) * Math.PI)));
          c_rgba[1] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[1]) * Math.PI)));
          c_rgba[2] = Math.floor(127.5 * (1 + Math.cos((1 - rgb[2]) * Math.PI)));
          c_rgba[3] = Math.floor(alpha * 255);
          break;
        case "linear":
          c_rgba[0] = Math.floor(rgb[0] * 255 + 0.5);
          c_rgba[1] = Math.floor(rgb[1] * 255 + 0.5);
          c_rgba[2] = Math.floor(rgb[2] * 255 + 0.5);
          c_rgba[3] = Math.floor(alpha * 255 + 0.5);
          break;
        case "sqrt":
          c_rgba[0] = Math.floor(Math.sqrt(rgb[0]) * 255 + 0.5);
          c_rgba[1] = Math.floor(Math.sqrt(rgb[1]) * 255 + 0.5);
          c_rgba[2] = Math.floor(Math.sqrt(rgb[2]) * 255 + 0.5);
          c_rgba[3] = Math.floor(Math.sqrt(alpha) * 255 + 0.5);
          break;
        default:
          throw new Error(`Invalid Ramp value (${this.Ramp})`);
      }
      this.Table.push(c_rgba);
    }
    this.buildSpecialColors();
  }
  buildSpecialColors() {
    const numberOfColors = this.NumberOfColors;
    const belowRangeColorIndex = numberOfColors + BELOW_RANGE_COLOR_INDEX2;
    const aboveRangeColorIndex = numberOfColors + ABOVE_RANGE_COLOR_INDEX2;
    const nanColorIndex = numberOfColors + NAN_COLOR_INDEX2;
    if (this.UseBelowRangeColor || numberOfColors === 0) {
      this.Table[belowRangeColorIndex] = this.BelowRangeColor;
    } else {
      this.Table[belowRangeColorIndex] = this.Table[0];
    }
    if (this.UseAboveRangeColor || numberOfColors === 0) {
      this.Table[aboveRangeColorIndex] = this.AboveRangeColor;
    } else {
      this.Table[aboveRangeColorIndex] = this.Table[numberOfColors - 1];
    }
    this.Table[nanColorIndex] = this.NaNColor;
  }
  mapValue(v) {
    const index2 = this.getIndex(v);
    if (index2 < 0) {
      return this.NaNColor;
    } else if (index2 === 0) {
      if (this.UseBelowRangeColor && v < this.TableRange[0]) {
        return this.BelowRangeColor;
      }
    } else if (index2 === this.NumberOfColors - 1) {
      if (this.UseAboveRangeColor && v > this.TableRange[1]) {
        return this.AboveRangeColor;
      }
    }
    return this.Table[index2];
  }
  getIndex(v) {
    const p = {
      Range: [],
      MaxIndex: this.NumberOfColors - 1,
      Shift: -this.TableRange[0],
      Scale: 1
    };
    if (this.TableRange[1] <= this.TableRange[0]) {
      p.Scale = Number.MAX_VALUE;
    } else {
      p.Scale = p.MaxIndex / (this.TableRange[1] - this.TableRange[0]);
    }
    p.Range[0] = this.TableRange[0];
    p.Range[1] = this.TableRange[1];
    if (isNaN(v)) {
      return -1;
    }
    let index2 = linearIndexLookupMain(v, p);
    if (index2 === this.NumberOfColors + BELOW_RANGE_COLOR_INDEX2) {
      index2 = 0;
    } else if (index2 === this.NumberOfColors + ABOVE_RANGE_COLOR_INDEX2) {
      index2 = this.NumberOfColors - 1;
    }
    return index2;
  }
  setTableValue(index2, rgba, g, b, a) {
    let colorArray;
    if (typeof rgba === "number" && g !== undefined && b !== undefined && a !== undefined) {
      colorArray = [rgba, g, b, a];
    } else if (Array.isArray(rgba)) {
      colorArray = rgba;
    } else {
      throw new Error("Invalid arguments for setTableValue");
    }
    if (index2 < 0) {
      throw new Error(`Can't set the table value for negative index (${index2})`);
    }
    if (index2 >= this.NumberOfColors) {
      throw new Error(`Index ${index2} is greater than the number of colors ${this.NumberOfColors}`);
    }
    this.Table[index2] = colorArray;
    if (index2 === 0 || index2 === this.NumberOfColors - 1) {
      this.buildSpecialColors();
    }
  }
}
var lookupTable_default = LookupTable;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/colormap.js
var COLOR_TRANSPARENT = [0, 0, 0, 0];
function linspace(a, b, n) {
  n = n === null ? 100 : n;
  const increment = (b - a) / (n - 1);
  const vector = [];
  while (n-- > 0) {
    vector.push(a);
    a += increment;
  }
  vector[vector.length - 1] = b;
  return vector;
}
function getRank(array, elem) {
  let left = 0;
  let right = array.length - 1;
  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    const midElem = array[mid];
    if (midElem === elem) {
      return mid;
    } else if (elem < midElem) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return left;
}
function searchSorted(inputArray, values) {
  let i;
  const indexes = [];
  const len5 = values.length;
  inputArray.sort(function(a, b) {
    return a - b;
  });
  for (i = 0;i < len5; i++) {
    indexes[i] = getRank(inputArray, values[i]);
  }
  return indexes;
}
function makeMappingArray(N, data, gamma) {
  let i;
  const x = [];
  const y0 = [];
  const y1 = [];
  const lut = [];
  gamma = gamma === null ? 1 : gamma;
  for (i = 0;i < data.length; i++) {
    const element = data[i];
    x.push((N - 1) * element[0]);
    y0.push(element[1]);
    y1.push(element[1]);
  }
  const xLinSpace = linspace(0, 1, N);
  for (i = 0;i < N; i++) {
    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);
  }
  const xLinSpaceIndexes = searchSorted(x, xLinSpace);
  for (i = 1;i < N - 1; i++) {
    const index2 = xLinSpaceIndexes[i];
    const colorPercent = (xLinSpace[i] - x[index2 - 1]) / (x[index2] - x[index2 - 1]);
    const colorDelta = y0[index2] - y1[index2 - 1];
    lut[i] = colorPercent * colorDelta + y1[index2 - 1];
  }
  lut[0] = y1[0];
  lut[N - 1] = y0[data.length - 1];
  return lut;
}
function createLinearSegmentedColormap(segmentedData, N, gamma) {
  let i;
  const lut = [];
  N = N === null ? 256 : N;
  gamma = gamma === null ? 1 : gamma;
  const redLut = makeMappingArray(N, segmentedData.red, gamma);
  const greenLut = makeMappingArray(N, segmentedData.green, gamma);
  const blueLut = makeMappingArray(N, segmentedData.blue, gamma);
  for (i = 0;i < N; i++) {
    const red = Math.round(redLut[i] * 255);
    const green = Math.round(greenLut[i] * 255);
    const blue = Math.round(blueLut[i] * 255);
    const rgba = [red, green, blue, 255];
    lut.push(rgba);
  }
  return lut;
}
function getColormap2(id, colormapData) {
  let colormap = cpuColormaps_default[id];
  if (!colormap) {
    colormap = cpuColormaps_default[id] = colormapData || {
      name: "",
      colors: []
    };
  }
  if (!colormap.colors && colormap.segmentedData) {
    colormap.colors = createLinearSegmentedColormap(colormap.segmentedData, colormap.numColors, colormap.gamma);
  }
  const cpuFallbackColormap = {
    getId() {
      return id;
    },
    getColorSchemeName() {
      return colormap.name;
    },
    setColorSchemeName(name) {
      colormap.name = name;
    },
    getNumberOfColors() {
      return colormap.colors.length;
    },
    setNumberOfColors(numColors) {
      while (colormap.colors.length < numColors) {
        colormap.colors.push(COLOR_TRANSPARENT);
      }
      colormap.colors.length = numColors;
    },
    getColor(index2) {
      if (this.isValidIndex(index2)) {
        return colormap.colors[index2];
      }
      return COLOR_TRANSPARENT;
    },
    getColorRepeating(index2) {
      const numColors = colormap.colors.length;
      index2 = numColors ? index2 % numColors : 0;
      return this.getColor(index2);
    },
    setColor(index2, rgba) {
      if (this.isValidIndex(index2)) {
        colormap.colors[index2] = rgba;
      }
    },
    addColor(rgba) {
      colormap.colors.push(rgba);
    },
    insertColor(index2, rgba) {
      if (this.isValidIndex(index2)) {
        colormap.colors.splice(index2, 1, rgba);
      }
    },
    removeColor(index2) {
      if (this.isValidIndex(index2)) {
        colormap.colors.splice(index2, 1);
      }
    },
    clearColors() {
      colormap.colors = [];
    },
    buildLookupTable(lut) {
      if (!lut) {
        return;
      }
      const numColors = colormap.colors.length;
      lut.setNumberOfTableValues(numColors);
      for (let i = 0;i < numColors; i++) {
        lut.setTableValue(i, colormap.colors[i]);
      }
    },
    createLookupTable() {
      const lut = new lookupTable_default;
      this.buildLookupTable(lut);
      return lut;
    },
    isValidIndex(index2) {
      return index2 >= 0 && index2 < colormap.colors.length;
    }
  };
  return cpuFallbackColormap;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUT.js
function storedPixelDataToCanvasImageDataPseudocolorLUT(image, grayscaleLut, colorLUT, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let grayscale;
  let rgba;
  let clut;
  start = now_default();
  if (colorLUT instanceof lookupTable_default) {
    clut = colorLUT.Table;
  } else {
    clut = colorLUT;
  }
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}
var storedPixelDataToCanvasImageDataPseudocolorLUT_default = storedPixelDataToCanvasImageDataPseudocolorLUT;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUTPET.js
function storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, lutFunction, colorLUT, canvasImageDataData) {
  let start = now_default();
  const pixelData = image.voxelManager.getScalarData();
  image.stats.lastGetPixelDataTime = now_default() - start;
  const numPixels = pixelData.length;
  const minPixelValue = image.minPixelValue;
  let canvasImageDataIndex = 0;
  let storedPixelDataIndex = 0;
  let grayscale;
  let rgba;
  let clut;
  start = now_default();
  if (colorLUT instanceof lookupTable_default) {
    clut = colorLUT.Table;
  } else {
    clut = colorLUT;
  }
  if (minPixelValue < 0) {
    while (storedPixelDataIndex < numPixels) {
      grayscale = lutFunction(pixelData[storedPixelDataIndex++] + -minPixelValue);
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  } else {
    while (storedPixelDataIndex < numPixels) {
      grayscale = lutFunction(pixelData[storedPixelDataIndex++]);
      rgba = clut[grayscale];
      canvasImageDataData[canvasImageDataIndex++] = rgba[0];
      canvasImageDataData[canvasImageDataIndex++] = rgba[1];
      canvasImageDataData[canvasImageDataIndex++] = rgba[2];
      canvasImageDataData[canvasImageDataIndex++] = rgba[3];
    }
  }
  image.stats.lastStoredPixelDataToCanvasImageDataTime = now_default() - start;
}
var storedPixelDataToCanvasImageDataPseudocolorLUTPET_default = storedPixelDataToCanvasImageDataPseudocolorLUTPET;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js
function clamp(value, min5, max5) {
  return Math.max(min5, Math.min(max5, value));
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderPseudoColorImage.js
function getRenderCanvas3(enabledElement, image, invalidated) {
  if (!enabledElement.renderingTools.renderCanvas) {
    enabledElement.renderingTools.renderCanvas = document.createElement("canvas");
  }
  const renderCanvas = enabledElement.renderingTools.renderCanvas;
  let colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;
  if (enabledElement.options && enabledElement.options.colormap) {
    console.warn("enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead");
  }
  if (colormap && typeof colormap === "string") {
    colormap = getColormap2(colormap);
  }
  if (!colormap) {
    throw new Error("renderPseudoColorImage: colormap not found.");
  }
  const colormapId = colormap.getId();
  if (!doesImageNeedToBeRendered(enabledElement, image) && !invalidated && enabledElement.renderingTools.colormapId === colormapId) {
    return renderCanvas;
  }
  if (renderCanvas.width !== image.width || renderCanvas.height !== image.height) {
    initializeRenderCanvas_default(enabledElement, image);
  }
  let start = now_default();
  if (!enabledElement.renderingTools.colorLUT || invalidated || enabledElement.renderingTools.colormapId !== colormapId) {
    colormap.setNumberOfColors(256);
    enabledElement.renderingTools.colorLUT = colormap.createLookupTable();
    enabledElement.renderingTools.colormapId = colormapId;
  }
  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
  const { viewport } = enabledElement;
  const colorLUT = enabledElement.renderingTools.colorLUT;
  if (viewport.modality === "PT") {
    const { windowWidth, windowCenter } = viewport.voi;
    const minimum = windowCenter - windowWidth / 2;
    const maximum = windowCenter + windowWidth / 2;
    const range = maximum - minimum;
    const collectedMultiplierTerms = 255 / range;
    let petVOILutFunction;
    if (viewport.invert) {
      petVOILutFunction = (value) => {
        return clamp(Math.floor(255 - (value - minimum) * collectedMultiplierTerms), 0, 255);
      };
    } else {
      petVOILutFunction = (value) => {
        return clamp(Math.floor((value - minimum) * collectedMultiplierTerms), 0, 255);
      };
    }
    storedPixelDataToCanvasImageDataPseudocolorLUTPET_default(image, petVOILutFunction, colorLUT, renderCanvasData.data);
  } else {
    const lut = getLut_default(image, enabledElement.viewport, invalidated);
    image.stats = image.stats || {};
    image.stats.lastLutGenerateTime = now_default() - start;
    storedPixelDataToCanvasImageDataPseudocolorLUT_default(image, lut, colorLUT, renderCanvasData.data);
  }
  start = now_default();
  renderCanvasContext.putImageData(renderCanvasData, 0, 0);
  image.stats.lastPutImageDataTime = now_default() - start;
  return renderCanvas;
}
function renderPseudoColorImage(enabledElement, invalidated) {
  if (enabledElement === undefined) {
    throw new Error("drawImage: enabledElement parameter must not be undefined");
  }
  const image = enabledElement.image;
  if (image === undefined) {
    throw new Error("drawImage: image must be loaded before it can be drawn");
  }
  const context = enabledElement.canvas.getContext("2d");
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "black";
  context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
  setToPixelCoordinateSystem_default(enabledElement, context);
  const renderCanvas = getRenderCanvas3(enabledElement, image, invalidated);
  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
  const width = enabledElement.viewport.displayedArea.brhc.x - sx;
  const height = enabledElement.viewport.displayedArea.brhc.y - sy;
  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
  enabledElement.renderingTools = saveLastRendered_default(enabledElement);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js
function drawImageSync_default(enabledElement, invalidated) {
  const image = enabledElement.image;
  if (!enabledElement.canvas || !enabledElement.image) {
    return;
  }
  const start = now_default();
  image.stats = {
    lastGetPixelDataTime: -1,
    lastStoredPixelDataToCanvasImageDataTime: -1,
    lastPutImageDataTime: -1,
    lastRenderTime: -1,
    lastLutGenerateTime: -1
  };
  if (image) {
    let render = image.render;
    if (!render) {
      if (enabledElement.viewport.colormap) {
        render = renderPseudoColorImage;
      } else if (image.color) {
        render = renderColorImage;
      } else {
        render = renderGrayscaleImage;
      }
    }
    render(enabledElement, invalidated);
  }
  const renderTimeInMs = now_default() - start;
  image.stats.lastRenderTime = renderTimeInMs;
  enabledElement.invalid = false;
  enabledElement.needsRedraw = false;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getTransform.js
function getTransform_default(enabledElement) {
  return calculateTransform_default(enabledElement);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.js
function canvasToPixel_default(enabledElement, pt) {
  const transform = getTransform_default(enabledElement);
  transform.invert();
  return transform.transformPoint(pt);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setDefaultViewport.js
var state3 = {
  viewport: {}
};

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/createViewport.js
function createDefaultDisplayedArea() {
  return {
    tlhc: {
      x: 1,
      y: 1
    },
    brhc: {
      x: 1,
      y: 1
    },
    rowPixelSpacing: 1,
    columnPixelSpacing: 1,
    presentationSizeMode: "NONE"
  };
}
function createViewport() {
  const displayedArea = createDefaultDisplayedArea();
  const initialDefaultViewport = {
    scale: 1,
    translation: {
      x: 0,
      y: 0
    },
    voi: {
      windowWidth: undefined,
      windowCenter: undefined,
      voiLUTFunction: VOILUTFunctionType_default.LINEAR
    },
    invert: false,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: undefined,
    voiLUT: undefined,
    colormap: undefined,
    labelmap: false,
    displayedArea
  };
  return Object.assign({}, initialDefaultViewport, state3.viewport);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/validator.js
function validateParameterUndefinedOrNull(checkParam, errorMsg) {
  if (checkParam === undefined || checkParam === null) {
    throw new Error(errorMsg);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.js
function isRotated(rotation) {
  return !(rotation === null || rotation === undefined || rotation === 0 || rotation === 180);
}
function getImageSize_default(image, rotation = null) {
  validateParameterUndefinedOrNull(image, "getImageSize: parameter image must not be undefined");
  validateParameterUndefinedOrNull(image.width, "getImageSize: parameter image must have width");
  validateParameterUndefinedOrNull(image.height, "getImageSize: parameter image must have height");
  if (isRotated(rotation)) {
    return {
      height: image.width,
      width: image.height
    };
  }
  return {
    width: image.width,
    height: image.height
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.js
function getImageFitScale_default(canvas, image, rotation = null) {
  validateParameterUndefinedOrNull(canvas, "getImageScale: parameter canvas must not be undefined");
  validateParameterUndefinedOrNull(image, "getImageScale: parameter image must not be undefined");
  const imageSize = getImageSize_default(image, rotation);
  const rowPixelSpacing = image.rowPixelSpacing || 1;
  const columnPixelSpacing = image.columnPixelSpacing || 1;
  let verticalRatio = 1;
  let horizontalRatio = 1;
  if (rowPixelSpacing < columnPixelSpacing) {
    horizontalRatio = columnPixelSpacing / rowPixelSpacing;
  } else {
    verticalRatio = rowPixelSpacing / columnPixelSpacing;
  }
  const verticalScale = canvas.height / imageSize.height / verticalRatio;
  const horizontalScale = canvas.width / imageSize.width / horizontalRatio;
  return {
    verticalScale,
    horizontalScale,
    scaleFactor: Math.min(horizontalScale, verticalScale)
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js
function getDefaultViewport_default(canvas, image, modality, colormap) {
  if (canvas === undefined) {
    throw new Error("getDefaultViewport: parameter canvas must not be undefined");
  }
  if (image === undefined) {
    return createViewport();
  }
  const scale8 = getImageFitScale_default(canvas, image, 0).scaleFactor;
  let voi;
  if (modality === "PT" && image.isPreScaled) {
    voi = {
      windowWidth: 5,
      windowCenter: 2.5
    };
  } else if (image.windowWidth !== undefined && image.windowCenter !== undefined) {
    voi = {
      windowWidth: Array.isArray(image.windowWidth) ? image.windowWidth[0] : image.windowWidth,
      windowCenter: Array.isArray(image.windowCenter) ? image.windowCenter[0] : image.windowCenter
    };
  }
  return {
    scale: scale8,
    translation: {
      x: 0,
      y: 0
    },
    voi,
    invert: image.invert,
    pixelReplication: false,
    rotation: 0,
    hflip: false,
    vflip: false,
    modalityLUT: image.modalityLUT,
    modality,
    voiLUT: image.voiLUT,
    colormap: colormap !== undefined ? colormap : image.colormap,
    displayedArea: {
      tlhc: {
        x: 1,
        y: 1
      },
      brhc: {
        x: image.columns,
        y: image.rows
      },
      rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,
      columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,
      presentationSizeMode: "NONE"
    }
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.js
function pixelToCanvas_default(enabledElement, pt) {
  const transform = getTransform_default(enabledElement);
  return transform.transformPoint(pt);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.js
function fitToWindow_default(enabledElement) {
  const { image } = enabledElement;
  enabledElement.viewport.scale = getImageFitScale_default(enabledElement.canvas, image, enabledElement.viewport.rotation).scaleFactor;
  enabledElement.viewport.translation.x = 0;
  enabledElement.viewport.translation.y = 0;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resize.js
function setCanvasSize(enabledElement) {
  const { canvas } = enabledElement;
  const { clientWidth, clientHeight } = canvas;
  if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
    canvas.width = clientWidth;
    canvas.height = clientHeight;
  }
}
function wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  const scale8 = enabledElement.viewport.scale;
  const imageSize = getImageSize_default(enabledElement.image, enabledElement.viewport.rotation);
  const imageWidth = Math.round(imageSize.width * scale8);
  const imageHeight = Math.round(imageSize.height * scale8);
  const x = enabledElement.viewport.translation.x;
  const y = enabledElement.viewport.translation.y;
  return imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight || imageWidth <= oldCanvasWidth && imageHeight === oldCanvasHeight && x === 0 && y === 0;
}
function relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight) {
  const scale8 = enabledElement.viewport.scale;
  const canvasWidth = enabledElement.canvas.width;
  const canvasHeight = enabledElement.canvas.height;
  const relWidthChange = canvasWidth / oldCanvasWidth;
  const relHeightChange = canvasHeight / oldCanvasHeight;
  const relChange = Math.sqrt(relWidthChange * relHeightChange);
  enabledElement.viewport.scale = relChange * scale8;
}
function resize_default(enabledElement, forceFitToWindow = false) {
  const oldCanvasWidth = enabledElement.canvas.width;
  const oldCanvasHeight = enabledElement.canvas.height;
  setCanvasSize(enabledElement);
  if (enabledElement.image === undefined) {
    return;
  }
  if (forceFitToWindow || wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)) {
    fitToWindow_default(enabledElement);
  } else {
    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/correctShift.js
function correctShift_default(shift, viewportOrientation) {
  const { hflip, vflip, rotation } = viewportOrientation;
  shift.x *= hflip ? -1 : 1;
  shift.y *= vflip ? -1 : 1;
  if (rotation !== 0) {
    const angle3 = rotation * Math.PI / 180;
    const cosA = Math.cos(angle3);
    const sinA = Math.sin(angle3);
    const newX = shift.x * cosA - shift.y * sinA;
    const newY = shift.x * sinA + shift.y * cosA;
    shift.x = newX;
    shift.y = newY;
  }
  return shift;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.js
function resetCamera_default(enabledElement, resetPan = true, resetZoom = true) {
  const { canvas, image, viewport } = enabledElement;
  const scale8 = getImageFitScale_default(canvas, image, 0).scaleFactor;
  viewport.vflip = false;
  viewport.hflip = false;
  if (resetPan) {
    viewport.translation.x = 0;
    viewport.translation.y = 0;
  }
  if (resetZoom) {
    viewport.displayedArea.tlhc.x = 1;
    viewport.displayedArea.tlhc.y = 1;
    viewport.displayedArea.brhc.x = image.columns;
    viewport.displayedArea.brhc.y = image.rows;
    viewport.scale = scale8;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js
var EPSILON6 = 1;

class StackViewport extends Viewport_default {
  constructor(props) {
    super(props);
    this.imageIds = [];
    this.imageKeyToIndexMap = new Map;
    this.currentImageIdIndex = 0;
    this.targetImageIdIndex = 0;
    this.imagesLoader = this;
    this.globalDefaultProperties = {};
    this.perImageIdDefaultProperties = new Map;
    this.voiUpdatedWithSetProperties = false;
    this.invert = false;
    this.initialInvert = false;
    this.initialTransferFunctionNodes = null;
    this.stackInvalidated = false;
    this._publishCalibratedEvent = false;
    this.updateRenderingPipeline = () => {
      this._configureRenderingPipeline();
    };
    this.resize = () => {
      if (this.useCPURendering) {
        this._resizeCPU();
      }
    };
    this._resizeCPU = () => {
      if (this._cpuFallbackEnabledElement.viewport) {
        resize_default(this._cpuFallbackEnabledElement);
      }
    };
    this.getFrameOfReferenceUID = (sliceIndex) => this.getImagePlaneReferenceData(sliceIndex)?.FrameOfReferenceUID;
    this.getCornerstoneImage = () => this.csImage;
    this.createActorMapper = (imageData) => {
      const mapper = vtkImageMapper$1.newInstance();
      mapper.setInputData(imageData);
      const actor = vtkImageSlice$1.newInstance();
      actor.setMapper(mapper);
      const { preferSizeOverAccuracy } = getConfiguration().rendering;
      if (preferSizeOverAccuracy) {
        mapper.setPreferSizeOverAccuracy(true);
      }
      if (imageData.getPointData().getScalars().getNumberOfComponents() > 1) {
        actor.getProperty().setIndependentComponents(false);
      }
      return actor;
    };
    this.getNumberOfSlices = () => {
      return this.imageIds.length;
    };
    this.getDefaultProperties = (imageId) => {
      let imageProperties;
      if (imageId !== undefined) {
        imageProperties = this.perImageIdDefaultProperties.get(imageId);
      }
      if (imageProperties !== undefined) {
        return imageProperties;
      }
      return {
        ...this.globalDefaultProperties
      };
    };
    this.getProperties = () => {
      const { colormap, voiRange, VOILUTFunction, interpolationType, invert: invert4, voiUpdatedWithSetProperties } = this;
      return {
        colormap,
        voiRange,
        VOILUTFunction,
        interpolationType,
        invert: invert4,
        isComputedVOI: !voiUpdatedWithSetProperties
      };
    };
    this.resetCameraForResize = () => {
      return this.resetCamera({
        resetPan: true,
        resetZoom: true,
        resetToCenter: true,
        suppressEvents: true
      });
    };
    this.getRotationCPU = () => {
      const { viewport } = this._cpuFallbackEnabledElement;
      return viewport.rotation;
    };
    this.getRotationGPU = () => {
      const { viewUp: currentViewUp, viewPlaneNormal, flipVertical } = this.getCameraNoRotation();
      const initialViewUp = flipVertical ? exports_vec3.negate(exports_vec3.create(), this.initialViewUp) : this.initialViewUp;
      const initialToCurrentViewUpAngle = exports_vec3.angle(initialViewUp, currentViewUp) * 180 / Math.PI;
      const initialToCurrentViewUpCross = exports_vec3.cross(exports_vec3.create(), initialViewUp, currentViewUp);
      const normalDot = exports_vec3.dot(initialToCurrentViewUpCross, viewPlaneNormal);
      return normalDot >= 0 ? initialToCurrentViewUpAngle : (360 - initialToCurrentViewUpAngle) % 360;
    };
    this.setRotation = (rotation) => {
      const previousCamera = this.getCamera();
      if (this.useCPURendering) {
        this.setRotationCPU(rotation);
      } else {
        this.setRotationGPU(rotation);
      }
      if (this._suppressCameraModifiedEvents) {
        return;
      }
      const camera = this.getCamera();
      const eventDetail = {
        previousCamera,
        camera,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      triggerEvent(this.element, Events_default.CAMERA_MODIFIED, eventDetail);
    };
    this.renderImageObject = (image) => {
      this._setCSImage(image);
      const renderFn = this.useCPURendering ? this._updateToDisplayImageCPU : this._updateActorToDisplayImageId;
      renderFn.call(this, image);
    };
    this._setCSImage = (image) => {
      image.isPreScaled = image.preScale?.scaled;
      this.csImage = image;
    };
    this.canvasToWorldCPU = (canvasPos, worldPos = [0, 0, 0]) => {
      if (!this._cpuFallbackEnabledElement.image) {
        return;
      }
      const [px, py] = canvasToPixel_default(this._cpuFallbackEnabledElement, canvasPos);
      const { origin, spacing, direction } = this.getImageData();
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      exports_vec3.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
      exports_vec3.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
      return worldPos;
    };
    this.worldToCanvasCPU = (worldPos) => {
      const { spacing, direction, origin } = this.getImageData();
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      const diff = exports_vec3.subtract(exports_vec3.create(), worldPos, origin);
      const indexPoint = [
        exports_vec3.dot(diff, iVector) / spacing[0],
        exports_vec3.dot(diff, jVector) / spacing[1]
      ];
      const canvasPoint = pixelToCanvas_default(this._cpuFallbackEnabledElement, indexPoint);
      return canvasPoint;
    };
    this.canvasToWorldGPU = (canvasPos) => {
      const renderer = this.getRenderer();
      const vtkCamera3 = this.getVtkActiveCamera();
      const crange = vtkCamera3.getClippingRange();
      const distance4 = vtkCamera3.getDistance();
      vtkCamera3.setClippingRange(distance4, distance4 + 0.1);
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size = openGLRenderWindow.getSize();
      const devicePixelRatio2 = window.devicePixelRatio || 1;
      const canvasPosWithDPR = [
        canvasPos[0] * devicePixelRatio2,
        canvasPos[1] * devicePixelRatio2
      ];
      const displayCoord = [
        canvasPosWithDPR[0] + this.sx,
        canvasPosWithDPR[1] + this.sy
      ];
      displayCoord[1] = size[1] - displayCoord[1];
      const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer);
      vtkCamera3.setClippingRange(crange[0], crange[1]);
      return [worldCoord[0], worldCoord[1], worldCoord[2]];
    };
    this.worldToCanvasGPU = (worldPos) => {
      const renderer = this.getRenderer();
      const vtkCamera3 = this.getVtkActiveCamera();
      const crange = vtkCamera3.getClippingRange();
      const distance4 = vtkCamera3.getDistance();
      vtkCamera3.setClippingRange(distance4, distance4 + 0.1);
      const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const size = openGLRenderWindow.getSize();
      const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
      displayCoord[1] = size[1] - displayCoord[1];
      const canvasCoord = [
        displayCoord[0] - this.sx,
        displayCoord[1] - this.sy
      ];
      vtkCamera3.setClippingRange(crange[0], crange[1]);
      const devicePixelRatio2 = window.devicePixelRatio || 1;
      const canvasCoordWithDPR = [
        canvasCoord[0] / devicePixelRatio2,
        canvasCoord[1] / devicePixelRatio2
      ];
      return canvasCoordWithDPR;
    };
    this.getCurrentImageIdIndex = () => {
      return this.currentImageIdIndex;
    };
    this.getSliceIndex = () => {
      return this.currentImageIdIndex;
    };
    this.getTargetImageIdIndex = () => {
      return this.targetImageIdIndex;
    };
    this.getImageIds = () => {
      return this.imageIds;
    };
    this.getCurrentImageId = (index2 = this.getCurrentImageIdIndex()) => {
      return this.imageIds[index2];
    };
    this.hasImageId = (imageId) => {
      return this.imageKeyToIndexMap.has(imageId);
    };
    this.hasImageURI = (imageURI) => {
      return this.imageKeyToIndexMap.has(imageURI);
    };
    this.customRenderViewportToCanvas = () => {
      if (!this.useCPURendering) {
        throw new Error("Custom cpu rendering pipeline should only be hit in CPU rendering mode");
      }
      if (this._cpuFallbackEnabledElement.image) {
        drawImageSync_default(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated);
        this.cpuRenderingInvalidated = false;
      } else {
        this.fillWithBackgroundColor();
      }
      return {
        canvas: this.canvas,
        element: this.element,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId,
        viewportStatus: this.viewportStatus
      };
    };
    this.renderingPipelineFunctions = {
      getImageData: {
        cpu: this.getImageDataCPU,
        gpu: this.getImageDataGPU
      },
      setColormap: {
        cpu: this.setColormapCPU,
        gpu: this.setColormapGPU
      },
      getCamera: {
        cpu: this.getCameraCPU,
        gpu: super.getCamera
      },
      setCamera: {
        cpu: this.setCameraCPU,
        gpu: super.setCamera
      },
      getPan: {
        cpu: this.getPanCPU,
        gpu: super.getPan
      },
      setPan: {
        cpu: this.setPanCPU,
        gpu: super.setPan
      },
      getZoom: {
        cpu: this.getZoomCPU,
        gpu: super.getZoom
      },
      setZoom: {
        cpu: this.setZoomCPU,
        gpu: super.setZoom
      },
      setVOI: {
        cpu: this.setVOICPU,
        gpu: this.setVOIGPU
      },
      getRotation: {
        cpu: this.getRotationCPU,
        gpu: this.getRotationGPU
      },
      setInterpolationType: {
        cpu: this.setInterpolationTypeCPU,
        gpu: this.setInterpolationTypeGPU
      },
      setInvertColor: {
        cpu: this.setInvertColorCPU,
        gpu: this.setInvertColorGPU
      },
      resetCamera: {
        cpu: (options = {}) => {
          const { resetPan = true, resetZoom = true } = options;
          this.resetCameraCPU({ resetPan, resetZoom });
          return true;
        },
        gpu: (options = {}) => {
          const { resetPan = true, resetZoom = true } = options;
          this.resetCameraGPU({ resetPan, resetZoom });
          return true;
        }
      },
      canvasToWorld: {
        cpu: this.canvasToWorldCPU,
        gpu: this.canvasToWorldGPU
      },
      worldToCanvas: {
        cpu: this.worldToCanvasCPU,
        gpu: this.worldToCanvasGPU
      },
      getRenderer: {
        cpu: () => this.getCPUFallbackError("getRenderer"),
        gpu: super.getRenderer
      },
      getDefaultActor: {
        cpu: () => this.getCPUFallbackError("getDefaultActor"),
        gpu: super.getDefaultActor
      },
      getActors: {
        cpu: () => this.getCPUFallbackError("getActors"),
        gpu: super.getActors
      },
      getActor: {
        cpu: () => this.getCPUFallbackError("getActor"),
        gpu: super.getActor
      },
      setActors: {
        cpu: () => this.getCPUFallbackError("setActors"),
        gpu: super.setActors
      },
      addActors: {
        cpu: () => this.getCPUFallbackError("addActors"),
        gpu: super.addActors
      },
      addActor: {
        cpu: () => this.getCPUFallbackError("addActor"),
        gpu: super.addActor
      },
      removeAllActors: {
        cpu: () => this.getCPUFallbackError("removeAllActors"),
        gpu: super.removeAllActors
      },
      unsetColormap: {
        cpu: this.unsetColormapCPU,
        gpu: this.unsetColormapGPU
      }
    };
    this.scaling = {};
    this.modality = null;
    this.useCPURendering = getShouldUseCPURendering();
    this._configureRenderingPipeline();
    const result = this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport();
    this.currentImageIdIndex = 0;
    this.targetImageIdIndex = 0;
    this.resetCamera();
    this.initializeElementDisabledHandler();
  }
  setUseCPURendering(value) {
    this.useCPURendering = value;
    this._configureRenderingPipeline(value);
  }
  static get useCustomRenderingPipeline() {
    return getShouldUseCPURendering();
  }
  _configureRenderingPipeline(value) {
    this.useCPURendering = value ?? getShouldUseCPURendering();
    for (const key in this.renderingPipelineFunctions) {
      if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, key)) {
        const functions = this.renderingPipelineFunctions[key];
        this[key] = this.useCPURendering ? functions.cpu : functions.gpu;
      }
    }
    const result = this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport();
  }
  _resetCPUFallbackElement() {
    this._cpuFallbackEnabledElement = {
      canvas: this.canvas,
      renderingTools: {},
      transform: new Transform2,
      viewport: { rotation: 0 }
    };
  }
  _resetGPUViewport() {
    const renderer = this.getRenderer();
    const camera = vtkCamera$1.newInstance();
    renderer.setActiveCamera(camera);
    const viewPlaneNormal = [0, 0, -1];
    this.initialViewUp = [0, -1, 0];
    camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
    camera.setViewUp(...this.initialViewUp);
    camera.setParallelProjection(true);
    camera.setThicknessFromFocalPoint(0.1);
    camera.setFreezeFocalPoint(true);
  }
  initializeElementDisabledHandler() {
    eventTarget_default.addEventListener(Events_default.ELEMENT_DISABLED, function elementDisabledHandler() {
      clearTimeout(this.debouncedTimeout);
      eventTarget_default.removeEventListener(Events_default.ELEMENT_DISABLED, elementDisabledHandler);
    });
  }
  getImageDataGPU() {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    if (!isImageActor(defaultActor)) {
      return;
    }
    const { actor } = defaultActor;
    const vtkImageData2 = actor.getMapper().getInputData();
    const csImage = this.csImage;
    return {
      dimensions: vtkImageData2.getDimensions(),
      spacing: vtkImageData2.getSpacing(),
      origin: vtkImageData2.getOrigin(),
      direction: vtkImageData2.getDirection(),
      get scalarData() {
        return csImage?.voxelManager.getScalarData();
      },
      imageData: actor.getMapper().getInputData(),
      metadata: {
        Modality: this.modality,
        FrameOfReferenceUID: this.getFrameOfReferenceUID()
      },
      scaling: this.scaling,
      hasPixelSpacing: this.hasPixelSpacing,
      calibration: { ...csImage?.calibration, ...this.calibration },
      preScale: {
        ...csImage?.preScale
      },
      voxelManager: csImage?.voxelManager
    };
  }
  getImageDataCPU() {
    const { metadata } = this._cpuFallbackEnabledElement;
    if (!metadata) {
      return;
    }
    const spacing = metadata.spacing;
    const csImage = this.csImage;
    return {
      dimensions: metadata.dimensions,
      spacing,
      origin: metadata.origin,
      direction: metadata.direction,
      metadata: {
        Modality: this.modality,
        FrameOfReferenceUID: this.getFrameOfReferenceUID()
      },
      scaling: this.scaling,
      imageData: {
        getDirection: () => metadata.direction,
        getDimensions: () => metadata.dimensions,
        getScalarData: () => this.cpuImagePixelData,
        getSpacing: () => spacing,
        worldToIndex: (point) => {
          const canvasPoint = this.worldToCanvasCPU(point);
          const pixelCoord = canvasToPixel_default(this._cpuFallbackEnabledElement, canvasPoint);
          return [pixelCoord[0], pixelCoord[1], 0];
        },
        indexToWorld: (point, destPoint) => {
          const canvasPoint = pixelToCanvas_default(this._cpuFallbackEnabledElement, [
            point[0],
            point[1]
          ]);
          return this.canvasToWorldCPU(canvasPoint, destPoint);
        }
      },
      scalarData: this.cpuImagePixelData,
      hasPixelSpacing: this.hasPixelSpacing,
      calibration: { ...csImage?.calibration, ...this.calibration },
      preScale: {
        ...csImage?.preScale
      },
      voxelManager: csImage?.voxelManager
    };
  }
  buildMetadata(image) {
    const imageId = image.imageId;
    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel } = getMetaData("imagePixelModule", imageId);
    const { windowWidth, windowCenter, voiLUTFunction } = image;
    const { modality } = getMetaData("generalSeriesModule", imageId);
    const imageIdScalingFactor = getMetaData("scalingModule", imageId);
    const calibration = getMetaData(MetadataModules_default.CALIBRATION, imageId);
    if (modality === "PT" && imageIdScalingFactor) {
      this._addScalingToViewport(imageIdScalingFactor);
    }
    this.modality = modality;
    const voiLUTFunctionEnum = this._getValidVOILUTFunction(voiLUTFunction);
    this.VOILUTFunction = voiLUTFunctionEnum;
    this.calibration = calibration;
    let imagePlaneModule = this._getImagePlaneModule(imageId);
    if (!this.useCPURendering) {
      imagePlaneModule = this.calibrateIfNecessary(imageId, imagePlaneModule);
    }
    return {
      imagePlaneModule,
      imagePixelModule: {
        bitsAllocated,
        bitsStored,
        samplesPerPixel,
        highBit,
        photometricInterpretation,
        pixelRepresentation,
        windowWidth,
        windowCenter,
        modality,
        voiLUTFunction: voiLUTFunctionEnum
      }
    };
  }
  calibrateIfNecessary(imageId, imagePlaneModule) {
    const calibration = getMetaData("calibratedPixelSpacing", imageId);
    const isUpdated = this.calibration !== calibration;
    const { scale: scale8 } = calibration || {};
    this.hasPixelSpacing = scale8 > 0 || imagePlaneModule.rowPixelSpacing > 0;
    imagePlaneModule.calibration = calibration;
    if (!isUpdated) {
      return imagePlaneModule;
    }
    this.calibration = calibration;
    this._publishCalibratedEvent = true;
    this._calibrationEvent = {
      scale: scale8,
      calibration
    };
    return imagePlaneModule;
  }
  setDefaultProperties(ViewportProperties, imageId) {
    if (imageId == null) {
      this.globalDefaultProperties = ViewportProperties;
    } else {
      this.perImageIdDefaultProperties.set(imageId, ViewportProperties);
      if (this.getCurrentImageId() === imageId) {
        this.setProperties(ViewportProperties);
      }
    }
  }
  clearDefaultProperties(imageId) {
    if (imageId == null) {
      this.globalDefaultProperties = {};
      this.resetProperties();
    } else {
      this.perImageIdDefaultProperties.delete(imageId);
      this.resetToDefaultProperties();
    }
  }
  setProperties({ colormap, voiRange, VOILUTFunction, invert: invert4, interpolationType } = {}, suppressEvents = false) {
    this.viewportStatus = this.csImage ? ViewportStatus_default.PRE_RENDER : ViewportStatus_default.LOADING;
    this.globalDefaultProperties = {
      colormap: this.globalDefaultProperties.colormap ?? colormap,
      voiRange: this.globalDefaultProperties.voiRange ?? voiRange,
      VOILUTFunction: this.globalDefaultProperties.VOILUTFunction ?? VOILUTFunction,
      invert: this.globalDefaultProperties.invert ?? invert4,
      interpolationType: this.globalDefaultProperties.interpolationType ?? interpolationType
    };
    if (typeof colormap !== "undefined") {
      this.setColormap(colormap);
    }
    if (typeof voiRange !== "undefined") {
      const voiUpdatedWithSetProperties = true;
      this.setVOI(voiRange, { suppressEvents, voiUpdatedWithSetProperties });
    }
    if (typeof VOILUTFunction !== "undefined") {
      this.setVOILUTFunction(VOILUTFunction, suppressEvents);
    }
    if (typeof invert4 !== "undefined") {
      this.setInvertColor(invert4);
    }
    if (typeof interpolationType !== "undefined") {
      this.setInterpolationType(interpolationType);
    }
  }
  resetProperties() {
    this.cpuRenderingInvalidated = true;
    this.voiUpdatedWithSetProperties = false;
    this.viewportStatus = ViewportStatus_default.PRE_RENDER;
    this.fillWithBackgroundColor();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement.renderingTools = {};
    }
    this._resetProperties();
    this.render();
  }
  _resetProperties() {
    let voiRange;
    if (this._isCurrentImagePTPrescaled()) {
      voiRange = this._getDefaultPTPrescaledVOIRange();
    } else {
      voiRange = this._getVOIRangeForCurrentImage();
    }
    this.setVOI(voiRange);
    this.setInvertColor(this.initialInvert);
    this.setInterpolationType(InterpolationType_default.LINEAR);
    if (!this.useCPURendering) {
      const transferFunction = this.getTransferFunction();
      setTransferFunctionNodes(transferFunction, this.initialTransferFunctionNodes);
      const nodes = getTransferFunctionNodes(transferFunction);
      const RGBPoints = nodes.reduce((acc, node) => {
        acc.push(node[0], node[1], node[2], node[3]);
        return acc;
      }, []);
      const defaultActor = this.getDefaultActor();
      const matchedColormap = findMatchingColormap(RGBPoints, defaultActor.actor);
      this.setColormap(matchedColormap);
    }
  }
  resetToDefaultProperties() {
    this.cpuRenderingInvalidated = true;
    this.viewportStatus = ViewportStatus_default.PRE_RENDER;
    this.fillWithBackgroundColor();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement.renderingTools = {};
    }
    const currentImageId = this.getCurrentImageId();
    const properties = this.perImageIdDefaultProperties.get(currentImageId) || this.globalDefaultProperties;
    if (properties.colormap?.name) {
      this.setColormap(properties.colormap);
    }
    let voiRange;
    if (properties.voiRange == undefined) {
      voiRange = this._getVOIRangeForCurrentImage();
    } else {
      voiRange = properties.voiRange;
    }
    this.setVOI(voiRange);
    this.setInterpolationType(InterpolationType_default.LINEAR);
    this.setInvertColor(false);
    this.render();
  }
  _getVOIFromCache() {
    let voiRange;
    if (this.voiUpdatedWithSetProperties) {
      voiRange = this.voiRange;
    } else if (this._isCurrentImagePTPrescaled()) {
      voiRange = this._getDefaultPTPrescaledVOIRange();
    } else {
      voiRange = this._getVOIRangeForCurrentImage() ?? this.voiRange;
    }
    return voiRange;
  }
  _setPropertiesFromCache() {
    const voiRange = this._getVOIFromCache();
    const { interpolationType, invert: invert4 } = this;
    this.setVOI(voiRange);
    this.setInterpolationType(interpolationType);
    this.setInvertColor(invert4);
  }
  getCameraCPU() {
    const { metadata, viewport } = this._cpuFallbackEnabledElement;
    if (!metadata) {
      return {};
    }
    const { direction } = metadata;
    const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
    let viewUp = direction.slice(3, 6).map((x) => -x);
    if (viewport.rotation) {
      const rotationMatrix = exports_mat4.fromRotation(exports_mat4.create(), viewport.rotation * Math.PI / 180, viewPlaneNormal);
      viewUp = exports_vec3.transformMat4(exports_vec3.create(), viewUp, rotationMatrix);
    }
    const canvasCenter = [
      this.element.clientWidth / 2,
      this.element.clientHeight / 2
    ];
    const canvasCenterWorld = this.canvasToWorld(canvasCenter);
    const topLeftWorld = this.canvasToWorld([0, 0]);
    const bottomLeftWorld = this.canvasToWorld([0, this.element.clientHeight]);
    const parallelScale = exports_vec3.distance(topLeftWorld, bottomLeftWorld) / 2;
    return {
      parallelProjection: true,
      focalPoint: canvasCenterWorld,
      position: [0, 0, 0],
      parallelScale,
      scale: viewport.scale,
      viewPlaneNormal: [
        viewPlaneNormal[0],
        viewPlaneNormal[1],
        viewPlaneNormal[2]
      ],
      viewUp: [viewUp[0], viewUp[1], viewUp[2]],
      flipHorizontal: this.flipHorizontal,
      flipVertical: this.flipVertical
    };
  }
  setCameraCPU(cameraInterface) {
    const { viewport, image } = this._cpuFallbackEnabledElement;
    const previousCamera = this.getCameraCPU();
    const { focalPoint, parallelScale, scale: scale8, flipHorizontal, flipVertical } = cameraInterface;
    const { clientHeight } = this.element;
    if (focalPoint) {
      const focalPointCanvas = this.worldToCanvasCPU(focalPoint);
      const focalPointPixel = canvasToPixel_default(this._cpuFallbackEnabledElement, focalPointCanvas);
      const prevFocalPointCanvas = this.worldToCanvasCPU(previousCamera.focalPoint);
      const prevFocalPointPixel = canvasToPixel_default(this._cpuFallbackEnabledElement, prevFocalPointCanvas);
      const deltaPixel = exports_vec2.create();
      exports_vec2.subtract(deltaPixel, exports_vec2.fromValues(focalPointPixel[0], focalPointPixel[1]), exports_vec2.fromValues(prevFocalPointPixel[0], prevFocalPointPixel[1]));
      const shift = correctShift_default({ x: deltaPixel[0], y: deltaPixel[1] }, viewport);
      viewport.translation.x -= shift.x;
      viewport.translation.y -= shift.y;
    }
    if (parallelScale) {
      const { rowPixelSpacing } = image;
      const scale9 = clientHeight * rowPixelSpacing * 0.5 / parallelScale;
      viewport.scale = scale9;
      viewport.parallelScale = parallelScale;
    }
    if (scale8) {
      const { rowPixelSpacing } = image;
      viewport.scale = scale8;
      viewport.parallelScale = clientHeight * rowPixelSpacing * 0.5 / scale8;
    }
    if (flipHorizontal !== undefined || flipVertical !== undefined) {
      this.setFlipCPU({ flipHorizontal, flipVertical });
    }
    this._cpuFallbackEnabledElement.transform = calculateTransform_default(this._cpuFallbackEnabledElement);
    const eventDetail = {
      previousCamera,
      camera: this.getCamera(),
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId
    };
    triggerEvent(this.element, Events_default.CAMERA_MODIFIED, eventDetail);
  }
  getPanCPU() {
    const { viewport } = this._cpuFallbackEnabledElement;
    return [viewport.translation.x, viewport.translation.y];
  }
  setPanCPU(pan) {
    const camera = this.getCameraCPU();
    this.setCameraCPU({
      ...camera,
      focalPoint: [...pan.map((p) => -p), 0]
    });
  }
  getZoomCPU() {
    const { viewport } = this._cpuFallbackEnabledElement;
    return viewport.scale;
  }
  setZoomCPU(zoom) {
    const camera = this.getCameraCPU();
    this.setCameraCPU({ ...camera, scale: zoom });
  }
  setFlipCPU({ flipHorizontal, flipVertical }) {
    const { viewport } = this._cpuFallbackEnabledElement;
    if (flipHorizontal !== undefined) {
      viewport.hflip = flipHorizontal;
      this.flipHorizontal = viewport.hflip;
    }
    if (flipVertical !== undefined) {
      viewport.vflip = flipVertical;
      this.flipVertical = viewport.vflip;
    }
  }
  setVOILUTFunction(voiLUTFunction, suppressEvents) {
    if (this.useCPURendering) {
      throw new Error("VOI LUT function is not supported in CPU rendering");
    }
    const newVOILUTFunction = this._getValidVOILUTFunction(voiLUTFunction);
    let forceRecreateLUTFunction = false;
    if (this.VOILUTFunction !== newVOILUTFunction) {
      forceRecreateLUTFunction = true;
    }
    this.VOILUTFunction = newVOILUTFunction;
    const { voiRange } = this.getProperties();
    this.setVOI(voiRange, { suppressEvents, forceRecreateLUTFunction });
  }
  setRotationCPU(rotation) {
    const { viewport } = this._cpuFallbackEnabledElement;
    viewport.rotation = rotation;
  }
  setRotationGPU(rotation) {
    const panFit = this.getPan(this.fitToCanvasCamera);
    const pan = this.getPan();
    const panSub = exports_vec2.sub([0, 0], panFit, pan);
    this.setPan(panSub, false);
    const { flipVertical } = this.getCamera();
    const initialViewUp = flipVertical ? exports_vec3.negate(exports_vec3.create(), this.initialViewUp) : this.initialViewUp;
    this.setCameraNoEvent({
      viewUp: initialViewUp
    });
    this.getVtkActiveCamera().roll(-rotation);
    const afterPan = this.getPan();
    const afterPanFit = this.getPan(this.fitToCanvasCamera);
    const newCenter = exports_vec2.sub([0, 0], afterPan, afterPanFit);
    const newOffset = exports_vec2.add([0, 0], panFit, newCenter);
    this.setPan(newOffset, false);
  }
  setInterpolationTypeGPU(interpolationType) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    if (!isImageActor(defaultActor)) {
      return;
    }
    const { actor } = defaultActor;
    const volumeProperty = actor.getProperty();
    volumeProperty.setInterpolationType(interpolationType);
    this.interpolationType = interpolationType;
  }
  setInterpolationTypeCPU(interpolationType) {
    const { viewport } = this._cpuFallbackEnabledElement;
    viewport.pixelReplication = interpolationType === InterpolationType_default.LINEAR ? false : true;
    this.interpolationType = interpolationType;
  }
  setInvertColorCPU(invert4) {
    const { viewport } = this._cpuFallbackEnabledElement;
    if (!viewport) {
      return;
    }
    viewport.invert = invert4;
    this.invert = invert4;
  }
  setInvertColorGPU(invert4) {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    if (!isImageActor(defaultActor)) {
      return;
    }
    if (actorIsA(defaultActor, "vtkVolume")) {
      const volumeActor = defaultActor.actor;
      const tfunc = volumeActor.getProperty().getRGBTransferFunction(0);
      if (!this.invert && invert4 || this.invert && !invert4) {
        invertRgbTransferFunction(tfunc);
      }
      this.invert = invert4;
    } else if (actorIsA(defaultActor, "vtkImageSlice")) {
      const imageSliceActor = defaultActor.actor;
      const tfunc = imageSliceActor.getProperty().getRGBTransferFunction(0);
      if (!this.invert && invert4 || this.invert && !invert4) {
        invertRgbTransferFunction(tfunc);
      }
      this.invert = invert4;
    }
  }
  setVOICPU(voiRange, options = {}) {
    const { suppressEvents = false } = options;
    const { viewport, image } = this._cpuFallbackEnabledElement;
    if (!viewport || !image) {
      return;
    }
    if (typeof voiRange === "undefined") {
      const { windowWidth: ww, windowCenter: wc } = image;
      const wwToUse = Array.isArray(ww) ? ww[0] : ww;
      const wcToUse = Array.isArray(wc) ? wc[0] : wc;
      viewport.voi = {
        windowWidth: wwToUse,
        windowCenter: wcToUse,
        voiLUTFunction: image.voiLUTFunction
      };
      const { lower, upper } = toLowHighRange(wwToUse, wcToUse, image.voiLUTFunction);
      voiRange = { lower, upper };
    } else {
      const { lower, upper } = voiRange;
      const { windowCenter, windowWidth } = toWindowLevel(lower, upper);
      if (!viewport.voi) {
        viewport.voi = {
          windowWidth: 0,
          windowCenter: 0,
          voiLUTFunction: image.voiLUTFunction
        };
      }
      viewport.voi.windowWidth = windowWidth;
      viewport.voi.windowCenter = windowCenter;
    }
    this.voiRange = voiRange;
    const eventDetail = {
      viewportId: this.id,
      range: voiRange
    };
    if (!suppressEvents) {
      triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetail);
    }
  }
  getTransferFunction() {
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    if (!isImageActor(defaultActor)) {
      return;
    }
    const imageActor = defaultActor.actor;
    return imageActor.getProperty().getRGBTransferFunction(0);
  }
  setVOIGPU(voiRange, options = {}) {
    const { suppressEvents = false, forceRecreateLUTFunction = false, voiUpdatedWithSetProperties = false } = options;
    if (voiRange && this.voiRange && this.voiRange.lower === voiRange.lower && this.voiRange.upper === voiRange.upper && !forceRecreateLUTFunction && !this.stackInvalidated) {
      return;
    }
    const defaultActor = this.getDefaultActor();
    if (!defaultActor) {
      return;
    }
    if (!isImageActor(defaultActor)) {
      return;
    }
    const imageActor = defaultActor.actor;
    let voiRangeToUse = voiRange;
    if (typeof voiRangeToUse === "undefined") {
      const imageData = imageActor.getMapper().getInputData();
      const range = imageData.getPointData().getScalars().getRange();
      const maxVoiRange = { lower: range[0], upper: range[1] };
      voiRangeToUse = maxVoiRange;
    }
    imageActor.getProperty().setUseLookupTableScalarRange(true);
    let transferFunction = imageActor.getProperty().getRGBTransferFunction(0);
    const isSigmoidTFun = this.VOILUTFunction === VOILUTFunctionType_default.SAMPLED_SIGMOID;
    if (isSigmoidTFun || !transferFunction || forceRecreateLUTFunction) {
      const transferFunctionCreator = isSigmoidTFun ? createSigmoidRGBTransferFunction : createLinearRGBTransferFunction;
      transferFunction = transferFunctionCreator(voiRangeToUse);
      if (this.invert) {
        invertRgbTransferFunction(transferFunction);
      }
      imageActor.getProperty().setRGBTransferFunction(0, transferFunction);
      this.initialTransferFunctionNodes = getTransferFunctionNodes(transferFunction);
    }
    if (!isSigmoidTFun) {
      transferFunction.setRange(voiRangeToUse.lower, voiRangeToUse.upper);
    }
    this.voiRange = voiRangeToUse;
    if (!this.voiUpdatedWithSetProperties) {
      this.voiUpdatedWithSetProperties = voiUpdatedWithSetProperties;
    }
    if (suppressEvents) {
      return;
    }
    const eventDetail = {
      viewportId: this.id,
      range: voiRangeToUse,
      VOILUTFunction: this.VOILUTFunction
    };
    triggerEvent(this.element, Events_default.VOI_MODIFIED, eventDetail);
  }
  _addScalingToViewport(imageIdScalingFactor) {
    if (this.scaling.PT) {
      return;
    }
    const { suvbw, suvlbm, suvbsa } = imageIdScalingFactor;
    const ptScaling = {};
    if (suvlbm) {
      ptScaling.suvbwToSuvlbm = suvlbm / suvbw;
    }
    if (suvbsa) {
      ptScaling.suvbwToSuvbsa = suvbsa / suvbw;
    }
    this.scaling.PT = ptScaling;
  }
  _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {
    let numberOfComponents = 1;
    if (photometricInterpretation === "RGB" || photometricInterpretation.includes("YBR") || photometricInterpretation === "PALETTE COLOR") {
      numberOfComponents = 3;
    }
    return numberOfComponents;
  }
  getImageDataMetadata(image) {
    const { imagePlaneModule, imagePixelModule } = this.buildMetadata(image);
    let { rowCosines, columnCosines } = imagePlaneModule;
    if (rowCosines == null || columnCosines == null) {
      rowCosines = [1, 0, 0];
      columnCosines = [0, 1, 0];
    }
    const rowCosineVec = exports_vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = exports_vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
    const scanAxisNormal = exports_vec3.create();
    exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
      origin = [0, 0, 0];
    }
    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;
    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;
    const xVoxels = image.columns;
    const yVoxels = image.rows;
    const zSpacing = EPSILON6;
    const zVoxels = 1;
    const numberOfComponents = image.numberOfComponents || this._getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);
    return {
      bitsAllocated: imagePixelModule.bitsAllocated,
      numberOfComponents,
      origin,
      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
      dimensions: [xVoxels, yVoxels, zVoxels],
      spacing: [xSpacing, ySpacing, zSpacing],
      numVoxels: xVoxels * yVoxels * zVoxels,
      imagePlaneModule,
      imagePixelModule
    };
  }
  matchImagesForOverlay(currentImageId, targetOverlayImageId) {
    const matchImagesForOverlay = (targetImageId) => {
      const overlayImagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, targetOverlayImageId);
      const currentImagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, targetImageId);
      const overlayOrientation = overlayImagePlaneModule.imageOrientationPatient;
      const currentOrientation = currentImagePlaneModule.imageOrientationPatient;
      if (overlayOrientation && currentOrientation) {
        const closeEnough = isEqual(overlayImagePlaneModule.imageOrientationPatient, currentImagePlaneModule.imageOrientationPatient);
        if (closeEnough) {
          const referencePosition = overlayImagePlaneModule.imagePositionPatient;
          const currentPosition = currentImagePlaneModule.imagePositionPatient;
          if (referencePosition && currentPosition) {
            const closeEnough2 = isEqual(referencePosition, currentPosition);
            if (closeEnough2) {
              const referenceRows = overlayImagePlaneModule.rows;
              const referenceColumns = overlayImagePlaneModule.columns;
              const currentRows = currentImagePlaneModule.rows;
              const currentColumns = currentImagePlaneModule.columns;
              if (referenceRows === currentRows && referenceColumns === currentColumns) {
                return targetImageId;
              }
            }
          }
        }
      } else {
        const referenceRows = overlayImagePlaneModule.rows;
        const referenceColumns = overlayImagePlaneModule.columns;
        const currentRows = currentImagePlaneModule.rows;
        const currentColumns = currentImagePlaneModule.columns;
        if (referenceRows === currentRows && referenceColumns === currentColumns) {
          return targetImageId;
        }
      }
    };
    return matchImagesForOverlay(currentImageId);
  }
  getImagePlaneReferenceData(sliceIndex = this.getCurrentImageIdIndex()) {
    const imageId = this.imageIds[sliceIndex];
    if (!imageId) {
      return;
    }
    const imagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, imageId);
    if (!imagePlaneModule) {
      return;
    }
    const { imagePositionPatient, frameOfReferenceUID: FrameOfReferenceUID } = imagePlaneModule;
    let { rowCosines, columnCosines } = imagePlaneModule;
    rowCosines ||= [1, 0, 0];
    columnCosines ||= [0, 1, 0];
    const viewPlaneNormal = exports_vec3.cross([0, 0, 0], columnCosines, rowCosines);
    return {
      FrameOfReferenceUID,
      viewPlaneNormal,
      cameraFocalPoint: imagePositionPatient,
      referencedImageId: imageId,
      sliceIndex
    };
  }
  _getCameraOrientation(imageDataDirection) {
    const viewPlaneNormal = imageDataDirection.slice(6, 9).map((x) => -x);
    const viewUp = imageDataDirection.slice(3, 6).map((x) => -x);
    return {
      viewPlaneNormal: [
        viewPlaneNormal[0],
        viewPlaneNormal[1],
        viewPlaneNormal[2]
      ],
      viewUp: [viewUp[0], viewUp[1], viewUp[2]]
    };
  }
  createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray }) {
    const values = new pixelArray.constructor(pixelArray.length);
    const scalarArray = vtkDataArray$1.newInstance({
      name: "Pixels",
      numberOfComponents,
      values
    });
    const imageData = vtkImageData$1.newInstance();
    imageData.setDimensions(dimensions);
    imageData.setSpacing(spacing);
    imageData.setDirection(direction);
    imageData.setOrigin(origin);
    imageData.getPointData().setScalars(scalarArray);
    return imageData;
  }
  _createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray }) {
    try {
      this._imageData = this.createVTKImageData({
        origin,
        direction,
        dimensions,
        spacing,
        numberOfComponents,
        pixelArray
      });
    } catch (e) {
      console.error(e);
    }
  }
  async setStack(imageIds, currentImageIdIndex = 0) {
    this._throwIfDestroyed();
    this.imageIds = imageIds;
    this.imageKeyToIndexMap.clear();
    imageIds.forEach((imageId2, index2) => {
      this.imageKeyToIndexMap.set(imageId2, index2);
      this.imageKeyToIndexMap.set(imageIdToURI(imageId2), index2);
    });
    this.currentImageIdIndex = currentImageIdIndex;
    this.targetImageIdIndex = currentImageIdIndex;
    const imageRetrieveConfiguration = getMetaData(imageRetrieveMetadataProvider_default.IMAGE_RETRIEVE_CONFIGURATION, imageIds[currentImageIdIndex], "stack");
    this.imagesLoader = imageRetrieveConfiguration ? (imageRetrieveConfiguration.create || createProgressive)(imageRetrieveConfiguration) : this;
    this.stackInvalidated = true;
    this.flipVertical = false;
    this.flipHorizontal = false;
    this.voiRange = null;
    this.interpolationType = InterpolationType_default.LINEAR;
    this.invert = false;
    this.viewportStatus = ViewportStatus_default.LOADING;
    this.fillWithBackgroundColor();
    if (this.useCPURendering) {
      this._cpuFallbackEnabledElement.renderingTools = {};
      delete this._cpuFallbackEnabledElement.viewport.colormap;
    }
    const imageId = await this._setImageIdIndex(currentImageIdIndex);
    const eventDetail = {
      imageIds,
      viewportId: this.id,
      element: this.element,
      currentImageIdIndex
    };
    triggerEvent(this.element, Events_default.VIEWPORT_NEW_IMAGE_SET, eventDetail);
    return imageId;
  }
  _throwIfDestroyed() {
    if (this.isDisabled) {
      throw new Error("The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you " + "are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance " + "using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.");
    }
  }
  _checkVTKImageDataMatchesCornerstoneImage(image, imageData) {
    if (!imageData) {
      return false;
    }
    const [xSpacing, ySpacing] = imageData.getSpacing();
    const [xVoxels, yVoxels] = imageData.getDimensions();
    const imagePlaneModule = this._getImagePlaneModule(image.imageId);
    const direction = imageData.getDirection();
    const rowCosines = direction.slice(0, 3);
    const columnCosines = direction.slice(3, 6);
    const dataType = imageData.getPointData().getScalars().getDataType();
    const isSameXSpacing = isEqual(xSpacing, image.columnPixelSpacing);
    const isSameYSpacing = isEqual(ySpacing, image.rowPixelSpacing);
    const isXSpacingValid = isSameXSpacing || image.columnPixelSpacing === null && xSpacing === 1;
    const isYSpacingValid = isSameYSpacing || image.rowPixelSpacing === null && ySpacing === 1;
    const isXVoxelsMatching = xVoxels === image.columns;
    const isYVoxelsMatching = yVoxels === image.rows;
    const isRowCosinesMatching = isEqual(imagePlaneModule.rowCosines, rowCosines);
    const isColumnCosinesMatching = isEqual(imagePlaneModule.columnCosines, columnCosines);
    const isDataTypeMatching = dataType === image.voxelManager.getScalarData().constructor.name;
    const result = isXSpacingValid && isYSpacingValid && isXVoxelsMatching && isYVoxelsMatching && isRowCosinesMatching && isColumnCosinesMatching && isDataTypeMatching;
    return result;
  }
  _updateVTKImageDataFromCornerstoneImage(image) {
    const imagePlaneModule = this._getImagePlaneModule(image.imageId);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
      origin = [0, 0, 0];
    }
    this._imageData.setOrigin(origin);
    updateVTKImageDataWithCornerstoneImage(this._imageData, image);
  }
  _loadAndDisplayImage(imageId, imageIdIndex) {
    return this.useCPURendering ? this._loadAndDisplayImageCPU(imageId, imageIdIndex) : this._loadAndDisplayImageGPU(imageId, imageIdIndex);
  }
  _loadAndDisplayImageCPU(imageId, imageIdIndex) {
    return new Promise((resolve, reject) => {
      function successCallback(image, imageIdIndex2, imageId2) {
        if (this.currentImageIdIndex !== imageIdIndex2) {
          return;
        }
        const pixelData = image.voxelManager.getScalarData();
        const preScale = image.preScale;
        const scalingParams = preScale?.scalingParameters;
        const scaledWithNonIntegers = preScale?.scaled && scalingParams?.rescaleIntercept % 1 !== 0 || scalingParams?.rescaleSlope % 1 !== 0;
        if (pixelData instanceof Float32Array && scaledWithNonIntegers) {
          const floatMinMax = {
            min: image.maxPixelValue,
            max: image.minPixelValue
          };
          const floatRange = Math.abs(floatMinMax.max - floatMinMax.min);
          const intRange = 65535;
          const slope = floatRange / intRange;
          const intercept = floatMinMax.min;
          const numPixels = pixelData.length;
          const intPixelData = new Uint16Array(numPixels);
          let min5 = 65535;
          let max5 = 0;
          for (let i = 0;i < numPixels; i++) {
            const rescaledPixel = Math.floor((pixelData[i] - intercept) / slope);
            intPixelData[i] = rescaledPixel;
            min5 = Math.min(min5, rescaledPixel);
            max5 = Math.max(max5, rescaledPixel);
          }
          image.minPixelValue = min5;
          image.maxPixelValue = max5;
          image.slope = slope;
          image.intercept = intercept;
          image.getPixelData = () => intPixelData;
          image.preScale = {
            ...image.preScale,
            scaled: false
          };
        }
        this._setCSImage(image);
        this.viewportStatus = ViewportStatus_default.PRE_RENDER;
        const eventDetail2 = {
          image,
          imageId: imageId2,
          imageIdIndex: imageIdIndex2,
          viewportId: this.id,
          renderingEngineId: this.renderingEngineId
        };
        triggerEvent(this.element, Events_default.STACK_NEW_IMAGE, eventDetail2);
        this._updateToDisplayImageCPU(image);
        this.render();
        this.currentImageIdIndex = imageIdIndex2;
        resolve(imageId2);
      }
      function errorCallback(error, imageIdIndex2, imageId2) {
        const eventDetail2 = {
          error,
          imageIdIndex: imageIdIndex2,
          imageId: imageId2
        };
        if (!this.suppressEvents) {
          triggerEvent(eventTarget_default, Events_default.IMAGE_LOAD_ERROR, eventDetail2);
        }
        reject(error);
      }
      function sendRequest(imageId2, imageIdIndex2, options2) {
        return loadAndCacheImage(imageId2, options2).then((image) => {
          successCallback.call(this, image, imageIdIndex2, imageId2);
        }, (error) => {
          errorCallback.call(this, error, imageIdIndex2, imageId2);
        });
      }
      const priority = -5;
      const requestType = RequestType_default.Interaction;
      const additionalDetails = { imageId, imageIdIndex };
      const options = {
        useRGBA: true,
        requestType
      };
      const eventDetail = {
        imageId,
        imageIdIndex,
        viewportId: this.id,
        renderingEngineId: this.renderingEngineId
      };
      triggerEvent(this.element, Events_default.PRE_STACK_NEW_IMAGE, eventDetail);
      imageLoadPoolManager_default.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
    });
  }
  successCallback(imageId, image) {
    const imageIdIndex = this.imageIds.indexOf(imageId);
    if (this.currentImageIdIndex !== imageIdIndex) {
      return;
    }
    const csImgFrame = this.csImage?.imageFrame;
    const imgFrame = image?.imageFrame;
    const photometricInterpretation = csImgFrame?.photometricInterpretation || this.csImage?.photometricInterpretation;
    const newPhotometricInterpretation = imgFrame?.photometricInterpretation || image?.photometricInterpretation;
    if (photometricInterpretation !== newPhotometricInterpretation) {
      this.stackInvalidated = true;
    }
    this._setCSImage(image);
    const eventDetail = {
      image,
      imageId,
      imageIdIndex,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId
    };
    this._updateActorToDisplayImageId(image);
    triggerEvent(this.element, Events_default.STACK_NEW_IMAGE, eventDetail);
    this.render();
    this.currentImageIdIndex = imageIdIndex;
  }
  errorCallback(imageId, permanent, error) {
    if (!permanent) {
      return;
    }
    const imageIdIndex = this.imageIds.indexOf(imageId);
    const eventDetail = {
      error,
      imageIdIndex,
      imageId
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOAD_ERROR, eventDetail);
  }
  getLoaderImageOptions(imageId) {
    const imageIdIndex = this.imageIds.indexOf(imageId);
    const { transferSyntaxUID } = getMetaData("transferSyntax", imageId) || {};
    const options = {
      useRGBA: false,
      transferSyntaxUID,
      priority: 5,
      requestType: RequestType_default.Interaction,
      additionalDetails: { imageId, imageIdIndex }
    };
    return options;
  }
  async loadImages(imageIds, listener) {
    const resultList = await Promise.allSettled(imageIds.map((imageId) => {
      const options = this.getLoaderImageOptions(imageId);
      return loadAndCacheImage(imageId, options).then((image) => {
        listener.successCallback(imageId, image);
        return imageId;
      }, (error) => {
        listener.errorCallback(imageId, true, error);
        return imageId;
      });
    }));
    const errorList = resultList.filter((item) => item.status === "rejected");
    if (errorList && errorList.length) {
      const event2 = new CustomEvent(Events_default.IMAGE_LOAD_ERROR, {
        detail: errorList,
        cancelable: true
      });
      eventTarget_default.dispatchEvent(event2);
    }
    return resultList;
  }
  _loadAndDisplayImageGPU(imageId, imageIdIndex) {
    const eventDetail = {
      imageId,
      imageIdIndex,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId
    };
    triggerEvent(this.element, Events_default.PRE_STACK_NEW_IMAGE, eventDetail);
    return this.imagesLoader.loadImages([imageId], this).then((v) => {
      return imageId;
    });
  }
  _updateToDisplayImageCPU(image) {
    const metadata = this.getImageDataMetadata(image);
    const viewport = getDefaultViewport_default(this.canvas, image, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
    const { windowCenter, windowWidth, voiLUTFunction } = viewport.voi;
    this.voiRange = toLowHighRange(windowWidth, windowCenter, voiLUTFunction);
    this._cpuFallbackEnabledElement.image = image;
    this._cpuFallbackEnabledElement.metadata = {
      ...metadata
    };
    this.cpuImagePixelData = image.voxelManager.getScalarData();
    const viewportSettingToUse = Object.assign({}, viewport, this._cpuFallbackEnabledElement.viewport);
    this._cpuFallbackEnabledElement.viewport = this.stackInvalidated ? viewport : viewportSettingToUse;
    this.stackInvalidated = false;
    this.cpuRenderingInvalidated = true;
    this._cpuFallbackEnabledElement.transform = calculateTransform_default(this._cpuFallbackEnabledElement);
  }
  getSliceViewInfo() {
    throw new Error("Method not implemented.");
  }
  addImages(stackInputs) {
    const actors = [];
    stackInputs.forEach((stackInput) => {
      const { imageId, ...rest } = stackInput;
      const image = cache_default.getImage(imageId);
      const { origin, dimensions, direction, spacing, numberOfComponents } = this.getImageDataMetadata(image);
      const imagedata = this.createVTKImageData({
        origin,
        dimensions,
        direction,
        spacing,
        numberOfComponents,
        pixelArray: image.voxelManager.getScalarData()
      });
      const imageActor = this.createActorMapper(imagedata);
      if (imageActor) {
        actors.push({
          uid: stackInput.actorUID ?? uuidv4(),
          actor: imageActor,
          referencedId: imageId,
          ...rest
        });
        if (stackInput.callback) {
          stackInput.callback({ imageActor, imageId: stackInput.imageId });
        }
      }
    });
    this.addActors(actors);
  }
  _updateActorToDisplayImageId(image) {
    const sameImageData = this._checkVTKImageDataMatchesCornerstoneImage(image, this._imageData);
    const viewPresentation = this.getViewPresentation();
    if (sameImageData && !this.stackInvalidated) {
      this._updateVTKImageDataFromCornerstoneImage(image);
      this.resetCameraNoEvent();
      this.setViewPresentation(viewPresentation);
      this._setPropertiesFromCache();
      this.stackActorReInitialized = false;
      return;
    }
    const { origin, direction, dimensions, spacing, numberOfComponents, imagePixelModule } = this.getImageDataMetadata(image);
    const pixelArray = image.voxelManager.getScalarData();
    this._createVTKImageData({
      origin,
      direction,
      dimensions,
      spacing,
      numberOfComponents,
      pixelArray
    });
    this._updateVTKImageDataFromCornerstoneImage(image);
    const actor = this.createActorMapper(this._imageData);
    const oldActors = this.getActors();
    if (oldActors.length && oldActors[0].uid === this.id) {
      oldActors[0].actor = actor;
    } else {
      oldActors.unshift({ uid: this.id, actor });
    }
    this.setActors(oldActors);
    const { viewPlaneNormal, viewUp } = this._getCameraOrientation(direction);
    const previousCamera = this.getCamera();
    this.setCameraNoEvent({ viewUp, viewPlaneNormal });
    this.initialViewUp = viewUp;
    this.resetCameraNoEvent();
    this.setViewPresentation(viewPresentation);
    this.triggerCameraEvent(this.getCamera(), previousCamera);
    const monochrome1 = imagePixelModule.photometricInterpretation === "MONOCHROME1";
    this.stackInvalidated = true;
    const voiRange = this._getInitialVOIRange(image);
    this.setVOI(voiRange, {
      forceRecreateLUTFunction: !!monochrome1
    });
    this.initialInvert = !!monochrome1;
    this.setInvertColor(this.invert || this.initialInvert);
    this.stackInvalidated = false;
    this.stackActorReInitialized = true;
    if (this._publishCalibratedEvent) {
      this.triggerCalibrationEvent();
    }
  }
  _getInitialVOIRange(image) {
    if (this.voiRange && this.voiUpdatedWithSetProperties) {
      return this.voiRange;
    }
    const { windowCenter, windowWidth, voiLUTFunction } = image;
    let voiRange = this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
    voiRange = this._getPTPreScaledRange() || voiRange;
    return voiRange;
  }
  _getPTPreScaledRange() {
    if (!this._isCurrentImagePTPrescaled()) {
      return;
    }
    return this._getDefaultPTPrescaledVOIRange();
  }
  _isCurrentImagePTPrescaled() {
    if (this.modality !== "PT" || !this.csImage.isPreScaled) {
      return false;
    }
    if (!this.csImage.preScale?.scalingParameters.suvbw) {
      return false;
    }
    return true;
  }
  _getDefaultPTPrescaledVOIRange() {
    return { lower: 0, upper: 5 };
  }
  _getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType_default.LINEAR) {
    let center, width;
    if (typeof windowCenter === "number" && typeof windowWidth === "number") {
      center = windowCenter;
      width = windowWidth;
    } else if (Array.isArray(windowCenter) && Array.isArray(windowWidth)) {
      center = windowCenter[0];
      width = windowWidth[0];
    }
    if (center !== undefined && width !== undefined) {
      return toLowHighRange(width, center, voiLUTFunction);
    }
  }
  async _setImageIdIndex(imageIdIndex) {
    if (imageIdIndex >= this.imageIds.length) {
      throw new Error(`ImageIdIndex provided ${imageIdIndex} is invalid, the stack only has ${this.imageIds.length} elements`);
    }
    this.currentImageIdIndex = imageIdIndex;
    this.hasPixelSpacing = true;
    this.viewportStatus = ViewportStatus_default.PRE_RENDER;
    const imageId = await this._loadAndDisplayImage(this.imageIds[imageIdIndex], imageIdIndex);
    if (this.perImageIdDefaultProperties.size >= 1) {
      const defaultProperties = this.perImageIdDefaultProperties.get(imageId);
      if (defaultProperties !== undefined) {
        this.setProperties(defaultProperties);
      } else if (this.globalDefaultProperties !== undefined) {
        this.setProperties(this.globalDefaultProperties);
      }
    }
    return imageId;
  }
  resetCameraCPU({ resetPan = true, resetZoom = true }) {
    const { image } = this._cpuFallbackEnabledElement;
    if (!image) {
      return;
    }
    resetCamera_default(this._cpuFallbackEnabledElement, resetPan, resetZoom);
    const { scale: scale8 } = this._cpuFallbackEnabledElement.viewport;
    const { clientWidth, clientHeight } = this.element;
    const center = [clientWidth / 2, clientHeight / 2];
    const centerWorld = this.canvasToWorldCPU(center);
    this.setCameraCPU({
      focalPoint: centerWorld,
      scale: scale8
    });
  }
  resetCameraGPU({ resetPan, resetZoom }) {
    this.setCamera({
      flipHorizontal: false,
      flipVertical: false,
      viewUp: this.initialViewUp
    });
    const resetToCenter = true;
    return super.resetCamera({ resetPan, resetZoom, resetToCenter });
  }
  scroll(delta, debounce2 = true, loop = false) {
    const imageIds = this.imageIds;
    const currentTargetImageIdIndex = this.targetImageIdIndex;
    const numberOfFrames = imageIds.length;
    let newTargetImageIdIndex = currentTargetImageIdIndex + delta;
    newTargetImageIdIndex = Math.max(0, newTargetImageIdIndex);
    if (loop) {
      newTargetImageIdIndex = newTargetImageIdIndex % numberOfFrames;
    } else {
      newTargetImageIdIndex = Math.min(numberOfFrames - 1, newTargetImageIdIndex);
    }
    this.targetImageIdIndex = newTargetImageIdIndex;
    const targetImageId = imageIds[newTargetImageIdIndex];
    const imageAlreadyLoaded = cache_default.isLoaded(targetImageId);
    if (imageAlreadyLoaded || !debounce2) {
      this.setImageIdIndex(newTargetImageIdIndex);
    } else {
      clearTimeout(this.debouncedTimeout);
      this.debouncedTimeout = window.setTimeout(() => {
        this.setImageIdIndex(newTargetImageIdIndex);
      }, 40);
    }
    const eventData = {
      newImageIdIndex: newTargetImageIdIndex,
      imageId: targetImageId,
      direction: delta
    };
    if (newTargetImageIdIndex !== currentTargetImageIdIndex) {
      triggerEvent(this.element, Events_default.STACK_VIEWPORT_SCROLL, eventData);
    }
  }
  setImageIdIndex(imageIdIndex) {
    this._throwIfDestroyed();
    if (this.currentImageIdIndex === imageIdIndex) {
      return Promise.resolve(this.getCurrentImageId());
    }
    const imageIdPromise = this._setImageIdIndex(imageIdIndex);
    return imageIdPromise;
  }
  calibrateSpacing(imageId) {
    const imageIdIndex = this.getImageIds().indexOf(imageId);
    this.stackInvalidated = true;
    this._loadAndDisplayImage(imageId, imageIdIndex);
  }
  triggerCameraEvent(camera, previousCamera) {
    const eventDetail = {
      previousCamera,
      camera,
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId
    };
    if (!this.suppressEvents) {
      triggerEvent(this.element, Events_default.CAMERA_MODIFIED, eventDetail);
    }
  }
  triggerCalibrationEvent() {
    const { imageData } = this.getImageData();
    const eventDetail = {
      element: this.element,
      viewportId: this.id,
      renderingEngineId: this.renderingEngineId,
      imageId: this.getCurrentImageId(),
      imageData,
      worldToIndex: imageData.getWorldToIndex(),
      ...this._calibrationEvent
    };
    if (!this.suppressEvents) {
      triggerEvent(this.element, Events_default.IMAGE_SPACING_CALIBRATED, eventDetail);
    }
    this._publishCalibratedEvent = false;
  }
  jumpToWorld(worldPos) {
    const imageIds = this.getImageIds();
    const imageData = this.getImageData();
    const { direction, spacing } = imageData;
    const imageId = getClosestImageId({ direction, spacing, imageIds }, worldPos, this.getCamera().viewPlaneNormal);
    const index2 = imageIds.indexOf(imageId);
    if (index2 === -1) {
      return false;
    }
    this.setImageIdIndex(index2);
    this.render();
    return true;
  }
  _getVOIRangeForCurrentImage() {
    const { windowCenter, windowWidth, voiLUTFunction } = this.csImage;
    return this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
  }
  _getValidVOILUTFunction(voiLUTFunction) {
    if (!Object.values(VOILUTFunctionType_default).includes(voiLUTFunction)) {
      return VOILUTFunctionType_default.LINEAR;
    }
    return voiLUTFunction;
  }
  getSliceInfo() {
    const sliceIndex = this.getSliceIndex();
    const { dimensions } = this.getImageData();
    return {
      width: dimensions[0],
      height: dimensions[1],
      sliceIndex,
      slicePlane: 2
    };
  }
  isReferenceViewable(viewRef, options = {}) {
    const testIndex = this.getCurrentImageIdIndex();
    const currentImageId = this.imageIds[testIndex];
    if (!currentImageId || !viewRef) {
      return false;
    }
    const { referencedImageId, multiSliceReference } = viewRef;
    if (referencedImageId) {
      if (referencedImageId === currentImageId) {
        return true;
      }
      viewRef.referencedImageURI ||= imageIdToURI(referencedImageId);
      const { referencedImageURI } = viewRef;
      const foundSliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
      if (options.asOverlay) {
        const matchedImageId = this.matchImagesForOverlay(currentImageId, referencedImageId);
        if (matchedImageId) {
          return true;
        }
      }
      if (foundSliceIndex === undefined) {
        return false;
      }
      if (options.withNavigation) {
        return true;
      }
      const rangeEndSliceIndex = multiSliceReference && this.imageKeyToIndexMap.get(multiSliceReference.referencedImageId);
      return testIndex <= rangeEndSliceIndex && testIndex >= foundSliceIndex;
    }
    if (!super.isReferenceViewable(viewRef, options)) {
      return false;
    }
    if (viewRef.volumeId) {
      return options.asVolume;
    }
    const { cameraFocalPoint } = viewRef;
    if (options.asNearbyProjection && cameraFocalPoint) {
      const { spacing, direction, origin } = this.getImageData();
      const viewPlaneNormal = direction.slice(6, 9);
      const sliceThickness = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);
      const diff = exports_vec3.subtract(exports_vec3.create(), cameraFocalPoint, origin);
      const distanceToPlane2 = exports_vec3.dot(diff, viewPlaneNormal);
      const threshold = sliceThickness / 2;
      if (Math.abs(distanceToPlane2) <= threshold) {
        return true;
      }
    }
    return false;
  }
  getViewReference(viewRefSpecifier = {}) {
    const { sliceIndex = this.getCurrentImageIdIndex() } = viewRefSpecifier;
    const reference = super.getViewReference(viewRefSpecifier);
    const referencedImageId = this.getCurrentImageId(sliceIndex);
    if (!referencedImageId) {
      return;
    }
    reference.referencedImageId = referencedImageId;
    if (this.getCurrentImageIdIndex() !== sliceIndex) {
      const referenceData = this.getImagePlaneReferenceData(sliceIndex);
      if (!referenceData) {
        return;
      }
      Object.assign(reference, referenceData);
    }
    return reference;
  }
  setViewReference(viewRef) {
    if (!viewRef?.referencedImageId) {
      if (viewRef?.sliceIndex !== undefined) {
        this.scroll(viewRef.sliceIndex - this.targetImageIdIndex);
      }
      return;
    }
    const { referencedImageId } = viewRef;
    viewRef.referencedImageURI ||= imageIdToURI(referencedImageId);
    const { referencedImageURI } = viewRef;
    const sliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
    if (sliceIndex === undefined) {
      console.error(`No image URI found for ${referencedImageURI}`);
      return;
    }
    this.scroll(sliceIndex - this.targetImageIdIndex);
  }
  getViewReferenceId(specifier = {}) {
    const { sliceIndex = this.currentImageIdIndex } = specifier;
    return `imageId:${this.imageIds[sliceIndex]}`;
  }
  getSliceIndexForImage(reference) {
    if (!reference) {
      return;
    }
    if (typeof reference === "string") {
      return this.imageKeyToIndexMap.get(reference);
    }
    if (reference.referencedImageId) {
      return this.imageKeyToIndexMap.get(reference.referencedImageId);
    }
    return;
  }
  getCPUFallbackError(method) {
    return new Error(`method ${method} cannot be used during CPU Fallback mode`);
  }
  fillWithBackgroundColor() {
    const renderingEngine = this.getRenderingEngine();
    if (renderingEngine) {
      renderingEngine.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
    }
  }
  unsetColormapCPU() {
    delete this._cpuFallbackEnabledElement.viewport.colormap;
    this._cpuFallbackEnabledElement.renderingTools = {};
    this.cpuRenderingInvalidated = true;
    this.fillWithBackgroundColor();
    this.render();
  }
  setColormapCPU(colormapData) {
    this.colormap = colormapData;
    const colormap = getColormap(colormapData.name);
    this._cpuFallbackEnabledElement.viewport.colormap = colormap;
    this._cpuFallbackEnabledElement.renderingTools = {};
    this.fillWithBackgroundColor();
    this.cpuRenderingInvalidated = true;
    this.render();
    const eventDetail = {
      viewportId: this.id,
      colormap: colormapData
    };
    triggerEvent(this.element, Events_default.COLORMAP_MODIFIED, eventDetail);
  }
  setColormapGPU(colormap) {
    const ActorEntry = this.getDefaultActor();
    const actor = ActorEntry.actor;
    const actorProp = actor.getProperty();
    const rgbTransferFunction = actorProp.getRGBTransferFunction();
    const colormapObj = getColormap(colormap.name) || vtkColorMaps2.getPresetByName(colormap.name);
    if (!rgbTransferFunction) {
      const cfun = vtkColorTransferFunction$1.newInstance();
      cfun.applyColorMap(colormapObj);
      cfun.setMappingRange(this.voiRange.lower, this.voiRange.upper);
      actorProp.setRGBTransferFunction(0, cfun);
    } else {
      rgbTransferFunction.applyColorMap(colormapObj);
      rgbTransferFunction.setMappingRange(this.voiRange.lower, this.voiRange.upper);
      actorProp.setRGBTransferFunction(0, rgbTransferFunction);
    }
    this.colormap = colormap;
    this.render();
    const eventDetail = {
      viewportId: this.id,
      colormap
    };
    triggerEvent(this.element, Events_default.COLORMAP_MODIFIED, eventDetail);
  }
  unsetColormapGPU() {
    throw new Error("unsetColormapGPU not implemented.");
  }
  _getImagePlaneModule(imageId) {
    const imagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, imageId);
    this.hasPixelSpacing = !imagePlaneModule.usingDefaultValues || this.calibration?.scale > 0;
    this.calibration ||= imagePlaneModule.calibration;
    const newImagePlaneModule = {
      ...imagePlaneModule
    };
    if (!newImagePlaneModule.columnPixelSpacing) {
      newImagePlaneModule.columnPixelSpacing = 1;
    }
    if (!newImagePlaneModule.rowPixelSpacing) {
      newImagePlaneModule.rowPixelSpacing = 1;
    }
    if (!newImagePlaneModule.columnCosines) {
      newImagePlaneModule.columnCosines = [0, 1, 0];
    }
    if (!newImagePlaneModule.rowCosines) {
      newImagePlaneModule.rowCosines = [1, 0, 0];
    }
    if (!newImagePlaneModule.imagePositionPatient) {
      newImagePlaneModule.imagePositionPatient = [0, 0, 0];
    }
    if (!newImagePlaneModule.imageOrientationPatient) {
      newImagePlaneModule.imageOrientationPatient = new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    return newImagePlaneModule;
  }
}
var StackViewport_default = StackViewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport3D.js
class VolumeViewport3D extends BaseVolumeViewport_default {
  constructor(props) {
    super(props);
    this.getNumberOfSlices = () => {
      return 1;
    };
    this.getRotation = () => 0;
    this.getCurrentImageIdIndex = () => {
      return 0;
    };
    this.getCurrentImageId = () => {
      return null;
    };
    this.resetCameraForResize = () => {
      return this.resetCamera({
        resetPan: true,
        resetZoom: true,
        resetToCenter: true
      });
    };
    const { parallelProjection, orientation } = this.options;
    const activeCamera = this.getVtkActiveCamera();
    if (parallelProjection != null) {
      activeCamera.setParallelProjection(parallelProjection);
    }
    if (orientation && orientation !== OrientationAxis_default.ACQUISITION) {
      this.applyViewOrientation(orientation);
    }
  }
  resetCamera({ resetPan = true, resetZoom = true, resetToCenter = true } = {}) {
    super.resetCamera({ resetPan, resetZoom, resetToCenter });
    const activeCamera = this.getVtkActiveCamera();
    if (activeCamera.getParallelProjection()) {
      activeCamera.setClippingRange(-rendering_default.MAXIMUM_RAY_DISTANCE, rendering_default.MAXIMUM_RAY_DISTANCE);
    } else {
      activeCamera.setClippingRange(rendering_default.MINIMUM_SLAB_THICKNESS, rendering_default.MAXIMUM_RAY_DISTANCE);
    }
    const renderer = this.getRenderer();
    renderer.resetCameraClippingRange();
    return true;
  }
  setSlabThickness(slabThickness, filterActorUIDs) {
    return null;
  }
  setBlendMode(blendMode, filterActorUIDs, immediate) {
    return null;
  }
  resetProperties(volumeId) {
    const volumeActor = volumeId ? this.getActor(volumeId) : this.getDefaultActor();
    if (!volumeActor) {
      throw new Error(`No actor found for the given volumeId: ${volumeId}`);
    }
    if (volumeActor.slabThickness) {
      volumeActor.slabThickness = rendering_default.MINIMUM_SLAB_THICKNESS;
      this.viewportProperties.slabThickness = undefined;
      this.updateClippingPlanesForActors(this.getCamera());
    }
    volumeId ||= this.getVolumeId();
    const imageVolume = cache_default.getVolume(volumeId);
    if (!imageVolume) {
      throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
    }
    setDefaultVolumeVOI_default(volumeActor.actor, imageVolume);
    if (isImageActor(volumeActor)) {
      const transferFunction = volumeActor.actor.getProperty().getRGBTransferFunction(0);
      setTransferFunctionNodes(transferFunction, this.initialTransferFunctionNodes);
    }
    this.setCamera(this.initialCamera);
    triggerEvent(this.element, Events_default.VOI_MODIFIED, super.getVOIModifiedEventDetail(volumeId));
  }
  getSliceIndex() {
    return null;
  }
  setCamera(props) {
    super.setCamera(props);
    this.getRenderer().resetCameraClippingRange();
    this.render();
  }
  setCameraClippingRange() {
    const activeCamera = this.getVtkActiveCamera();
    if (activeCamera.getParallelProjection()) {
      activeCamera.setClippingRange(-rendering_default.MAXIMUM_RAY_DISTANCE, rendering_default.MAXIMUM_RAY_DISTANCE);
    } else {
      activeCamera.setClippingRange(rendering_default.MINIMUM_SLAB_THICKNESS, rendering_default.MAXIMUM_RAY_DISTANCE);
    }
  }
  resetSlabThickness() {
    return null;
  }
}
var VolumeViewport3D_default = VolumeViewport3D;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var VIEWPORT_ELEMENT = "viewport-element";
var CANVAS_CSS_CLASS = "cornerstone-canvas";
var EPSILON7 = 0.0001;
function createCanvas(element) {
  const canvas = document.createElement("canvas");
  canvas.style.position = "absolute";
  canvas.style.width = "100%";
  canvas.style.height = "100%";
  canvas.style.imageRendering = "pixelated";
  canvas.classList.add(CANVAS_CSS_CLASS);
  element.appendChild(canvas);
  return canvas;
}
function createViewportElement(element) {
  const div4 = document.createElement("div");
  div4.style.position = "relative";
  div4.style.width = "100%";
  div4.style.height = "100%";
  div4.style.overflow = "hidden";
  div4.classList.add(VIEWPORT_ELEMENT);
  element.appendChild(div4);
  return div4;
}
function getOrCreateCanvas(element) {
  const canvasSelector = `canvas.${CANVAS_CSS_CLASS}`;
  const viewportElement = `div.${VIEWPORT_ELEMENT}`;
  const internalDiv = element.querySelector(viewportElement) || createViewportElement(element);
  const existingCanvas = internalDiv.querySelector(canvasSelector);
  if (existingCanvas) {
    return existingCanvas;
  }
  const canvas = createCanvas(internalDiv);
  const rect = internalDiv.getBoundingClientRect();
  const devicePixelRatio2 = window.devicePixelRatio || 1;
  const width = Math.ceil(rect.width * devicePixelRatio2);
  const height = Math.ceil(rect.height * devicePixelRatio2);
  canvas.width = width;
  canvas.height = height;
  return canvas;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setVolumesForViewports.js
async function setVolumesForViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {
  viewportIds.forEach((viewportId) => {
    const viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
      throw new Error(`Viewport with Id ${viewportId} does not exist`);
    }
    if (!(viewport instanceof BaseVolumeViewport_default)) {
      throw new Error("setVolumesForViewports only supports VolumeViewport and VolumeViewport3D");
    }
  });
  const setVolumePromises = viewportIds.map(async (viewportId) => {
    const viewport = renderingEngine.getViewport(viewportId);
    await viewport.setVolumes(volumeInputs, immediateRender, suppressEvents);
  });
  await Promise.all(setVolumePromises);
  return;
}
var setVolumesForViewports_default = setVolumesForViewports;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addVolumesToViewports.js
async function addVolumesToViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {
  for (const viewportId of viewportIds) {
    const viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
      throw new Error(`Viewport with Id ${viewportId} does not exist`);
    }
    if (!(viewport instanceof BaseVolumeViewport_default)) {
      console.warn(`Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`);
      return;
    }
  }
  const addVolumePromises = viewportIds.map(async (viewportId) => {
    const viewport = renderingEngine.getViewport(viewportId);
    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);
  });
  await Promise.all(addVolumePromises);
  return;
}
var addVolumesToViewports_default = addVolumesToViewports;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addImageSlicesToViewports.js
function addImageSlicesToViewports(renderingEngine, stackInputs, viewportIds) {
  for (const viewportId of viewportIds) {
    const viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
      throw new Error(`Viewport with Id ${viewportId} does not exist`);
    }
    if (!viewport.addImages) {
      console.warn(`Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`);
      return;
    }
  }
  viewportIds.forEach((viewportId) => {
    const viewport = renderingEngine.getViewport(viewportId);
    viewport.addImages(stackInputs);
  });
}
var addImageSlicesToViewports_default = addImageSlicesToViewports;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasProperties.js
class CanvasProperties {
  constructor(actor) {
    this.opacity = 0.4;
    this.outlineOpacity = 0.4;
    this.transferFunction = [];
    this.actor = actor;
  }
  setRGBTransferFunction(index2, cfun) {
    this.transferFunction[index2] = cfun;
  }
  setScalarOpacity(opacity) {
  }
  setInterpolationTypeToNearest() {
  }
  setUseLabelOutline() {
  }
  setLabelOutlineOpacity(opacity) {
    this.outlineOpacity = opacity;
  }
  setLabelOutlineThickness() {
  }
  getColor(index2) {
    const cfun = this.transferFunction[0];
    const r = cfun.getRedValue(index2);
    const g = cfun.getGreenValue(index2);
    const b = cfun.getBlueValue(index2);
    return [r, g, b, this.opacity];
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasMapper.js
class CanvasMapper {
  constructor(actor) {
    this.actor = actor;
  }
  getInputData() {
    return this.actor.getImage();
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/index.js
class CanvasActor {
  constructor(viewport, derivedImage) {
    this.canvasProperties = new CanvasProperties(this);
    this.visibility = false;
    this.mapper = new CanvasMapper(this);
    this.className = "CanvasActor";
    this.derivedImage = derivedImage;
    this.viewport = viewport;
  }
  renderRLE(viewport, context, voxelManager) {
    const { width, height } = this.image;
    let { canvas } = this;
    if (!canvas || canvas.width !== width || canvas.height !== height) {
      this.canvas = canvas = new window.OffscreenCanvas(width, height);
    }
    const localContext = canvas.getContext("2d");
    const imageData = localContext.createImageData(width, height);
    const { data: imageArray } = imageData;
    imageArray.fill(0);
    const { map } = voxelManager;
    let dirtyX = Infinity;
    let dirtyY = Infinity;
    let dirtyX2 = -Infinity;
    let dirtyY2 = -Infinity;
    for (let y = 0;y < height; y++) {
      const row = map.getRun(y, 0);
      if (!row) {
        continue;
      }
      dirtyY = Math.min(dirtyY, y);
      dirtyY2 = Math.max(dirtyY2, y);
      const baseOffset = y * width << 2;
      let indicesToDelete;
      for (const run of row) {
        const { start, end, value: segmentIndex } = run;
        if (segmentIndex === 0) {
          indicesToDelete ||= [];
          indicesToDelete.push(row.indexOf(run));
          continue;
        }
        dirtyX = Math.min(dirtyX, start);
        dirtyX2 = Math.max(dirtyX2, end);
        const rgb = this.canvasProperties.getColor(segmentIndex).map((v) => v * 255);
        let startOffset = baseOffset + (start << 2);
        for (let i = start;i < end; i++) {
          imageArray[startOffset++] = rgb[0];
          imageArray[startOffset++] = rgb[1];
          imageArray[startOffset++] = rgb[2];
          imageArray[startOffset++] = rgb[3];
        }
      }
    }
    if (dirtyX > width) {
      return;
    }
    const dirtyWidth = dirtyX2 - dirtyX;
    const dirtyHeight = dirtyY2 - dirtyY;
    localContext.putImageData(imageData, 0, 0, dirtyX - 1, dirtyY - 1, dirtyWidth + 2, dirtyHeight + 2);
    context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
  }
  setMapper(mapper) {
    this.mapper = mapper;
  }
  render(viewport, context) {
    if (!this.visibility) {
      return;
    }
    const image = this.image || this.getImage();
    const { width, height } = image;
    const data = image.getScalarData();
    if (!data) {
      return;
    }
    const { voxelManager } = image;
    if (voxelManager) {
      if (voxelManager.map.getRun) {
        this.renderRLE(viewport, context, voxelManager);
        return;
      }
    }
    let { canvas } = this;
    if (!canvas || canvas.width !== width || canvas.height !== height) {
      this.canvas = canvas = new window.OffscreenCanvas(width, height);
    }
    const localContext = canvas.getContext("2d");
    const imageData = localContext.createImageData(width, height);
    const { data: imageArray } = imageData;
    let offset = 0;
    let destOffset = 0;
    let dirtyX = Infinity;
    let dirtyY = Infinity;
    let dirtyX2 = -Infinity;
    let dirtyY2 = -Infinity;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        const segmentIndex = data[offset++];
        if (segmentIndex) {
          dirtyX = Math.min(x, dirtyX);
          dirtyY = Math.min(y, dirtyY);
          dirtyX2 = Math.max(x, dirtyX2);
          dirtyY2 = Math.max(y, dirtyY2);
          const rgb = this.canvasProperties.getColor(segmentIndex);
          imageArray[destOffset] = rgb[0] * 255;
          imageArray[destOffset + 1] = rgb[1] * 255;
          imageArray[destOffset + 2] = rgb[2] * 255;
          imageArray[destOffset + 3] = 127;
        }
        destOffset += 4;
      }
    }
    if (dirtyX > width) {
      return;
    }
    const dirtyWidth = dirtyX2 - dirtyX + 1;
    const dirtyHeight = dirtyY2 - dirtyY + 1;
    localContext.putImageData(imageData, 0, 0, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
  }
  getClassName() {
    return this.className;
  }
  getProperty() {
    return this.canvasProperties;
  }
  setVisibility(visibility) {
    this.visibility = visibility;
  }
  getMapper() {
    return this.mapper;
  }
  isA(actorType) {
    return actorType === this.className;
  }
  getImage() {
    if (this.image) {
      return this.image;
    }
    this.image = { ...this.derivedImage };
    const imageData = this.viewport.getImageData();
    Object.assign(this.image, {
      worldToIndex: (worldPos) => imageData.imageData.worldToIndex(worldPos),
      indexToWorld: (index2, destPoint) => imageData.imageData.indexToWorld(index2, destPoint),
      getDimensions: () => imageData.dimensions,
      getScalarData: () => this.derivedImage?.getPixelData(),
      getDirection: () => imageData.direction,
      getSpacing: () => imageData.spacing,
      setOrigin: () => null,
      setDerivedImage: (image) => {
        this.derivedImage = image;
        this.image = null;
      },
      modified: () => null
    });
    return this.image;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js
class FrameRange {
  static {
    this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
  }
  static imageIdToFrames(imageId) {
    const match = imageId.match(this.frameRangeExtractor);
    if (!match || !match[2]) {
      return null;
    }
    const range = match[2].split("-").map((it) => Number(it));
    if (range.length === 1) {
      return range[0];
    }
    return range;
  }
  static imageIdToFrameEnd(imageId) {
    const range = this.imageIdToFrames(imageId);
    return Array.isArray(range) ? range[1] : range;
  }
  static imageIdToFrameStart(imageId) {
    const range = this.imageIdToFrames(imageId);
    return Array.isArray(range) ? range[0] : range;
  }
  static framesToString(range) {
    if (Array.isArray(range)) {
      return `${range[0]}-${range[1]}`;
    }
    return String(range);
  }
  static framesToImageId(imageId, range) {
    const match = imageId.match(this.frameRangeExtractor);
    if (!match || !match[2]) {
      return null;
    }
    const newRangeString = this.framesToString(range);
    return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js
class VideoViewport extends Viewport_default {
  static {
    this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
  }
  constructor(props) {
    super({
      ...props,
      canvas: props.canvas || getOrCreateCanvas(props.element)
    });
    this.videoWidth = 0;
    this.videoHeight = 0;
    this.loop = true;
    this.mute = true;
    this.isPlaying = false;
    this.scrollSpeed = 1;
    this.playbackRate = 1;
    this.frameRange = [0, 0];
    this.fps = 30;
    this.videoCamera = {
      panWorld: [0, 0],
      parallelScale: 1
    };
    this.voiRange = {
      lower: 0,
      upper: 255
    };
    this.getProperties = () => {
      return {
        loop: this.videoElement.loop,
        muted: this.videoElement.muted,
        playbackRate: this.playbackRate,
        scrollSpeed: this.scrollSpeed,
        voiRange: { ...this.voiRange }
      };
    };
    this.getMiddleSliceData = () => {
      throw new Error("Method not implemented.");
    };
    this.useCustomRenderingPipeline = true;
    this.resetCamera = () => {
      this.refreshRenderValues();
      this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
      if (!this.isPlaying) {
        this.renderFrame();
      }
      return true;
    };
    this.getNumberOfSlices = () => {
      const computedSlices = Math.round(this.videoElement.duration * this.fps / this.scrollSpeed);
      return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;
    };
    this.getFrameOfReferenceUID = () => {
      return this.videoElement.src;
    };
    this.resize = () => {
      const canvas = this.canvas;
      const { clientWidth, clientHeight } = canvas;
      if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth;
        canvas.height = clientHeight;
      }
      this.refreshRenderValues();
      if (!this.isPlaying) {
        this.renderFrame();
      }
    };
    this.canvasToWorld = (canvasPos, destPos = [0, 0, 0]) => {
      const pan = this.videoCamera.panWorld;
      const worldToCanvasRatio = this.getWorldToCanvasRatio();
      const panOffsetCanvas = [
        pan[0] * worldToCanvasRatio,
        pan[1] * worldToCanvasRatio
      ];
      const subCanvasPos = [
        canvasPos[0] - panOffsetCanvas[0],
        canvasPos[1] - panOffsetCanvas[1]
      ];
      destPos.splice(0, 2, subCanvasPos[0] / worldToCanvasRatio, subCanvasPos[1] / worldToCanvasRatio);
      return destPos;
    };
    this.worldToCanvas = (worldPos) => {
      const pan = this.videoCamera.panWorld;
      const worldToCanvasRatio = this.getWorldToCanvasRatio();
      const canvasPos = [
        (worldPos[0] + pan[0]) * worldToCanvasRatio,
        (worldPos[1] + pan[1]) * worldToCanvasRatio
      ];
      return canvasPos;
    };
    this.getRotation = () => 0;
    this.canvasToIndex = (canvasPos) => {
      const transform = this.getTransform();
      transform.invert();
      return transform.transformPoint(canvasPos.map((it) => it * devicePixelRatio));
    };
    this.indexToCanvas = (indexPos) => {
      const transform = this.getTransform();
      return transform.transformPoint(indexPos).map((it) => it / devicePixelRatio);
    };
    this.customRenderViewportToCanvas = () => {
      this.renderFrame();
    };
    this.renderFrame = () => {
      const dpr = window.devicePixelRatio || 1;
      const transform = this.getTransform();
      const transformationMatrix = transform.getMatrix();
      const ctx = this.canvasContext;
      ctx.resetTransform();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.transform(transformationMatrix[0] / dpr, transformationMatrix[1] / dpr, transformationMatrix[2] / dpr, transformationMatrix[3] / dpr, transformationMatrix[4] / dpr, transformationMatrix[5] / dpr);
      ctx.drawImage(this.videoElement, 0, 0, this.videoWidth, this.videoHeight);
      for (const actor of this.getActors()) {
        actor.actor.render(this, this.canvasContext);
      }
      this.canvasContext.resetTransform();
      triggerEvent(this.element, Events_default.STACK_NEW_IMAGE, {
        element: this.element,
        viewportId: this.id,
        viewport: this,
        renderingEngineId: this.renderingEngineId,
        time: this.videoElement.currentTime,
        duration: this.videoElement.duration
      });
      triggerEvent(this.element, Events_default.IMAGE_RENDERED, {
        element: this.element,
        viewportId: this.id,
        viewport: this,
        imageIndex: this.getCurrentImageIdIndex(),
        numberOfSlices: this.numberOfFrames,
        renderingEngineId: this.renderingEngineId,
        time: this.videoElement.currentTime,
        duration: this.videoElement.duration
      });
      this.initialRender?.();
      const frame = this.getFrameNumber();
      if (this.isPlaying) {
        if (frame < this.frameRange[0]) {
          this.setFrameNumber(this.frameRange[0]);
        } else if (frame > this.frameRange[1]) {
          if (this.loop) {
            this.setFrameNumber(this.frameRange[0]);
          } else {
            this.pause();
          }
        }
      }
    };
    this.renderWhilstPlaying = () => {
      this.renderFrame();
      if (this.isPlaying) {
        requestAnimationFrame(this.renderWhilstPlaying);
      }
    };
    this.canvasContext = this.canvas.getContext("2d");
    this.renderingEngineId = props.renderingEngineId;
    this.element.setAttribute("data-viewport-uid", this.id);
    this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId);
    this.videoElement = document.createElement("video");
    this.videoElement.muted = this.mute;
    this.videoElement.loop = this.loop;
    this.videoElement.autoplay = true;
    this.videoElement.crossOrigin = "anonymous";
    this.addEventListeners();
    this.resize();
  }
  static get useCustomRenderingPipeline() {
    return true;
  }
  addEventListeners() {
    this.canvas.addEventListener(Events_default.ELEMENT_DISABLED, this.elementDisabledHandler);
  }
  removeEventListeners() {
    this.canvas.removeEventListener(Events_default.ELEMENT_DISABLED, this.elementDisabledHandler);
  }
  elementDisabledHandler() {
    this.removeEventListeners();
    this.videoElement.remove();
  }
  getImageDataMetadata(image) {
    const imageId = typeof image === "string" ? image : image.imageId;
    const imagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, imageId);
    let rowCosines = imagePlaneModule.rowCosines;
    let columnCosines = imagePlaneModule.columnCosines;
    const usingDefaultValues = imagePlaneModule.usingDefaultValues;
    if (usingDefaultValues || rowCosines == null || columnCosines == null) {
      rowCosines = [1, 0, 0];
      columnCosines = [0, 1, 0];
    }
    const rowCosineVec = exports_vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = exports_vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
    const { rows, columns } = imagePlaneModule;
    const scanAxisNormal = exports_vec3.create();
    exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
      origin = [0, 0, 0];
    }
    const xSpacing = imagePlaneModule.columnPixelSpacing || 1;
    const ySpacing = imagePlaneModule.rowPixelSpacing || 1;
    const xVoxels = imagePlaneModule.columns;
    const yVoxels = imagePlaneModule.rows;
    const zSpacing = 1;
    const zVoxels = 1;
    this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;
    return {
      bitsAllocated: 8,
      numberOfComponents: 3,
      origin,
      rows,
      columns,
      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
      dimensions: [xVoxels, yVoxels, zVoxels],
      spacing: [xSpacing, ySpacing, zSpacing],
      hasPixelSpacing: this.hasPixelSpacing,
      numVoxels: xVoxels * yVoxels * zVoxels,
      imagePlaneModule
    };
  }
  setDataIds(imageIds, options) {
    this.setVideo(imageIds[0], (options.viewReference?.sliceIndex || 0) + 1);
  }
  setVideo(imageId, frameNumber) {
    this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;
    const imageUrlModule = getMetaData(MetadataModules_default.IMAGE_URL, imageId);
    if (!imageUrlModule?.rendered) {
      throw new Error(`Video Image ID ${imageId} does not have a rendered video view`);
    }
    const { rendered } = imageUrlModule;
    const generalSeries = getMetaData(MetadataModules_default.GENERAL_SERIES, imageId);
    this.modality = generalSeries?.Modality;
    this.metadata = this.getImageDataMetadata(imageId);
    let { cineRate, numberOfFrames } = getMetaData(MetadataModules_default.CINE, imageId);
    this.numberOfFrames = numberOfFrames;
    return this.setVideoURL(rendered).then(() => {
      if (!numberOfFrames || numberOfFrames === 1) {
        numberOfFrames = Math.round(this.videoElement.duration * (cineRate || 30));
      }
      if (!cineRate) {
        cineRate = Math.round(numberOfFrames / this.videoElement.duration);
      }
      this.fps = cineRate;
      this.numberOfFrames = numberOfFrames;
      this.setFrameRange([1, numberOfFrames]);
      this.initialRender = () => {
        this.initialRender = null;
        this.pause();
        this.setFrameNumber(frameNumber || 1);
      };
      return new Promise((resolve) => {
        window.setTimeout(() => {
          this.setFrameNumber(frameNumber || 1);
          resolve(this);
        }, 25);
      });
    });
  }
  async setVideoURL(videoURL) {
    return new Promise((resolve) => {
      this.videoElement.src = videoURL;
      this.videoElement.preload = "auto";
      const loadedMetadataEventHandler = () => {
        this.videoWidth = this.videoElement.videoWidth;
        this.videoHeight = this.videoElement.videoHeight;
        this.videoElement.removeEventListener("loadedmetadata", loadedMetadataEventHandler);
        this.refreshRenderValues();
        resolve(true);
      };
      this.videoElement.addEventListener("loadedmetadata", loadedMetadataEventHandler);
    });
  }
  getImageIds() {
    const imageIds = new Array(this.numberOfFrames);
    const baseImageId = this.imageId.replace(/[0-9]+$/, "");
    for (let i = 0;i < this.numberOfFrames; i++) {
      imageIds[i] = `${baseImageId}${i + 1}`;
    }
    return imageIds;
  }
  togglePlayPause() {
    if (this.isPlaying) {
      this.pause();
      return false;
    } else {
      this.play();
      return true;
    }
  }
  async play() {
    try {
      if (!this.isPlaying) {
        this.isPlaying = true;
        await this.videoElement.play();
        this.renderWhilstPlaying();
      }
    } catch (e) {
    }
  }
  pause() {
    try {
      this.isPlaying = false;
      this.videoElement.pause();
    } catch (e) {
    }
  }
  async scroll(delta = 1) {
    await this.pause();
    const videoElement = this.videoElement;
    const renderFrame = this.renderFrame;
    const currentTime = videoElement.currentTime;
    const newTime = currentTime + delta * this.scrollSpeed / this.fps;
    videoElement.currentTime = newTime;
    const seekEventListener = (evt) => {
      renderFrame();
      videoElement.removeEventListener("seeked", seekEventListener);
    };
    videoElement.addEventListener("seeked", seekEventListener);
  }
  async start() {
    const videoElement = this.videoElement;
    const renderFrame = this.renderFrame;
    videoElement.currentTime = 0;
    if (videoElement.paused) {
      const seekEventListener = (evt) => {
        renderFrame();
        videoElement.removeEventListener("seeked", seekEventListener);
      };
      videoElement.addEventListener("seeked", seekEventListener);
    }
  }
  async end() {
    const videoElement = this.videoElement;
    const renderFrame = this.renderFrame;
    videoElement.currentTime = videoElement.duration;
    if (videoElement.paused) {
      const seekEventListener = (evt) => {
        renderFrame();
        videoElement.removeEventListener("seeked", seekEventListener);
      };
      videoElement.addEventListener("seeked", seekEventListener);
    }
  }
  async setTime(timeInSeconds) {
    const videoElement = this.videoElement;
    const renderFrame = this.renderFrame;
    videoElement.currentTime = timeInSeconds;
    if (videoElement.paused) {
      const seekEventListener = (evt) => {
        renderFrame();
        videoElement.removeEventListener("seeked", seekEventListener);
      };
      videoElement.addEventListener("seeked", seekEventListener);
    }
  }
  getSliceViewInfo() {
    throw new Error("Method not implemented.");
  }
  async setFrameNumber(frame) {
    this.setTime((frame - 1) / this.fps);
  }
  setFrameRange(frameRange) {
    if (!frameRange) {
      this.frameRange = [1, this.numberOfFrames];
      return;
    }
    if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {
      return;
    }
    this.frameRange = [frameRange[0], frameRange[1]];
  }
  getSliceIndexForImage(reference) {
    if (!reference) {
      return;
    }
    if (typeof reference === "string") {
      return FrameRange.imageIdToFrameStart(reference);
    }
    if (reference.referencedImageId) {
      return FrameRange.imageIdToFrameStart(reference.referencedImageId);
    }
    return;
  }
  getFrameRange() {
    return this.frameRange;
  }
  setProperties(props) {
    if (props.loop !== undefined) {
      this.videoElement.loop = props.loop;
    }
    if (props.muted !== undefined) {
      this.videoElement.muted = props.muted;
    }
    if (props.playbackRate !== undefined) {
      this.setPlaybackRate(props.playbackRate);
    }
    if (props.scrollSpeed !== undefined) {
      this.setScrollSpeed(props.scrollSpeed);
    }
    if (props.voiRange) {
      this.setVOI(props.voiRange);
    }
  }
  setPlaybackRate(rate = 1) {
    this.playbackRate = rate;
    if (rate < 0.0625) {
      this.pause();
      return;
    }
    if (!this.videoElement) {
      return;
    }
    this.videoElement.playbackRate = rate;
    this.play();
  }
  setScrollSpeed(scrollSpeed = 1, unit = exports_VideoEnums.SpeedUnit.FRAME) {
    this.scrollSpeed = unit === exports_VideoEnums.SpeedUnit.SECOND ? scrollSpeed * this.fps : scrollSpeed;
  }
  resetProperties() {
    this.setProperties({
      loop: false,
      muted: true
    });
  }
  getScalarData() {
    if (this.scalarData?.frameNumber === this.getFrameNumber()) {
      return this.scalarData;
    }
    if (!this.videoElement || !this.videoElement.videoWidth || !this.videoElement.videoHeight) {
      console.debug("Video not ready yet, returning empty scalar data");
      const emptyData = new Uint8ClampedArray;
      emptyData.getRange = () => [0, 255];
      emptyData.frameNumber = -1;
      return emptyData;
    }
    const canvas = document.createElement("canvas");
    canvas.width = this.videoElement.videoWidth;
    canvas.height = this.videoElement.videoHeight;
    const context = canvas.getContext("2d");
    context.drawImage(this.videoElement, 0, 0);
    const canvasData = context.getImageData(0, 0, canvas.width, canvas.height);
    const scalarData = canvasData.data;
    scalarData.getRange = () => [0, 255];
    scalarData.frameNumber = this.getFrameNumber();
    this.scalarData = scalarData;
    return scalarData;
  }
  getImageData() {
    const { metadata } = this;
    const spacing = metadata.spacing;
    const imageData = {
      getDirection: () => metadata.direction,
      getDimensions: () => metadata.dimensions,
      getRange: () => [0, 255],
      getScalarData: () => this.getScalarData(),
      getSpacing: () => metadata.spacing,
      worldToIndex: (point) => {
        const canvasPoint = this.worldToCanvas(point);
        const pixelCoord = this.canvasToIndex(canvasPoint);
        return [pixelCoord[0], pixelCoord[1], 0];
      },
      indexToWorld: (point, destPoint) => {
        const canvasPoint = this.indexToCanvas([point[0], point[1]]);
        return this.canvasToWorld(canvasPoint, destPoint);
      }
    };
    const imageDataForReturn = {
      dimensions: metadata.dimensions,
      spacing,
      origin: metadata.origin,
      direction: metadata.direction,
      metadata: {
        Modality: this.modality,
        FrameOfReferenceUID: metadata.FrameOfReferenceUID
      },
      getScalarData: () => this.getScalarData(),
      scalarData: this.getScalarData(),
      imageData,
      voxelManager: {
        forEach: (callback, options) => {
          return pointInShapeCallback(options.imageData, {
            pointInShapeFn: options.isInObject ?? (() => true),
            callback,
            boundsIJK: options.boundsIJK,
            returnPoints: options.returnPoints ?? false
          });
        }
      },
      hasPixelSpacing: this.hasPixelSpacing,
      calibration: this.calibration,
      preScale: {
        scaled: false
      }
    };
    Object.defineProperty(imageData, "scalarData", {
      get: () => this.getScalarData(),
      enumerable: true
    });
    return imageDataForReturn;
  }
  hasImageURI(imageURI) {
    const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);
    const testURI = framesMatch ? imageURI.substring(0, framesMatch.index) : imageURI;
    return this.imageId.includes(testURI);
  }
  setVOI(voiRange) {
    this.voiRange = voiRange;
    this.setColorTransform();
  }
  setWindowLevel(windowWidth = 256, windowCenter = 128) {
    const lower = windowCenter - windowWidth / 2;
    const upper = windowCenter + windowWidth / 2 - 1;
    this.setVOI({ lower, upper });
    this.setColorTransform();
  }
  setAverageWhite(averageWhite) {
    this.averageWhite = averageWhite;
    this.setColorTransform();
  }
  setColorTransform() {
    if (!this.voiRange && !this.averageWhite) {
      this.feFilter = null;
      return;
    }
    const white = this.averageWhite || [255, 255, 255];
    const maxWhite = Math.max(...white);
    const scaleWhite = white.map((c) => maxWhite / c);
    const { lower = 0, upper = 255 } = this.voiRange || {};
    const wlScale = (upper - lower + 1) / 255;
    const wlDelta = lower / 255;
    this.feFilter = `url('data:image/svg+xml,      <svg xmlns="http://www.w3.org/2000/svg">        <filter id="colour" color-interpolation-filters="linearRGB">        <feColorMatrix type="matrix"         values="          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta}           0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta}           0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta}           0 0 0 1 0" />        </filter>      </svg>#colour')`;
    this.canvas.style.filter = this.feFilter;
  }
  setCamera(camera) {
    const { parallelScale, focalPoint } = camera;
    if (parallelScale) {
      this.videoCamera.parallelScale = this.element.clientHeight / 2 / parallelScale;
    }
    if (focalPoint !== undefined) {
      const focalPointCanvas = this.worldToCanvas(focalPoint);
      const canvasCenter = [
        this.element.clientWidth / 2,
        this.element.clientHeight / 2
      ];
      const panWorldDelta = [
        (focalPointCanvas[0] - canvasCenter[0]) / this.videoCamera.parallelScale,
        (focalPointCanvas[1] - canvasCenter[1]) / this.videoCamera.parallelScale
      ];
      this.videoCamera.panWorld = [
        this.videoCamera.panWorld[0] - panWorldDelta[0],
        this.videoCamera.panWorld[1] - panWorldDelta[1]
      ];
    }
    this.canvasContext.fillStyle = "rgba(0,0,0,1)";
    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
    if (!this.isPlaying) {
      this.renderFrame();
    }
  }
  getCurrentImageId(index2 = this.getCurrentImageIdIndex()) {
    const current = this.imageId.replace("/frames/1", `/frames/${index2 + 1}`);
    return current;
  }
  getViewReferenceId(specifier = {}) {
    const { sliceIndex } = specifier;
    if (sliceIndex === undefined) {
      return `videoId:${this.getCurrentImageId()}`;
    }
    if (Array.isArray(sliceIndex)) {
      return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${sliceIndex[0] + 1}-${sliceIndex[1] + 1}`;
    }
    const baseTarget = this.imageId.replace("/frames/1", `/frames/${1 + sliceIndex}`);
    return `videoId:${baseTarget}`;
  }
  isReferenceViewable(viewRef, options = {}) {
    let { imageURI } = options;
    const { referencedImageId, sliceIndex, multiSliceReference } = viewRef;
    if (!super.isReferenceViewable(viewRef)) {
      return false;
    }
    const imageId = this.getCurrentImageId();
    if (!imageURI) {
      const colonIndex = imageId.indexOf(":");
      imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);
    }
    if (options.withNavigation) {
      return true;
    }
    const currentIndex = this.getSliceIndex();
    if (multiSliceReference) {
      const rangeEndSliceIndex = FrameRange.imageIdToFrameEnd(multiSliceReference.referencedImageId);
      return currentIndex >= sliceIndex && currentIndex <= rangeEndSliceIndex;
    }
    if (sliceIndex !== undefined) {
      return currentIndex === sliceIndex;
    }
    if (!referencedImageId) {
      return false;
    }
    const match = referencedImageId.match(VideoViewport.frameRangeExtractor);
    if (!match) {
      return true;
    }
    if (!match[2]) {
      return true;
    }
    const range = match[2].split("-").map((it) => Number(it));
    const frame = currentIndex + 1;
    return range[0] <= frame && frame <= (range[1] ?? range[0]);
  }
  setViewReference(viewRef) {
    if (typeof viewRef.sliceIndex === "number") {
      this.setFrameNumber(viewRef.sliceIndex + 1);
    } else if (Array.isArray(viewRef.sliceIndex)) {
      this.setFrameRange(viewRef.sliceIndex);
    }
  }
  getViewReference(viewRefSpecifier) {
    const sliceIndex = viewRefSpecifier?.sliceIndex ?? (this.isPlaying ? this.frameRange[0] : this.getCurrentImageIdIndex());
    const rangeEndSliceIndex = viewRefSpecifier?.rangeEndSliceIndex ?? (this.isPlaying ? this.frameRange[1] - 1 : undefined);
    const multiSliceReference = rangeEndSliceIndex > sliceIndex ? {
      sliceIndex: rangeEndSliceIndex,
      referencedImageId: this.getCurrentImageId(rangeEndSliceIndex)
    } : undefined;
    return {
      ...super.getViewReference(viewRefSpecifier),
      referencedImageId: this.getViewReferenceId(viewRefSpecifier),
      sliceIndex,
      multiSliceReference
    };
  }
  getFrameNumber() {
    return 1 + this.getCurrentImageIdIndex();
  }
  getCurrentImageIdIndex() {
    return Math.round(this.videoElement.currentTime * this.fps);
  }
  getSliceIndex() {
    return this.getCurrentImageIdIndex() / this.scrollSpeed;
  }
  getCamera() {
    const { parallelScale } = this.videoCamera;
    const canvasCenter = [
      this.element.clientWidth / 2,
      this.element.clientHeight / 2
    ];
    const canvasCenterWorld = this.canvasToWorld(canvasCenter);
    return {
      parallelProjection: true,
      focalPoint: canvasCenterWorld,
      position: [0, 0, 0],
      viewUp: [0, -1, 0],
      parallelScale: this.element.clientHeight / 2 / parallelScale,
      viewPlaneNormal: [0, 0, 1]
    };
  }
  getFrameRate() {
    return this.fps;
  }
  getPan() {
    const panWorld = this.videoCamera.panWorld;
    return [panWorld[0], panWorld[1]];
  }
  refreshRenderValues() {
    let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;
    if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {
      worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;
    }
    const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);
    const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);
    const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;
    const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;
    const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;
    const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;
    this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];
    this.videoCamera.parallelScale = worldToCanvasRatio;
  }
  getWorldToCanvasRatio() {
    return this.videoCamera.parallelScale;
  }
  getCanvasToWorldRatio() {
    return 1 / this.videoCamera.parallelScale;
  }
  getTransform() {
    const panWorld = this.videoCamera.panWorld;
    const devicePixelRatio2 = window.devicePixelRatio || 1;
    const worldToCanvasRatio = this.getWorldToCanvasRatio();
    const canvasToWorldRatio = this.getCanvasToWorldRatio();
    const halfCanvas = [
      this.canvas.offsetWidth / 2,
      this.canvas.offsetHeight / 2
    ];
    const halfCanvasWorldCoordinates = [
      halfCanvas[0] * canvasToWorldRatio,
      halfCanvas[1] * canvasToWorldRatio
    ];
    const transform = new Transform2;
    transform.scale(devicePixelRatio2, devicePixelRatio2);
    transform.translate(halfCanvas[0], halfCanvas[1]);
    transform.scale(worldToCanvasRatio, worldToCanvasRatio);
    transform.translate(panWorld[0], panWorld[1]);
    transform.translate(-halfCanvasWorldCoordinates[0], -halfCanvasWorldCoordinates[1]);
    return transform;
  }
  updateCameraClippingPlanesAndRange() {
  }
  addImages(stackInputs) {
    const actors = this.getActors();
    stackInputs.forEach((stackInput) => {
      const { imageId, ...rest } = stackInput;
      const image = cache_default.getImage(imageId);
      const imageActor = this.createActorMapper(image);
      const uid = stackInput.actorUID ?? uuidv4();
      if (imageActor) {
        actors.push({ uid, actor: imageActor, referencedId: imageId, ...rest });
        if (stackInput.callback) {
          stackInput.callback({
            imageActor,
            imageId
          });
        }
      }
    });
    this.setActors(actors);
  }
  createActorMapper(image) {
    return new CanvasActor(this, image);
  }
}
var VideoViewport_default = VideoViewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/constants/microscopyViewportCss.js
var microscopyViewportCss = `
.DicomMicroscopyViewer {
  --ol-partial-background-color: rgba(127, 127, 127, 0.7);
  --ol-foreground-color: #000000;
  --ol-subtle-foreground-color: #000;
  --ol-subtle-background-color: rgba(78, 78, 78, 0.5);
}

.DicomMicroscopyViewer .ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.DicomMicroscopyViewer .ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.DicomMicroscopyViewer .ol-scale-bar-inner {
  display: flex;
}

.DicomMicroscopyViewer .ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.DicomMicroscopyViewer .ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.DicomMicroscopyViewer .ol-unsupported {
  display: none;
}

.DicomMicroscopyViewer .ol-viewport,
.DicomMicroscopyViewer .ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.DicomMicroscopyViewer .ol-viewport canvas {
  all: unset;
}

.DicomMicroscopyViewer .ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.DicomMicroscopyViewer .ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.DicomMicroscopyViewer .ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.DicomMicroscopyViewer .ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.DicomMicroscopyViewer .ol-zoom {
  top: 0.5em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-rotate {
  top: 0.5em;
  right: 0.5em;
  transition:
    opacity 0.25s linear,
    visibility 0s linear;
}

.DicomMicroscopyViewer .ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition:
    opacity 0.25s linear,
    visibility 0s linear 0.25s;
}

.DicomMicroscopyViewer .ol-zoom-extent {
  top: 4.643em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-full-screen {
  right: 0.5em;
  top: 0.5em;
}

.DicomMicroscopyViewer .ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: 0.4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.DicomMicroscopyViewer .ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.DicomMicroscopyViewer .ol-zoom-extent button {
  line-height: 1.4em;
}

.DicomMicroscopyViewer .ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.DicomMicroscopyViewer .ol-touch .ol-control button {
  font-size: 1.5em;
}

.DicomMicroscopyViewer .ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-control button:hover,
.DicomMicroscopyViewer .ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.DicomMicroscopyViewer .ol-attribution {
  text-align: right;
  bottom: 0.5em;
  right: 0.5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.DicomMicroscopyViewer .ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.DicomMicroscopyViewer .ol-attribution ul {
  margin: 0;
  padding: 1px 0.5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.DicomMicroscopyViewer .ol-attribution li {
  display: inline;
  list-style: none;
}

.DicomMicroscopyViewer .ol-attribution li:not(:last-child):after {
  content: ' ';
}

.DicomMicroscopyViewer .ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.DicomMicroscopyViewer .ol-attribution button {
  flex-shrink: 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-collapsed ul {
  display: none;
}

.DicomMicroscopyViewer .ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible img {
  margin-top: -0.2em;
  max-height: 1.6em;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-zoomslider {
  top: 4.5em;
  left: 0.5em;
  height: 200px;
}

.DicomMicroscopyViewer .ol-zoomslider button {
  position: relative;
  height: 10px;
}

.DicomMicroscopyViewer .ol-touch .ol-zoomslider {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap button {
  display: block;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.DicomMicroscopyViewer .ol-overviewmap-box {
  border: 0.5px dotted var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}

@layout-header-background: #007ea3;
@primary-color: #007ea3;
@processing-color: #8cb8c6;
@success-color: #3f9c35;
@warning-color: #eeaf30;
@error-color: #96172e;
@font-size-base: 14px;

.DicomMicroscopyViewer .ol-tooltip {
  font-size: 16px !important;
}
`;
var microscopyViewportCss_default = microscopyViewportCss;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js
var _map = Symbol.for("map");
var EVENT_POSTRENDER = "postrender";

class WSIViewport extends Viewport_default {
  constructor(props) {
    super({
      ...props,
      canvas: props.canvas || getOrCreateCanvas(props.element)
    });
    this.internalCamera = {
      rotation: 0,
      centerIndex: [0, 0],
      extent: [0, -2, 1, -1],
      xSpacing: 1,
      ySpacing: 1,
      resolution: 1,
      zoom: 1
    };
    this.voiRange = {
      lower: 0,
      upper: 255
    };
    this.getProperties = () => {
      return {};
    };
    this.resetCamera = () => {
      return true;
    };
    this.getNumberOfSlices = () => {
      return 1;
    };
    this.getFrameOfReferenceUID = () => {
      return this.frameOfReferenceUID;
    };
    this.resize = () => {
      const canvas = this.canvas;
      const { clientWidth, clientHeight } = canvas;
      if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth;
        canvas.height = clientHeight;
      }
      this.refreshRenderValues();
    };
    this.canvasToWorld = (canvasPos) => {
      if (!this.metadata) {
        return;
      }
      const [px, py] = this.canvasToIndex(canvasPos);
      const { origin, spacing, direction } = this.getImageData();
      const worldPos = exports_vec3.fromValues(0, 0, 0);
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      exports_vec3.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
      exports_vec3.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
      return [worldPos[0], worldPos[1], worldPos[2]];
    };
    this.worldToCanvas = (worldPos) => {
      if (!this.metadata) {
        return;
      }
      const { spacing, direction, origin } = this.metadata;
      const iVector = direction.slice(0, 3);
      const jVector = direction.slice(3, 6);
      const diff = exports_vec3.subtract([0, 0, 0], worldPos, origin);
      const indexPoint = [
        exports_vec3.dot(diff, iVector) / spacing[0],
        exports_vec3.dot(diff, jVector) / spacing[1]
      ];
      const canvasPoint = this.indexToCanvas(indexPoint);
      return canvasPoint;
    };
    this.postrender = () => {
      this.refreshRenderValues();
      triggerEvent(this.element, Events_default.IMAGE_RENDERED, {
        element: this.element,
        viewportId: this.id,
        viewport: this,
        renderingEngineId: this.renderingEngineId
      });
    };
    this.getRotation = () => 0;
    this.canvasToIndex = (canvasPos) => {
      const transform = this.getTransform();
      transform.invert();
      return transform.transformPoint(canvasPos);
    };
    this.indexToCanvas = (indexPos) => {
      const transform = this.getTransform();
      return transform.transformPoint(indexPos);
    };
    this.customRenderViewportToCanvas = () => {
    };
    this.getImageIds = () => {
      return [this.imageIds[0]];
    };
    this.renderingEngineId = props.renderingEngineId;
    this.element.setAttribute("data-viewport-uid", this.id);
    this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId);
    this.element.style.position = "relative";
    this.microscopyElement = document.createElement("div");
    this.microscopyElement.setAttribute("class", "DicomMicroscopyViewer");
    this.microscopyElement.id = uuidv4();
    this.microscopyElement.innerText = "Initial";
    this.microscopyElement.style.background = "grey";
    this.microscopyElement.style.width = "100%";
    this.microscopyElement.style.height = "100%";
    this.microscopyElement.style.position = "absolute";
    this.microscopyElement.style.left = "0";
    this.microscopyElement.style.top = "0";
    const cs3dElement = this.element.firstElementChild;
    cs3dElement.insertBefore(this.microscopyElement, cs3dElement.childNodes[1]);
    this.addEventListeners();
    this.addWidget("DicomMicroscopyViewer", {
      getEnabled: () => !!this.viewer,
      setEnabled: () => {
        this.elementDisabledHandler();
      }
    });
    this.resize();
  }
  static get useCustomRenderingPipeline() {
    return true;
  }
  addEventListeners() {
    this.canvas.addEventListener(Events_default.ELEMENT_DISABLED, this.elementDisabledHandler);
  }
  removeEventListeners() {
    this.canvas.removeEventListener(Events_default.ELEMENT_DISABLED, this.elementDisabledHandler);
  }
  elementDisabledHandler() {
    this.removeEventListeners();
    this.viewer?.cleanup();
    this.viewer = null;
    const cs3dElement = this.element.firstElementChild;
    cs3dElement.removeChild(this.microscopyElement);
    this.microscopyElement = null;
  }
  getImageDataMetadata(imageIndex = 0) {
    const maxImage = this.metadataDicomweb.reduce((maxImage2, image) => {
      return maxImage2?.NumberOfFrames < image.NumberOfFrames ? image : maxImage2;
    });
    const { TotalPixelMatrixColumns: columns, TotalPixelMatrixRows: rows, ImageOrientationSlide, ImagedVolumeWidth: width, ImagedVolumeHeight: height, ImagedVolumeDepth: depth } = maxImage;
    const imagePlaneModule = getMetaData(MetadataModules_default.IMAGE_PLANE, this.imageIds[imageIndex]);
    let rowCosines = ImageOrientationSlide.slice(0, 3);
    let columnCosines = ImageOrientationSlide.slice(3, 6);
    if (rowCosines == null || columnCosines == null) {
      rowCosines = [1, 0, 0];
      columnCosines = [0, 1, 0];
    }
    const rowCosineVec = exports_vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = exports_vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
    const scanAxisNormal = exports_vec3.create();
    exports_vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    const { XOffsetInSlideCoordinateSystem = 0, YOffsetInSlideCoordinateSystem = 0, ZOffsetInSlideCoordinateSystem = 0 } = maxImage.TotalPixelMatrixOriginSequence?.[0] || {};
    const origin = [
      XOffsetInSlideCoordinateSystem,
      YOffsetInSlideCoordinateSystem,
      ZOffsetInSlideCoordinateSystem
    ];
    const xSpacing = width / columns;
    const ySpacing = height / rows;
    const xVoxels = columns;
    const yVoxels = rows;
    const zSpacing = depth;
    const zVoxels = 1;
    this.hasPixelSpacing = !!(width && height);
    return {
      bitsAllocated: 8,
      numberOfComponents: 3,
      origin,
      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
      dimensions: [xVoxels, yVoxels, zVoxels],
      spacing: [xSpacing, ySpacing, zSpacing],
      hasPixelSpacing: this.hasPixelSpacing,
      numVoxels: xVoxels * yVoxels * zVoxels,
      imagePlaneModule
    };
  }
  async setFrameNumber(frame) {
  }
  setProperties(props) {
  }
  resetProperties() {
    this.setProperties({});
  }
  getScalarData() {
    return null;
  }
  getImageData() {
    const { metadata } = this;
    if (!metadata) {
      return null;
    }
    const { spacing } = metadata;
    const imageData = {
      getDirection: () => metadata.direction,
      getDimensions: () => metadata.dimensions,
      getRange: () => [0, 255],
      getScalarData: () => this.getScalarData(),
      getSpacing: () => metadata.spacing,
      worldToIndex: (point) => {
        const canvasPoint = this.worldToCanvas(point);
        const pixelCoord = this.canvasToIndex(canvasPoint);
        return [pixelCoord[0], pixelCoord[1], 0];
      },
      indexToWorld: (point) => {
        const canvasPoint = this.indexToCanvas([point[0], point[1]]);
        return this.canvasToWorld(canvasPoint);
      }
    };
    const imageDataReturn = {
      dimensions: metadata.dimensions,
      spacing,
      numberOfComponents: 3,
      origin: metadata.origin,
      direction: metadata.direction,
      metadata: {
        Modality: this.modality,
        FrameOfReferenceUID: this.frameOfReferenceUID
      },
      hasPixelSpacing: this.hasPixelSpacing,
      calibration: this.calibration,
      preScale: {
        scaled: false
      },
      scalarData: this.getScalarData(),
      imageData,
      voxelManager: {
        forEach: (callback, options) => {
          return pointInShapeCallback(options.imageData, {
            pointInShapeFn: options.isInObject ?? (() => true),
            callback,
            boundsIJK: options.boundsIJK,
            returnPoints: options.returnPoints ?? false
          });
        }
      }
    };
    return imageDataReturn;
  }
  hasImageURI(imageURI) {
    return true;
  }
  setCamera(camera) {
    const previousCamera = this.getCamera();
    const { parallelScale, focalPoint } = camera;
    const view = this.getView();
    const { xSpacing } = this.internalCamera;
    if (parallelScale) {
      const worldToCanvasRatio = this.element.clientHeight / parallelScale;
      const resolution = 1 / xSpacing / worldToCanvasRatio;
      view.setResolution(resolution);
    }
    if (focalPoint) {
      const newCanvas = this.worldToCanvas(focalPoint);
      const newIndex = this.canvasToIndex(newCanvas);
      view.setCenter(newIndex);
    }
    const updatedCamera = this.getCamera();
    this.triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera);
  }
  getCurrentImageId() {
    return this.imageIds[0];
  }
  getFrameNumber() {
    return 1;
  }
  getCamera() {
    this.refreshRenderValues();
    const { resolution, xSpacing } = this.internalCamera;
    const canvasToWorldRatio = resolution * xSpacing;
    const canvasCenter = [
      this.element.clientWidth / 2,
      this.element.clientHeight / 2
    ];
    const focalPoint = this.canvasToWorld(canvasCenter);
    return {
      parallelProjection: true,
      focalPoint,
      position: focalPoint,
      viewUp: [0, -1, 0],
      parallelScale: this.element.clientHeight * canvasToWorldRatio,
      viewPlaneNormal: [0, 0, 1]
    };
  }
  static {
    this.getDicomMicroscopyViewer = async () => {
      return peerImport("dicom-microscopy-viewer");
    };
  }
  setDataIds(imageIds, options) {
    if (options?.miniNavigationOverlay !== false) {
      WSIViewport.addMiniNavigationOverlayCss();
    }
    const webClient = options?.webClient || getMetaData(MetadataModules_default.WADO_WEB_CLIENT, imageIds[0]);
    if (!webClient) {
      throw new Error(`To use setDataIds on WSI data, you must provide metaData.webClient for ${imageIds[0]}`);
    }
    return this.setWSI(imageIds, webClient);
  }
  async setWSI(imageIds, client) {
    this.microscopyElement.style.background = "black";
    this.microscopyElement.innerText = "Loading";
    this.imageIds = imageIds;
    const DicomMicroscopyViewer = await WSIViewport.getDicomMicroscopyViewer();
    this.frameOfReferenceUID = null;
    const metadataDicomweb = this.imageIds.map((imageId) => {
      const imageMetadata = client.getDICOMwebMetadata(imageId);
      Object.defineProperty(imageMetadata, "isMultiframe", {
        value: imageMetadata.isMultiframe,
        enumerable: false
      });
      Object.defineProperty(imageMetadata, "frameNumber", {
        value: undefined,
        enumerable: false
      });
      const imageType = imageMetadata["00080008"]?.Value;
      if (imageType?.length === 1) {
        imageMetadata["00080008"].Value = imageType[0].split("\\");
      }
      const frameOfReference = imageMetadata["00200052"]?.Value?.[0];
      if (!this.frameOfReferenceUID) {
        this.frameOfReferenceUID = frameOfReference;
      } else if (frameOfReference !== this.frameOfReferenceUID) {
        imageMetadata["00200052"].Value = [this.frameOfReferenceUID];
      }
      return imageMetadata;
    });
    const volumeImages = [];
    metadataDicomweb.forEach((m) => {
      const image = new DicomMicroscopyViewer.metadata.VLWholeSlideMicroscopyImage({
        metadata: m
      });
      const imageFlavor = image.ImageType[2];
      if (imageFlavor === "VOLUME" || imageFlavor === "THUMBNAIL") {
        volumeImages.push(image);
      } else {
        console.log("Unknown image type", image.ImageType);
      }
    });
    this.metadataDicomweb = volumeImages;
    const viewer = new DicomMicroscopyViewer.viewer.VolumeImageViewer({
      client,
      metadata: volumeImages,
      controls: ["overview", "position"],
      retrieveRendered: false,
      bindings: {}
    });
    viewer.render({ container: this.microscopyElement });
    this.metadata = this.getImageDataMetadata();
    viewer.deactivateDragPanInteraction();
    this.viewer = viewer;
    this.map = viewer[_map];
    this.map.on(EVENT_POSTRENDER, this.postrender);
    this.resize();
    this.microscopyElement.innerText = "";
    Object.assign(this.microscopyElement.style, {
      "--ol-partial-background-color": "rgba(127, 127, 127, 0.7)",
      "--ol-foreground-color": "#000000",
      "--ol-subtle-foreground-color": "#000",
      "--ol-subtle-background-color": "rgba(78, 78, 78, 0.5)",
      background: "none"
    });
  }
  scroll(delta) {
    const camera = this.getCamera();
    this.setCamera({
      parallelScale: camera.parallelScale * (1 + 0.1 * delta)
    });
  }
  getSliceIndex() {
    return 0;
  }
  getView() {
    if (!this.viewer) {
      return;
    }
    const map = this.viewer[_map];
    const anyWindow = window;
    anyWindow.map = map;
    anyWindow.viewer = this.viewer;
    anyWindow.view = map?.getView();
    anyWindow.wsi = this;
    return map?.getView();
  }
  refreshRenderValues() {
    const view = this.getView();
    if (!view) {
      return;
    }
    const resolution = view.getResolution();
    if (!resolution || resolution < epsilon_default) {
      return;
    }
    const centerIndex = view.getCenter();
    const extent = view.getProjection().getExtent();
    const rotation = view.getRotation();
    const zoom = view.getZoom();
    const { metadata: { spacing: [xSpacing, ySpacing] } } = this;
    const worldToCanvasRatio = 1 / resolution / xSpacing;
    Object.assign(this.internalCamera, {
      extent,
      centerIndex,
      worldToCanvasRatio,
      xSpacing,
      ySpacing,
      resolution,
      rotation,
      zoom
    });
  }
  getZoom() {
    return this.getView()?.getZoom();
  }
  setZoom(zoom) {
    this.getView()?.setZoom(zoom);
  }
  getTransform() {
    this.refreshRenderValues();
    const { centerIndex: center, resolution, rotation } = this.internalCamera;
    const halfCanvas = [this.canvas.width / 2, this.canvas.height / 2];
    const transform = new Transform2;
    transform.translate(halfCanvas[0], halfCanvas[1]);
    transform.rotate(rotation);
    transform.scale(1 / resolution, -1 / resolution);
    transform.translate(-center[0], -center[1]);
    return transform;
  }
  getViewReferenceId() {
    return `imageId:${this.getCurrentImageId()}`;
  }
  getCurrentImageIdIndex() {
    return 0;
  }
  static {
    this.overlayCssId = "overlayCss";
  }
  static addMiniNavigationOverlayCss() {
    if (document.getElementById(this.overlayCssId)) {
      return;
    }
    const overlayCss = document.createElement("style");
    overlayCss.innerText = microscopyViewportCss_default;
    overlayCss.setAttribute("id", this.overlayCssId);
    document.getElementsByTagName("head")[0].append(overlayCss);
  }
}
var WSIViewport_default = WSIViewport;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeToViewportClass.js
var viewportTypeToViewportClass = {
  [ViewportType_default.ORTHOGRAPHIC]: VolumeViewport_default,
  [ViewportType_default.PERSPECTIVE]: VolumeViewport_default,
  [ViewportType_default.STACK]: StackViewport_default,
  [ViewportType_default.VOLUME_3D]: VolumeViewport3D_default,
  [ViewportType_default.VIDEO]: VideoViewport_default,
  [ViewportType_default.WHOLE_SLIDE]: WSIViewport_default
};
var viewportTypeToViewportClass_default = viewportTypeToViewportClass;

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeUsesCustomRenderingPipeline.js
function viewportTypeUsesCustomRenderingPipeline(viewportType) {
  return viewportTypeToViewportClass_default[viewportType].useCustomRenderingPipeline;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/RenderingEngine.js
var VIEWPORT_MIN_SIZE = 2;

class RenderingEngine {
  constructor(id) {
    this._needsRender = new Set;
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
    this.renderFrameOfReference = (FrameOfReferenceUID) => {
      const viewports = this._getViewportsAsArray();
      const viewportIdsWithSameFrameOfReferenceUID = viewports.map((vp) => {
        if (vp.getFrameOfReferenceUID() === FrameOfReferenceUID) {
          return vp.id;
        }
      });
      this.renderViewports(viewportIdsWithSameFrameOfReferenceUID);
    };
    this._renderFlaggedViewports = () => {
      this._throwIfDestroyed();
      if (!this.useCPURendering) {
        this.performVtkDrawCall();
      }
      const viewports = this._getViewportsAsArray();
      const eventDetailArray = [];
      for (let i = 0;i < viewports.length; i++) {
        const viewport = viewports[i];
        if (this._needsRender.has(viewport.id)) {
          const eventDetail = this.renderViewportUsingCustomOrVtkPipeline(viewport);
          eventDetailArray.push(eventDetail);
          viewport.setRendered();
          this._needsRender.delete(viewport.id);
          if (this._needsRender.size === 0) {
            break;
          }
        }
      }
      this._animationFrameSet = false;
      this._animationFrameHandle = null;
      eventDetailArray.forEach((eventDetail) => {
        if (!eventDetail?.element) {
          return;
        }
        triggerEvent(eventDetail.element, Events_default.IMAGE_RENDERED, eventDetail);
      });
    };
    this.id = id ? id : uuidv4();
    this.useCPURendering = getShouldUseCPURendering();
    renderingEngineCache_default.set(this);
    if (!isCornerstoneInitialized()) {
      throw new Error("@cornerstonejs/core is not initialized, run init() first");
    }
    if (!this.useCPURendering) {
      this.offscreenMultiRenderWindow = vtkOffscreenMultiRenderWindow_default.newInstance();
      this.offScreenCanvasContainer = document.createElement("div");
      this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer);
    }
    this._viewports = new Map;
    this.hasBeenDestroyed = false;
  }
  enableElement(viewportInputEntry) {
    const viewportInput = this._normalizeViewportInputEntry(viewportInputEntry);
    this._throwIfDestroyed();
    const { element, viewportId } = viewportInput;
    if (!element) {
      throw new Error("No element provided");
    }
    const viewport = this.getViewport(viewportId);
    if (viewport) {
      this.disableElement(viewportId);
    }
    const { type } = viewportInput;
    const viewportUsesCustomRenderingPipeline = viewportTypeUsesCustomRenderingPipeline(type);
    if (!this.useCPURendering && !viewportUsesCustomRenderingPipeline) {
      this.enableVTKjsDrivenViewport(viewportInput);
    } else {
      this.addCustomViewport(viewportInput);
    }
    const canvas = getOrCreateCanvas(element);
    const { background } = viewportInput.defaultOptions;
    this.fillCanvasWithBackgroundColor(canvas, background);
  }
  disableElement(viewportId) {
    this._throwIfDestroyed();
    const viewport = this.getViewport(viewportId);
    if (!viewport) {
      console.warn(`viewport ${viewportId} does not exist`);
      return;
    }
    this._resetViewport(viewport);
    if (!viewportTypeUsesCustomRenderingPipeline(viewport.type) && !this.useCPURendering) {
      this.offscreenMultiRenderWindow.removeRenderer(viewportId);
    }
    this._removeViewport(viewportId);
    viewport.isDisabled = true;
    this._needsRender.delete(viewportId);
    const viewports = this.getViewports();
    if (!viewports.length) {
      this._clearAnimationFrame();
    }
  }
  setViewports(publicViewportInputEntries) {
    const viewportInputEntries = this._normalizeViewportInputEntries(publicViewportInputEntries);
    this._throwIfDestroyed();
    this._reset();
    const vtkDrivenViewportInputEntries = [];
    const customRenderingViewportInputEntries = [];
    viewportInputEntries.forEach((vpie) => {
      if (!this.useCPURendering && !viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
        vtkDrivenViewportInputEntries.push(vpie);
      } else {
        customRenderingViewportInputEntries.push(vpie);
      }
    });
    this.setVtkjsDrivenViewports(vtkDrivenViewportInputEntries);
    this.setCustomViewports(customRenderingViewportInputEntries);
    viewportInputEntries.forEach((vp) => {
      const canvas = getOrCreateCanvas(vp.element);
      const { background } = vp.defaultOptions;
      this.fillCanvasWithBackgroundColor(canvas, background);
    });
  }
  resize(immediate = true, keepCamera = true) {
    this._throwIfDestroyed();
    const viewports = this._getViewportsAsArray();
    const vtkDrivenViewports = [];
    const customRenderingViewports = [];
    viewports.forEach((vpie) => {
      if (!viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
        vtkDrivenViewports.push(vpie);
      } else {
        customRenderingViewports.push(vpie);
      }
    });
    if (vtkDrivenViewports.length) {
      this._resizeVTKViewports(vtkDrivenViewports, keepCamera, immediate);
    }
    if (customRenderingViewports.length) {
      this._resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera, immediate);
    }
  }
  getViewport(viewportId) {
    return this._viewports.get(viewportId);
  }
  getViewports() {
    this._throwIfDestroyed();
    return this._getViewportsAsArray();
  }
  getStackViewport(viewportId) {
    this._throwIfDestroyed();
    const viewport = this.getViewport(viewportId);
    if (!viewport) {
      throw new Error(`Viewport with Id ${viewportId} does not exist`);
    }
    if (!(viewport instanceof StackViewport_default)) {
      throw new Error(`Viewport with Id ${viewportId} is not a StackViewport.`);
    }
    return viewport;
  }
  getStackViewports() {
    this._throwIfDestroyed();
    const viewports = this.getViewports();
    return viewports.filter((vp) => vp instanceof StackViewport_default);
  }
  getVolumeViewports() {
    this._throwIfDestroyed();
    const viewports = this.getViewports();
    const isVolumeViewport = (viewport) => {
      return viewport instanceof BaseVolumeViewport_default;
    };
    return viewports.filter(isVolumeViewport);
  }
  render() {
    const viewports = this.getViewports();
    const viewportIds = viewports.map((vp) => vp.id);
    this._setViewportsToBeRenderedNextFrame(viewportIds);
  }
  renderViewports(viewportIds) {
    this._setViewportsToBeRenderedNextFrame(viewportIds);
  }
  renderViewport(viewportId) {
    this._setViewportsToBeRenderedNextFrame([viewportId]);
  }
  destroy() {
    if (this.hasBeenDestroyed) {
      return;
    }
    if (!this.useCPURendering) {
      const viewports = this._getViewportsAsArray();
      viewports.forEach((vp) => {
        this.offscreenMultiRenderWindow.removeRenderer(vp.id);
      });
      this.offscreenMultiRenderWindow.delete();
      delete this.offscreenMultiRenderWindow;
    }
    this._reset();
    renderingEngineCache_default.delete(this.id);
    this.hasBeenDestroyed = true;
  }
  fillCanvasWithBackgroundColor(canvas, backgroundColor) {
    const ctx = canvas.getContext("2d");
    let fillStyle;
    if (backgroundColor) {
      const rgb = backgroundColor.map((f) => Math.floor(255 * f));
      fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
    } else {
      fillStyle = "black";
    }
    ctx.fillStyle = fillStyle;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  _normalizeViewportInputEntry(viewportInputEntry) {
    const { type, defaultOptions } = viewportInputEntry;
    let options = defaultOptions;
    if (!options || Object.keys(options).length === 0) {
      options = {
        background: [0, 0, 0],
        orientation: null,
        displayArea: null
      };
      if (type === ViewportType_default.ORTHOGRAPHIC) {
        options = {
          ...options,
          orientation: OrientationAxis_default.AXIAL
        };
      }
    }
    return {
      ...viewportInputEntry,
      defaultOptions: options
    };
  }
  _normalizeViewportInputEntries(viewportInputEntries) {
    const normalizedViewportInputs = [];
    viewportInputEntries.forEach((viewportInput) => {
      normalizedViewportInputs.push(this._normalizeViewportInputEntry(viewportInput));
    });
    return normalizedViewportInputs;
  }
  _resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera = true, immediate = true) {
    customRenderingViewports.forEach((vp) => {
      if (typeof vp.resize === "function") {
        vp.resize();
      }
    });
    customRenderingViewports.forEach((vp) => {
      const prevCamera = vp.getCamera();
      vp.resetCamera();
      if (keepCamera) {
        vp.setCamera(prevCamera);
      }
    });
    if (immediate) {
      this.render();
    }
  }
  _resizeVTKViewports(vtkDrivenViewports, keepCamera = true, immediate = true) {
    const canvasesDrivenByVtkJs = vtkDrivenViewports.map((vp) => {
      return getOrCreateCanvas(vp.element);
    });
    canvasesDrivenByVtkJs.forEach((canvas) => {
      const devicePixelRatio2 = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * devicePixelRatio2;
      canvas.height = canvas.clientHeight * devicePixelRatio2;
    });
    if (canvasesDrivenByVtkJs.length) {
      const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
      this._resize(vtkDrivenViewports, offScreenCanvasWidth, offScreenCanvasHeight);
    }
    vtkDrivenViewports.forEach((vp) => {
      const prevCamera = vp.getCamera();
      const rotation = vp.getRotation();
      const { flipHorizontal } = prevCamera;
      vp.resetCameraForResize();
      const displayArea = vp.getDisplayArea();
      if (keepCamera) {
        if (displayArea) {
          if (flipHorizontal) {
            vp.setCamera({ flipHorizontal });
          }
          if (rotation) {
            vp.setViewPresentation({ rotation });
          }
        } else {
          vp.setCamera(prevCamera);
        }
      }
    });
    if (immediate) {
      this.render();
    }
  }
  enableVTKjsDrivenViewport(viewportInputEntry) {
    const viewports = this._getViewportsAsArray();
    const viewportsDrivenByVtkJs = viewports.filter((vp) => viewportTypeUsesCustomRenderingPipeline(vp.type) === false);
    const canvasesDrivenByVtkJs = viewportsDrivenByVtkJs.map((vp) => vp.canvas);
    const canvas = getOrCreateCanvas(viewportInputEntry.element);
    canvasesDrivenByVtkJs.push(canvas);
    const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
    const xOffset = this._resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight);
    const internalViewportEntry = { ...viewportInputEntry, canvas };
    this.addVtkjsDrivenViewport(internalViewportEntry, {
      offScreenCanvasWidth,
      offScreenCanvasHeight,
      xOffset
    });
  }
  _removeViewport(viewportId) {
    const viewport = this.getViewport(viewportId);
    if (!viewport) {
      console.warn(`viewport ${viewportId} does not exist`);
      return;
    }
    this._viewports.delete(viewportId);
  }
  addVtkjsDrivenViewport(viewportInputEntry, offscreenCanvasProperties) {
    const { element, canvas, viewportId, type, defaultOptions } = viewportInputEntry;
    element.tabIndex = -1;
    const { offScreenCanvasWidth, offScreenCanvasHeight, xOffset } = offscreenCanvasProperties;
    const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight } = this._getViewportCoordsOnOffScreenCanvas(viewportInputEntry, offScreenCanvasWidth, offScreenCanvasHeight, xOffset);
    this.offscreenMultiRenderWindow.addRenderer({
      viewport: [
        sxStartDisplayCoords,
        syStartDisplayCoords,
        sxEndDisplayCoords,
        syEndDisplayCoords
      ],
      id: viewportId,
      background: defaultOptions.background ? defaultOptions.background : [0, 0, 0]
    });
    const viewportInput = {
      id: viewportId,
      element,
      renderingEngineId: this.id,
      type,
      canvas,
      sx,
      sy,
      sWidth,
      sHeight,
      defaultOptions: defaultOptions || {}
    };
    let viewport;
    if (type === ViewportType_default.STACK) {
      viewport = new StackViewport_default(viewportInput);
    } else if (type === ViewportType_default.ORTHOGRAPHIC || type === ViewportType_default.PERSPECTIVE) {
      viewport = new VolumeViewport_default(viewportInput);
    } else if (type === ViewportType_default.VOLUME_3D) {
      viewport = new VolumeViewport3D_default(viewportInput);
    } else {
      throw new Error(`Viewport Type ${type} is not supported`);
    }
    this._viewports.set(viewportId, viewport);
    const eventDetail = {
      element,
      viewportId,
      renderingEngineId: this.id
    };
    if (!viewport.suppressEvents) {
      triggerEvent(eventTarget_default, Events_default.ELEMENT_ENABLED, eventDetail);
    }
  }
  addCustomViewport(viewportInputEntry) {
    const { element, viewportId, type, defaultOptions } = viewportInputEntry;
    element.tabIndex = -1;
    const canvas = getOrCreateCanvas(element);
    const { clientWidth, clientHeight } = canvas;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
      canvas.width = clientWidth;
      canvas.height = clientHeight;
    }
    const viewportInput = {
      id: viewportId,
      renderingEngineId: this.id,
      element,
      type,
      canvas,
      sx: 0,
      sy: 0,
      sWidth: clientWidth,
      sHeight: clientHeight,
      defaultOptions: defaultOptions || {}
    };
    const ViewportType2 = viewportTypeToViewportClass_default[type];
    const viewport = new ViewportType2(viewportInput);
    this._viewports.set(viewportId, viewport);
    const eventDetail = {
      element,
      viewportId,
      renderingEngineId: this.id
    };
    triggerEvent(eventTarget_default, Events_default.ELEMENT_ENABLED, eventDetail);
  }
  setCustomViewports(viewportInputEntries) {
    viewportInputEntries.forEach((vpie) => {
      this.addCustomViewport(vpie);
    });
  }
  setVtkjsDrivenViewports(viewportInputEntries) {
    if (viewportInputEntries.length) {
      const vtkDrivenCanvases = viewportInputEntries.map((vp) => getOrCreateCanvas(vp.element));
      vtkDrivenCanvases.forEach((canvas) => {
        const devicePixelRatio2 = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * devicePixelRatio2;
        canvas.height = rect.height * devicePixelRatio2;
      });
      const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(vtkDrivenCanvases);
      let xOffset = 0;
      for (let i = 0;i < viewportInputEntries.length; i++) {
        const vtkDrivenViewportInputEntry = viewportInputEntries[i];
        const canvas = vtkDrivenCanvases[i];
        const internalViewportEntry = {
          ...vtkDrivenViewportInputEntry,
          canvas
        };
        this.addVtkjsDrivenViewport(internalViewportEntry, {
          offScreenCanvasWidth,
          offScreenCanvasHeight,
          xOffset
        });
        xOffset += canvas.width;
      }
    }
  }
  _resizeOffScreenCanvas(canvasesDrivenByVtkJs) {
    const { offScreenCanvasContainer, offscreenMultiRenderWindow } = this;
    const offScreenCanvasHeight = Math.max(...canvasesDrivenByVtkJs.map((canvas) => canvas.height));
    let offScreenCanvasWidth = 0;
    canvasesDrivenByVtkJs.forEach((canvas) => {
      offScreenCanvasWidth += canvas.width;
    });
    offScreenCanvasContainer.width = offScreenCanvasWidth;
    offScreenCanvasContainer.height = offScreenCanvasHeight;
    offscreenMultiRenderWindow.resize();
    return { offScreenCanvasWidth, offScreenCanvasHeight };
  }
  _resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight) {
    let _xOffset = 0;
    for (let i = 0;i < viewportsDrivenByVtkJs.length; i++) {
      const viewport = viewportsDrivenByVtkJs[i];
      const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight } = this._getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset);
      _xOffset += viewport.canvas.width;
      viewport.sx = sx;
      viewport.sy = sy;
      viewport.sWidth = sWidth;
      viewport.sHeight = sHeight;
      const renderer = this.offscreenMultiRenderWindow.getRenderer(viewport.id);
      renderer.setViewport([
        sxStartDisplayCoords,
        syStartDisplayCoords,
        sxEndDisplayCoords,
        syEndDisplayCoords
      ]);
    }
    return _xOffset;
  }
  _getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset) {
    const { canvas } = viewport;
    const { width: sWidth, height: sHeight } = canvas;
    const sx = _xOffset;
    const sy = 0;
    const sxStartDisplayCoords = sx / offScreenCanvasWidth;
    const syStartDisplayCoords = sy + (offScreenCanvasHeight - sHeight) / offScreenCanvasHeight;
    const sWidthDisplayCoords = sWidth / offScreenCanvasWidth;
    const sHeightDisplayCoords = sHeight / offScreenCanvasHeight;
    return {
      sxStartDisplayCoords,
      syStartDisplayCoords,
      sxEndDisplayCoords: sxStartDisplayCoords + sWidthDisplayCoords,
      syEndDisplayCoords: syStartDisplayCoords + sHeightDisplayCoords,
      sx,
      sy,
      sWidth,
      sHeight
    };
  }
  _getViewportsAsArray() {
    return Array.from(this._viewports.values());
  }
  _setViewportsToBeRenderedNextFrame(viewportIds) {
    viewportIds.forEach((viewportId) => {
      this._needsRender.add(viewportId);
    });
    this._render();
  }
  _render() {
    if (this._needsRender.size > 0 && !this._animationFrameSet) {
      this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
      this._animationFrameSet = true;
    }
  }
  performVtkDrawCall() {
    const { offscreenMultiRenderWindow } = this;
    const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
    const renderers = offscreenMultiRenderWindow.getRenderers();
    if (!renderers.length) {
      return;
    }
    for (let i = 0;i < renderers.length; i++) {
      const { renderer, id } = renderers[i];
      if (this._needsRender.has(id)) {
        renderer.setDraw(true);
      } else {
        renderer.setDraw(false);
      }
    }
    renderWindow.render();
    for (let i = 0;i < renderers.length; i++) {
      renderers[i].renderer.setDraw(false);
    }
  }
  renderViewportUsingCustomOrVtkPipeline(viewport) {
    let eventDetail;
    if (viewport.sWidth < VIEWPORT_MIN_SIZE || viewport.sHeight < VIEWPORT_MIN_SIZE) {
      console.warn("Viewport is too small", viewport.sWidth, viewport.sHeight);
      return;
    }
    if (viewportTypeUsesCustomRenderingPipeline(viewport.type) === true) {
      eventDetail = viewport.customRenderViewportToCanvas();
    } else {
      if (this.useCPURendering) {
        throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
      }
      const { offscreenMultiRenderWindow } = this;
      const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
      const context = openGLRenderWindow.get3DContext();
      const offScreenCanvas = context.canvas;
      eventDetail = this._renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas);
    }
    return eventDetail;
  }
  _renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas) {
    const { element, canvas, sx, sy, sWidth, sHeight, id: viewportId, renderingEngineId, suppressEvents } = viewport;
    const { width: dWidth, height: dHeight } = canvas;
    const onScreenContext = canvas.getContext("2d");
    onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
    return {
      element,
      suppressEvents,
      viewportId,
      renderingEngineId,
      viewportStatus: viewport.viewportStatus
    };
  }
  _resetViewport(viewport) {
    const renderingEngineId = this.id;
    const { element, canvas, id: viewportId } = viewport;
    const eventDetail = {
      element,
      viewportId,
      renderingEngineId
    };
    viewport.removeWidgets();
    triggerEvent(eventTarget_default, Events_default.ELEMENT_DISABLED, eventDetail);
    element.removeAttribute("data-viewport-uid");
    element.removeAttribute("data-rendering-engine-uid");
    const context = canvas.getContext("2d");
    context.clearRect(0, 0, canvas.width, canvas.height);
  }
  _clearAnimationFrame() {
    window.cancelAnimationFrame(this._animationFrameHandle);
    this._needsRender.clear();
    this._animationFrameSet = false;
    this._animationFrameHandle = null;
  }
  _reset() {
    const viewports = this._getViewportsAsArray();
    viewports.forEach((viewport) => {
      this._resetViewport(viewport);
    });
    this._clearAnimationFrame();
    this._viewports = new Map;
  }
  _throwIfDestroyed() {
    if (this.hasBeenDestroyed) {
      throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
    }
  }
  _downloadOffScreenCanvas() {
    const dataURL = this._debugRender();
    _TEMPDownloadURI(dataURL);
  }
  _debugRender() {
    const { offscreenMultiRenderWindow } = this;
    const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
    const renderers = offscreenMultiRenderWindow.getRenderers();
    for (let i = 0;i < renderers.length; i++) {
      renderers[i].renderer.setDraw(true);
    }
    renderWindow.render();
    const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
    const context = openGLRenderWindow.get3DContext();
    const offScreenCanvas = context.canvas;
    const dataURL = offScreenCanvas.toDataURL();
    this._getViewportsAsArray().forEach((viewport) => {
      const { sx, sy, sWidth, sHeight } = viewport;
      const canvas = viewport.canvas;
      const { width: dWidth, height: dHeight } = canvas;
      const onScreenContext = canvas.getContext("2d");
      onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
    });
    return dataURL;
  }
}
var RenderingEngine_default = RenderingEngine;
function _TEMPDownloadURI(uri) {
  const link = document.createElement("a");
  link.download = "viewport.png";
  link.href = uri;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/index.js
var RenderingEngine_default2 = RenderingEngine_default;

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Surface.js
class Surface {
  constructor(props) {
    this._color = [200, 0, 0];
    this.id = props.id;
    this._points = props.points;
    this._polys = props.polys;
    this._color = props.color ?? this._color;
    this.frameOfReferenceUID = props.frameOfReferenceUID;
    this._segmentIndex = props.segmentIndex;
    this.sizeInBytes = this._getSizeInBytes();
    this._updateCentroid();
    this._visible = true;
  }
  _getSizeInBytes() {
    return this._points.length * 4 + this._polys.length * 4;
  }
  _updateCentroid() {
    const numberOfPoints = this._points.length / 3;
    let sumX = 0, sumY = 0, sumZ = 0;
    for (let i = 0;i < this._points.length; i += 3) {
      sumX += this._points[i];
      sumY += this._points[i + 1];
      sumZ += this._points[i + 2];
    }
    this._centroid = [
      sumX / numberOfPoints,
      sumY / numberOfPoints,
      sumZ / numberOfPoints
    ];
  }
  get color() {
    return this._color;
  }
  set color(color) {
    this._color = color;
  }
  get points() {
    return this._points;
  }
  set points(points) {
    this._points = points;
    this._updateCentroid();
  }
  get polys() {
    return this._polys;
  }
  set polys(polys) {
    this._polys = polys;
  }
  get segmentIndex() {
    return this._segmentIndex;
  }
  get visible() {
    return this._visible;
  }
  set visible(visible) {
    this._visible = visible;
  }
  get centroid() {
    return this._centroid;
  }
  get flatPointsArray() {
    return this._points;
  }
  get totalNumberOfPoints() {
    return this._points.length / 3;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js
var exports_utilities = {};
__export(exports_utilities, {
  worldToImageCoords: () => worldToImageCoords_default,
  windowLevel: () => exports_windowLevel,
  uuidv4: () => uuidv4,
  updateVTKImageDataWithCornerstoneImage: () => updateVTKImageDataWithCornerstoneImage,
  triggerEvent: () => triggerEvent,
  transformWorldToIndexContinuous: () => transformWorldToIndexContinuous,
  transformWorldToIndex: () => transformWorldToIndex,
  transformIndexToWorld: () => transformIndexToWorld,
  transferFunctionUtils: () => exports_transferFunctionUtils,
  splitImageIdsBy4DTags: () => splitImageIdsBy4DTags_default,
  spatialRegistrationMetadataProvider: () => spatialRegistrationMetadataProvider_default,
  sortImageIdsAndGetSpacing: () => sortImageIdsAndGetSpacing,
  snapFocalPointToSlice: () => snapFocalPointToSlice,
  scroll: () => scroll,
  scaleRgbTransferFunction: () => scaleRGBTransferFunction,
  scaleArray: () => scaleArray,
  roundToPrecision: () => roundToPrecision,
  roundNumber: () => roundNumber_default,
  renderToCanvasGPU: () => renderToCanvasGPU,
  renderToCanvasCPU: () => renderToCanvasCPU,
  pointInShapeCallback: () => pointInShapeCallback,
  planar: () => exports_planar,
  makeVolumeMetadata: () => makeVolumeMetadata,
  loadImageToCanvas: () => loadImageToCanvas,
  jumpToSlice: () => jumpToSlice,
  isVideoTransferSyntax: () => isVideoTransferSyntax,
  isValidVolume: () => isValidVolume,
  isPTPrescaledWithSUV: () => isPTPrescaledWithSUV_default,
  isOpposite: () => isOpposite,
  isImageActor: () => isImageActor,
  isEqualNegative: () => isEqualNegative,
  isEqualAbs: () => isEqualAbs,
  isEqual: () => isEqual,
  invertRgbTransferFunction: () => invertRgbTransferFunction,
  indexWithinDimensions: () => indexWithinDimensions,
  imageToWorldCoords: () => imageToWorldCoords,
  imageRetrieveMetadataProvider: () => imageRetrieveMetadataProvider_default,
  imageIdToURI: () => imageIdToURI,
  hasNaNValues: () => hasNaNValues,
  hasFloatScalingParameters: () => hasFloatScalingParameters,
  getVolumeViewportsContainingSameVolumes: () => getVolumeViewportsContainingSameVolumes_default,
  getVolumeViewportScrollInfo: () => getVolumeViewportScrollInfo_default,
  getVolumeSliceRangeInfo: () => getVolumeSliceRangeInfo_default,
  getVolumeId: () => getVolumeId,
  getVolumeDirectionVectors: () => getVolumeDirectionVectors,
  getVolumeActorCorners: () => getVolumeActorCorners,
  getVoiFromSigmoidRGBTransferFunction: () => getVoiFromSigmoidRGBTransferFunction,
  getViewportsWithVolumeId: () => getViewportsWithVolumeId_default,
  getViewportsWithImageURI: () => getViewportsWithImageURI,
  getViewportModality: () => getViewportModality,
  getViewportImageIds: () => getViewportImageIds_default,
  getViewportImageCornersInWorld: () => getViewportImageCornersInWorld,
  getTargetVolumeAndSpacingInNormalDir: () => getTargetVolumeAndSpacingInNormalDir,
  getSpacingInNormalDirection: () => getSpacingInNormalDirection,
  getSliceRange: () => getSliceRange,
  getScalingParameters: () => getScalingParameters,
  getRuntimeId: () => getRuntimeId,
  getRandomSampleFromArray: () => getRandomSampleFromArray,
  getMinMax: () => getMinMax,
  getImageSliceDataForVolumeViewport: () => getImageSliceDataForVolumeViewport_default,
  getImageLegacy: () => getImageLegacy_default,
  getDynamicVolumeInfo: () => getDynamicVolumeInfo_default,
  getCurrentVolumeViewportSlice: () => getCurrentVolumeViewportSlice,
  getClosestStackImageIndexForPoint: () => getClosestStackImageIndexForPoint,
  getClosestImageId: () => getClosestImageId,
  getBufferConfiguration: () => getBufferConfiguration,
  genericMetadataProvider: () => genericMetadataProvider_default,
  generateVolumePropsFromImageIds: () => generateVolumePropsFromImageIds,
  fnv1aHash: () => fnv1aHash,
  eventListener: () => exports_eventListener,
  deepMerge: () => deepMerge_default,
  deepEqual: () => deepEqual,
  deepClone: () => deepClone,
  decimate: () => decimate,
  createSubVolume: () => createSubVolume,
  createSigmoidRGBTransferFunction: () => createSigmoidRGBTransferFunction,
  createLinearRGBTransferFunction: () => createLinearRGBTransferFunction,
  convertVolumeToStackViewport: () => convertVolumeToStackViewport,
  convertToGrayscale: () => convertToGrayscale,
  convertStackToVolumeViewport: () => convertStackToVolumeViewport,
  colormap: () => exports_colormap,
  color: () => exports_color,
  clip: () => clip_default,
  clamp: () => clamp,
  calibratedPixelSpacingMetadataProvider: () => calibratedPixelSpacingMetadataProvider_default,
  calculateViewportsSpatialRegistration: () => calculateViewportsSpatialRegistration_default,
  calculateSpacingBetweenImageIds: () => calculateSpacingBetweenImageIds,
  autoLoad: () => autoLoad_default,
  applyPreset: () => applyPreset,
  actorIsA: () => actorIsA,
  VoxelManager: () => VoxelManager,
  RLEVoxelMap: () => RLEVoxelMap,
  ProgressiveIterator: () => ProgressiveIterator,
  PointsManager: () => PointsManager,
  HistoryMemo: () => exports_historyMemo,
  FrameRange: () => FrameRange
});

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/index.js
var exports_eventListener = {};
__export(exports_eventListener, {
  TargetEventListeners: () => TargetEventListeners,
  MultiTargetEventListenerManager: () => MultiTargetEventListenerManager
});

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js
var EventListenerPhases;
(function(EventListenerPhases2) {
  EventListenerPhases2[EventListenerPhases2["None"] = 0] = "None";
  EventListenerPhases2[EventListenerPhases2["Capture"] = 1] = "Capture";
  EventListenerPhases2[EventListenerPhases2["Bubble"] = 2] = "Bubble";
})(EventListenerPhases || (EventListenerPhases = {}));

class TargetEventListeners {
  constructor(target) {
    this._eventListeners = new Map;
    this._children = new Map;
    this._target = target;
  }
  get isEmpty() {
    return this._eventListeners.size === 0 && this._children.size === 0;
  }
  addEventListener(type, callback, options) {
    const dotIndex = type.indexOf(".");
    const isNamespace = dotIndex !== -1;
    if (isNamespace) {
      const namespaceToken = type.substring(0, dotIndex);
      let childElementEventListener = this._children.get(namespaceToken);
      if (!childElementEventListener) {
        childElementEventListener = new TargetEventListeners(this._target);
        this._children.set(namespaceToken, childElementEventListener);
      }
      type = type.substring(dotIndex + 1);
      childElementEventListener.addEventListener(type, callback, options);
    } else {
      this._addEventListener(type, callback, options);
    }
  }
  removeEventListener(type, callback, options) {
    const dotIndex = type.indexOf(".");
    const isNamespace = dotIndex !== -1;
    if (isNamespace) {
      const namespaceToken = type.substring(0, dotIndex);
      const childElementEventListener = this._children.get(namespaceToken);
      if (!childElementEventListener) {
        return;
      }
      type = type.substring(dotIndex + 1);
      childElementEventListener.removeEventListener(type, callback, options);
      if (childElementEventListener.isEmpty) {
        this._children.delete(namespaceToken);
      }
    } else {
      this._removeEventListener(type, callback, options);
    }
  }
  reset() {
    Array.from(this._children.entries()).forEach(([namespace, child]) => {
      child.reset();
      if (child.isEmpty) {
        this._children.delete(namespace);
      } else {
        throw new Error("Child is not empty and cannot be removed");
      }
    });
    this._unregisterAllEvents();
  }
  _addEventListener(type, callback, options) {
    let listenersMap = this._eventListeners.get(type);
    if (!listenersMap) {
      listenersMap = new Map;
      this._eventListeners.set(type, listenersMap);
    }
    const useCapture = options?.capture ?? false;
    const listenerPhase = useCapture ? EventListenerPhases.Capture : EventListenerPhases.Bubble;
    const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;
    if (registeredPhases & listenerPhase) {
      console.warn("A listener is already registered for this phase");
      return;
    }
    listenersMap.set(callback, registeredPhases | listenerPhase);
    this._target.addEventListener(type, callback, options);
  }
  _removeEventListener(type, callback, options) {
    const useCapture = options?.capture ?? false;
    const listenerPhase = useCapture ? EventListenerPhases.Capture : EventListenerPhases.Bubble;
    const listenersMap = this._eventListeners.get(type);
    if (!listenersMap) {
      return;
    }
    const callbacks = callback ? [callback] : Array.from(listenersMap.keys());
    callbacks.forEach((callbackItem) => {
      const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;
      const phaseRegistered = !!(registeredPhases & listenerPhase);
      if (!phaseRegistered) {
        return;
      }
      this._target.removeEventListener(type, callbackItem, options);
      const newListenerPhase = registeredPhases ^ listenerPhase;
      if (newListenerPhase === EventListenerPhases.None) {
        listenersMap.delete(callbackItem);
      } else {
        listenersMap.set(callbackItem, newListenerPhase);
      }
    });
    if (!listenersMap.size) {
      this._eventListeners.delete(type);
    }
  }
  _unregisterAllListeners(type, listenersMap) {
    Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {
      const startPhase = EventListenerPhases.Capture;
      for (let currentPhase = startPhase;eventPhases; currentPhase <<= 1) {
        if (!(eventPhases & currentPhase)) {
          continue;
        }
        const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;
        this.removeEventListener(type, listener, { capture: useCapture });
        eventPhases ^= currentPhase;
      }
    });
  }
  _unregisterAllEvents() {
    Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {
      this._unregisterAllListeners(type, listenersMap);
    });
  }
}
// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js
class MultiTargetEventListenerManager {
  constructor() {
    this._targetsEventListeners = new Map;
  }
  addEventListener(target, type, callback, options) {
    let eventListeners = this._targetsEventListeners.get(target);
    if (!eventListeners) {
      eventListeners = new TargetEventListeners(target);
      this._targetsEventListeners.set(target, eventListeners);
    }
    eventListeners.addEventListener(type, callback, options);
  }
  removeEventListener(target, type, callback, options) {
    const eventListeners = this._targetsEventListeners.get(target);
    if (!eventListeners) {
      return;
    }
    eventListeners.removeEventListener(type, callback, options);
    if (eventListeners.isEmpty) {
      this._targetsEventListeners.delete(target);
    }
  }
  reset() {
    Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {
      targetEventListeners.reset();
      this._targetsEventListeners.delete(target);
    });
  }
}
// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js
function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {
  const size = rgbTransferFunction.getSize();
  for (let index2 = 0;index2 < size; index2++) {
    const nodeValue1 = [];
    rgbTransferFunction.getNodeValue(index2, nodeValue1);
    nodeValue1[1] = nodeValue1[1] * scalingFactor;
    nodeValue1[2] = nodeValue1[2] * scalingFactor;
    nodeValue1[3] = nodeValue1[3] * scalingFactor;
    rgbTransferFunction.setNodeValue(index2, nodeValue1);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js
function getMinMax(storedPixelData) {
  let min5 = storedPixelData[0];
  let max5 = storedPixelData[0];
  let storedPixel;
  const numPixels = storedPixelData.length;
  for (let index2 = 1;index2 < numPixels; index2++) {
    storedPixel = storedPixelData[index2];
    min5 = Math.min(min5, storedPixel);
    max5 = Math.max(max5, storedPixel);
  }
  return {
    min: min5,
    max: max5
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js
var LAST_RUNTIME_ID = Symbol("LastRuntimeId");
var GLOBAL_CONTEXT = {};
var DEFAULT_MAX = 4294967295;
var DEFAULT_SEPARATOR = "-";
function getRuntimeId(context, separator, max5) {
  return getNextRuntimeId(context !== null && typeof context === "object" ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max5 === "number" && max5 > 0 ? max5 : DEFAULT_MAX) >>> 0).join(typeof separator === "string" ? separator : DEFAULT_SEPARATOR);
}
function getNextRuntimeId(context, symbol, max5) {
  let idComponents = context[symbol];
  if (!(idComponents instanceof Array)) {
    idComponents = [0];
    Object.defineProperty(context, symbol, { value: idComponents });
  }
  for (let carry = true, i = 0;carry && i < idComponents.length; ++i) {
    let n = idComponents[i] | 0;
    if (n < max5) {
      carry = false;
      n = n + 1;
    } else {
      n = 0;
      if (i + 1 === idComponents.length) {
        idComponents.push(0);
      }
    }
    idComponents[i] = n;
  }
  return idComponents;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js
var state4 = {};
var metadataProvider2 = {
  add: (imageId, payload) => {
    const imageURI = imageIdToURI(imageId);
    state4[imageURI] = payload;
  },
  get: (type, imageId) => {
    if (type === "calibratedPixelSpacing") {
      const imageURI = imageIdToURI(imageId);
      return state4[imageURI];
    }
  }
};
var calibratedPixelSpacingMetadataProvider_default = metadataProvider2;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js
function isOpposite(v1, v2, tolerance = 0.00001) {
  return Math.abs(v1[0] + v2[0]) < tolerance && Math.abs(v1[1] + v2[1]) < tolerance && Math.abs(v1[2] + v2[2]) < tolerance;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js
function indexWithinDimensions(index2, dimensions) {
  if (index2[0] < 0 || index2[0] >= dimensions[0] || index2[1] < 0 || index2[1] >= dimensions[1] || index2[2] < 0 || index2[2] >= dimensions[2]) {
    return false;
  }
  return true;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js
function getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {
  let renderingEngines;
  if (renderingEngineId) {
    renderingEngines = [getRenderingEngine(renderingEngineId)];
  } else {
    renderingEngines = getRenderingEngines();
  }
  const sameVolumesViewports = [];
  renderingEngines.forEach((renderingEngine) => {
    const targetActors = targetViewport.getActors();
    const viewports = renderingEngine.getVolumeViewports();
    for (const vp of viewports) {
      const vpActors = vp.getActors();
      if (vpActors.length !== targetActors.length) {
        continue;
      }
      const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));
      if (sameVolumes) {
        sameVolumesViewports.push(vp);
      }
    }
  });
  return sameVolumesViewports;
}
var getVolumeViewportsContainingSameVolumes_default = getVolumeViewportsContainingSameVolumes;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js
var isPTPrescaledWithSUV = (image) => {
  return image.preScale.scaled && image.preScale.scalingParameters.suvbw;
};
var isPTPrescaledWithSUV_default = isPTPrescaledWithSUV;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js
function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = "_thumbnails", viewportOptions = {
  displayArea: { imageArea: [1, 1] }
}) {
  if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
    throw new Error("canvas element is required");
  }
  const isVolume = !imageOrVolume.imageId;
  const image = !isVolume && imageOrVolume;
  const volume = isVolume && imageOrVolume;
  const imageIdToPrint = image.imageId || volume.volumeId;
  const viewportId = `renderGPUViewport-${imageIdToPrint}`;
  const element = document.createElement("div");
  const devicePixelRatio2 = window.devicePixelRatio || 1;
  if (!viewportOptions.displayArea) {
    viewportOptions.displayArea = { imageArea: [1, 1] };
  }
  const originalWidth = canvas.width;
  const originalHeight = canvas.height;
  element.style.width = `${originalWidth / devicePixelRatio2 + EPSILON7}px`;
  element.style.height = `${originalHeight / devicePixelRatio2 + EPSILON7}px`;
  element.style.visibility = "hidden";
  element.style.position = "absolute";
  document.body.appendChild(element);
  const uniqueId = viewportId.split(":").join("-");
  element.setAttribute("viewport-id-for-remove", uniqueId);
  const temporaryCanvas = getOrCreateCanvas(element);
  const renderingEngine = getRenderingEngine(renderingEngineId) || new RenderingEngine_default2(renderingEngineId);
  let viewport = renderingEngine.getViewport(viewportId);
  if (!viewport) {
    const viewportInput = {
      viewportId,
      type: isVolume ? ViewportType_default.ORTHOGRAPHIC : ViewportType_default.STACK,
      element,
      defaultOptions: {
        ...viewportOptions,
        suppressEvents: true
      }
    };
    renderingEngine.enableElement(viewportInput);
    viewport = renderingEngine.getViewport(viewportId);
  }
  return new Promise((resolve) => {
    let elementRendered = false;
    let { viewReference } = viewportOptions;
    const onImageRendered = (eventDetail) => {
      if (elementRendered) {
        return;
      }
      if (viewReference) {
        const useViewRef = viewReference;
        viewReference = null;
        viewport.setViewReference(useViewRef);
        viewport.render();
        return;
      }
      const context = canvas.getContext("2d");
      context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);
      const origin = viewport.canvasToWorld([0, 0]);
      const topRight = viewport.canvasToWorld([
        temporaryCanvas.width / devicePixelRatio2,
        0
      ]);
      const bottomLeft = viewport.canvasToWorld([
        0,
        temporaryCanvas.height / devicePixelRatio2
      ]);
      const thicknessMm = 1;
      elementRendered = true;
      element.removeEventListener(Events_default.IMAGE_RENDERED, onImageRendered);
      setTimeout(() => {
        renderingEngine.disableElement(viewportId);
        const elements = document.querySelectorAll(`[viewport-id-for-remove="${uniqueId}"]`);
        elements.forEach((element2) => {
          element2.remove();
        });
      }, 0);
      resolve({
        origin,
        bottomLeft,
        topRight,
        thicknessMm
      });
    };
    element.addEventListener(Events_default.IMAGE_RENDERED, onImageRendered);
    if (isVolume) {
      viewport.setVolumes([volume], false, true);
    } else {
      viewport.renderImageObject(imageOrVolume);
    }
    viewport.resetCamera();
    if (modality === "PT" && !isPTPrescaledWithSUV_default(image)) {
      viewport.setProperties({
        voiRange: {
          lower: image.minPixelValue,
          upper: image.maxPixelValue
        }
      });
    }
    viewport.render();
  });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js
function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {
  const volume = imageOrVolume;
  if (volume.volumeId) {
    throw new Error("Unsupported volume rendering for CPU");
  }
  const image = imageOrVolume;
  const viewport = getDefaultViewport_default(canvas, image, modality);
  const enabledElement = {
    canvas,
    viewport,
    image,
    renderingTools: {}
  };
  enabledElement.transform = calculateTransform_default(enabledElement);
  const invalidated = true;
  return new Promise((resolve, reject) => {
    drawImageSync_default(enabledElement, invalidated);
    resolve(null);
  });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js
function loadImageToCanvas(options) {
  const { canvas, imageId, viewReference, requestType = RequestType_default.Thumbnail, priority = -5, renderingEngineId = "_thumbnails", useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions } = options;
  const volumeId = viewReference?.volumeId;
  const isVolume = volumeId && !imageId;
  const viewportOptions = viewReference && baseViewportOptions ? { ...baseViewportOptions, viewReference } : baseViewportOptions;
  const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;
  return new Promise((resolve, reject) => {
    function successCallback(imageOrVolume, imageId2) {
      const { modality } = getMetaData("generalSeriesModule", imageId2) || {};
      const image = !isVolume && imageOrVolume;
      const volume = isVolume && imageOrVolume;
      if (image) {
        image.isPreScaled = image.isPreScaled || image.preScale?.scaled;
      }
      if (thumbnail) {
        canvas.height = 256;
        canvas.width = 256;
      }
      if (imageAspect && image) {
        canvas.width = image && canvas.height * image.width / image.height;
      }
      canvas.style.width = `${canvas.width / devicePixelRatio}px`;
      canvas.style.height = `${canvas.height / devicePixelRatio}px`;
      if (volume && useCPURendering) {
        reject(new Error("CPU rendering of volume not supported"));
      }
      renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);
    }
    function errorCallback(error, imageId2) {
      console.error(error, imageId2);
      reject(error);
    }
    function sendRequest(imageId2, imageIdIndex, options3) {
      return loadAndCacheImage(imageId2, options3).then((image) => {
        successCallback.call(this, image, imageId2);
      }, (error) => {
        errorCallback.call(this, error, imageId2);
      });
    }
    const options2 = {
      useRGBA: !!useCPURendering,
      requestType
    };
    if (volumeId) {
      const volume = cache_default.getVolume(volumeId);
      if (!volume) {
        reject(new Error(`Volume id ${volumeId} not found in cache`));
      }
      const useImageId = volume.imageIds[0];
      successCallback(volume, useImageId);
    } else {
      imageLoadPoolManager_default.addRequest(sendRequest.bind(null, imageId, null, options2), requestType, { imageId }, priority);
    }
  });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js
var exports_historyMemo = {};
__export(exports_historyMemo, {
  HistoryMemo: () => HistoryMemo,
  DefaultHistoryMemo: () => DefaultHistoryMemo
});

class HistoryMemo {
  constructor(label = "Tools", size = 50) {
    this.position = -1;
    this.redoAvailable = 0;
    this.undoAvailable = 0;
    this.ring = new Array;
    this.label = label;
    this._size = size;
  }
  get size() {
    return this._size;
  }
  set size(newSize) {
    this.ring = new Array(newSize);
    this._size = newSize;
    this.position = -1;
    this.redoAvailable = 0;
    this.undoAvailable = 0;
  }
  undo(items = 1) {
    while (items > 0 && this.undoAvailable > 0) {
      const item = this.ring[this.position];
      item.restoreMemo(true);
      items--;
      this.redoAvailable++;
      this.undoAvailable--;
      this.position = (this.position - 1 + this.size) % this.size;
    }
  }
  redo(items = 1) {
    while (items > 0 && this.redoAvailable > 0) {
      const newPosition = (this.position + 1) % this.size;
      const item = this.ring[newPosition];
      item.restoreMemo(false);
      items--;
      this.position = newPosition;
      this.undoAvailable++;
      this.redoAvailable--;
    }
  }
  push(item) {
    if (!item) {
      return;
    }
    const memo = item.restoreMemo ? item : item.createMemo?.();
    if (!memo) {
      return;
    }
    this.redoAvailable = 0;
    if (this.undoAvailable < this._size) {
      this.undoAvailable++;
    }
    this.position = (this.position + 1) % this._size;
    this.ring[this.position] = memo;
    return memo;
  }
}
var DefaultHistoryMemo = new HistoryMemo;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js
function worldToImageCoords(imageId, worldCoords) {
  const imagePlaneModule = getMetaData("imagePlaneModule", imageId);
  if (!imagePlaneModule) {
    throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);
  }
  const { columnCosines, rowCosines, imagePositionPatient: origin } = imagePlaneModule;
  let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;
  columnPixelSpacing ||= 1;
  rowPixelSpacing ||= 1;
  const newOrigin = exports_vec3.create();
  exports_vec3.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);
  exports_vec3.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);
  const sub6 = exports_vec3.create();
  exports_vec3.sub(sub6, worldCoords, newOrigin);
  const rowDistance = exports_vec3.dot(sub6, rowCosines);
  const columnDistance = exports_vec3.dot(sub6, columnCosines);
  const imageCoords = [
    rowDistance / rowPixelSpacing,
    columnDistance / columnPixelSpacing
  ];
  return imageCoords;
}
var worldToImageCoords_default = worldToImageCoords;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js
function imageToWorldCoords(imageId, imageCoords) {
  const imagePlaneModule = getMetaData("imagePlaneModule", imageId);
  if (!imagePlaneModule) {
    throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);
  }
  const { columnCosines, rowCosines, imagePositionPatient: origin } = imagePlaneModule;
  let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;
  columnPixelSpacing ||= 1;
  rowPixelSpacing ||= 1;
  const imageCoordsInWorld = exports_vec3.create();
  exports_vec3.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));
  exports_vec3.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));
  return Array.from(imageCoordsInWorld);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js
function getViewportsWithImageURI(imageURI) {
  const renderingEngines = getRenderingEngines();
  const viewports = [];
  renderingEngines.forEach((renderingEngine) => {
    const viewportsForRenderingEngine = renderingEngine.getViewports();
    viewportsForRenderingEngine.forEach((viewport) => {
      if (viewport.hasImageURI(imageURI)) {
        viewports.push(viewport);
      }
    });
  });
  return viewports;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js
function getClosestStackImageIndexForPoint(point, viewport) {
  const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);
  return minimalDistance ? minimalDistance.index : null;
}
function calculateMinimalDistanceForStackViewport(point, viewport) {
  const imageIds = viewport.getImageIds();
  const currentImageIdIndex = viewport.getCurrentImageIdIndex();
  if (imageIds.length === 0) {
    return null;
  }
  const getDistance = (imageId) => {
    const planeMetadata = getPlaneMetadata(imageId);
    if (!planeMetadata) {
      return null;
    }
    const plane = planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);
    const distance4 = planeDistanceToPoint(plane, point);
    return distance4;
  };
  const closestStack = {
    distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,
    index: currentImageIdIndex
  };
  const higherImageIds = imageIds.slice(currentImageIdIndex + 1);
  for (let i = 0;i < higherImageIds.length; i++) {
    const id = higherImageIds[i];
    const distance4 = getDistance(id);
    if (distance4 === null) {
      continue;
    }
    if (distance4 <= closestStack.distance) {
      closestStack.distance = distance4;
      closestStack.index = i + currentImageIdIndex + 1;
    } else {
      break;
    }
  }
  const lowerImageIds = imageIds.slice(0, currentImageIdIndex);
  for (let i = lowerImageIds.length - 1;i >= 0; i--) {
    const id = lowerImageIds[i];
    const distance4 = getDistance(id);
    if (distance4 === null || distance4 === closestStack.distance) {
      continue;
    }
    if (distance4 < closestStack.distance) {
      closestStack.distance = distance4;
      closestStack.index = i;
    } else {
      break;
    }
  }
  return closestStack.distance === Infinity ? null : closestStack;
}
function getPlaneMetadata(imageId) {
  const targetImagePlane = getMetaData("imagePlaneModule", imageId);
  if (!targetImagePlane || !(targetImagePlane.rowCosines instanceof Array && targetImagePlane.rowCosines.length === 3) || !(targetImagePlane.columnCosines instanceof Array && targetImagePlane.columnCosines.length === 3) || !(targetImagePlane.imagePositionPatient instanceof Array && targetImagePlane.imagePositionPatient.length === 3)) {
    return null;
  }
  const { rowCosines, columnCosines, imagePositionPatient } = targetImagePlane;
  const rowVec = exports_vec3.set(exports_vec3.create(), ...rowCosines);
  const colVec = exports_vec3.set(exports_vec3.create(), ...columnCosines);
  const planeNormal = exports_vec3.cross(exports_vec3.create(), rowVec, colVec);
  return { rowCosines, columnCosines, imagePositionPatient, planeNormal };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js
function getCurrentVolumeViewportSlice(viewport) {
  const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();
  const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();
  const ijkOriginPoint = transformCanvasToIJK(viewport, [0, 0]);
  const ijkRowPoint = transformCanvasToIJK(viewport, [canvasWidth - 1, 0]);
  const ijkColPoint = transformCanvasToIJK(viewport, [0, canvasHeight - 1]);
  const ijkRowVec = exports_vec3.sub(exports_vec3.create(), ijkRowPoint, ijkOriginPoint);
  const ijkColVec = exports_vec3.sub(exports_vec3.create(), ijkColPoint, ijkOriginPoint);
  const ijkSliceVec = exports_vec3.cross(exports_vec3.create(), ijkRowVec, ijkColVec);
  exports_vec3.normalize(ijkRowVec, ijkRowVec);
  exports_vec3.normalize(ijkColVec, ijkColVec);
  exports_vec3.normalize(ijkSliceVec, ijkSliceVec);
  const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));
  const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));
  if (!exports_common.equals(1, maxIJKRowVec) || !exports_common.equals(1, maxIJKColVec)) {
    throw new Error("Livewire is not available for rotate/oblique viewports");
  }
  const { voxelManager } = viewport.getImageData();
  const sliceViewInfo = viewport.getSliceViewInfo();
  const scalarData = voxelManager.getSliceData(sliceViewInfo);
  return {
    width: sliceViewInfo.width,
    height: sliceViewInfo.height,
    scalarData,
    sliceToIndexMatrix,
    indexToSliceMatrix
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js
var state5 = {};
var spatialRegistrationMetadataProvider = {
  add: (query, payload) => {
    const [viewportId1, viewportId2] = query;
    const entryId = `${viewportId1}_${viewportId2}`;
    if (!state5[entryId]) {
      state5[entryId] = {};
    }
    state5[entryId] = payload;
  },
  get: (type, viewportId1, viewportId2) => {
    if (type !== "spatialRegistrationModule") {
      return;
    }
    const entryId = `${viewportId1}_${viewportId2}`;
    if (state5[entryId]) {
      return state5[entryId];
    }
    const entryIdReverse = `${viewportId2}_${viewportId1}`;
    if (state5[entryIdReverse]) {
      return exports_mat4.invert(exports_mat4.create(), state5[entryIdReverse]);
    }
  }
};
addProvider(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));
var spatialRegistrationMetadataProvider_default = spatialRegistrationMetadataProvider;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js
var ALLOWED_DELTA = 0.05;
function calculateViewportsSpatialRegistration(viewport1, viewport2) {
  const imageId1 = viewport1.getSliceIndex();
  const imageId2 = viewport2.getSliceIndex();
  const imagePlaneModule1 = getMetaData("imagePlaneModule", imageId1.toString());
  const imagePlaneModule2 = getMetaData("imagePlaneModule", imageId2.toString());
  if (!imagePlaneModule1 || !imagePlaneModule2) {
    console.log("Viewport spatial registration requires image plane module");
    return;
  }
  const { imageOrientationPatient: iop2 } = imagePlaneModule2;
  const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);
  if (!isSameImagePlane) {
    console.log("Viewport spatial registration only supported for same orientation (hence translation only) for now", imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);
    return;
  }
  const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;
  const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;
  const translation = exports_vec3.subtract(exports_vec3.create(), imagePositionPatient1, imagePositionPatient2);
  const mat = exports_mat4.fromTranslation(exports_mat4.create(), translation);
  spatialRegistrationMetadataProvider_default.add([viewport1.id, viewport2.id], mat);
}
var calculateViewportsSpatialRegistration_default = calculateViewportsSpatialRegistration;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js
function getViewportImageCornersInWorld(viewport) {
  const { imageData, dimensions } = viewport.getImageData() || {};
  if (!imageData || !dimensions) {
    return [];
  }
  const { canvas } = viewport;
  const ratio = window.devicePixelRatio;
  const topLeftCanvas = [0, 0];
  const topRightCanvas = [canvas.width / ratio, 0];
  const bottomRightCanvas = [
    canvas.width / ratio,
    canvas.height / ratio
  ];
  const bottomLeftCanvas = [0, canvas.height / ratio];
  const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
  const topRightWorld = viewport.canvasToWorld(topRightCanvas);
  const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
  const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);
  const topLeftImage = imageData.worldToIndex(topLeftWorld);
  const topRightImage = imageData.worldToIndex(topRightWorld);
  const bottomRightImage = imageData.worldToIndex(bottomRightWorld);
  const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);
  return _getStackViewportImageCorners({
    dimensions,
    imageData,
    topLeftImage,
    topRightImage,
    bottomRightImage,
    bottomLeftImage,
    topLeftWorld,
    topRightWorld,
    bottomRightWorld,
    bottomLeftWorld
  });
}
function _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld }) {
  const topLeftImageWorld = _isInBounds(topLeftImage, dimensions) ? topLeftWorld : imageData.indexToWorld([0, 0, 0]);
  const topRightImageWorld = _isInBounds(topRightImage, dimensions) ? topRightWorld : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);
  const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions) ? bottomRightWorld : imageData.indexToWorld([
    dimensions[0] - 1,
    dimensions[1] - 1,
    0
  ]);
  const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions) ? bottomLeftWorld : imageData.indexToWorld([0, dimensions[1] - 1, 0]);
  return [
    topLeftImageWorld,
    topRightImageWorld,
    bottomLeftImageWorld,
    bottomRightImageWorld
  ];
}
function _isInBounds(imageCoord, dimensions) {
  return imageCoord[0] > 0 || imageCoord[0] < dimensions[0] - 1 || imageCoord[1] > 0 || imageCoord[1] < dimensions[1] - 1 || imageCoord[2] > 0 || imageCoord[2] < dimensions[2] - 1;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/getEnabledElement.js
function getEnabledElement(element) {
  if (!element) {
    return;
  }
  const { viewportUid, renderingEngineUid } = element.dataset;
  return getEnabledElementByIds(viewportUid, renderingEngineUid);
}
function getEnabledElementByIds(viewportId, renderingEngineId) {
  if (!renderingEngineId || !viewportId) {
    return;
  }
  const renderingEngine = getRenderingEngine_default(renderingEngineId);
  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
    return;
  }
  const viewport = renderingEngine.getViewport(viewportId);
  if (!viewport) {
    return;
  }
  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
  return {
    viewport,
    renderingEngine,
    viewportId,
    renderingEngineId,
    FrameOfReferenceUID
  };
}
function getEnabledElementByViewportId(viewportId) {
  const renderingEngines = getRenderingEngines();
  for (let i = 0;i < renderingEngines.length; i++) {
    const renderingEngine = renderingEngines[i];
    const viewport = renderingEngine.getViewport(viewportId);
    if (viewport) {
      return getEnabledElementByIds(viewportId, renderingEngine.id);
    }
  }
}
function getEnabledElements() {
  const enabledElements = [];
  const renderingEngines = getRenderingEngines();
  renderingEngines.forEach((renderingEngine) => {
    const viewports = renderingEngine.getViewports();
    viewports.forEach(({ element }) => {
      enabledElements.push(getEnabledElement(element));
    });
  });
  return enabledElements;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js
function getImageLegacy(element) {
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    return;
  }
  const { viewport } = enabledElement;
  if (!(viewport instanceof StackViewport_default)) {
    throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);
  }
  return viewport.getCornerstoneImage();
}
var getImageLegacy_default = getImageLegacy;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js
function isValidVolume(imageIds) {
  const imageId0 = imageIds[0];
  const { modality, seriesInstanceUID } = getMetaData("generalSeriesModule", imageId0);
  const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows } = getMetaData("imagePlaneModule", imageId0);
  const baseMetadata = {
    modality,
    imageOrientationPatient,
    pixelSpacing,
    frameOfReferenceUID,
    columns,
    rows,
    seriesInstanceUID
  };
  const validVolume = imageIds.every((imageId) => {
    const { modality: modality2, seriesInstanceUID: seriesInstanceUID2 } = getMetaData("generalSeriesModule", imageId);
    const { imageOrientationPatient: imageOrientationPatient2, pixelSpacing: pixelSpacing2, columns: columns2, rows: rows2 } = getMetaData("imagePlaneModule", imageId);
    return seriesInstanceUID2 === baseMetadata.seriesInstanceUID && modality2 === baseMetadata.modality && columns2 === baseMetadata.columns && rows2 === baseMetadata.rows && isEqual(imageOrientationPatient2, baseMetadata.imageOrientationPatient) && isEqual(pixelSpacing2, baseMetadata.pixelSpacing);
  });
  return validVolume;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js
var videoUIDs = new Set([
  "1.2.840.10008.1.2.4.100",
  "1.2.840.10008.1.2.4.100.1",
  "1.2.840.10008.1.2.4.101",
  "1.2.840.10008.1.2.4.101.1",
  "1.2.840.10008.1.2.4.102",
  "1.2.840.10008.1.2.4.102.1",
  "1.2.840.10008.1.2.4.103",
  "1.2.840.10008.1.2.4.103.1",
  "1.2.840.10008.1.2.4.104",
  "1.2.840.10008.1.2.4.104.1",
  "1.2.840.10008.1.2.4.105",
  "1.2.840.10008.1.2.4.105.1",
  "1.2.840.10008.1.2.4.106",
  "1.2.840.10008.1.2.4.106.1",
  "1.2.840.10008.1.2.4.107",
  "1.2.840.10008.1.2.4.108"
]);
function isVideoTransferSyntax(uidOrUids) {
  if (!uidOrUids) {
    return false;
  }
  const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];
  return uids.find((uid) => videoUIDs.has(uid));
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js
async function convertStackToVolumeViewport({ viewport, options = {} }) {
  const renderingEngine = viewport.getRenderingEngine();
  let volumeId = options.volumeId || `${uuidv4()}`;
  if (volumeId.split(":").length === 0) {
    const schema = getUnknownVolumeLoaderSchema();
    volumeId = `${schema}:${volumeId}`;
  }
  const { id, element } = viewport;
  const viewportId = options.viewportId || id;
  const imageIds = viewport.getImageIds();
  const prevViewPresentation = viewport.getViewPresentation();
  const prevViewReference = viewport.getViewReference();
  renderingEngine.enableElement({
    viewportId,
    type: ViewportType_default.ORTHOGRAPHIC,
    element,
    defaultOptions: {
      background: options.background,
      orientation: options.orientation
    }
  });
  const volume = await createAndCacheVolume(volumeId, {
    imageIds
  });
  volume.load();
  const volumeViewport = renderingEngine.getViewport(viewportId);
  await setVolumesForViewports_default(renderingEngine, [
    {
      volumeId
    }
  ], [viewportId]);
  const volumeViewportNewVolumeHandler = () => {
    volumeViewport.render();
    element.removeEventListener(Events_default.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);
  };
  const addVolumeViewportNewVolumeListener = () => {
    element.addEventListener(Events_default.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);
  };
  addVolumeViewportNewVolumeListener();
  volumeViewport.setViewPresentation(prevViewPresentation);
  volumeViewport.setViewReference(prevViewReference);
  volumeViewport.render();
  return volumeViewport;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js
async function convertVolumeToStackViewport({ viewport, options }) {
  const volumeViewport = viewport;
  const { id, element } = volumeViewport;
  const renderingEngine = viewport.getRenderingEngine();
  const { background } = options;
  const viewportId = options.viewportId || id;
  const volume = cache_default.getVolume(volumeViewport.getVolumeId());
  if (!(volume instanceof ImageVolume)) {
    throw new Error("Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.");
  }
  const viewportInput = {
    viewportId,
    type: ViewportType_default.STACK,
    element,
    defaultOptions: {
      background
    }
  };
  const prevView = volumeViewport.getViewReference();
  renderingEngine.enableElement(viewportInput);
  const stackViewport = renderingEngine.getViewport(viewportId);
  await stackViewport.setStack(volume.imageIds);
  stackViewport.setViewReference(prevView);
  stackViewport.render();
  return stackViewport;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js
function roundNumber2(value, precision = 2) {
  if (Array.isArray(value)) {
    return value.map((v) => roundNumber2(v, precision)).join(", ");
  }
  if (value === undefined || value === null || value === "") {
    return "NaN";
  }
  value = Number(value);
  const absValue = Math.abs(value);
  if (absValue < 0.0001) {
    return `${value}`;
  }
  const fixedPrecision = absValue >= 100 ? precision - 2 : absValue >= 10 ? precision - 1 : absValue >= 1 ? precision : absValue >= 0.1 ? precision + 1 : absValue >= 0.01 ? precision + 2 : absValue >= 0.001 ? precision + 3 : precision + 4;
  return value.toFixed(fixedPrecision);
}
function roundToPrecision(value) {
  return Math.round(value / epsilon_default) * epsilon_default;
}
var roundNumber_default = roundNumber2;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js
function convertToGrayscale(scalarData, width, height) {
  const isRGBA = scalarData.length === width * height * 4;
  const isRGB = scalarData.length === width * height * 3;
  if (isRGBA || isRGB) {
    const newScalarData = new Float32Array(width * height);
    let offset = 0;
    let destOffset = 0;
    const increment = isRGBA ? 4 : 3;
    for (let x = 0;x < width; x++) {
      for (let y = 0;y < height; y++) {
        const r = scalarData[offset];
        const g = scalarData[offset + 1];
        const b = scalarData[offset + 2];
        newScalarData[destOffset] = (r + g + b) / 3;
        offset += increment;
        destOffset++;
      }
    }
    return newScalarData;
  } else {
    return scalarData;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js
function getViewportImageIds(viewport) {
  if (viewport instanceof VolumeViewport_default) {
    const volume = cache_default.getVolume(viewport.getVolumeId());
    return volume.imageIds;
  } else if (viewport.getImageIds) {
    return viewport.getImageIds();
  }
}
var getViewportImageIds_default = getViewportImageIds;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js
function getRandomSampleFromArray(array, size) {
  const clonedArray = [...array];
  if (size >= clonedArray.length) {
    shuffleArray(clonedArray);
    return clonedArray;
  }
  shuffleArray(clonedArray);
  return clonedArray.slice(0, size);
}
function shuffleArray(array) {
  for (let i = array.length - 1;i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js
var exports_color = {};
__export(exports_color, {
  rgbToHex: () => rgbToHex,
  hexToRgb: () => hexToRgb
});
function componentToHex(c) {
  const hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }
  if (obj1 == null || obj2 == null) {
    return false;
  }
  try {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  } catch (error) {
    console.debug("Error in JSON.stringify during deep comparison:", error);
    return obj1 === obj2;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js
function _getViewportModality(viewport, volumeId, getVolume) {
  if (!getVolume) {
    throw new Error("getVolume is required, use the utilities export instead ");
  }
  if (viewport.modality) {
    return viewport.modality;
  }
  if (viewport.setVolumes) {
    volumeId = volumeId ?? viewport.getVolumeId();
    if (!volumeId || !getVolume) {
      return;
    }
    const volume = getVolume(volumeId);
    return volume.metadata.Modality;
  }
  throw new Error("Invalid viewport type");
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js
var groupBy = (array, key) => {
  return array.reduce((rv, x) => {
    (rv[x[key]] = rv[x[key]] || []).push(x);
    return rv;
  }, {});
};
function getIPPGroups(imageIds) {
  const ippMetadata = imageIds.map((imageId) => {
    const { imagePositionPatient } = getMetaData("imagePlaneModule", imageId) || {};
    return { imageId, imagePositionPatient };
  });
  if (!ippMetadata.every((item) => item.imagePositionPatient)) {
    return null;
  }
  const positionGroups = groupBy(ippMetadata, "imagePositionPatient");
  const positions = Object.keys(positionGroups);
  const frame_count = positionGroups[positions[0]].length;
  if (frame_count === 1) {
    return null;
  }
  const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);
  if (!frame_count_equal) {
    return null;
  }
  return positionGroups;
}
function test4DTag(IPPGroups, value_getter) {
  const frame_groups = {};
  let first_frame_value_set = [];
  const positions = Object.keys(IPPGroups);
  for (let i = 0;i < positions.length; i++) {
    const frame_value_set = new Set;
    const frames = IPPGroups[positions[i]];
    for (let j = 0;j < frames.length; j++) {
      const frame_value = value_getter(frames[j].imageId) || 0;
      frame_groups[frame_value] = frame_groups[frame_value] || [];
      frame_groups[frame_value].push({ imageId: frames[j].imageId });
      frame_value_set.add(frame_value);
      if (frame_value_set.size - 1 < j) {
        return;
      }
    }
    if (i == 0) {
      first_frame_value_set = Array.from(frame_value_set);
    } else if (!setEquals(first_frame_value_set, frame_value_set)) {
      return;
    }
  }
  return frame_groups;
}
function getTagValue(imageId, tag) {
  const value = getMetaData(tag, imageId);
  try {
    return parseFloat(value);
  } catch {
    return;
  }
}
function getPhilipsPrivateBValue(imageId) {
  const value = getMetaData("20011003", imageId);
  try {
    const { InlineBinary } = value;
    if (InlineBinary) {
      const value_bytes = atob(InlineBinary);
      const ary_buf = new ArrayBuffer(value_bytes.length);
      const dv = new DataView(ary_buf);
      for (let i = 0;i < value_bytes.length; i++) {
        dv.setUint8(i, value_bytes.charCodeAt(i));
      }
      return new Float32Array(ary_buf)[0];
    }
    return parseFloat(value);
  } catch {
    return;
  }
}
function getSiemensPrivateBValue(imageId) {
  let value = getMetaData("0019100c", imageId) || getMetaData("0019100C", imageId);
  try {
    const { InlineBinary } = value;
    if (InlineBinary) {
      value = atob(InlineBinary);
    }
    return parseFloat(value);
  } catch {
    return;
  }
}
function getGEPrivateBValue(imageId) {
  let value = getMetaData("00431039", imageId);
  try {
    const { InlineBinary } = value;
    if (InlineBinary) {
      value = atob(InlineBinary).split("//");
    }
    return parseFloat(value[0]) % 1e5;
  } catch {
    return;
  }
}
function setEquals(set_a, set_b) {
  if (set_a.length != set_b.size) {
    return false;
  }
  for (let i = 0;i < set_a.length; i++) {
    if (!set_b.has(set_a[i])) {
      return false;
    }
  }
  return true;
}
function getPetFrameReferenceTime(imageId) {
  const moduleInfo = getMetaData("petImageModule", imageId);
  return moduleInfo ? moduleInfo["frameReferenceTime"] : 0;
}
function splitImageIdsBy4DTags(imageIds) {
  const positionGroups = getIPPGroups(imageIds);
  if (!positionGroups) {
    return { imageIdGroups: [imageIds], splittingTag: null };
  }
  const tags = [
    "TemporalPositionIdentifier",
    "DiffusionBValue",
    "TriggerTime",
    "EchoTime",
    "EchoNumber",
    "PhilipsPrivateBValue",
    "SiemensPrivateBValue",
    "GEPrivateBValue",
    "PetFrameReferenceTime"
  ];
  const fncList2 = [
    (imageId) => getTagValue(imageId, tags[0]),
    (imageId) => getTagValue(imageId, tags[1]),
    (imageId) => getTagValue(imageId, tags[2]),
    (imageId) => getTagValue(imageId, tags[3]),
    (imageId) => getTagValue(imageId, tags[4]),
    getPhilipsPrivateBValue,
    getSiemensPrivateBValue,
    getGEPrivateBValue,
    getPetFrameReferenceTime
  ];
  for (let i = 0;i < fncList2.length; i++) {
    const frame_groups = test4DTag(positionGroups, fncList2[i]);
    if (frame_groups) {
      const sortedKeys = Object.keys(frame_groups).map(Number.parseFloat).sort((a, b) => a - b);
      const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));
      return { imageIdGroups, splittingTag: tags[i] };
    }
  }
  return { imageIdGroups: [imageIds], splittingTag: null };
}
var splitImageIdsBy4DTags_default = splitImageIdsBy4DTags;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js
function getDynamicVolumeInfo(imageIds) {
  const { imageIdGroups: timePoints, splittingTag } = splitImageIdsBy4DTags_default(imageIds);
  const isDynamicVolume = timePoints.length > 1;
  return { isDynamicVolume, timePoints, splittingTag };
}
var getDynamicVolumeInfo_default = getDynamicVolumeInfo;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js
function scaleArray(array, scalingParameters) {
  const arrayLength = array.length;
  const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;
  if (scalingParameters.modality === "PT" && typeof suvbw === "number") {
    for (let i = 0;i < arrayLength; i++) {
      array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);
    }
  } else {
    for (let i = 0;i < arrayLength; i++) {
      array[i] = array[i] * rescaleSlope + rescaleIntercept;
    }
  }
  return array;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js
function clip(val, low, high) {
  return Math.min(Math.max(low, val), high);
}
var clip_default = clip;

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js
function scroll(viewport, options) {
  const enabledElement = getEnabledElement(viewport.element);
  if (!enabledElement) {
    throw new Error("Scroll::Viewport is not enabled (it might be disabled)");
  }
  if (viewport instanceof StackViewport_default && viewport.getImageIds().length === 0) {
    throw new Error("Scroll::Stack Viewport has no images");
  }
  const { volumeId, delta, scrollSlabs } = options;
  if (viewport instanceof VolumeViewport_default) {
    scrollVolume(viewport, volumeId, delta, scrollSlabs);
  } else {
    const imageIdIndex = viewport.getCurrentImageIdIndex();
    if (imageIdIndex + delta > viewport.getImageIds().length - 1 || imageIdIndex + delta < 0) {
      const eventData = {
        imageIdIndex,
        direction: delta
      };
      triggerEvent(eventTarget_default, Events_default.STACK_SCROLL_OUT_OF_BOUNDS, eventData);
    }
    viewport.scroll(delta, options.debounceLoading, options.loop);
  }
}
function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {
  const useSlabThickness = scrollSlabs;
  const { numScrollSteps, currentStepIndex, sliceRangeInfo } = getVolumeViewportScrollInfo_default(viewport, volumeId, useSlabThickness);
  if (!sliceRangeInfo) {
    return;
  }
  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
  const { focalPoint, viewPlaneNormal, position } = camera;
  const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
  viewport.setCamera({
    focalPoint: newFocalPoint,
    position: newPosition
  });
  viewport.render();
  const desiredStepIndex = currentStepIndex + delta;
  const VolumeScrollEventDetail = {
    volumeId,
    viewport,
    delta,
    desiredStepIndex,
    currentStepIndex,
    numScrollSteps,
    currentImageId: viewport.getCurrentImageId()
  };
  if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) && viewport.getCurrentImageId()) {
    triggerEvent(eventTarget_default, Events_default.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);
  } else {
    triggerEvent(eventTarget_default, Events_default.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js
async function jumpToSlice(element, options = {}) {
  const { imageIndex, debounceLoading, volumeId } = options;
  const enabledElement = getEnabledElement(element);
  if (!enabledElement) {
    throw new Error("Element has been disabled");
  }
  const { viewport } = enabledElement;
  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);
  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);
  const delta = imageIndexToJump - currentImageIndex;
  scroll(viewport, { delta, debounceLoading, volumeId });
}
function _getImageSliceData(viewport, debounceLoading) {
  if (viewport instanceof StackViewport_default) {
    return {
      numberOfSlices: viewport.getImageIds().length,
      imageIndex: debounceLoading ? viewport.getTargetImageIdIndex() : viewport.getCurrentImageIdIndex()
    };
  }
  return {
    numberOfSlices: viewport.getNumberOfSlices(),
    imageIndex: viewport.getSliceIndex()
  };
}
function _getImageIndexToJump(numberOfSlices, imageIndex) {
  const lastSliceIndex = numberOfSlices - 1;
  return clip_default(imageIndex, 0, lastSliceIndex);
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSubVolume.js
function createSubVolume(referencedVolumeId, boundsIJK, options = {}) {
  const referencedVolume = cache_default.getVolume(referencedVolumeId);
  if (!referencedVolume) {
    throw new Error(`Referenced volume with id ${referencedVolumeId} does not exist.`);
  }
  const { metadata, spacing, direction, dimensions: refVolumeDim } = referencedVolume;
  const { minX, maxX, minY, maxY, minZ, maxZ } = boundsIJK;
  const ijkTopLeft = [
    Math.min(minX, maxX),
    Math.min(minY, maxY),
    Math.min(minZ, maxZ)
  ];
  const boundingBoxOriginWorld = transformIndexToWorld(referencedVolume.imageData, ijkTopLeft);
  const dimensions = [
    Math.abs(maxX - minX) + 1,
    Math.abs(maxY - minY) + 1,
    Math.abs(maxZ - minZ) + 1
  ];
  const { targetBuffer } = options;
  const subVolumeOptions = {
    metadata,
    dimensions,
    spacing,
    origin: boundingBoxOriginWorld,
    direction,
    targetBuffer,
    scalarData: targetBuffer?.type === "Float32Array" ? new Float32Array(dimensions[0] * dimensions[1] * dimensions[2]) : undefined
  };
  const subVolume = createLocalVolume(uuidv4(), subVolumeOptions);
  const subVolumeData = subVolume.voxelManager.getCompleteScalarDataArray();
  const subVolumeSliceSize = dimensions[0] * dimensions[1];
  const refVolumeSliceSize = refVolumeDim[0] * refVolumeDim[1];
  const refVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
  for (let z = 0;z < dimensions[2]; z++) {
    for (let y = 0;y < dimensions[1]; y++) {
      const rowStartWorld = transformIndexToWorld(subVolume.imageData, [
        0,
        y,
        z
      ]);
      const refVolumeRowStartIJK = transformWorldToIndex(referencedVolume.imageData, rowStartWorld);
      const refVolumeRowStartOffset = refVolumeRowStartIJK[2] * refVolumeSliceSize + refVolumeRowStartIJK[1] * refVolumeDim[0] + refVolumeRowStartIJK[0];
      const rowData = refVolumeData.slice(refVolumeRowStartOffset, refVolumeRowStartOffset + dimensions[0]);
      const subVolumeLineStartOffset = z * subVolumeSliceSize + y * dimensions[0];
      subVolumeData.set(rowData, subVolumeLineStartOffset);
    }
  }
  subVolume.voxelManager.setCompleteScalarDataArray(subVolumeData);
  return subVolume;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeDirectionVectors.js
function getVolumeDirectionVectors(imageData, camera) {
  const { viewUp, viewPlaneNormal } = camera;
  const ijkOrigin = transformWorldToIndexContinuous(imageData, [0, 0, 0]);
  const worldVecColDir = exports_vec3.negate(exports_vec3.create(), viewUp);
  const worldVecSliceDir = exports_vec3.negate(exports_vec3.create(), viewPlaneNormal);
  const worldVecRowDir = exports_vec3.cross(exports_vec3.create(), worldVecColDir, worldVecSliceDir);
  const ijkVecColDir = exports_vec3.sub(exports_vec3.create(), transformWorldToIndexContinuous(imageData, worldVecColDir), ijkOrigin);
  const ijkVecSliceDir = exports_vec3.sub(exports_vec3.create(), transformWorldToIndexContinuous(imageData, worldVecSliceDir), ijkOrigin);
  exports_vec3.normalize(ijkVecColDir, ijkVecColDir);
  exports_vec3.normalize(ijkVecSliceDir, ijkVecSliceDir);
  const ijkVecRowDir = exports_vec3.cross(exports_vec3.create(), ijkVecColDir, ijkVecSliceDir);
  return {
    worldVecRowDir,
    worldVecColDir,
    worldVecSliceDir,
    ijkVecRowDir,
    ijkVecColDir,
    ijkVecSliceDir
  };
}

// ../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js
var getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache_default.getVolume);

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/StreamingDynamicImageVolume.js
class StreamingDynamicImageVolume extends BaseStreamingImageVolume {
  constructor(imageVolumeProperties, streamingProperties) {
    super(imageVolumeProperties, streamingProperties);
    this._dimensionGroupNumber = 1;
    this._loadedDimensionGroups = new Set;
    this._getImageIdRequests = (imageIds, priority) => {
      return this.getImageIdsRequests(imageIds, priority);
    };
    this.getImageLoadRequests = (priority) => {
      const imageIds = this.getImageIdsToLoad();
      return this._getImageIdRequests(imageIds, priority);
    };
    const { imageIdGroups, splittingTag } = imageVolumeProperties;
    this._splittingTag = splittingTag;
    this._imageIdGroups = imageIdGroups;
    this.numDimensionGroups = this._imageIdGroups.length;
    this.numTimePoints = this.numDimensionGroups;
  }
  _getImageIdsToLoad() {
    const imageIdGroups = this._imageIdGroups;
    const initialImageIdGroupIndex = this._dimensionGroupNumber - 1;
    const imageIds = [...imageIdGroups[initialImageIdGroupIndex]];
    let leftIndex = initialImageIdGroupIndex - 1;
    let rightIndex = initialImageIdGroupIndex + 1;
    while (leftIndex >= 0 || rightIndex < imageIdGroups.length) {
      if (leftIndex >= 0) {
        imageIds.push(...imageIdGroups[leftIndex--]);
      }
      if (rightIndex < imageIdGroups.length) {
        imageIds.push(...imageIdGroups[rightIndex++]);
      }
    }
    return imageIds;
  }
  getImageIdsToLoad() {
    return this._getImageIdsToLoad();
  }
  get dimensionGroupNumber() {
    return this._dimensionGroupNumber;
  }
  set timePointIndex(index2) {
    console.warn("Warning: timePointIndex is deprecated. Please use dimensionGroupNumber instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.");
    this.dimensionGroupNumber = index2 + 1;
  }
  set dimensionGroupNumber(dimensionGroupNumber) {
    if (this._dimensionGroupNumber === dimensionGroupNumber) {
      return;
    }
    this._dimensionGroupNumber = dimensionGroupNumber;
    this.voxelManager.setDimensionGroupNumber(dimensionGroupNumber);
    this.invalidateVolume(true);
    triggerEvent(eventTarget_default, Events_default.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED, {
      volumeId: this.volumeId,
      dimensionGroupNumber,
      numDimensionGroups: this.numDimensionGroups,
      imageIdGroupIndex: dimensionGroupNumber - 1,
      numImageIdGroups: this.numDimensionGroups,
      splittingTag: this.splittingTag
    });
    triggerEvent(eventTarget_default, Events_default.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED, {
      volumeId: this.volumeId,
      timePointIndex: dimensionGroupNumber - 1,
      numTimePoints: this.numDimensionGroups,
      imageIdGroupIndex: dimensionGroupNumber - 1,
      numImageIdGroups: this.numDimensionGroups,
      splittingTag: this.splittingTag
    });
  }
  get timePointIndex() {
    console.warn("Warning: timePointIndex is deprecated. Please use dimensionGroupNumber instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.");
    return this._dimensionGroupNumber - 1;
  }
  scroll(delta) {
    const newDimensionGroupNumber = this._dimensionGroupNumber + delta;
    if (newDimensionGroupNumber < 1) {
      this.dimensionGroupNumber = this.numDimensionGroups;
    } else if (newDimensionGroupNumber > this.numDimensionGroups) {
      this.dimensionGroupNumber = 1;
    } else {
      this.dimensionGroupNumber = newDimensionGroupNumber;
    }
  }
  getCurrentDimensionGroupImageIds() {
    return this._imageIdGroups[this._dimensionGroupNumber - 1];
  }
  getCurrentTimePointImageIds() {
    console.warn("Warning: getCurrentTimePointImageIds is deprecated. Please use getCurrentDimensionGroupImageIds instead.");
    return this.getCurrentDimensionGroupImageIds();
  }
  flatImageIdIndexToTimePointIndex(flatImageIdIndex) {
    console.warn("Warning: flatImageIdIndexToTimePointIndex is deprecated. Please use flatImageIdIndexToDimensionGroupNumber instead.");
    return this.flatImageIdIndexToDimensionGroupNumber(flatImageIdIndex) - 1;
  }
  flatImageIdIndexToDimensionGroupNumber(flatImageIdIndex) {
    return Math.floor(flatImageIdIndex / this._imageIdGroups[0].length) + 1;
  }
  flatImageIdIndexToImageIdIndex(flatImageIdIndex) {
    return flatImageIdIndex % this._imageIdGroups[0].length;
  }
  get splittingTag() {
    return this._splittingTag;
  }
  isTimePointLoaded(timePointIndex) {
    console.warn("Warning: isTimePointLoaded is deprecated. Please use isDimensionGroupLoaded instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.");
    return this.isDimensionGroupLoaded(timePointIndex + 1);
  }
  isDimensionGroupLoaded(dimensionGroupNumber) {
    return this._loadedDimensionGroups.has(dimensionGroupNumber);
  }
  markDimensionGroupAsLoaded(dimensionGroupNumber) {
    this._loadedDimensionGroups.add(dimensionGroupNumber);
    triggerEvent(eventTarget_default, Events_default.DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED, {
      volumeId: this.volumeId,
      dimensionGroupNumber
    });
    triggerEvent(eventTarget_default, Events_default.DYNAMIC_VOLUME_TIME_POINT_LOADED, {
      volumeId: this.volumeId,
      timePointIndex: dimensionGroupNumber - 1
    });
  }
  checkTimePointCompletion(imageIdIndex) {
    console.warn("Warning: checkTimePointCompletion is deprecated. Please use checkDimensionGroupCompletion instead.");
    this.checkDimensionGroupCompletion(imageIdIndex);
  }
  checkDimensionGroupCompletion(imageIdIndex) {
    const dimensionGroupNumber = this.flatImageIdIndexToDimensionGroupNumber(imageIdIndex);
    const imageIdsInDimensionGroup = this._imageIdGroups[dimensionGroupNumber - 1];
    const allLoaded = imageIdsInDimensionGroup.every((imageId) => {
      const index2 = this.getImageIdIndex(imageId);
      return this.cachedFrames[index2] === ImageQualityStatus_default.FULL_RESOLUTION;
    });
    if (allLoaded && !this.isDimensionGroupLoaded(dimensionGroupNumber)) {
      this.markDimensionGroupAsLoaded(dimensionGroupNumber);
    }
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageRetrievalPoolManager.js
var imageRetrievalPoolManager = new RequestPoolManager("imageRetrievalPool");
imageRetrievalPoolManager.setMaxSimultaneousRequests(RequestType_default.Interaction, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(RequestType_default.Thumbnail, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(RequestType_default.Prefetch, 200);
imageRetrievalPoolManager.grabDelay = 0;
var imageRetrievalPoolManager_default = imageRetrievalPoolManager;

// ../../node_modules/@cornerstonejs/core/dist/esm/Settings.js
var DEFAULT_SETTINGS = Symbol("DefaultSettings");
var RUNTIME_SETTINGS = Symbol("RuntimeSettings");
var OBJECT_SETTINGS_MAP = Symbol("ObjectSettingsMap");
var DICTIONARY = Symbol("Dictionary");

class Settings {
  constructor(base) {
    const dictionary = Object.create(base instanceof Settings && DICTIONARY in base ? base[DICTIONARY] : null);
    Object.seal(Object.defineProperty(this, DICTIONARY, {
      value: dictionary
    }));
  }
  set(key, value) {
    return set8(this[DICTIONARY], key, value, null);
  }
  get(key) {
    return get2(this[DICTIONARY], key);
  }
  unset(key) {
    return unset(this[DICTIONARY], key + "");
  }
  forEach(callback) {
    iterate(this[DICTIONARY], callback);
  }
  extend() {
    return new Settings(this);
  }
  import(root) {
    if (isPlainObject(root)) {
      Object.keys(root).forEach((key) => {
        set8(this[DICTIONARY], key, root[key], null);
      });
    }
  }
  dump() {
    const context = {};
    iterate(this[DICTIONARY], (key, value) => {
      if (typeof value !== "undefined") {
        deepSet(context, key, value);
      }
    });
    return context;
  }
  static assert(subject) {
    return subject instanceof Settings ? subject : Settings.getRuntimeSettings();
  }
  static getDefaultSettings(subfield = null) {
    let defaultSettings = Settings[DEFAULT_SETTINGS];
    if (!(defaultSettings instanceof Settings)) {
      defaultSettings = new Settings;
      Settings[DEFAULT_SETTINGS] = defaultSettings;
    }
    if (subfield) {
      const settingObj = {};
      defaultSettings.forEach((name) => {
        if (name.startsWith(subfield)) {
          const setting = name.split(`${subfield}.`)[1];
          settingObj[setting] = defaultSettings.get(name);
        }
      });
      return settingObj;
    }
    return defaultSettings;
  }
  static getRuntimeSettings() {
    let runtimeSettings = Settings[RUNTIME_SETTINGS];
    if (!(runtimeSettings instanceof Settings)) {
      runtimeSettings = new Settings(Settings.getDefaultSettings());
      Settings[RUNTIME_SETTINGS] = runtimeSettings;
    }
    return runtimeSettings;
  }
  static getObjectSettings(subject, from) {
    let settings = null;
    if (subject instanceof Settings) {
      settings = subject;
    } else if (typeof subject === "object" && subject !== null) {
      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];
      if (!(objectSettingsMap instanceof WeakMap)) {
        objectSettingsMap = new WeakMap;
        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;
      }
      settings = objectSettingsMap.get(subject);
      if (!(settings instanceof Settings)) {
        settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));
        objectSettingsMap.set(subject, settings);
      }
    }
    return settings;
  }
  static extendRuntimeSettings() {
    return Settings.getRuntimeSettings().extend();
  }
}
function unset(dictionary, name) {
  if (name.endsWith(".")) {
    let deleteCount = 0;
    const namespace = name;
    const base = namespace.slice(0, -1);
    const deleteAll = base.length === 0;
    for (const key in dictionary) {
      if (Object.prototype.hasOwnProperty.call(dictionary, key) && (deleteAll || key.startsWith(namespace) || key === base)) {
        delete dictionary[key];
        ++deleteCount;
      }
    }
    return deleteCount > 0;
  }
  return delete dictionary[name];
}
function iterate(dictionary, callback) {
  for (const key in dictionary) {
    callback(key, dictionary[key]);
  }
}
function setAll(dictionary, prefix, record, references) {
  let failCount;
  if (references.has(record)) {
    return set8(dictionary, prefix, null, references);
  }
  references.add(record);
  failCount = 0;
  for (const field in record) {
    if (Object.prototype.hasOwnProperty.call(record, field)) {
      const key = field.length === 0 ? prefix : `${prefix}.${field}`;
      if (!set8(dictionary, key, record[field], references)) {
        ++failCount;
      }
    }
  }
  references.delete(record);
  return failCount === 0;
}
function set8(dictionary, key, value, references) {
  if (isValidKey(key)) {
    if (isPlainObject(value)) {
      return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet);
    }
    dictionary[key] = value;
    return true;
  }
  return false;
}
function get2(dictionary, key) {
  return dictionary[key];
}
function isValidKey(key) {
  let last, current, previous;
  if (typeof key !== "string" || (last = key.length - 1) < 0) {
    return false;
  }
  previous = -1;
  while ((current = key.indexOf(".", previous + 1)) >= 0) {
    if (current - previous < 2 || current === last) {
      return false;
    }
    previous = current;
  }
  return true;
}
function isPlainObject(subject) {
  if (typeof subject === "object" && subject !== null) {
    const prototype = Object.getPrototypeOf(subject);
    if (prototype === Object.prototype || prototype === null) {
      return true;
    }
  }
  return false;
}
function deepSet(context, key, value) {
  const separator = key.indexOf(".");
  if (separator >= 0) {
    const subKey = key.slice(0, separator);
    let subContext = context[subKey];
    if (typeof subContext !== "object" || subContext === null) {
      const subContextValue = subContext;
      subContext = {};
      if (typeof subContextValue !== "undefined") {
        subContext[""] = subContextValue;
      }
      context[subKey] = subContext;
    }
    deepSet(subContext, key.slice(separator + 1, key.length), value);
  } else {
    context[key] = value;
  }
}
Settings.getDefaultSettings().set("useCursors", true);

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/geometryLoader.js
var exports_geometryLoader = {};
__export(exports_geometryLoader, {
  registerUnknownGeometryLoader: () => registerUnknownGeometryLoader,
  registerGeometryLoader: () => registerGeometryLoader,
  loadGeometry: () => loadGeometry,
  loadAndCacheGeometry: () => loadAndCacheGeometry,
  createAndCacheGeometry: () => createAndCacheGeometry
});

// ../../node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// ../../node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// ../../node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero4;
    compare2 = f;
    delta = f;
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero4() {
  return 0;
}

// ../../node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

// ../../node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;
// ../../node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i22, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i22 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i22 / inc > stop)
      --i22;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i22 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i22 * inc > stop)
      --i22;
  }
  if (i22 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start, stop, count * 2);
  return [i1, i22, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse = stop < start, [i1, i22, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i22 >= i1))
    return [];
  const n = i22 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0;i < n; ++i)
        ticks2[i] = (i22 - i) / -inc;
    else
      for (let i = 0;i < n; ++i)
        ticks2[i] = (i22 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0;i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0;i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
// ../../node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// ../../node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend111(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// ../../node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend111(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl;
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min5 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s = max5 - min5, l = (max5 + min5) / 2;
  if (s) {
    if (r === max5)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max5)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max5 + min5 : 2 - max5 - min5;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend111(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
// ../../node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v32) {
  var t22 = t1 * t1, t3 = t22 * t1;
  return ((1 - 3 * t1 + 3 * t22 - t3) * v0 + (4 - 6 * t22 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t22 - 3 * t3) * v2 + t3 * v32) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v32 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v32);
  };
}

// ../../node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v32 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v32);
  };
}

// ../../node_modules/d3-interpolate/src/constant.js
var constant_default = (x) => () => x;

// ../../node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// ../../node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0;i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// ../../node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0;i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// ../../node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0;i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (;i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0;i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// ../../node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// ../../node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// ../../node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// ../../node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero5(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm2, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm2 = reB.exec(b))) {
    if ((bs = bm2.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm2 = bm2[0])) {
      if (s[i])
        s[i] += bm2;
      else
        s[++i] = bm2;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm2) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero5(b) : (b = q.length, function(t) {
    for (var i3 = 0, o;i3 < b; ++i3)
      s[(o = q[i3]).i] = o.x(t);
    return s.join("");
  });
}

// ../../node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}
// ../../node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
// ../../node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// ../../node_modules/d3-scale/src/number.js
function number2(x) {
  return +x;
}

// ../../node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity5(x) {
  return x;
}
function normalize6(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate) {
  var d02 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d02)
    d02 = normalize6(d1, d02), r0 = interpolate(r1, r0);
  else
    d02 = normalize6(d02, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d02(x));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize6(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x) {
    var i3 = bisect_default(domain, x, 1, j) - 1;
    return r[i3](d[i3](x));
  };
}
function copy7(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform, untransform, unknown, clamp2 = identity5, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp2 !== identity5)
      clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale8;
  }
  function scale8(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp2(x)));
  }
  scale8.invert = function(y) {
    return clamp2(untransform((input || (input = piecewise(range, domain.map(transform), number_default)))(y)));
  };
  scale8.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale8.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale8.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round_default, rescale();
  };
  scale8.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity5, rescale()) : clamp2 !== identity5;
  };
  scale8.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale8.unknown = function(_) {
    return arguments.length ? (unknown = _, scale8) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity5, identity5);
}

// ../../node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1000000000000000000000 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// ../../node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// ../../node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length5 = 0;
    while (i > 0 && g > 0) {
      if (length5 + g + 1 > width)
        g = Math.max(1, width - length5);
      t.push(value.substring(i -= g, i + g));
      if ((length5 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// ../../node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// ../../node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// ../../node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1;i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// ../../node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// ../../node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// ../../node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  b: (x) => Math.round(x).toString(2),
  c: (x) => x + "",
  d: formatDecimal_default,
  e: (x, p) => x.toExponential(p),
  f: (x, p) => x.toFixed(p),
  g: (x, p) => x.toPrecision(p),
  o: (x) => Math.round(x).toString(8),
  p: (x, p) => formatRounded_default(x * 100, p),
  r: formatRounded_default,
  s: formatPrefixAuto_default,
  X: (x) => Math.round(x).toString(16).toUpperCase(),
  x: (x) => Math.round(x).toString(16)
};

// ../../node_modules/d3-format/src/identity.js
function identity_default(x) {
  return x;
}

// ../../node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity_default : formatGroup_default(map.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? identity_default : formatNumerals_default(map.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var { fill, align, sign, symbol, zero: zero6, width, comma, precision, trim, type } = specifier;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === undefined && (precision = 12), trim = true, type = "g";
    if (zero6 || fill === "0" && align === "=")
      zero6 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero6)
        value = group(value, Infinity);
      var length5 = valuePrefix.length + value.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill) : "";
      if (comma && zero6)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length5);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format.toString = function() {
      return specifier + "";
    };
    return format;
  }
  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix
  };
}

// ../../node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
// ../../node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}
// ../../node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}
// ../../node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max5) {
  step = Math.abs(step), max5 = Math.abs(max5) - step;
  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
}
// ../../node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// ../../node_modules/d3-scale/src/linear.js
function linearish(scale8) {
  var domain = scale8.domain;
  scale8.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale8.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale8.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale8;
  };
  return scale8;
}
function linear2() {
  var scale8 = continuous();
  scale8.copy = function() {
    return copy7(scale8, linear2());
  };
  initRange.apply(scale8, arguments);
  return linearish(scale8);
}
// ../../node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
function vtkTexture(publicAPI, model) {
  model.classHierarchy.push("vtkTexture");
  publicAPI.imageLoaded = () => {
    model.image.removeEventListener("load", publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = (imageData) => {
    if (model.jsImageData === imageData) {
      return;
    }
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = (canvas) => {
    if (model.canvas === canvas) {
      return;
    }
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = (image) => {
    if (model.image === image) {
      return;
    }
    if (image !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
    }
    model.image = image;
    model.imageLoaded = false;
    if (image.complete) {
      publicAPI.imageLoaded();
    } else {
      image.addEventListener("load", publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = () => {
    let width = 0;
    let height = 0;
    let depth = 1;
    if (publicAPI.getInputData()) {
      const data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    const dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = () => {
    if (!model.imageLoaded || publicAPI.getInputData())
      return null;
    if (model.jsImageData) {
      return model.jsImageData();
    }
    if (model.canvas) {
      const context = model.canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      const canvas = document.createElement("canvas");
      canvas.width = model.image.width;
      canvas.height = model.image.height;
      const context = canvas.getContext("2d");
      context.translate(0, canvas.height);
      context.scale(1, -1);
      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      return imageData;
    }
    return null;
  };
}
var generateMipmaps = (nativeArray, width, height, level) => {
  const g3m = [1, 2, 1];
  const g3w = 4;
  const kernel = g3m;
  const kernelWeight = g3w;
  const hs = nativeArray.length / (width * height);
  let currentWidth = width;
  let currentHeight = height;
  let imageData = nativeArray;
  const maps = [imageData];
  for (let i = 0;i < level; i++) {
    const oldData = [...imageData];
    currentWidth /= 2;
    currentHeight /= 2;
    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
    const vs2 = hs * currentWidth;
    let shift = 0;
    for (let p = 0;p < imageData.length; p += hs) {
      if (p % vs2 === 0) {
        shift += 2 * hs * currentWidth;
      }
      for (let c = 0;c < hs; c++) {
        let sample = oldData[shift + c];
        sample += oldData[shift + hs + c];
        sample += oldData[shift - 2 * vs2 + c];
        sample += oldData[shift - 2 * vs2 + hs + c];
        sample /= 4;
        imageData[p + c] = sample;
      }
      shift += 2 * hs;
    }
    let dataCopy = [...imageData];
    for (let p = 0;p < imageData.length; p += hs) {
      for (let c = 0;c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0;
        for (let k = 0;k < kernel.length; k++) {
          let index2 = p + c + x * hs;
          const lineShift = index2 % vs2 - (p + c) % vs2;
          if (lineShift > hs)
            index2 += vs2;
          if (lineShift < -hs)
            index2 -= vs2;
          if (dataCopy[index2]) {
            value += dataCopy[index2] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    dataCopy = [...imageData];
    for (let p = 0;p < imageData.length; p += hs) {
      for (let c = 0;c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0;
        for (let k = 0;k < kernel.length; k++) {
          const index2 = p + c + x * vs2;
          if (dataCopy[index2]) {
            value += dataCopy[index2] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    maps.push(imageData);
  }
  return maps;
};
var DEFAULT_VALUES108 = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0,
  resizable: false
};
function extend112(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES108, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 6, 0);
  macro.get(publicAPI, model, ["canvas", "image", "jsImageData", "imageLoaded", "resizable"]);
  macro.setGet(publicAPI, model, ["repeat", "edgeClamp", "interpolate", "mipLevel"]);
  vtkTexture(publicAPI, model);
}
var newInstance110 = macro.newInstance(extend112, "vtkTexture");
var STATIC12 = {
  generateMipmaps
};
var vtkTexture$1 = {
  newInstance: newInstance110,
  extend: extend112,
  ...STATIC12
};

// ../../node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js
var faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
var faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
var edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
var edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
var faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];
var ptv3 = new Float64Array(3);
var pt2v3 = new Float64Array(3);
var tmpv3 = new Float64Array(3);
var tmp2v3 = new Float64Array(3);
var xDir = new Float64Array(3);
var yDir = new Float64Array(3);
var invmat = new Float64Array(16);
function applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultGenerateTicks(dataBounds) {
  const ticks2 = [];
  const tickStrings = [];
  for (let i = 0;i < 3; i++) {
    const scale8 = linear2().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
    ticks2[i] = scale8.ticks(5);
    const format2 = scale8.tickFormat(5);
    tickStrings[i] = ticks2[i].map(format2);
  }
  return {
    ticks: ticks2,
    tickStrings
  };
}
function vtkCubeAxesActorHelper(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActorHelper");
  publicAPI.setRenderable = (renderable) => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.tmActor.addTexture(model.renderable.getTmTexture());
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    publicAPI.modified();
  };
  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
    const value = model.renderable.get_tmAtlas().get(text);
    if (!value) {
      return;
    }
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const size = model.lastSize;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    exports_vec3.transformMat4(tmpv3, ptv3, cmat);
    tmpv3[0] += 0.1;
    exports_vec3.transformMat4(pt2v3, tmpv3, imat);
    exports_vec3.subtract(xDir, pt2v3, ptv3);
    tmpv3[0] -= 0.1;
    tmpv3[1] += 0.1;
    exports_vec3.transformMat4(pt2v3, tmpv3, imat);
    exports_vec3.subtract(yDir, pt2v3, ptv3);
    for (let i = 0;i < 3; i++) {
      xDir[i] /= 0.5 * 0.1 * size[0];
      yDir[i] /= 0.5 * 0.1 * size[1];
    }
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    if (dir[0] < -0.5) {
      exports_vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);
    } else if (dir[0] > 0.5) {
      exports_vec3.scale(tmpv3, xDir, dir[0] * offset);
    } else {
      exports_vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2);
    }
    exports_vec3.add(ptv3, ptv3, tmpv3);
    exports_vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2);
    exports_vec3.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    exports_vec3.scale(tmpv3, xDir, value.width);
    exports_vec3.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    exports_vec3.scale(tmpv3, yDir, value.height);
    exports_vec3.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    exports_vec3.scale(tmpv3, xDir, value.width);
    exports_vec3.subtract(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };
  publicAPI.updateTexturePolyData = () => {
    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
    exports_mat4.transpose(cmat, cmat);
    const numLabels = model.renderable.getTextValues().length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    exports_mat4.invert(invmat, cmat);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    let ptIdx = 0;
    let textIdx = 0;
    let axisIdx = 0;
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const textValues = model.renderable.getTextValues();
    while (ptIdx < coords.length / 3) {
      ptv3[0] = coords[ptIdx * 3];
      ptv3[1] = coords[ptIdx * 3 + 1];
      ptv3[2] = coords[ptIdx * 3 + 2];
      exports_vec3.transformMat4(tmpv3, ptv3, cmat);
      ptv3[0] = coords[ptIdx * 3 + 3];
      ptv3[1] = coords[ptIdx * 3 + 4];
      ptv3[2] = coords[ptIdx * 3 + 5];
      exports_vec3.transformMat4(tmp2v3, ptv3, cmat);
      exports_vec3.subtract(tmpv3, tmpv3, tmp2v3);
      const dir = [tmpv3[0], tmpv3[1]];
      normalize2D(dir);
      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
      ptIdx += 2;
      textIdx++;
      for (let t = 0;t < model.renderable.getTickCounts()[axisIdx]; t++) {
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
        ptIdx++;
        textIdx++;
      }
      axisIdx++;
    }
    const tcoordDA = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: "TextureCoordinates"
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    model.camera = camera;
    publicAPI.updateTexturePolyData();
  };
}
var newCubeAxesActorHelper = macro.newInstance(function(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);
  macro.obj(publicAPI, model);
  model.tmPolyData = vtkPolyData$1.newInstance();
  model.tmMapper = vtkMapper$1.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  macro.setGet(publicAPI, model, ["renderable"]);
  macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "axisTextStyle", "tickTextStyle", "tmActor", "ticks"]);
  model.forceUpdate = false;
  model.lastRedrawTime = {};
  macro.obj(model.lastRedrawTime, {
    mtime: 0
  });
  model.lastRebuildTime = {};
  macro.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.lastTickBounds = [];
  vtkCubeAxesActorHelper(publicAPI, model);
}, "vtkCubeAxesActorHelper");
function vtkCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActor");
  publicAPI.setCamera = (cam) => {
    if (model.camera === cam) {
      return;
    }
    if (model.cameraModifiedSub) {
      model.cameraModifiedSub.unsubscribe();
      model.cameraModifiedSub = null;
    }
    model.camera = cam;
    if (cam) {
      model.cameraModifiedSub = cam.onModified(publicAPI.update);
    }
    publicAPI.update();
    publicAPI.modified();
  };
  publicAPI.computeFacesToDraw = () => {
    const cmat = model.camera.getViewMatrix();
    exports_mat4.transpose(cmat, cmat);
    let changed = false;
    const length5 = vtkBoundingBox.getDiagonalLength(model.dataBounds);
    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180);
    for (let f = 0;f < 6; f++) {
      let drawit = false;
      const faceAxis = Math.floor(f / 2);
      const otherAxis1 = (faceAxis + 1) % 3;
      const otherAxis2 = (faceAxis + 2) % 3;
      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length5 * faceNormals[f][faceAxis];
        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
        exports_vec3.transformMat4(tmpv3, ptv3, cmat);
        ptv3[faceAxis] = model.dataBounds[f];
        exports_vec3.transformMat4(tmp2v3, ptv3, cmat);
        exports_vec3.subtract(tmpv3, tmp2v3, tmpv3);
        exports_vec3.normalize(tmpv3, tmpv3);
        drawit = tmpv3[2] > faceDot;
        if (!model.camera.getParallelProjection()) {
          exports_vec3.normalize(tmp2v3, tmp2v3);
          drawit = exports_vec3.dot(tmp2v3, tmpv3) > faceDot;
        }
      }
      if (drawit !== model.lastFacesToDraw[f]) {
        model.lastFacesToDraw[f] = drawit;
        changed = true;
      }
    }
    return changed;
  };
  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks2) => {
    let numPts = 0;
    let numLines = 0;
    numPts += 8;
    let numEdgesToDraw = 0;
    for (let e = 0;e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        numEdgesToDraw++;
      }
    }
    numLines += numEdgesToDraw;
    if (model.gridLines) {
      for (let f = 0;f < 6; f++) {
        if (facesToDraw[f]) {
          numPts += ticks2[faceAxes[f][0]].length * 2 + ticks2[faceAxes[f][1]].length * 2;
          numLines += ticks2[faceAxes[f][0]].length + ticks2[faceAxes[f][1]].length;
        }
      }
    }
    const points = new Float64Array(numPts * 3);
    const lines = new Uint32Array(numLines * 3);
    let ptIdx = 0;
    let lineIdx = 0;
    for (let z = 0;z < 2; z++) {
      for (let y = 0;y < 2; y++) {
        for (let x = 0;x < 2; x++) {
          points[ptIdx * 3] = model.dataBounds[x];
          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
          ptIdx++;
        }
      }
    }
    for (let e = 0;e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        lines[lineIdx * 3] = 2;
        lines[lineIdx * 3 + 1] = edgePoints[e][0];
        lines[lineIdx * 3 + 2] = edgePoints[e][1];
        lineIdx++;
      }
    }
    if (model.gridLines) {
      for (let f = 0;f < 6; f++) {
        if (facesToDraw[f]) {
          const faceIdx = Math.floor(f / 2);
          let aticks = ticks2[faceAxes[f][0]];
          for (let t = 0;t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
          aticks = ticks2[faceAxes[f][1]];
          for (let t = 0;t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
        }
      }
    }
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getLines().setData(lines, 1);
    model.polyData.getLines().modified();
    model.polyData.modified();
  };
  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks2, tickStrings) => {
    let textPointCount = 0;
    for (let e = 0;e < 12; e++) {
      if (edgesToDraw[e] === 1) {
        textPointCount += 2;
        textPointCount += ticks2[edgeAxes[e]].length;
      }
    }
    const points = model.polyData.getPoints().getData();
    const textPoints = new Float64Array(textPointCount * 3);
    let ptIdx = 0;
    let textIdx = 0;
    let axisCount = 0;
    for (let f = 0;f < 6; f++) {
      if (facesToDraw[f]) {
        for (let e = 0;e < 4; e++) {
          const edgeIdx = faceEdges[f][e];
          if (edgesToDraw[edgeIdx] === 1) {
            const edgeAxis = edgeAxes[edgeIdx];
            const ptIdx1 = edgePoints[edgeIdx][0] * 3;
            const ptIdx2 = edgePoints[edgeIdx][1] * 3;
            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
            ptIdx++;
            const faceIdx = Math.floor(f / 2);
            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
            ptIdx++;
            model.textValues[textIdx] = model.axisLabels[edgeAxis];
            textIdx++;
            const otherAxis1 = (edgeAxis + 1) % 3;
            const otherAxis2 = (edgeAxis + 2) % 3;
            const aticks = ticks2[edgeAxis];
            const atickStrings = tickStrings[edgeAxis];
            model.tickCounts[axisCount] = aticks.length;
            for (let t = 0;t < aticks.length; t++) {
              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
              ptIdx++;
              model.textValues[textIdx] = atickStrings[t];
              textIdx++;
            }
            axisCount++;
          }
        }
      }
    }
    model.textPolyData.getPoints().setData(textPoints, 3);
    model.textPolyData.modified();
  };
  publicAPI.update = () => {
    if (!model.camera) {
      return;
    }
    const facesChanged = publicAPI.computeFacesToDraw();
    const facesToDraw = model.lastFacesToDraw;
    let boundsChanged = false;
    for (let i = 0;i < 6; i++) {
      if (model.dataBounds[i] !== model.lastTickBounds[i]) {
        boundsChanged = true;
        model.lastTickBounds[i] = model.dataBounds[i];
      }
    }
    if (facesChanged || boundsChanged || model.forceUpdate) {
      const edgesToDraw = new Array(12).fill(0);
      for (let f = 0;f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0;e < 4; e++) {
            edgesToDraw[faceEdges[f][e]]++;
          }
        }
      }
      const t = model.generateTicks(model.dataBounds);
      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);
      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);
      if (boundsChanged || model.forceUpdate) {
        publicAPI.updateTextureAtlas(t.tickStrings);
      }
    }
    model.forceUpdate = false;
  };
  publicAPI.updateTextureAtlas = (tickStrings) => {
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model._tmAtlas.clear();
    let maxWidth = 0;
    let totalHeight = 1;
    for (let i = 0;i < 3; i++) {
      if (!model._tmAtlas.has(model.axisLabels[i])) {
        applyTextStyle(model.tmContext, model.axisTextStyle);
        const metrics = model.tmContext.measureText(model.axisLabels[i]);
        const entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.axisTextStyle
        };
        model._tmAtlas.set(model.axisLabels[i], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
      }
      applyTextStyle(model.tmContext, model.tickTextStyle);
      for (let t = 0;t < tickStrings[i].length; t++) {
        if (!model._tmAtlas.has(tickStrings[i][t])) {
          const metrics = model.tmContext.measureText(tickStrings[i][t]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          model._tmAtlas.set(tickStrings[i][t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
      }
    }
    maxWidth = nearestPowerOfTwo(maxWidth);
    totalHeight = nearestPowerOfTwo(totalHeight);
    model._tmAtlas.forEach((value) => {
      value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
    });
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
    model._tmAtlas.forEach((value, key) => {
      applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
  };
  publicAPI.onModified(() => {
    model.forceUpdate = true;
    publicAPI.update();
  });
  publicAPI.setTickTextStyle = (tickStyle) => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = (axisStyle) => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.get_tmAtlas = () => model._tmAtlas;
  publicAPI.getBounds = () => {
    publicAPI.update();
    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());
    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
    return model.bounds;
  };
  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);
  publicAPI.setProperty = (p) => _setProp(p)[0];
}
function defaultValues3(publicAPI, model, initialValues) {
  return {
    boundsScaleFactor: 1.3,
    camera: null,
    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],
    faceVisibilityAngle: 8,
    gridLines: true,
    axisLabels: null,
    axisTitlePixelOffset: 35,
    tickLabelPixelOffset: 12,
    generateTicks: defaultGenerateTicks,
    ...initialValues,
    axisTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 18,
      fontFamily: "serif",
      ...initialValues?.axisTextStyle
    },
    tickTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 14,
      fontFamily: "serif",
      ...initialValues?.tickTextStyle
    }
  };
}
function extend113(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  vtkActor$1.extend(publicAPI, model, defaultValues3(publicAPI, model, initialValues));
  model.lastFacesToDraw = [false, false, false, false, false, false];
  model.axisLabels = ["X-Axis", "Y-Axis", "Z-Axis"];
  model.tickCounts = [];
  model.textValues = [];
  model.lastTickBounds = [];
  model.tmCanvas = document.createElement("canvas");
  model.tmContext = model.tmCanvas.getContext("2d");
  model._tmAtlas = new Map;
  model.tmTexture = vtkTexture$1.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  publicAPI.getProperty().setDiffuse(0);
  publicAPI.getProperty().setAmbient(1);
  model.gridMapper = vtkMapper$1.newInstance();
  model.polyData = vtkPolyData$1.newInstance();
  model.gridMapper.setInputData(model.polyData);
  model.gridActor = vtkActor$1.newInstance();
  model.gridActor.setMapper(model.gridMapper);
  model.gridActor.setProperty(publicAPI.getProperty());
  model.gridActor.setParentProp(publicAPI);
  model.textPolyData = vtkPolyData$1.newInstance();
  macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "boundsScaleFactor", "faceVisibilityAngle", "gridLines", "tickLabelPixelOffset", "generateTicks"]);
  macro.setGetArray(publicAPI, model, ["dataBounds"], 6);
  macro.setGetArray(publicAPI, model, ["axisLabels"], 3);
  macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle", "camera", "tmTexture", "textValues", "textPolyData", "tickCounts", "gridActor"]);
  vtkCubeAxesActor(publicAPI, model);
}
var newInstance111 = macro.newInstance(extend113, "vtkCubeAxesActor");
var vtkCubeAxesActor$1 = {
  newInstance: newInstance111,
  extend: extend113,
  newCubeAxesActorHelper,
  defaultGenerateTicks
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js
function vtkOpenGLCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES109 = {};
function extend114(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES109, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkOpenGLCubeAxesActor(publicAPI, model);
}
var newInstance112 = newInstance(extend114, "vtkOpenGLCubeAxesActor");
registerOverride("vtkCubeAxesActor", newInstance112);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper2D.js
var {
  ColorMode: ColorMode4,
  ScalarMode: ScalarMode4,
  GetArray: GetArray3
} = Constants10;
function vtkMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkMapper2D");
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode4, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode4, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode4.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode4.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode4.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode4.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray3.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode4.USE_CELL_FIELD_DATA) {
      const cd2 = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray3.BY_ID) {
        scalars = cd2.getArrayByIndex(arrayId);
      } else {
        scalars = cd2.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode4.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray3.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.mapScalars = (input, alpha) => {
    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorMapColors = null;
      return;
    }
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString)
      return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
}
var DEFAULT_VALUES110 = {
  static: false,
  lookupTable: null,
  scalarVisibility: false,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  renderTime: 0,
  colorByArrayName: null,
  transformCoordinate: null,
  viewSpecificProperties: null,
  customShaderAttributes: []
};
function extend115(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES110, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorMapColors"]);
  macro.setGet(publicAPI, model, [
    "arrayAccessMode",
    "colorByArrayName",
    "colorMode",
    "lookupTable",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "transformCoordinate",
    "useLookupTableScalarRange",
    "viewSpecificProperties",
    "customShaderAttributes"
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }
  vtkMapper2D(publicAPI, model);
}
var newInstance113 = macro.newInstance(extend115, "vtkMapper2D");
var vtkMapper2D$1 = {
  newInstance: newInstance113,
  extend: extend115
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
var vtkPolyData2DFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

uniform int PrimitiveIDOffset;

// Texture coordinates
//VTK::TCoord::Dec

// Scalar coloring
//VTK::Color::Dec

// Depth Peeling
//VTK::DepthPeeling::Dec

// picking support
//VTK::Picking::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Color::Impl
  //VTK::TCoord::Impl

  //VTK::DepthPeeling::Impl
  //VTK::Picking::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
var vtkPolyData2DVS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyData2DVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model Coordinates
// WC - WC world coordinates
// VC - View Coordinates
// DC - Display Coordinates

in vec4 vertexWC;

// frag position in VC
//VTK::PositionVC::Dec

// material property values
//VTK::Color::Dec

// Texture coordinates
//VTK::TCoord::Dec

// Apple Bug
//VTK::PrimID::Dec

uniform mat4 WCVCMatrix;  // World to view matrix

void main()
{
  // Apple Bug
  //VTK::PrimID::Impl

  gl_Position = WCVCMatrix*vertexWC;

  //VTK::TCoord::Impl

  //VTK::Color::Impl

  //VTK::PositionVC::Impl
}
`;

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
var DisplayLocation = {
  BACKGROUND: 0,
  FOREGROUND: 1
};
var Constants19 = {
  DisplayLocation
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js
var {
  primTypes: primTypes3
} = vtkHelper;
var {
  ScalarMode: ScalarMode5
} = vtkMapper2D$1;
var {
  vtkErrorMacro: vtkErrorMacro40
} = macro$1;
var StartEvent3 = {
  type: "StartEvent"
};
var EndEvent3 = {
  type: "EndEvent"
};
function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLActor2D = publicAPI.getFirstAncestorOfType("vtkOpenGLActor2D");
      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };
  publicAPI.overlayPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyData2DVS;
    shaders.Fragment = vtkPolyData2DFS;
    shaders.Geometry = "";
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes3.Start;i < primTypes3.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor2D.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent3);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent3);
    if (!model.currentInput) {
      vtkErrorMacro40("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    if (model._openGLRenderer.getSelector()) {
      switch (model._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      if ((scalarMode === ScalarMode5.USE_CELL_DATA || scalarMode === ScalarMode5.USE_CELL_FIELD_DATA || scalarMode === ScalarMode5.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode5.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor2D.getActiveTextures()) {
      tcoords = null;
    }
    const transformCoordinate = model.renderable.getTransformCoordinate();
    const view = ren.getRenderWindow().getViews()[0];
    const vsize = view.getViewportSize(ren);
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${c ? c.getMTime() : 1}` + `D${tcoords ? tcoords.getMTime() : 1}` + `E${transformCoordinate ? ren.getMTime() : 1}` + `F${vsize}`;
    if (model.VBOBuildString !== toString) {
      let points = poly.getPoints();
      if (transformCoordinate) {
        const p = vtkPoints$1.newInstance();
        const numPts = points.getNumberOfPoints();
        p.setNumberOfPoints(numPts);
        const point = [];
        for (let i = 0;i < numPts; ++i) {
          points.getPoint(i, point);
          transformCoordinate.setValue(point);
          const v = transformCoordinate.getComputedDoubleViewportValue(ren);
          p.setPoint(i, v[0], v[1], 0);
        }
        points = p;
      }
      const options = {
        points,
        tcoords,
        colors: c,
        cellOffset: 0,
        haveCellScalars: model.haveCellSCalars,
        customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
      };
      options.cellOffset += model.primitives[primTypes3.Points].getCABO().createVBO(poly.getVerts(), "verts", representation, options);
      options.cellOffset += model.primitives[primTypes3.Lines].getCABO().createVBO(poly.getLines(), "lines", representation, options);
      options.cellOffset += model.primitives[primTypes3.Tris].getCABO().createVBO(poly.getPolys(), "polys", representation, options);
      options.cellOffset += model.primitives[primTypes3.TriStrips].getCABO().createVBO(poly.getStrips(), "strips", representation, options);
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    gl.depthMask(true);
    for (let i = primTypes3.Start;i < primTypes3.End; i++) {
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.lastBoundBO = model.primitives[i];
        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.lastBoundBO) {
      model.lastBoundBO.getVAO().release();
    }
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    if (model.haveCellScalars) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", ["uniform samplerBuffer texture1;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", ["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["in vec4 diffuseColor;", "out vec4 fcolorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["fcolorVSOutput = diffuseColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", [`in vec4 fcolorVSOutput[];
`, "out vec4 fcolorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["fcolorGSOutput = fcolorVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", ["in vec4 fcolorVSOutput;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", ["gl_FragData[0] = fcolorVSOutput;"]).result;
    } else {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", ["uniform vec4 diffuseColor;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", ["gl_FragData[0] = diffuseColor;"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
      if (tcdim === 1) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in float tcoordMC;", "out float tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", [`in float tcoordVCVSOutput[];
`, "out float tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, ["//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result;
      } else if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordMC;", "out vec2 tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", [`in vec2 tcoordVCVSOutput[];
`, "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", ["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result;
      }
      if (model.haveCellScalars) {
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PrimID::Impl", ["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform vec3 mapperIndex;", "uniform int picking;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isAttributeUsed("vertexWC")) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
        vtkErrorMacro40("Error setting vertexWC in shader VAO.");
      }
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro40(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro40("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
        cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
      }
      const tus = model.openGLActor2D.getActiveTextures();
      if (tus) {
        for (let index2 = 0;index2 < tus.length; ++index2) {
          const tex = tus[index2];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
      cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const c = model.renderable.getColorMapColors();
    if (!c || c.getNumberOfComponents() === 0) {
      const program = cellBO.getProgram();
      const ppty = actor.getProperty();
      const opacity = ppty.getOpacity();
      const dColor = ppty.getColor();
      const diffuseColor = [dColor[0], dColor[1], dColor[2], opacity];
      program.setUniform4f("diffuseColor", diffuseColor);
    }
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
  };
  function safeMatrixMultiply2(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index2) => {
      if (index2 === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const view = ren.getRenderWindow().getViews()[0];
    const size = view.getViewportSize(ren);
    const vport = ren.getViewport();
    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);
    const tileViewport = [0, 0, 1, 1];
    const visVP = [0, 0, 1, 1];
    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
    if (visVP[0] >= visVP[2]) {
      return;
    }
    if (visVP[1] >= visVP[3]) {
      return;
    }
    size[0] = round(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
    size[1] = round(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
    const winSize = model._openGLRenderer.getParent().getSize();
    const xoff = round(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
    const yoff = round(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);
    const left = -xoff;
    let right = -xoff + size[0];
    const bottom = -yoff;
    let top = -yoff + size[1];
    if (left === right) {
      right = left + 1;
    }
    if (bottom === top) {
      top = bottom + 1;
    }
    const tmpMat42 = exports_mat4.identity(new Float64Array(16));
    tmpMat42[0] = 2 / (right - left);
    tmpMat42[1 * 4 + 1] = 2 / (top - bottom);
    tmpMat42[0 * 4 + 3] = -1 * (right + left) / (right - left);
    tmpMat42[1 * 4 + 3] = -1 * (top + bottom) / (top - bottom);
    tmpMat42[2 * 4 + 2] = 0;
    tmpMat42[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1 : 1;
    tmpMat42[3 * 4 + 3] = 1;
    exports_mat4.transpose(tmpMat42, tmpMat42);
    program.setUniformMatrix("WCVCMatrix", safeMatrixMultiply2([tmpMat42, inverseShiftScaleMatrix], exports_mat4, model.tmpMat4));
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES111 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null
};
function extend116(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES111, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes3;
  model.tmpMat4 = exports_mat4.identity(new Float64Array(16));
  for (let i = primTypes3.Start;i < primTypes3.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper2D(publicAPI, model);
}
var newInstance114 = newInstance(extend116, "vtkOpenGLPolyDataMapper2D");
registerOverride("vtkMapper2D", newInstance114);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js
var {
  VectorMode: VectorMode4
} = vtkScalarsToColors$1;
function applyTextStyle2(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultAutoLayout(publicAPI, model) {
  return (helper) => {
    const lastSize = helper.getLastSize();
    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
    const axisTextStyle = helper.getAxisTextStyle();
    const tickTextStyle = helper.getTickTextStyle();
    Object.assign(axisTextStyle, model.axisTextStyle);
    Object.assign(tickTextStyle, model.tickTextStyle);
    axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
    if (helper.getLastAspectRatio() > 1) {
      tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
    } else {
      tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
    }
    const textSizes = helper.updateTextureAtlas();
    helper.setTopTitle(false);
    const boxSize = helper.getBoxSizeByReference();
    if (helper.getLastAspectRatio() > 1) {
      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);
      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
        helper.setTopTitle(true);
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
      } else {
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
      }
      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
    } else {
      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
      const titleHeight = 2 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];
      const tickWidth = 2 * textSizes.tickWidth / lastSize[0];
      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
      boxSize[1] = titleHeight;
      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
    }
    helper.recomputeBarSegments(textSizes);
  };
}
function defaultGenerateTicks2(publicApi, model) {
  return (helper) => {
    const lastTickBounds = helper.getLastTickBounds();
    const scale8 = linear2().domain([lastTickBounds[0], lastTickBounds[1]]);
    const ticks2 = scale8.ticks(5);
    const format2 = scale8.tickFormat(5);
    helper.setTicks(ticks2);
    helper.setTickStrings(ticks2.map(format2));
  };
}
function vtkScalarBarActorHelper(publicAPI, model) {
  model.classHierarchy.push("vtkScalarBarActorHelper");
  publicAPI.setRenderable = (renderable) => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.barActor.setProperty(renderable.getProperty());
    model.barActor.setParentProp(renderable);
    model.barActor.setCoordinateSystemToDisplay();
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    model.tmActor.setCoordinateSystemToDisplay();
    model.generateTicks = renderable.generateTicks;
    model.axisTextStyle = {
      ...renderable.getAxisTextStyle()
    };
    model.tickTextStyle = {
      ...renderable.getTickTextStyle()
    };
    publicAPI.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    const scalarsToColors = model.renderable.getScalarsToColors();
    if (!scalarsToColors || !model.renderable.getVisibility()) {
      return;
    }
    model.barMapper.setLookupTable(scalarsToColors);
    model.camera = camera;
    model.renderWindow = renderWindow;
    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
      const range = scalarsToColors.getMappingRange();
      model.lastTickBounds = [...range];
      model.renderable.getGenerateTicks()(publicAPI);
      if (model.renderable.getAutomated()) {
        model.renderable.getAutoLayout()(publicAPI);
      } else {
        model.axisTextStyle = {
          ...model.renderable.getAxisTextStyle()
        };
        model.tickTextStyle = {
          ...model.renderable.getTickTextStyle()
        };
        model.barPosition = [...model.renderable.getBarPosition()];
        model.barSize = [...model.renderable.getBarSize()];
        model.boxPosition = [...model.renderable.getBoxPosition()];
        model.boxSize = [...model.renderable.getBoxSize()];
        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();
        const textSizes = publicAPI.updateTextureAtlas();
        publicAPI.recomputeBarSegments(textSizes);
      }
      publicAPI.updatePolyDataForLabels();
      publicAPI.updatePolyDataForBarSegments();
      model.lastRebuildTime.modified();
      model.forceUpdate = false;
    }
  };
  publicAPI.updateTextureAtlas = () => {
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    const results = {};
    const newTmAtlas = new Map;
    let maxWidth = 0;
    let totalHeight = 1;
    applyTextStyle2(model.tmContext, model.axisTextStyle);
    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
    let entry = {
      height: metrics.actualBoundingBoxAscent + 2,
      startingHeight: totalHeight,
      width: metrics.width + 2,
      textStyle: model.axisTextStyle
    };
    newTmAtlas.set(model.renderable.getAxisLabel(), entry);
    totalHeight += entry.height;
    maxWidth = entry.width;
    results.titleWidth = entry.width;
    results.titleHeight = entry.height;
    results.tickWidth = 0;
    results.tickHeight = 0;
    applyTextStyle2(model.tmContext, model.tickTextStyle);
    const strings = [...publicAPI.getTickStrings(), "NaN", "Below", "Above"];
    for (let t = 0;t < strings.length; t++) {
      if (!newTmAtlas.has(strings[t])) {
        metrics = model.tmContext.measureText(strings[t]);
        entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.tickTextStyle
        };
        newTmAtlas.set(strings[t], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
        if (results.tickWidth < entry.width) {
          results.tickWidth = entry.width;
        }
        if (results.tickHeight < entry.height) {
          results.tickHeight = entry.height;
        }
      }
    }
    maxWidth = nearestPowerOfTwo(maxWidth);
    totalHeight = nearestPowerOfTwo(totalHeight);
    newTmAtlas.forEach((value) => {
      value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
    });
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
    newTmAtlas.forEach((value, key) => {
      applyTextStyle2(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
    model._tmAtlas = newTmAtlas;
    return results;
  };
  publicAPI.computeBarSize = (textSizes) => {
    model.vertical = model.boxSize[1] > model.boxSize[0];
    const tickHeight = 2 * textSizes.tickHeight / model.lastSize[1];
    const segSize = [1, 1];
    if (model.vertical) {
      const tickWidth = 2 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
      if (model.topTitle) {
        const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0] - tickWidth;
        model.barSize[1] = model.boxSize[1] - titleHeight;
      } else {
        const titleWidth = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
        model.barSize[1] = model.boxSize[1];
      }
      model.barPosition[0] = model.boxPosition[0] + tickWidth;
      model.barPosition[1] = model.boxPosition[1];
      segSize[1] = tickHeight;
    } else {
      const tickWidth = (2 * textSizes.tickWidth - 8) / model.lastSize[0];
      const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
      model.barSize[0] = model.boxSize[0];
      model.barPosition[0] = model.boxPosition[0];
      model.barSize[1] = model.boxSize[1] - titleHeight;
      model.barPosition[1] = model.boxPosition[1];
      segSize[0] = tickWidth;
    }
    return segSize;
  };
  publicAPI.recomputeBarSegments = (textSizes) => {
    const segSize = publicAPI.computeBarSize(textSizes);
    model.barSegments = [];
    const startPos = [0, 0];
    const barAxis = model.vertical ? 1 : 0;
    const segSpace = model.vertical ? 0.01 : 0.02;
    function pushSeg(title, scalars) {
      model.barSegments.push({
        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
        scalars,
        title
      });
      startPos[barAxis] += segSize[barAxis] + segSpace;
    }
    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
      pushSeg("NaN", [NaN, NaN, NaN, NaN]);
    }
    if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {
      pushSeg("Below", [-0.1, -0.1, -0.1, -0.1]);
    }
    const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();
    startPos[barAxis] += segSpace;
    const oldSegSize = segSize[barAxis];
    segSize[barAxis] = haveAbove ? 1 - 2 * segSpace - segSize[barAxis] - startPos[barAxis] : 1 - segSpace - startPos[barAxis];
    pushSeg("ticks", model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
      segSize[barAxis] = oldSegSize;
      startPos[barAxis] += segSpace;
      pushSeg("Above", [1.1, 1.1, 1.1, 1.1]);
    }
  };
  const tmp2v32 = new Float64Array(3);
  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
    const value = model._tmAtlas.get(text);
    if (!value) {
      return;
    }
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    tmp2v32[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
    tmp2v32[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
    tmp2v32[2] = pos[2];
    tmp2v32[0] += offset[0];
    tmp2v32[1] += offset[1];
    const textSize = [];
    const textAxes = orientation === "vertical" ? [1, 0] : [0, 1];
    if (orientation === "vertical") {
      textSize[0] = value.width;
      textSize[1] = -value.height;
      if (alignment[0] === "middle") {
        tmp2v32[1] -= value.width / 2;
      } else if (alignment[0] === "right") {
        tmp2v32[1] -= value.width;
      }
      if (alignment[1] === "middle") {
        tmp2v32[0] += value.height / 2;
      } else if (alignment[1] === "top") {
        tmp2v32[0] += value.height;
      }
    } else {
      textSize[0] = value.width;
      textSize[1] = value.height;
      if (alignment[0] === "middle") {
        tmp2v32[0] -= value.width / 2;
      } else if (alignment[0] === "right") {
        tmp2v32[0] -= value.width;
      }
      if (alignment[1] === "middle") {
        tmp2v32[1] -= value.height / 2;
      } else if (alignment[1] === "top") {
        tmp2v32[1] -= value.height;
      }
    }
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    tmp2v32[textAxes[0]] += textSize[0];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    tmp2v32[textAxes[1]] += textSize[1];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    tmp2v32[textAxes[0]] -= textSize[0];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };
  const tmpv32 = new Float64Array(3);
  publicAPI.updatePolyDataForLabels = () => {
    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    const offsetAxis = model.vertical ? 0 : 1;
    const spacedAxis = model.vertical ? 1 : 0;
    tmpv32[2] = -0.99;
    const alignment = model.vertical ? ["right", "middle"] : ["middle", "bottom"];
    let dir = [0, 1];
    const tickOffsets = [0, 0];
    if (model.vertical) {
      tickOffsets[0] = -model.tickLabelPixelOffset;
      if (model.topTitle) {
        tmpv32[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
        tmpv32[1] = model.barPosition[1] + model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
      } else {
        tmpv32[0] = model.barPosition[0] + model.barSize[0];
        tmpv32[1] = model.barPosition[1] + 0.5 * model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "top"], "vertical", [model.axisTitlePixelOffset, 0], results);
      }
      dir = [-1, 0];
    } else {
      tickOffsets[1] = model.tickLabelPixelOffset;
      tmpv32[0] = model.barPosition[0] + 0.5 * model.barSize[0];
      tmpv32[1] = model.barPosition[1] + model.barSize[1];
      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
    }
    tmpv32[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
    tmpv32[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;
    let tickSeg = null;
    for (let i = 0;i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      if (seg.title === "ticks") {
        tickSeg = seg;
      } else {
        tmpv32[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
        publicAPI.createPolyDataForOneLabel(seg.title, tmpv32, alignment, "horizontal", tickOffsets, results);
      }
    }
    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
    const ticks2 = publicAPI.getTicks();
    const tickStrings = publicAPI.getTickStrings();
    for (let t = 0;t < ticks2.length; t++) {
      const tickPos = (ticks2[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
      tmpv32[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv32, alignment, "horizontal", tickOffsets, results);
    }
    const tcoordDA = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: "TextureCoordinates"
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updatePolyDataForBarSegments = () => {
    const scalarsToColors = model.renderable.getScalarsToColors();
    let numberOfExtraColors = 0;
    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    const numPts = 4 * (1 + numberOfExtraColors);
    const numQuads = numPts;
    let numComps = 1;
    if (scalarsToColors.getVectorMode() === VectorMode4.COMPONENT) {
      numComps = scalarsToColors.getVectorComponent() + 1;
    }
    const points = new Float64Array(numPts * 3);
    const cells = new Uint16Array(numQuads * 5);
    const scalars = new Float32Array(numPts * numComps);
    let ptIdx = 0;
    let cellIdx = 0;
    for (let i = 0;i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      for (let e = 0;e < 4; e++) {
        tmpv32[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
        tmpv32[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
        points[ptIdx * 3] = (0.5 * tmpv32[0] + 0.5) * model.lastSize[0];
        points[ptIdx * 3 + 1] = (0.5 * tmpv32[1] + 0.5) * model.lastSize[1];
        points[ptIdx * 3 + 2] = tmpv32[2];
        for (let nc = 0;nc < numComps; nc++) {
          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
        }
        ptIdx++;
      }
      cells[cellIdx * 5] = 4;
      cells[cellIdx * 5 + 1] = ptIdx - 4;
      cells[cellIdx * 5 + 2] = ptIdx - 3;
      cells[cellIdx * 5 + 3] = ptIdx - 2;
      cells[cellIdx * 5 + 4] = ptIdx - 1;
      cellIdx++;
    }
    const scalarsDA = vtkDataArray$1.newInstance({
      numberOfComponents: numComps,
      values: scalars,
      name: "Scalars"
    });
    model.polyData.getPointData().setScalars(scalarsDA);
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getPolys().setData(cells, 1);
    model.polyData.getPolys().modified();
    model.polyData.modified();
  };
}
var newScalarBarActorHelper = macro.newInstance(function(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "tickLabelPixelOffset", "renderable", "topTitle", "ticks", "tickStrings"]);
  macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "lastTickBounds", "axisTextStyle", "tickTextStyle", "barActor", "tmActor"]);
  macro.getArray(publicAPI, model, ["boxPosition", "boxSize"]);
  macro.setArray(publicAPI, model, ["boxPosition", "boxSize"], 2);
  model.forceUpdate = false;
  model.lastRebuildTime = {};
  macro.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.tmCanvas = document.createElement("canvas");
  model.tmContext = model.tmCanvas.getContext("2d");
  model._tmAtlas = new Map;
  model.barMapper = vtkMapper$1.newInstance();
  model.barMapper.setInterpolateScalarsBeforeMapping(true);
  model.barMapper.setUseLookupTableScalarRange(true);
  model.polyData = vtkPolyData$1.newInstance();
  model.barMapper.setInputData(model.polyData);
  model.barActor = vtkActor$1.newInstance();
  model.barActor.setMapper(model.barMapper);
  model.tmPolyData = vtkPolyData$1.newInstance();
  model.tmMapper = vtkMapper$1.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmTexture = vtkTexture$1.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  model.tmActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  model.tmActor.addTexture(model.tmTexture);
  model.barPosition = [0, 0];
  model.barSize = [0, 0];
  model.boxPosition = [0.88, -0.92];
  model.boxSize = [0.1, 1.1];
  model.lastTickBounds = [];
  vtkScalarBarActorHelper(publicAPI, model);
}, "vtkScalarBarActorHelper");
function vtkScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkScalarBarActor");
  publicAPI.setTickTextStyle = (tickStyle) => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = (axisStyle) => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.resetAutoLayoutToDefault = () => {
    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
  };
  publicAPI.resetGenerateTicksToDefault = () => {
    publicAPI.setGenerateTicks(defaultGenerateTicks2());
  };
}
function defaultValues4(initialValues) {
  return {
    automated: true,
    autoLayout: null,
    axisLabel: "Scalar Value",
    barPosition: [0, 0],
    barSize: [0, 0],
    boxPosition: [0.88, -0.92],
    boxSize: [0.1, 1.1],
    scalarToColors: null,
    axisTitlePixelOffset: 36,
    axisTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 18,
      fontFamily: "serif"
    },
    tickLabelPixelOffset: 14,
    tickTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 14,
      fontFamily: "serif"
    },
    generateTicks: null,
    drawNanAnnotation: true,
    drawBelowRangeSwatch: true,
    drawAboveRangeSwatch: true,
    ...initialValues
  };
}
function extend117(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues4(initialValues));
  if (!model.autoLayout)
    model.autoLayout = defaultAutoLayout(publicAPI, model);
  if (!model.generateTicks)
    model.generateTicks = defaultGenerateTicks2();
  vtkActor$1.extend(publicAPI, model, initialValues);
  publicAPI.getProperty().setDiffuse(0);
  publicAPI.getProperty().setAmbient(1);
  macro.setGet(publicAPI, model, ["automated", "autoLayout", "axisTitlePixelOffset", "axisLabel", "scalarsToColors", "tickLabelPixelOffset", "generateTicks", "drawNanAnnotation", "drawBelowRangeSwatch", "drawAboveRangeSwatch"]);
  macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle"]);
  macro.getArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"]);
  macro.setArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"], 2);
  vtkScalarBarActor(publicAPI, model);
}
var newInstance115 = macro.newInstance(extend117, "vtkScalarBarActor");
var vtkScalarBarActor$1 = {
  newInstance: newInstance115,
  extend: extend117,
  newScalarBarActorHelper
};

// ../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js
function vtkOpenGLScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES112 = {};
function extend118(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES112, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkOpenGLScalarBarActor(publicAPI, model);
}
var newInstance116 = newInstance(extend118, "vtkOpenGLScalarBarActor");
registerOverride("vtkScalarBarActor", newInstance116);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js
var {
  CoordinateSystem: CoordinateSystem4
} = vtkProp$1;
function vtkWebGPUActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      model.bufferShift[0] = mcwc[3];
      model.bufferShift[1] = mcwc[7];
      model.bufferShift[2] = mcwc[11];
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      exports_mat4.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        exports_mat4.identity(model.keyMatrices.normalMatrix);
      } else {
        exports_mat4.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        exports_mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        exports_mat4.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      exports_mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
        exports_mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        exports_mat4.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES113 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};
function extend119(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES113, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor(publicAPI, model);
}
var newInstance117 = macro.newInstance(extend119);
registerOverride3("vtkActor", newInstance117);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js
var {
  CoordinateSystem: CoordinateSystem5
} = vtkProp$1;
function vtkWebGPUActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.bufferShift[0] = 0;
      model.bufferShift[1] = 0;
      model.bufferShift[2] = 0;
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      exports_mat4.identity(model.keyMatrices.bcwc);
      exports_mat4.identity(model.keyMatrices.normalMatrix);
      exports_mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
        exports_mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        exports_mat4.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES114 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};
function extend120(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES114, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor2D(publicAPI, model);
}
var newInstance118 = macro.newInstance(extend120);
registerOverride3("vtkActor2D", newInstance118);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js
function vtkWebGPUCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES115 = {};
function extend121(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES115, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkWebGPUCubeAxesActor(publicAPI, model);
}
var newInstance119 = newInstance(extend121, "vtkWebGPUCubeAxesActor");
registerOverride3("vtkCubeAxesActor", newInstance119);

// ../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js
var {
  DisplayLocation: DisplayLocation2
} = Constants19;
function vtkProperty2D(publicAPI, model) {
  model.classHierarchy.push("vtkProperty2D");
  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation2.BACKGROUND);
  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation2.FOREGROUND);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation, model.representation);
}
var DEFAULT_VALUES116 = {
  color: [1, 1, 1],
  opacity: 1,
  pointSize: 1,
  lineWidth: 1,
  representation: Representation.SURFACE,
  displayLocation: DisplayLocation2.FOREGROUND
};
function extend122(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES116, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["opacity", "lineWidth", "pointSize", "displayLocation", "representation"]);
  macro.setGetArray(publicAPI, model, ["color"], 3);
  vtkProperty2D(publicAPI, model);
}
var newInstance120 = macro.newInstance(extend122, "vtkProperty2D");
var vtkProperty2D$1 = {
  newInstance: newInstance120,
  extend: extend122,
  ...Constants19
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js
var {
  BufferUsage: BufferUsage5,
  PrimitiveTypes: PrimitiveTypes3
} = vtkWebGPUBufferManager$1;
var {
  Representation: Representation7
} = vtkProperty$1;
var {
  ScalarMode: ScalarMode6
} = vtkMapper$1;
var {
  CoordinateSystem: CoordinateSystem6
} = vtkProp$1;
var {
  DisplayLocation: DisplayLocation3
} = vtkProperty2D$1;
var vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var pi: f32 = 3.14159265359; 
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var pi: f32 = 3.14159265359; 

  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;
  
  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  
  var L: vec3<f32> = normalize(direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf*incoming*angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); 
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// TODO: find some way to reduce the number of arguments going in here
fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = color * (1.0 / (dist*dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  
  // Cones.x is the inner phi and cones.y is the outer phi
  var theta: f32 = mdot(normalize(direction), L);
  var epsilon: f32 = cones.x - cones.y;
  var intensity: f32 = (theta - cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist*dist;

  var incoming: vec3<f32> = color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
function isEdges(hash) {
  return hash.indexOf("edge") >= 0;
}
function vtkWebGPUCellArrayMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCellArrayMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (model.is2D) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
        model.forceZValue = true;
      } else {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
        model.forceZValue = false;
      }
      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem6.DISPLAY;
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.updateUBO = () => {
    const actor = model.WebGPUActor.getRenderable();
    const ppty = actor.getProperty();
    const utime = model.UBO.getSendTime();
    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
      model.UBO.setArray("BCWCMatrix", keyMats.bcwc);
      model.UBO.setArray("BCSCMatrix", keyMats.bcsc);
      model.UBO.setArray("MCWCNormals", keyMats.normalMatrix);
      if (model.is2D) {
        model.UBO.setValue("ZValue", model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation3.FOREGROUND ? 1 : 0);
        const aColor2 = ppty.getColorByReference();
        model.UBO.setValue("AmbientIntensity", 1);
        model.UBO.setArray("DiffuseColor", [aColor2[0], aColor2[1], aColor2[2], 1]);
        model.UBO.setValue("DiffuseIntensity", 0);
        model.UBO.setValue("SpecularIntensity", 0);
      } else {
        let aColor2 = ppty.getAmbientColorByReference();
        model.UBO.setValue("AmbientIntensity", ppty.getAmbient());
        model.UBO.setArray("AmbientColor", [aColor2[0], aColor2[1], aColor2[2], 1]);
        model.UBO.setValue("DiffuseIntensity", ppty.getDiffuse());
        aColor2 = ppty.getDiffuseColorByReference();
        model.UBO.setArray("DiffuseColor", [aColor2[0], aColor2[1], aColor2[2], 1]);
        model.UBO.setValue("Roughness", ppty.getRoughness());
        model.UBO.setValue("BaseIOR", ppty.getBaseIOR());
        model.UBO.setValue("Metallic", ppty.getMetallic());
        model.UBO.setValue("NormalStrength", ppty.getNormalStrength());
        model.UBO.setValue("Emission", ppty.getEmission());
        model.UBO.setValue("SpecularIntensity", ppty.getSpecular());
        aColor2 = ppty.getSpecularColorByReference();
        model.UBO.setArray("SpecularColor", [aColor2[0], aColor2[1], aColor2[2], 1]);
      }
      const aColor = ppty.getEdgeColorByReference?.();
      if (aColor) {
        model.UBO.setArray("EdgeColor", [aColor[0], aColor[1], aColor[2], 1]);
      }
      model.UBO.setValue("LineWidth", ppty.getLineWidth());
      model.UBO.setValue("Opacity", ppty.getOpacity());
      model.UBO.setValue("PropID", model.WebGPUActor.getPropID());
      const device = model.WebGPURenderWindow.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.haveWideLines = () => {
    const actor = model.WebGPUActor.getRenderable();
    const representation = actor.getProperty().getRepresentation();
    if (actor.getProperty().getLineWidth() <= 1) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes3.Verts) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes3.Triangles || model.primitiveType === PrimitiveTypes3.TriangleStrips) {
      return representation === Representation7.WIREFRAME;
    }
    return true;
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    if (!vDesc.hasOutput("vertexVC"))
      vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    if (model.useRendererMatrix) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;", "    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);", "pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;", "    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;", "    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;", "    pCoord.z = 0.5 - 0.5 * pCoord.z;", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    }
    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex");
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", [
        "    var tmpPos: vec4<f32> = pCoord;",
        "    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);",
        "    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;",
        "    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;",
        "    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;",
        "    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;",
        "    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);",
        "    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
        "//VTK::Position::Impl"
      ]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = pCoord;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const normalBuffer = vertexInput.getBuffer("normalMC");
    const actor = model.WebGPUActor.getRenderable();
    if (normalBuffer) {
      const vDesc = pipeline.getShaderDescription("vertex");
      if (!vDesc.hasOutput("normalVC")) {
        vDesc.addOutput("vec3<f32>", "normalVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("tangentVC")) {
        vDesc.addOutput("vec3<f32>", "tangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("bitangentVC")) {
        vDesc.addOutput("vec3<f32>", "bitangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [
        "  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);",
        "  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));",
        "  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));",
        "  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));",
        "  output.tangentVC = normalize(tangent);",
        "  output.bitangentVC = normalize(cross(output.normalVC, tangent));"
      ]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      if (actor.getProperty().getNormalTexture()) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  var tangent: vec3<f32> = input.tangentVC;", "  var bitangent: vec3<f32> = input.bitangentVC;", "  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(", "    tangent.x, bitangent.x, normal.x,", "    tangent.y, bitangent.y, normal.y,", "    tangent.z, bitangent.z, normal.z,", "  );", "  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);", "  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);", "  normal = normalize(normal);"]).result;
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  normal = normalize(normal);"]).result;
      }
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
    if (hash.includes("sel"))
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    if (!vDesc.hasOutput("vertexVC"))
      vDesc.addOutput("vec4<f32>", "vertexVC");
    const renderer = model.WebGPURenderer.getRenderable();
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (code.includes("var normal:") && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes("sel")) {
      const lightingCode = [
        "  var pi: f32 = 3.14159265359;",
        "  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);",
        "  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector",
        "  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;",
        "  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);",
        "  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;",
        "  var alpha: f32 = roughness*roughness;",
        "  var ior: f32 = mapperUBO.BaseIOR;",
        "  var k: f32 = alpha*alpha / 2;",
        "  var diffuse: vec3<f32> = vec3<f32>(0.);",
        "  var specular: vec3<f32> = vec3<f32>(0.);",
        "  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;",
        "  {",
        "    var i: i32 = 0;",
        "    loop {",
        "      if !(i < rendererUBO.LightCount) { break; }",
        "      switch (i32(rendererLightSSBO.values[i].LightData.x)) {",
        "         // Point Light",
        "         case 0 {",
        "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);",
        "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
        "           specular += max(vec3<f32>(0), calculated.specular);",
        "          }",
        "         // Directional light",
        "         case 1 {",
        "           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;",
        "           dir = normalize(dir);",
        "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color",
        "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
        "           specular += max(vec3<f32>(0), calculated.specular);",
        "         }",
        "         // Spot Light",
        "         case 2 {",
        "           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;",
        "           dir = normalize(dir);",
        "           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);",
        "           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);",
        "           diffuse += max(vec3<f32>(0), calculated.diffuse);",
        "           specular += max(vec3<f32>(0), calculated.specular);",
        "         }",
        "         default { continue; }",
        "       }",
        "      continuing { i++; }",
        "    }",
        "  }",
        "  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel",
        "  fresnel = min(1.0, fresnel);",
        "  // This could be controlled with its own variable (that isnt base color) for better artistic control",
        "  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account",
        "  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);",
        "  kS = min(vec3<f32>(1.0), kS);",
        "  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);",
        "  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;",
        "  PBR += emission;",
        "  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);"
      ];
      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {
        lightingCode.push("  // To get diffuse IBL, the texture is sampled with normals in worldspace", "  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;", "  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);", "  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors", "  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment", "  var VreflN: vec3<f32> = normalize(reflect(-V, normal));", "  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;", "  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);", "  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);", "  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;", "  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);", "  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;", "  computedColor += vec4<f32>(specularIBLContribution*kS, 0);", "  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;", "  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;", "  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);");
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", lightingCode).result;
      fDesc.setCode(code);
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", ["  var diffuse: vec3<f32> = diffuseColor.rgb;", "  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;", "  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderLight", publicAPI.replaceShaderLight);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    if (isEdges(hash)) {
      const fDesc2 = pipeline.getShaderDescription("fragment");
      let code2 = fDesc2.getCode();
      code2 = vtkWebGPUShaderCache$1.substitute(code2, "//VTK::Color::Impl", ["ambientColor = mapperUBO.EdgeColor;", "diffuseColor = mapperUBO.EdgeColor;"]).result;
      fDesc2.setCode(code2);
      return;
    }
    const colorBuffer = vertexInput.getBuffer("colorVI");
    if (!colorBuffer)
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec4<f32>", "color", colorBuffer.getArrayInformation()[0].interpolation);
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["  output.color = colorVI;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["ambientColor = input.color;", "diffuseColor = input.color;", "opacity = mapperUBO.Opacity * input.color.a;"]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderColor", publicAPI.replaceShaderColor);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    if (!vertexInput.hasAttribute("tcoord"))
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    const tcoords = vertexInput.getBuffer("tcoord");
    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
    let code = vDesc.getCode();
    vDesc.addOutput(`vec${numComp}<f32>`, "tcoordVS");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", ["  output.tcoordVS = tcoord;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    const actor = model.WebGPUActor.getRenderable();
    const checkDims = (texture) => {
      if (!texture)
        return false;
      const dims = texture.getDimensionality();
      return dims === numComp;
    };
    const usedTextures = [];
    if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {
      if (checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {
        usedTextures.push("_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);");
      }
    }
    if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getRoughnessTexture())) {
        usedTextures.push("_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);");
      }
    }
    if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getMetallicTexture())) {
        usedTextures.push("_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);");
      }
    }
    if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getNormalTexture())) {
        usedTextures.push("_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);");
      }
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {
        usedTextures.push("_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);");
      }
    }
    if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getEmissionTexture())) {
        usedTextures.push("_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);");
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", usedTextures).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes("sel")) {
      const fDesc = pipeline.getShaderDescription("fragment");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["  var compositeID: u32 = 0u;"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderSelect", publicAPI.replaceShaderSelect);
  publicAPI.getUsage = (rep, i) => {
    if (rep === Representation7.POINTS || i === PrimitiveTypes3.Points) {
      return BufferUsage5.Verts;
    }
    if (i === PrimitiveTypes3.Lines) {
      return BufferUsage5.Lines;
    }
    if (rep === Representation7.WIREFRAME) {
      if (i === PrimitiveTypes3.Triangles) {
        return BufferUsage5.LinesFromTriangles;
      }
      return BufferUsage5.LinesFromStrips;
    }
    if (i === PrimitiveTypes3.Triangles) {
      return BufferUsage5.Triangles;
    }
    if (i === PrimitiveTypes3.TriangleStrips) {
      return BufferUsage5.Strips;
    }
    if (i === PrimitiveTypes3.TriangleEdges) {
      return BufferUsage5.LinesFromTriangles;
    }
    return BufferUsage5.LinesFromStrips;
  };
  publicAPI.getHashFromUsage = (usage) => `pt${usage}`;
  publicAPI.getTopologyFromUsage = (usage) => {
    switch (usage) {
      case BufferUsage5.Triangles:
        return "triangle-list";
      case BufferUsage5.Verts:
        return "point-list";
      case BufferUsage5.Lines:
      default:
        return "line-list";
    }
  };
  publicAPI.buildVertexInput = () => {
    const pd = model.currentInput;
    const cells = model.cellArray;
    const primType = model.primitiveType;
    const actor = model.WebGPUActor.getRenderable();
    let representation = actor.getProperty().getRepresentation();
    const device = model.WebGPURenderWindow.getDevice();
    let edges = false;
    if (primType === PrimitiveTypes3.TriangleEdges) {
      edges = true;
      representation = Representation7.WIREFRAME;
    }
    const vertexInput = model.vertexInput;
    const points = pd.getPoints();
    let indexBuffer;
    if (cells) {
      const buffRequest = {
        hash: `R${representation}P${primType}${cells.getMTime()}`,
        usage: BufferUsage5.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation
      };
      indexBuffer = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    }
    if (points) {
      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      const buffRequest = {
        hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,
        usage: BufferUsage5.PointArray,
        format: "float32x4",
        dataArray: points,
        indexBuffer,
        shift,
        packExtra: true
      };
      const buff = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ["vertexBC"]);
    } else {
      vertexInput.removeBufferIfPresent("vertexBC");
    }
    const usage = publicAPI.getUsage(representation, primType);
    model._usesCellNormals = false;
    if (!model.is2D && (usage === BufferUsage5.Triangles || usage === BufferUsage5.Strips)) {
      const normals = pd.getPointData().getNormals();
      const buffRequest = {
        format: "snorm8x4",
        indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };
      if (normals) {
        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = normals;
        buffRequest.usage = BufferUsage5.PointArray;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ["normalMC"]);
      } else if (primType === PrimitiveTypes3.Triangles) {
        model._usesCellNormals = true;
        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = points;
        buffRequest.cells = cells;
        buffRequest.usage = BufferUsage5.NormalsFromPoints;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ["normalMC"]);
      } else {
        vertexInput.removeBufferIfPresent("normalMC");
      }
    } else {
      vertexInput.removeBufferIfPresent("normalMC");
    }
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c = model.renderable.getColorMapColors();
      if (c && !edges) {
        const scalarMode = model.renderable.getScalarMode();
        let haveCellScalars = false;
        if ((scalarMode === ScalarMode6.USE_CELL_DATA || scalarMode === ScalarMode6.USE_CELL_FIELD_DATA || scalarMode === ScalarMode6.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode6.USE_POINT_FIELD_DATA && c) {
          haveCellScalars = true;
        }
        const buffRequest = {
          usage: BufferUsage5.PointArray,
          format: "unorm8x4",
          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
          dataArray: c,
          indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        };
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ["colorVI"]);
        haveColors = true;
      }
    }
    if (!haveColors) {
      vertexInput.removeBufferIfPresent("colorVI");
    }
    let tcoords = null;
    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }
    if (tcoords && !edges) {
      const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());
      vertexInput.addBuffer(buff, ["tcoord"]);
    } else {
      vertexInput.removeBufferIfPresent("tcoord");
    }
  };
  publicAPI.updateTextures = () => {
    const usedTextures = [];
    const newTextures = [];
    const idata = model.renderable.getColorTextureMap?.();
    if (idata) {
      if (!model.colorTexture) {
        model.colorTexture = vtkTexture$1.newInstance({
          label: "polyDataColor"
        });
      }
      model.colorTexture.setInputData(idata);
      newTextures.push(["Diffuse", model.colorTexture]);
    }
    const actor = model.WebGPUActor.getRenderable();
    const renderer = model.WebGPURenderer.getRenderable();
    const textures = [];
    if (actor.getProperty().getDiffuseTexture?.()) {
      const pair = ["Diffuse", actor.getProperty().getDiffuseTexture()];
      textures.push(pair);
    }
    if (actor.getTextures()[0]) {
      const pair = ["Diffuse", actor.getTextures()[0]];
      textures.push(pair);
    }
    if (model.colorTexture) {
      const pair = ["Diffuse", model.colorTexture];
      textures.push(pair);
    }
    if (actor.getProperty().getRoughnessTexture?.()) {
      const pair = ["Roughness", actor.getProperty().getRoughnessTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getMetallicTexture?.()) {
      const pair = ["Metallic", actor.getProperty().getMetallicTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getNormalTexture?.()) {
      const pair = ["Normal", actor.getProperty().getNormalTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()) {
      const pair = ["AmbientOcclusion", actor.getProperty().getAmbientOcclusionTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getEmissionTexture?.()) {
      const pair = ["Emission", actor.getProperty().getEmissionTexture()];
      textures.push(pair);
    }
    if (renderer.getEnvironmentTexture?.()) {
      const pair = ["Environment", renderer.getEnvironmentTexture()];
      textures.push(pair);
    }
    for (let i = 0;i < textures.length; i++) {
      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {
        newTextures.push(textures[i]);
      }
      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {
        newTextures.push(textures[i]);
      }
    }
    for (let i = 0;i < newTextures.length; i++) {
      const srcTexture = newTextures[i][1];
      const textureName = newTextures[i][0];
      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture);
      if (newTex.getReady()) {
        let found = false;
        for (let t = 0;t < model.textures.length; t++) {
          if (model.textures[t] === newTex) {
            found = true;
            usedTextures[t] = true;
          }
        }
        if (!found) {
          usedTextures[model.textures.length] = true;
          const tview = newTex.createView(`${textureName}Texture`);
          model.textures.push(newTex);
          model.textureViews.push(tview);
          const interpolate = srcTexture.getInterpolate() ? "linear" : "nearest";
          let addressMode = null;
          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat())
            addressMode = "mirror-repeat";
          if (!addressMode && srcTexture.getEdgeClamp())
            addressMode = "clamp-to-edge";
          if (!addressMode && srcTexture.getRepeat())
            addressMode = "repeat";
          if (textureName !== "Environment") {
            tview.addSampler(model.device, {
              addressModeU: addressMode,
              addressModeV: addressMode,
              addressModeW: addressMode,
              minFilter: interpolate,
              magFilter: interpolate
            });
          } else {
            tview.addSampler(model.device, {
              addressModeU: "repeat",
              addressModeV: "clamp-to-edge",
              addressModeW: "repeat",
              minFilter: interpolate,
              magFilter: interpolate,
              mipmapFilter: "linear"
            });
          }
        }
      }
    }
    for (let i = model.textures.length - 1;i >= 0; i--) {
      if (!usedTextures[i]) {
        model.textures.splice(i, 1);
        model.textureViews.splice(i, 1);
      }
    }
  };
  publicAPI.computePipelineHash = () => {
    let pipelineHash = `pd${model.useRendererMatrix ? "r" : ""}${model.forceZValue ? "z" : ""}`;
    if (model.primitiveType === PrimitiveTypes3.TriangleEdges || model.primitiveType === PrimitiveTypes3.TriangleStripEdges) {
      pipelineHash += "edge";
    } else {
      if (model.vertexInput.hasAttribute(`normalMC`)) {
        pipelineHash += `n`;
      }
      if (model.vertexInput.hasAttribute(`colorVI`)) {
        pipelineHash += `c`;
      }
      if (model.vertexInput.hasAttribute(`tcoord`)) {
        const tcoords = model.vertexInput.getBuffer("tcoord");
        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
        pipelineHash += `t${numComp}`;
      }
      if (model.textures.length) {
        pipelineHash += `tx${model.textures.length}`;
      }
    }
    if (model._usesCellNormals) {
      pipelineHash += `cn`;
    }
    if (model.SSBO) {
      pipelineHash += `ssbo`;
    }
    const uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };
  publicAPI.updateBuffers = () => {
    if (model.primitiveType !== PrimitiveTypes3.TriangleEdges && model.primitiveType !== PrimitiveTypes3.TriangleStripEdges) {
      publicAPI.updateTextures();
    }
    const actor = model.WebGPUActor.getRenderable();
    const rep = actor.getProperty().getRepresentation();
    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    const vbo = model.vertexInput.getBuffer("vertexBC");
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();
    if (publicAPI.haveWideLines()) {
      const ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2));
    } else {
      publicAPI.setNumberOfInstances(1);
    }
  };
}
var DEFAULT_VALUES117 = {
  is2D: false,
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
};
function extend123(publicAPI, model) {
  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES117, initiaLalues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initiaLalues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = exports_mat3.identity(new Float64Array(9));
  model._tmpMat4 = exports_mat4.identity(new Float64Array(16));
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("BCWCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("BCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("MCWCNormals", "mat4x4<f32>");
  model.UBO.addEntry("AmbientColor", "vec4<f32>");
  model.UBO.addEntry("DiffuseColor", "vec4<f32>");
  model.UBO.addEntry("EdgeColor", "vec4<f32>");
  model.UBO.addEntry("SpecularColor", "vec4<f32>");
  model.UBO.addEntry("AmbientIntensity", "f32");
  model.UBO.addEntry("DiffuseIntensity", "f32");
  model.UBO.addEntry("Roughness", "f32");
  model.UBO.addEntry("Metallic", "f32");
  model.UBO.addEntry("Ambient", "f32");
  model.UBO.addEntry("Normal", "f32");
  model.UBO.addEntry("Emission", "f32");
  model.UBO.addEntry("NormalStrength", "f32");
  model.UBO.addEntry("BaseIOR", "f32");
  model.UBO.addEntry("SpecularIntensity", "f32");
  model.UBO.addEntry("LineWidth", "f32");
  model.UBO.addEntry("Opacity", "f32");
  model.UBO.addEntry("ZValue", "f32");
  model.UBO.addEntry("PropID", "u32");
  model.UBO.addEntry("ClipNear", "f32");
  model.UBO.addEntry("ClipFar", "f32");
  model.UBO.addEntry("Time", "u32");
  setGet(publicAPI, model, ["cellArray", "currentInput", "cellOffset", "is2D", "primitiveType", "renderEncoder"]);
  model.textures = [];
  vtkWebGPUCellArrayMapper(publicAPI, model);
}
var newInstance121 = newInstance(extend123, "vtkWebGPUCellArrayMapper");
var vtkWebGPUCellArrayMapper$1 = {
  newInstance: newInstance121,
  extend: extend123
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js
var {
  PrimitiveTypes: PrimitiveTypes4
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes4.Points;i <= PrimitiveTypes4.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
      for (let i = PrimitiveTypes4.TriangleEdges;i <= PrimitiveTypes4.TriangleStripEdges; i++) {
        if (prims[i - 2].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i - 2]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(model.primitives[i - 2].getCellOffset());
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
var DEFAULT_VALUES118 = {
  primitives: null
};
function extend124(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES118, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper(publicAPI, model);
}
var newInstance122 = newInstance(extend124, "vtkWebGPUPolyDataMapper");
registerOverride3("vtkMapper", newInstance122);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js
var {
  PrimitiveTypes: PrimitiveTypes5
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper2D");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes5.Points;i <= PrimitiveTypes5.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMapper.setIs2D(true);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
function defaultValues5(initialValues) {
  return {
    primitives: [],
    ...initialValues
  };
}
function extend125(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues5(initialValues));
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper2D(publicAPI, model);
}
var newInstance123 = newInstance(extend125, "vtkWebGPUPolyDataMapper2D");
registerOverride3("vtkMapper2D", newInstance123);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js
function vtkWebGPUScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES119 = {};
function extend126(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES119, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkWebGPUScalarBarActor(publicAPI, model);
}
var newInstance124 = newInstance(extend126, "vtkWebGPUScalarBarActor");
registerOverride3("vtkScalarBarActor", newInstance124);

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js
function vtkWebGPUTextureView(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureView");
  publicAPI.create = (texture, options) => {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = (textureHandle, options) => {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = (binding, group) => {
    let ttype = "f32";
    if (model.bindGroupLayoutEntry.texture.sampleType === "sint") {
      ttype = "i32";
    } else if (model.bindGroupLayoutEntry.texture.sampleType === "uint") {
      ttype = "u32";
    }
    let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
    if (model.bindGroupLayoutEntry.texture.sampleType === "depth") {
      result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
    }
    return result;
  };
  publicAPI.addSampler = (device, options) => {
    const newSamp = vtkWebGPUSampler$1.newInstance({
      label: `${model.label}Sampler`
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };
  publicAPI.getHandle = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}
var DEFAULT_VALUES120 = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};
function extend127(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES120, initialValues);
  macro.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    texture: {
      sampleType: "float",
      viewDimension: "2d"
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "texture"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "label", "sampler"]);
  vtkWebGPUTextureView(publicAPI, model);
}
var newInstance125 = macro.newInstance(extend127);
var vtkWebGPUTextureView$1 = {
  newInstance: newInstance125,
  extend: extend127
};

// ../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js
var {
  BufferUsage: BufferUsage6
} = vtkWebGPUBufferManager$1;
function vtkWebGPUTexture(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTexture");
  publicAPI.create = (device, options) => {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    const dimension = model.depth === 1 ? "2d" : "3d";
    model.format = options.format ? options.format : "rgba8unorm";
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      usage: model.usage,
      label: model.label,
      dimension,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = (device, handle, options) => {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : "rgba8unorm";
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
  };
  publicAPI.writeImageData = (req) => {
    let nativeArray = [];
    if (req.canvas) {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source: req.canvas,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true
      }, [model.width, model.height, model.depth]);
      model.ready = true;
      return;
    }
    if (req.jsImageData && !req.nativeArray) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    let bufferBytesPerRow = model.width * tDetails.stride;
    const fixAll = (arr, height, depth) => {
      const inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      if (halfFloat || inWidthInBytes % 256) {
        const inArray = arr;
        const inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
        const outBytesPerElement = tDetails.elementSize;
        const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        const outWidth = outWidthInBytes / outBytesPerElement;
        const outArray = macro.newTypedArray(halfFloat ? "Uint16Array" : inArray.constructor.name, outWidth * height * depth);
        for (let v = 0;v < height * depth; v++) {
          if (halfFloat) {
            for (let i = 0;i < inWidth; i++) {
              outArray[v * outWidth + i] = HalfFloat.toHalf(inArray[v * inWidth + i]);
            }
          } else {
            outArray.set(inArray.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      }
      return [arr, inWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    if (req.image) {
      const canvas = document.createElement("canvas");
      canvas.width = req.image.width;
      canvas.height = req.image.height;
      const ctx = canvas.getContext("2d");
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
      nativeArray = imageData.data;
    }
    const cmdEnc = model.device.createCommandEncoder();
    if (publicAPI.getDimensionality() !== 3) {
      const mips = vtkTexture$1.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
      let currentWidth = model.width;
      let currentHeight = model.height;
      for (let m = 0;m <= model.mipLevel; m++) {
        const fix = fixAll(mips[m], currentHeight, 1);
        bufferBytesPerRow = fix[1];
        const buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          nativeArray: fix[0],
          usage: BufferUsage6.Texture
        };
        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: currentHeight
        }, {
          texture: model.handle,
          mipLevel: m
        }, [currentWidth, currentHeight, 1]);
        currentWidth /= 2;
        currentHeight /= 2;
      }
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    } else {
      const fix = fixAll(nativeArray, model.height, model.depth);
      bufferBytesPerRow = fix[1];
      const buffRequest = {
        dataArray: req.dataArray ? req.dataArray : null,
        usage: BufferUsage6.Texture
      };
      buffRequest.nativeArray = fix[0];
      const buff = model.device.getBufferManager().getBuffer(buffRequest);
      cmdEnc.copyBufferToTexture({
        buffer: buff.getHandle(),
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        texture: model.handle
      }, [model.width, model.height, model.depth]);
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    }
  };
  publicAPI.getScale = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
    return halfFloat ? 1 : 255;
  };
  publicAPI.getNumberOfComponents = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = () => {
    let dims = 0;
    if (model.width > 1)
      dims++;
    if (model.height > 1)
      dims++;
    if (model.depth > 1)
      dims++;
    return dims;
  };
  publicAPI.resizeToMatch = (tex) => {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function(width, height) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function(label) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? "2d" : "3d";
    }
    const view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}
var DEFAULT_VALUES121 = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};
function extend128(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES121, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "ready", "width", "height", "depth", "format", "usage"]);
  macro.setGet(publicAPI, model, ["device", "label"]);
  vtkWebGPUTexture(publicAPI, model);
}
var newInstance126 = macro.newInstance(extend128);

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/validateContourSet.js
function validateContourSet(contourSetData) {
  if (!contourSetData || contourSetData.data.length === 0) {
    throw new Error("Invalid contour set data, see publicContourSetData type for more info");
  }
  if (!contourSetData.id) {
    throw new Error("Invalid contour set data, each contour set must have an id");
  }
  if (!contourSetData.data || !Array.isArray(contourSetData.data)) {
    throw new Error("Invalid contour set data, each contour set must have an array of contours");
  }
  contourSetData.data.forEach((contourData) => {
    if (!contourData.points || !Array.isArray(contourData.points)) {
      throw new Error("Invalid contour set data, each contour must have an array of points");
    }
    contourData.points.forEach((point) => {
      if (!point || !Array.isArray(point) || point.length !== 3) {
        throw new Error("Invalid contour set data, each point must be an array of length 3");
      }
    });
  });
}

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Contour.js
class Contour {
  constructor(props) {
    const { points, type } = props.data;
    this.id = props.id;
    this._points = points;
    this._type = type;
    this._color = props.color;
    this._segmentIndex = props.segmentIndex;
    this.sizeInBytes = this._getSizeInBytes();
  }
  _getSizeInBytes() {
    return this._points.length * 3;
  }
  get points() {
    return this._points;
  }
  set points(value) {
    this._points = value;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get segmentIndex() {
    return this._segmentIndex;
  }
  set segmentIndex(value) {
    this._segmentIndex = value;
  }
  get flatPointsArray() {
    return this._points.map((point) => [...point]).flat();
  }
}
var Contour_default = Contour;

// ../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ContourSet.js
class ContourSet {
  constructor(props) {
    this._color = [200, 0, 0];
    this.id = props.id;
    this._contours = [];
    this._color = props.color ?? this._color;
    this.frameOfReferenceUID = props.frameOfReferenceUID;
    this._segmentIndex = props.segmentIndex;
    this._createEachContour(props.data);
    this.sizeInBytes = this._getSizeInBytes();
  }
  _createEachContour(contourDataArray) {
    contourDataArray.forEach((contourData) => {
      const { points, type, color: color2 } = contourData;
      const contour = new Contour_default({
        id: `${this.id}-segment-${this._segmentIndex}`,
        data: {
          points,
          type,
          segmentIndex: this._segmentIndex,
          color: color2 ?? this._color
        },
        segmentIndex: this._segmentIndex,
        color: color2 ?? this._color
      });
      this._contours.push(contour);
    });
    this._updateContourSetCentroid();
  }
  _updateContourSetCentroid() {
    const numberOfPoints = this.totalNumberOfPoints;
    const flatPointsArray = this.flatPointsArray;
    const sumOfPoints = flatPointsArray.reduce((acc, point) => {
      return [acc[0] + point[0], acc[1] + point[1], acc[2] + point[2]];
    }, [0, 0, 0]);
    const centroid = [
      sumOfPoints[0] / numberOfPoints,
      sumOfPoints[1] / numberOfPoints,
      sumOfPoints[2] / numberOfPoints
    ];
    const closestPoint = flatPointsArray.reduce((closestPoint2, point) => {
      const distanceToPoint = this._getDistance(centroid, point);
      const distanceToClosestPoint = this._getDistance(centroid, closestPoint2);
      if (distanceToPoint < distanceToClosestPoint) {
        return point;
      } else {
        return closestPoint2;
      }
    }, flatPointsArray[0]);
    this._centroid = closestPoint;
  }
  _getSizeInBytes() {
    return this._contours.reduce((sizeInBytes, contour) => {
      return sizeInBytes + contour.sizeInBytes;
    }, 0);
  }
  _getDistance(pointA, pointB) {
    return Math.sqrt((pointA[0] - pointB[0]) ** 2 + (pointA[1] - pointB[1]) ** 2 + (pointA[2] - pointB[2]) ** 2);
  }
  get centroid() {
    return this._centroid;
  }
  get segmentIndex() {
    return this._segmentIndex;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._contours.forEach((contour) => {
      if (contour instanceof Contour_default) {
        contour.color = value;
      }
    });
  }
  get contours() {
    return this._contours;
  }
  get flatPointsArray() {
    return this._contours.flatMap((contour) => contour.points);
  }
  get numberOfContours() {
    return this._contours.length;
  }
  get totalNumberOfPoints() {
    return this._contours.reduce((numberOfPoints, contour) => {
      return numberOfPoints + contour.points.length;
    }, 0);
  }
  get numberOfPointsArray() {
    return this._contours.map((contour) => contour.points.length);
  }
  getPointsInContour(contourIndex) {
    return this._contours[contourIndex].points;
  }
  getNumberOfPointsInAContour(contourIndex) {
    return this.getPointsInContour(contourIndex).length;
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/createContourSet.js
function createContourSet(geometryId, contourSetData) {
  validateContourSet(contourSetData);
  const contourSet = new ContourSet({
    id: contourSetData.id,
    data: contourSetData.data,
    color: contourSetData.color,
    frameOfReferenceUID: contourSetData.frameOfReferenceUID,
    segmentIndex: contourSetData.segmentIndex ?? 1
  });
  const geometry = {
    id: geometryId,
    type: GeometryType_default.CONTOUR,
    data: contourSet,
    sizeInBytes: contourSet.sizeInBytes
  };
  return geometry;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/validateSurface.js
function validateSurface(surfaceData) {
  if (!surfaceData.id) {
    throw new Error("Surface must have an id");
  }
  if (surfaceData.points?.length === 0) {
    throw new Error("Surface must have non-empty points array");
  }
  if (surfaceData.polys?.length === 0) {
    throw new Error("Surface must have non-empty polys array");
  }
  if (!surfaceData.frameOfReferenceUID) {
    throw new Error("Surface must have a frameOfReferenceUID");
  }
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/createSurface.js
function createSurface(geometryId, surfaceData) {
  validateSurface(surfaceData);
  const surface = new Surface({
    id: surfaceData.id,
    points: surfaceData.points,
    polys: surfaceData.polys,
    color: surfaceData.color,
    frameOfReferenceUID: surfaceData.frameOfReferenceUID,
    segmentIndex: surfaceData.segmentIndex ?? 1
  });
  const geometry = {
    id: geometryId,
    type: GeometryType_default.SURFACE,
    data: surface,
    sizeInBytes: surface.sizeInBytes
  };
  return geometry;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/geometryLoader.js
var geometryLoaders = {};
var unknownGeometryLoader;
function loadGeometryFromGeometryLoader(geometryId, options) {
  const colonIndex = geometryId.indexOf(":");
  const scheme = geometryId.substring(0, colonIndex);
  let loader = geometryLoaders[scheme];
  if (loader === undefined || loader === null) {
    if (unknownGeometryLoader == null || typeof unknownGeometryLoader !== "function") {
      throw new Error(`No geometry loader for scheme ${scheme} has been registered`);
    }
    loader = unknownGeometryLoader;
  }
  const geometryLoadObject = loader(geometryId, options);
  geometryLoadObject.promise.then(function(geometry) {
    triggerEvent(eventTarget_default, Events_default.GEOMETRY_LOADED, { geometry });
  }, function(error) {
    const errorObject = {
      geometryId,
      error
    };
    triggerEvent(eventTarget_default, Events_default.GEOMETRY_LOADED_FAILED, errorObject);
  });
  return geometryLoadObject;
}
function loadGeometry(geometryId, options) {
  if (geometryId === undefined) {
    throw new Error("loadGeometry: parameter geometryId must not be undefined");
  }
  let geometryLoadObject = cache_default.getGeometryLoadObject(geometryId);
  if (geometryLoadObject !== undefined) {
    return geometryLoadObject.promise;
  }
  geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);
  return geometryLoadObject.promise;
}
async function loadAndCacheGeometry(geometryId, options) {
  if (geometryId === undefined) {
    throw new Error("createAndCacheGeometry: parameter geometryId must not be undefined");
  }
  let geometryLoadObject = cache_default.getGeometryLoadObject(geometryId);
  if (geometryLoadObject !== undefined) {
    return geometryLoadObject.promise;
  }
  geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);
  await cache_default.putGeometryLoadObject(geometryId, geometryLoadObject);
  return geometryLoadObject.promise;
}
function createAndCacheGeometry(geometryId, options) {
  if (geometryId === undefined) {
    throw new Error("createAndCacheGeometry: parameter geometryId must not be undefined");
  }
  let geometry = cache_default.getGeometry(geometryId);
  if (geometry) {
    return geometry;
  }
  if (options.type === GeometryType_default.CONTOUR) {
    geometry = createContourSet(geometryId, options.geometryData);
  } else if (options.type === GeometryType_default.SURFACE) {
    geometry = createSurface(geometryId, options.geometryData);
  } else {
    throw new Error("Unknown geometry type");
  }
  cache_default.putGeometrySync(geometryId, geometry);
  return geometry;
}
function registerGeometryLoader(scheme, geometryLoader) {
  geometryLoaders[scheme] = geometryLoader;
}
function registerUnknownGeometryLoader(geometryLoader) {
  const oldGeometryLoader = unknownGeometryLoader;
  unknownGeometryLoader = geometryLoader;
  return oldGeometryLoader;
}

// ../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneStreamingDynamicImageVolumeLoader.js
function cornerstoneStreamingDynamicImageVolumeLoader(volumeId, options) {
  if (!options || !options.imageIds || !options.imageIds.length) {
    throw new Error("ImageIds must be provided to create a 4D streaming image volume");
  }
  const { imageIds } = options;
  const { splittingTag, imageIdGroups } = splitImageIdsBy4DTags_default(imageIds);
  const middleIndex = Math.floor(imageIdGroups.length / 2);
  const volumeProps = generateVolumePropsFromImageIds(imageIdGroups[middleIndex], volumeId);
  const { metadata: volumeMetadata, dimensions, spacing, direction, sizeInBytes, origin, numberOfComponents, dataType } = volumeProps;
  const scanAxisNormal = direction.slice(6, 9);
  const sortedImageIdGroups = imageIdGroups.map((imageIds2) => {
    const sortedImageIds = sortImageIdsAndGetSpacing(imageIds2, scanAxisNormal).sortedImageIds;
    return sortedImageIds;
  });
  const sortedFlatImageIds = sortedImageIdGroups.flat();
  const voxelManager = VoxelManager.createScalarDynamicVolumeVoxelManager({
    dimensions,
    imageIdGroups: sortedImageIdGroups,
    dimensionGroupNumber: 1,
    numberOfComponents
  });
  let streamingImageVolume = new StreamingDynamicImageVolume({
    volumeId,
    metadata: volumeMetadata,
    dimensions,
    spacing,
    origin,
    direction,
    sizeInBytes,
    imageIds: sortedFlatImageIds,
    imageIdGroups: sortedImageIdGroups,
    splittingTag,
    voxelManager,
    numberOfComponents,
    dataType
  }, {
    imageIds: sortedFlatImageIds,
    loadStatus: {
      loaded: false,
      loading: false,
      cancelled: false,
      cachedFrames: [],
      callbacks: []
    }
  });
  return {
    promise: Promise.resolve(streamingImageVolume),
    decache: () => {
      streamingImageVolume.destroy();
      streamingImageVolume = null;
    },
    cancel: () => {
      streamingImageVolume.cancelLoading();
    }
  };
}
export {
  exports_volumeLoader as volumeLoader,
  exports_utilities as utilities,
  triggerEvent,
  setVolumesForViewports_default as setVolumesForViewports,
  setUseCPURendering,
  setPreferSizeOverAccuracy,
  setConfiguration,
  resetUseCPURendering,
  resetInitialization,
  imageLoadPoolManager_default as requestPoolManager,
  registerImageLoader,
  peerImport,
  exports_metaData as metaData,
  isCornerstoneInitialized,
  init,
  imageRetrievalPoolManager_default as imageRetrievalPoolManager,
  exports_imageLoader as imageLoader,
  imageLoadPoolManager_default as imageLoadPoolManager,
  getWebWorkerManager,
  getShouldUseCPURendering,
  getRenderingEngines,
  getRenderingEngine,
  getOrCreateCanvas,
  getEnabledElements,
  getEnabledElementByViewportId,
  getEnabledElementByIds,
  getEnabledElement,
  getConfiguration,
  exports_geometryLoader as geometryLoader,
  eventTarget_default as eventTarget,
  createVolumeMapper,
  createVolumeActor_default as createVolumeActor,
  cornerstoneStreamingImageVolumeLoader,
  cornerstoneStreamingDynamicImageVolumeLoader,
  convertMapperToNotSharedMapper,
  canRenderFloatTextures,
  cache_default as cache,
  addVolumesToViewports_default as addVolumesToViewports,
  addImageSlicesToViewports_default as addImageSlicesToViewports,
  WSIViewport_default as WSIViewport,
  VolumeViewport3D_default as VolumeViewport3D,
  VolumeViewport_default as VolumeViewport,
  Viewport_default as Viewport,
  VideoViewport_default as VideoViewport,
  Surface,
  StreamingImageVolume,
  StreamingDynamicImageVolume,
  StackViewport_default as StackViewport,
  Settings,
  RenderingEngine_default2 as RenderingEngine,
  ProgressiveRetrieveImages_default as ProgressiveRetrieveImages,
  ImageVolume_default as ImageVolume,
  exports_enums as Enums,
  Events_default as EVENTS,
  exports_constants as CONSTANTS,
  BaseVolumeViewport_default as BaseVolumeViewport
};
